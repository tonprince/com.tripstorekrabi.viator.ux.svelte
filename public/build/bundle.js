
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
(function() {
    const env = {"GOOGLE_API_KEY":"AIzaSyDbC7d471NZSrSvUiAvqqZqNh4ewrZgxUk"};
    try {
        if (process) {
            process.env = Object.assign({}, process.env);
            Object.assign(process.env, env);
            return;
        }
    } catch (e) {} // avoid ReferenceError: process is not defined
    globalThis.process = { env:env };
})();

/**
 * Template7 1.4.2
 * Mobile-first HTML template engine
 * 
 * http://www.idangero.us/template7/
 * 
 * Copyright 2019, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: June 14, 2019
 */

let t7ctx;
if (typeof window !== 'undefined') {
  t7ctx = window;
} else if (typeof global !== 'undefined') {
  t7ctx = global;
} else {
  t7ctx = undefined;
}

const Template7Context = t7ctx;

const Template7Utils = {
  quoteSingleRexExp: new RegExp('\'', 'g'),
  quoteDoubleRexExp: new RegExp('"', 'g'),
  isFunction(func) {
    return typeof func === 'function';
  },
  escape(string = '') {
    return string
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  },
  helperToSlices(string) {
    const { quoteDoubleRexExp, quoteSingleRexExp } = Template7Utils;
    const helperParts = string.replace(/[{}#}]/g, '').trim().split(' ');
    const slices = [];
    let shiftIndex;
    let i;
    let j;
    for (i = 0; i < helperParts.length; i += 1) {
      let part = helperParts[i];
      let blockQuoteRegExp;
      let openingQuote;
      if (i === 0) slices.push(part);
      else if (part.indexOf('"') === 0 || part.indexOf('\'') === 0) {
        blockQuoteRegExp = part.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
        openingQuote = part.indexOf('"') === 0 ? '"' : '\'';
        // Plain String
        if (part.match(blockQuoteRegExp).length === 2) {
          // One word string
          slices.push(part);
        } else {
          // Find closed Index
          shiftIndex = 0;
          for (j = i + 1; j < helperParts.length; j += 1) {
            part += ` ${helperParts[j]}`;
            if (helperParts[j].indexOf(openingQuote) >= 0) {
              shiftIndex = j;
              slices.push(part);
              break;
            }
          }
          if (shiftIndex) i = shiftIndex;
        }
      } else if (part.indexOf('=') > 0) {
        // Hash
        const hashParts = part.split('=');
        const hashName = hashParts[0];
        let hashContent = hashParts[1];
        if (!blockQuoteRegExp) {
          blockQuoteRegExp = hashContent.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
          openingQuote = hashContent.indexOf('"') === 0 ? '"' : '\'';
        }
        if (hashContent.match(blockQuoteRegExp).length !== 2) {
          shiftIndex = 0;
          for (j = i + 1; j < helperParts.length; j += 1) {
            hashContent += ` ${helperParts[j]}`;
            if (helperParts[j].indexOf(openingQuote) >= 0) {
              shiftIndex = j;
              break;
            }
          }
          if (shiftIndex) i = shiftIndex;
        }
        const hash = [hashName, hashContent.replace(blockQuoteRegExp, '')];
        slices.push(hash);
      } else {
        // Plain variable
        slices.push(part);
      }
    }
    return slices;
  },
  stringToBlocks(string) {
    const blocks = [];
    let i;
    let j;
    if (!string) return [];
    const stringBlocks = string.split(/({{[^{^}]*}})/);
    for (i = 0; i < stringBlocks.length; i += 1) {
      let block = stringBlocks[i];
      if (block === '') continue;
      if (block.indexOf('{{') < 0) {
        blocks.push({
          type: 'plain',
          content: block,
        });
      } else {
        if (block.indexOf('{/') >= 0) {
          continue;
        }
        block = block
          .replace(/{{([#/])*([ ])*/, '{{$1')
          .replace(/([ ])*}}/, '}}');
        if (block.indexOf('{#') < 0 && block.indexOf(' ') < 0 && block.indexOf('else') < 0) {
          // Simple variable
          blocks.push({
            type: 'variable',
            contextName: block.replace(/[{}]/g, ''),
          });
          continue;
        }
        // Helpers
        const helperSlices = Template7Utils.helperToSlices(block);
        let helperName = helperSlices[0];
        const isPartial = helperName === '>';
        const helperContext = [];
        const helperHash = {};
        for (j = 1; j < helperSlices.length; j += 1) {
          const slice = helperSlices[j];
          if (Array.isArray(slice)) {
            // Hash
            helperHash[slice[0]] = slice[1] === 'false' ? false : slice[1];
          } else {
            helperContext.push(slice);
          }
        }

        if (block.indexOf('{#') >= 0) {
          // Condition/Helper
          let helperContent = '';
          let elseContent = '';
          let toSkip = 0;
          let shiftIndex;
          let foundClosed = false;
          let foundElse = false;
          let depth = 0;
          for (j = i + 1; j < stringBlocks.length; j += 1) {
            if (stringBlocks[j].indexOf('{{#') >= 0) {
              depth += 1;
            }
            if (stringBlocks[j].indexOf('{{/') >= 0) {
              depth -= 1;
            }
            if (stringBlocks[j].indexOf(`{{#${helperName}`) >= 0) {
              helperContent += stringBlocks[j];
              if (foundElse) elseContent += stringBlocks[j];
              toSkip += 1;
            } else if (stringBlocks[j].indexOf(`{{/${helperName}`) >= 0) {
              if (toSkip > 0) {
                toSkip -= 1;
                helperContent += stringBlocks[j];
                if (foundElse) elseContent += stringBlocks[j];
              } else {
                shiftIndex = j;
                foundClosed = true;
                break;
              }
            } else if (stringBlocks[j].indexOf('else') >= 0 && depth === 0) {
              foundElse = true;
            } else {
              if (!foundElse) helperContent += stringBlocks[j];
              if (foundElse) elseContent += stringBlocks[j];
            }
          }
          if (foundClosed) {
            if (shiftIndex) i = shiftIndex;
            if (helperName === 'raw') {
              blocks.push({
                type: 'plain',
                content: helperContent,
              });
            } else {
              blocks.push({
                type: 'helper',
                helperName,
                contextName: helperContext,
                content: helperContent,
                inverseContent: elseContent,
                hash: helperHash,
              });
            }
          }
        } else if (block.indexOf(' ') > 0) {
          if (isPartial) {
            helperName = '_partial';
            if (helperContext[0]) {
              if (helperContext[0].indexOf('[') === 0) helperContext[0] = helperContext[0].replace(/[[\]]/g, '');
              else helperContext[0] = `"${helperContext[0].replace(/"|'/g, '')}"`;
            }
          }
          blocks.push({
            type: 'helper',
            helperName,
            contextName: helperContext,
            hash: helperHash,
          });
        }
      }
    }
    return blocks;
  },
  parseJsVariable(expression, replace, object) {
    return expression.split(/([+ \-*/^()&=|<>!%:?])/g).reduce((arr, part) => {
      if (!part) {
        return arr;
      }
      if (part.indexOf(replace) < 0) {
        arr.push(part);
        return arr;
      }
      if (!object) {
        arr.push(JSON.stringify(''));
        return arr;
      }

      let variable = object;
      if (part.indexOf(`${replace}.`) >= 0) {
        part.split(`${replace}.`)[1].split('.').forEach((partName) => {
          if (partName in variable) variable = variable[partName];
          else variable = undefined;
        });
      }
      if (
        (typeof variable === 'string')
        || Array.isArray(variable)
        || (variable.constructor && variable.constructor === Object)
      ) {
        variable = JSON.stringify(variable);
      }
      if (variable === undefined) variable = 'undefined';

      arr.push(variable);
      return arr;
    }, []).join('');

  },
  parseJsParents(expression, parents) {
    return expression.split(/([+ \-*^()&=|<>!%:?])/g).reduce((arr, part) => {
      if (!part) {
        return arr;
      }

      if (part.indexOf('../') < 0) {
        arr.push(part);
        return arr;
      }

      if (!parents || parents.length === 0) {
        arr.push(JSON.stringify(''));
        return arr;
      }

      const levelsUp = part.split('../').length - 1;
      const parentData = levelsUp > parents.length ? parents[parents.length - 1] : parents[levelsUp - 1];

      let variable = parentData;
      const parentPart = part.replace(/..\//g, '');
      parentPart.split('.').forEach((partName) => {
        if (typeof variable[partName] !== 'undefined') variable = variable[partName];
        else variable = 'undefined';
      });
      if (variable === false || variable === true) {
        arr.push(JSON.stringify(variable));
        return arr;
      }
      if (variable === null || variable === 'undefined') {
        arr.push(JSON.stringify(''));
        return arr;
      }
      arr.push(JSON.stringify(variable));
      return arr;
    }, []).join('');
  },
  getCompileVar(name, ctx, data = 'data_1') {
    let variable = ctx;
    let parts;
    let levelsUp = 0;
    let newDepth;
    if (name.indexOf('../') === 0) {
      levelsUp = name.split('../').length - 1;
      newDepth = variable.split('_')[1] - levelsUp;
      variable = `ctx_${newDepth >= 1 ? newDepth : 1}`;
      parts = name.split('../')[levelsUp].split('.');
    } else if (name.indexOf('@global') === 0) {
      variable = 'Template7.global';
      parts = name.split('@global.')[1].split('.');
    } else if (name.indexOf('@root') === 0) {
      variable = 'root';
      parts = name.split('@root.')[1].split('.');
    } else {
      parts = name.split('.');
    }
    for (let i = 0; i < parts.length; i += 1) {
      const part = parts[i];
      if (part.indexOf('@') === 0) {
        let dataLevel = data.split('_')[1];
        if (levelsUp > 0) {
          dataLevel = newDepth;
        }
        if (i > 0) {
          variable += `[(data_${dataLevel} && data_${dataLevel}.${part.replace('@', '')})]`;
        } else {
          variable = `(data_${dataLevel} && data_${dataLevel}.${part.replace('@', '')})`;
        }
      } else if (Number.isFinite ? Number.isFinite(part) : Template7Context.isFinite(part)) {
        variable += `[${part}]`;
      } else if (part === 'this' || part.indexOf('this.') >= 0 || part.indexOf('this[') >= 0 || part.indexOf('this(') >= 0) {
        variable = part.replace('this', ctx);
      } else {
        variable += `.${part}`;
      }
    }
    return variable;
  },
  getCompiledArguments(contextArray, ctx, data) {
    const arr = [];
    for (let i = 0; i < contextArray.length; i += 1) {
      if (/^['"]/.test(contextArray[i])) arr.push(contextArray[i]);
      else if (/^(true|false|\d+)$/.test(contextArray[i])) arr.push(contextArray[i]);
      else {
        arr.push(Template7Utils.getCompileVar(contextArray[i], ctx, data));
      }
    }

    return arr.join(', ');
  },
};

/* eslint no-eval: "off" */

const Template7Helpers = {
  _partial(partialName, options) {
    const ctx = this;
    const p = Template7Class.partials[partialName];
    if (!p || (p && !p.template)) return '';
    if (!p.compiled) {
      p.compiled = new Template7Class(p.template).compile();
    }
    Object.keys(options.hash).forEach((hashName) => {
      ctx[hashName] = options.hash[hashName];
    });
    return p.compiled(ctx, options.data, options.root);
  },
  escape(context) {
    if (typeof context === 'undefined' || context === null) return '';
    if (typeof context !== 'string') {
      throw new Error('Template7: Passed context to "escape" helper should be a string');
    }
    return Template7Utils.escape(context);
  },
  if(context, options) {
    let ctx = context;
    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
    if (ctx) {
      return options.fn(this, options.data);
    }

    return options.inverse(this, options.data);
  },
  unless(context, options) {
    let ctx = context;
    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
    if (!ctx) {
      return options.fn(this, options.data);
    }

    return options.inverse(this, options.data);
  },
  each(context, options) {
    let ctx = context;
    let ret = '';
    let i = 0;
    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
    if (Array.isArray(ctx)) {
      if (options.hash.reverse) {
        ctx = ctx.reverse();
      }
      for (i = 0; i < ctx.length; i += 1) {
        ret += options.fn(ctx[i], { first: i === 0, last: i === ctx.length - 1, index: i });
      }
      if (options.hash.reverse) {
        ctx = ctx.reverse();
      }
    } else {
      // eslint-disable-next-line
      for (const key in ctx) {
        i += 1;
        ret += options.fn(ctx[key], { key });
      }
    }
    if (i > 0) return ret;
    return options.inverse(this);
  },
  with(context, options) {
    let ctx = context;
    if (Template7Utils.isFunction(ctx)) { ctx = context.call(this); }
    return options.fn(ctx);
  },
  join(context, options) {
    let ctx = context;
    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
    return ctx.join(options.hash.delimiter || options.hash.delimeter);
  },
  js(expression, options) {
    const data = options.data;
    let func;
    let execute = expression;
    ('index first last key').split(' ').forEach((prop) => {
      if (typeof data[prop] !== 'undefined') {
        const re1 = new RegExp(`this.@${prop}`, 'g');
        const re2 = new RegExp(`@${prop}`, 'g');
        execute = execute
          .replace(re1, JSON.stringify(data[prop]))
          .replace(re2, JSON.stringify(data[prop]));
      }
    });
    if (options.root && execute.indexOf('@root') >= 0) {
      execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
    }
    if (execute.indexOf('@global') >= 0) {
      execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
    }
    if (execute.indexOf('../') >= 0) {
      execute = Template7Utils.parseJsParents(execute, options.parents);
    }
    if (execute.indexOf('return') >= 0) {
      func = `(function(){${execute}})`;
    } else {
      func = `(function(){return (${execute})})`;
    }
    return eval(func).call(this);
  },
  js_if(expression, options) {
    const data = options.data;
    let func;
    let execute = expression;
    ('index first last key').split(' ').forEach((prop) => {
      if (typeof data[prop] !== 'undefined') {
        const re1 = new RegExp(`this.@${prop}`, 'g');
        const re2 = new RegExp(`@${prop}`, 'g');
        execute = execute
          .replace(re1, JSON.stringify(data[prop]))
          .replace(re2, JSON.stringify(data[prop]));
      }
    });
    if (options.root && execute.indexOf('@root') >= 0) {
      execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
    }
    if (execute.indexOf('@global') >= 0) {
      execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
    }
    if (execute.indexOf('../') >= 0) {
      execute = Template7Utils.parseJsParents(execute, options.parents);
    }
    if (execute.indexOf('return') >= 0) {
      func = `(function(){${execute}})`;
    } else {
      func = `(function(){return (${execute})})`;
    }
    const condition = eval(func).call(this);
    if (condition) {
      return options.fn(this, options.data);
    }

    return options.inverse(this, options.data);
  },
};
Template7Helpers.js_compare = Template7Helpers.js_if;

const Template7Options = {};
const Template7Partials = {};

class Template7Class {
  constructor(template) {
    const t = this;
    t.template = template;
  }
  compile(template = this.template, depth = 1) {
    const t = this;
    if (t.compiled) return t.compiled;

    if (typeof template !== 'string') {
      throw new Error('Template7: Template must be a string');
    }
    const { stringToBlocks, getCompileVar, getCompiledArguments } = Template7Utils;

    const blocks = stringToBlocks(template);
    const ctx = `ctx_${depth}`;
    const data = `data_${depth}`;
    if (blocks.length === 0) {
      return function empty() { return ''; };
    }

    function getCompileFn(block, newDepth) {
      if (block.content) return t.compile(block.content, newDepth);
      return function empty() { return ''; };
    }
    function getCompileInverse(block, newDepth) {
      if (block.inverseContent) return t.compile(block.inverseContent, newDepth);
      return function empty() { return ''; };
    }

    let resultString = '';
    if (depth === 1) {
      resultString += `(function (${ctx}, ${data}, root) {\n`;
    } else {
      resultString += `(function (${ctx}, ${data}) {\n`;
    }
    if (depth === 1) {
      resultString += 'function isArray(arr){return Array.isArray(arr);}\n';
      resultString += 'function isFunction(func){return (typeof func === \'function\');}\n';
      resultString += 'function c(val, ctx) {if (typeof val !== "undefined" && val !== null) {if (isFunction(val)) {return val.call(ctx);} else return val;} else return "";}\n';
      resultString += 'root = root || ctx_1 || {};\n';
    }
    resultString += 'var r = \'\';\n';
    let i;
    for (i = 0; i < blocks.length; i += 1) {
      const block = blocks[i];
      // Plain block
      if (block.type === 'plain') {
        // eslint-disable-next-line
        resultString += `r +='${(block.content).replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/'/g, '\\' + '\'')}';`;
        continue;
      }
      let variable;
      let compiledArguments;
      // Variable block
      if (block.type === 'variable') {
        variable = getCompileVar(block.contextName, ctx, data);
        resultString += `r += c(${variable}, ${ctx});`;
      }
      // Helpers block
      if (block.type === 'helper') {
        let parents;
        if (ctx !== 'ctx_1') {
          const level = ctx.split('_')[1];
          let parentsString = `ctx_${level - 1}`;
          for (let j = level - 2; j >= 1; j -= 1) {
            parentsString += `, ctx_${j}`;
          }
          parents = `[${parentsString}]`;
        } else {
          parents = `[${ctx}]`;
        }
        let dynamicHelper;
        if (block.helperName.indexOf('[') === 0) {
          block.helperName = getCompileVar(block.helperName.replace(/[[\]]/g, ''), ctx, data);
          dynamicHelper = true;
        }
        if (dynamicHelper || block.helperName in Template7Helpers) {
          compiledArguments = getCompiledArguments(block.contextName, ctx, data);
          resultString += `r += (Template7Helpers${dynamicHelper ? `[${block.helperName}]` : `.${block.helperName}`}).call(${ctx}, ${compiledArguments && (`${compiledArguments}, `)}{hash:${JSON.stringify(block.hash)}, data: ${data} || {}, fn: ${getCompileFn(block, depth + 1)}, inverse: ${getCompileInverse(block, depth + 1)}, root: root, parents: ${parents}});`;
        } else if (block.contextName.length > 0) {
          throw new Error(`Template7: Missing helper: "${block.helperName}"`);
        } else {
          variable = getCompileVar(block.helperName, ctx, data);
          resultString += `if (${variable}) {`;
          resultString += `if (isArray(${variable})) {`;
          resultString += `r += (Template7Helpers.each).call(${ctx}, ${variable}, {hash:${JSON.stringify(block.hash)}, data: ${data} || {}, fn: ${getCompileFn(block, depth + 1)}, inverse: ${getCompileInverse(block, depth + 1)}, root: root, parents: ${parents}});`;
          resultString += '}else {';
          resultString += `r += (Template7Helpers.with).call(${ctx}, ${variable}, {hash:${JSON.stringify(block.hash)}, data: ${data} || {}, fn: ${getCompileFn(block, depth + 1)}, inverse: ${getCompileInverse(block, depth + 1)}, root: root, parents: ${parents}});`;
          resultString += '}}';
        }
      }
    }
    resultString += '\nreturn r;})';

    if (depth === 1) {
      // eslint-disable-next-line
      t.compiled = eval(resultString);
      return t.compiled;
    }
    return resultString;
  }
  static get options() {
    return Template7Options;
  }
  static get partials() {
    return Template7Partials;
  }
  static get helpers() {
    return Template7Helpers;
  }
}

function Template7(...args) {
  const [template, data] = args;
  if (args.length === 2) {
    let instance = new Template7Class(template);
    const rendered = instance.compile()(data);
    instance = null;
    return (rendered);
  }
  return new Template7Class(template);
}
Template7.registerHelper = function registerHelper(name, fn) {
  Template7Class.helpers[name] = fn;
};
Template7.unregisterHelper = function unregisterHelper(name) {
  Template7Class.helpers[name] = undefined;
  delete Template7Class.helpers[name];
};
Template7.registerPartial = function registerPartial(name, template) {
  Template7Class.partials[name] = { template };
};
Template7.unregisterPartial = function unregisterPartial(name) {
  if (Template7Class.partials[name]) {
    Template7Class.partials[name] = undefined;
    delete Template7Class.partials[name];
  }
};
Template7.compile = function compile(template, options) {
  const instance = new Template7Class(template, options);
  return instance.compile();
};

Template7.options = Template7Class.options;
Template7.helpers = Template7Class.helpers;
Template7.partials = Template7Class.partials;

/**
 * SSR Window 2.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2020, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: May 12, 2020
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend(target, src) {
    if (target === void 0) { target = {}; }
    if (src === void 0) { src = {}; }
    Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (isObject(src[key]) &&
            isObject(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}

var doc = typeof document !== 'undefined' ? document : {};
var ssrDocument = {
    body: {},
    addEventListener: function () { },
    removeEventListener: function () { },
    activeElement: {
        blur: function () { },
        nodeName: '',
    },
    querySelector: function () {
        return null;
    },
    querySelectorAll: function () {
        return [];
    },
    getElementById: function () {
        return null;
    },
    createEvent: function () {
        return {
            initEvent: function () { },
        };
    },
    createElement: function () {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function () { },
            getElementsByTagName: function () {
                return [];
            },
        };
    },
    createElementNS: function () {
        return {};
    },
    importNode: function () {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
extend(doc, ssrDocument);

var win = typeof window !== 'undefined' ? window : {};
var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState: function () { },
        pushState: function () { },
        go: function () { },
        back: function () { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener: function () { },
    removeEventListener: function () { },
    getComputedStyle: function () {
        return {
            getPropertyValue: function () {
                return '';
            },
        };
    },
    Image: function () { },
    Date: function () { },
    screen: {},
    setTimeout: function () { },
    clearTimeout: function () { },
    matchMedia: function () {
        return {};
    },
};
extend(win, ssrWindow);

class Dom7 {
  constructor(arr) {
    const self = this;
    // Create array-like object
    for (let i = 0; i < arr.length; i += 1) {
      self[i] = arr[i];
    }
    self.length = arr.length;
    // Return collection with methods
    return this;
  }
}

function $(selector, context) {
  const arr = [];
  let i = 0;
  if (selector && !context) {
    if (selector instanceof Dom7) {
      return selector;
    }
  }
  if (selector) {
      // String
    if (typeof selector === 'string') {
      let els;
      let tempParent;
      const html = selector.trim();
      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        let toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        tempParent = doc.createElement(toCreate);
        tempParent.innerHTML = html;
        for (i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
          // Pure ID selector
          els = [doc.getElementById(selector.trim().split('#')[1])];
        } else {
          // Other selectors
          els = (context || doc).querySelectorAll(selector.trim());
        }
        for (i = 0; i < els.length; i += 1) {
          if (els[i]) arr.push(els[i]);
        }
      }
    } else if (selector.nodeType || selector === win || selector === doc) {
      // Node/element
      arr.push(selector);
    } else if (selector.length > 0 && selector[0].nodeType) {
      // Array of elements or instance of Dom
      for (i = 0; i < selector.length; i += 1) {
        arr.push(selector[i]);
      }
    }
  }
  return new Dom7(arr);
}

$.fn = Dom7.prototype;
$.Class = Dom7;
$.Dom7 = Dom7;

function unique(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());
}

function requestAnimationFrame(callback) {
  if (win.requestAnimationFrame) return win.requestAnimationFrame(callback);
  else if (win.webkitRequestAnimationFrame) return win.webkitRequestAnimationFrame(callback);
  return win.setTimeout(callback, 1000 / 60);
}
function cancelAnimationFrame(id) {
  if (win.cancelAnimationFrame) return win.cancelAnimationFrame(id);
  else if (win.webkitCancelAnimationFrame) return win.webkitCancelAnimationFrame(id);
  return win.clearTimeout(id);
}

// Classes and attributes
function addClass(className) {
  if (typeof className === 'undefined') {
    return this;
  }
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
    }
  }
  return this;
}
function removeClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
    }
  }
  return this;
}
function hasClass(className) {
  if (!this[0]) return false;
  return this[0].classList.contains(className);
}
function toggleClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
    }
  }
  return this;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  }

  // Set attrs
  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      // eslint-disable-next-line
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
// eslint-disable-next-line
function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }
  return this;
}
// eslint-disable-next-line
function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        // eslint-disable-next-line
        for (const propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }
    return this;
  }
}
function data(key, value) {
  let el;
  if (typeof value === 'undefined') {
    el = this[0];
    // Get value
    if (el) {
      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
        return el.dom7ElementDataStorage[key];
      }

      const dataKey = el.getAttribute(`data-${key}`);
      if (dataKey) {
        return dataKey;
      }
      return undefined;
    }
    return undefined;
  }

  // Set value
  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }
  return this;
}
function removeData(key) {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}
function dataset() {
  const el = this[0];
  if (!el) return undefined;
  const dataset = {}; // eslint-disable-line
  if (el.dataset) {
    // eslint-disable-next-line
    for (const dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (let i = 0; i < el.attributes.length; i += 1) {
      // eslint-disable-next-line
      const attr = el.attributes[i];
      if (attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
      }
    }
  }
  // eslint-disable-next-line
  for (const key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;
    else if (dataset[key] === 'true') dataset[key] = true;
    else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }
  return dataset;
}
function val(value) {
  const dom = this;
  if (typeof value === 'undefined') {
    if (dom[0]) {
      if (dom[0].multiple && dom[0].nodeName.toLowerCase() === 'select') {
        const values = [];
        for (let i = 0; i < dom[0].selectedOptions.length; i += 1) {
          values.push(dom[0].selectedOptions[i].value);
        }
        return values;
      }
      return dom[0].value;
    }
    return undefined;
  }

  for (let i = 0; i < dom.length; i += 1) {
    const el = dom[i];
    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
      for (let j = 0; j < el.options.length; j += 1) {
        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
      }
    } else {
      el.value = value;
    }
  }
  return dom;
}
// Transforms
// eslint-disable-next-line
function transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransform = transform;
    elStyle.transform = transform;
  }
  return this;
}
function transition(duration) {
  if (typeof duration !== 'string') {
    duration = `${duration}ms`; // eslint-disable-line
  }
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransitionDuration = duration;
    elStyle.transitionDuration = duration;
  }
  return this;
}
// Events
function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    if ($(target).is(targetSelector)) listener.apply(target, eventData);
    else {
      const parents = $(target).parents(); // eslint-disable-line
      for (let k = 0; k < parents.length; k += 1) {
        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }
  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    listener.apply(this, eventData);
  }
  const events = eventType.split(' ');
  let j;
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent,
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent,
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  const events = eventType.split(' ');
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;
      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }
      if (handlers && handlers.length) {
        for (let k = handlers.length - 1; k >= 0; k -= 1) {
          const handler = handlers[k];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }
  return this;
}
function once(...args) {
  const dom = this;
  let [eventName, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventName, listener, capture] = args;
    targetSelector = undefined;
  }
  function onceHandler(...eventArgs) {
    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);
    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }
  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}
function trigger(...args) {
  const events = args[0].split(' ');
  const eventData = args[1];
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let evt;
      try {
        evt = new win.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true,
        });
      } catch (e) {
        evt = doc.createEvent('Event');
        evt.initEvent(event, true, true);
        evt.detail = eventData;
      }
      // eslint-disable-next-line
      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
      el.dispatchEvent(evt);
      el.dom7EventData = [];
      delete el.dom7EventData;
    }
  }
  return this;
}
function transitionEnd(callback) {
  const events = ['webkitTransitionEnd', 'transitionend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    /* jshint validthis:true */
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
function animationEnd(callback) {
  const events = ['webkitAnimationEnd', 'animationend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
// Sizing/Styles
function width() {
  if (this[0] === win) {
    return win.innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function height() {
  if (this[0] === win) {
    return win.innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = doc.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === win ? win.scrollY : el.scrollTop;
    const scrollLeft = el === win ? win.scrollX : el.scrollLeft;
    return {
      top: (box.top + scrollTop) - clientTop,
      left: (box.left + scrollLeft) - clientLeft,
    };
  }

  return null;
}
function hide() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }
  return this;
}
function show() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.style.display === 'none') {
      el.style.display = '';
    }
    if (win.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }
  return this;
}
function styles() {
  if (this[0]) return win.getComputedStyle(this[0], null);
  return {};
}
function css(props, value) {
  let i;
  if (arguments.length === 1) {
    if (typeof props === 'string') {
      if (this[0]) return win.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i = 0; i < this.length; i += 1) {
        // eslint-disable-next-line
        for (let prop in props) {
          this[i].style[prop] = props[prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === 'string') {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }
    return this;
  }
  return this;
}

// Dom manipulation
function toArray() {
  const arr = [];
  for (let i = 0; i < this.length; i += 1) {
    arr.push(this[i]);
  }
  return arr;
}
// Iterate over the collection passing elements to `callback`
function each(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], i, this[i]) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function forEach(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], this[i], i) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function filter(callback) {
  const matchedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
  }
  return new Dom7(matchedItems);
}
function map(callback) {
  const modifiedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    modifiedItems.push(callback.call(dom[i], i, dom[i]));
  }
  return new Dom7(modifiedItems);
}
// eslint-disable-next-line
function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : undefined;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }
  return this;
}
// eslint-disable-next-line
function text(text) {
  if (typeof text === 'undefined') {
    if (this[0]) {
      return this[0].textContent.trim();
    }
    return null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }
  return this;
}
function is(selector) {
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;
  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

    compareWith = $(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  } else if (selector === doc) return el === doc;
  else if (selector === win) return el === win;

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  return false;
}
function indexOf(el) {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i] === el) return i;
  }
  return -1;
}
function index() {
  let child = this[0];
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
// eslint-disable-next-line
function eq(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;
  let returnIndex;
  if (index > length - 1) {
    return new Dom7([]);
  }
  if (index < 0) {
    returnIndex = length + index;
    if (returnIndex < 0) return new Dom7([]);
    return new Dom7([this[returnIndex]]);
  }
  return new Dom7([this[index]]);
}
function append(...args) {
  let newChild;

  for (let k = 0; k < args.length; k += 1) {
    newChild = args[k];
    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = doc.createElement('div');
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}
// eslint-disable-next-line
function appendTo(parent) {
  $(parent).append(this);
  return this;
}
function prepend(newChild) {
  let i;
  let j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = doc.createElement('div');
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
// eslint-disable-next-line
function prependTo(parent) {
  $(parent).prepend(this);
  return this;
}
function insertBefore(selector) {
  const before = $(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (let j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}
function insertAfter(selector) {
  const after = $(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (let j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return new Dom7([this[0].nextElementSibling]);
      }
      return new Dom7([]);
    }

    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if ($(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return new Dom7(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return new Dom7([el.previousElementSibling]);
      }
      return new Dom7([]);
    }

    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if ($(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return new Dom7(prevEls);
}
function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}
function parent(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }
  return $(unique(parents));
}
function parents(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line
    while (parent) {
      if (selector) {
        if ($(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentNode;
    }
  }
  return $(unique(parents));
}
function closest(selector) {
  let closest = this; // eslint-disable-line
  if (typeof selector === 'undefined') {
    return new Dom7([]);
  }
  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }
  return closest;
}
function find(selector) {
  const foundElements = [];
  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return new Dom7(foundElements);
}
function children(selector) {
  const children = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].childNodes;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector) {
        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
      } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }
  return new Dom7(unique(children));
}
function remove() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function detach() {
  return this.remove();
}
function add(...args) {
  const dom = this;
  let i;
  let j;
  for (i = 0; i < args.length; i += 1) {
    const toAdd = $(args[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom[dom.length] = toAdd[j];
      dom.length += 1;
    }
  }
  return dom;
}
function empty() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.nodeType === 1) {
      for (let j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }
      el.textContent = '';
    }
  }
  return this;
}

var Methods = /*#__PURE__*/Object.freeze({
  addClass: addClass,
  removeClass: removeClass,
  hasClass: hasClass,
  toggleClass: toggleClass,
  attr: attr,
  removeAttr: removeAttr,
  prop: prop,
  data: data,
  removeData: removeData,
  dataset: dataset,
  val: val,
  transform: transform,
  transition: transition,
  on: on,
  off: off,
  once: once,
  trigger: trigger,
  transitionEnd: transitionEnd,
  animationEnd: animationEnd,
  width: width,
  outerWidth: outerWidth,
  height: height,
  outerHeight: outerHeight,
  offset: offset,
  hide: hide,
  show: show,
  styles: styles,
  css: css,
  toArray: toArray,
  each: each,
  forEach: forEach,
  filter: filter,
  map: map,
  html: html,
  text: text,
  is: is,
  indexOf: indexOf,
  index: index,
  eq: eq,
  append: append,
  appendTo: appendTo,
  prepend: prepend,
  prependTo: prependTo,
  insertBefore: insertBefore,
  insertAfter: insertAfter,
  next: next,
  nextAll: nextAll,
  prev: prev,
  prevAll: prevAll,
  siblings: siblings,
  parent: parent,
  parents: parents,
  closest: closest,
  find: find,
  children: children,
  remove: remove,
  detach: detach,
  add: add,
  empty: empty
});

function scrollTo(...args) {
  let [left, top, duration, easing, callback] = args;
  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    [left, top, duration, callback, easing] = args;
  }
  if (typeof easing === 'undefined') easing = 'swing';

  return this.each(function animate() {
    const el = this;
    let currentTop;
    let currentLeft;
    let maxTop;
    let maxLeft;
    let newTop;
    let newLeft;
    let scrollTop; // eslint-disable-line
    let scrollLeft; // eslint-disable-line
    let animateTop = top > 0 || top === 0;
    let animateLeft = left > 0 || left === 0;
    if (typeof easing === 'undefined') {
      easing = 'swing';
    }
    if (animateTop) {
      currentTop = el.scrollTop;
      if (!duration) {
        el.scrollTop = top;
      }
    }
    if (animateLeft) {
      currentLeft = el.scrollLeft;
      if (!duration) {
        el.scrollLeft = left;
      }
    }
    if (!duration) return;
    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }
    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }
    let startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;
    function render(time = new Date().getTime()) {
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));
      let done;
      if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));
      if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));
      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }
      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  });
}
// scrollTop(top, duration, easing, callback) {
function scrollTop(...args) {
  let [top, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [top, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }
  return dom.scrollTo(undefined, top, duration, easing, callback);
}
function scrollLeft(...args) {
  let [left, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [left, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }
  return dom.scrollTo(left, undefined, duration, easing, callback);
}

var Scroll = /*#__PURE__*/Object.freeze({
  scrollTo: scrollTo,
  scrollTop: scrollTop,
  scrollLeft: scrollLeft
});

function animate(initialProps, initialParams) {
  const els = this;
  const a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: 'swing', // or 'linear'
      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */
    }, initialParams),

    elements: els,
    animating: false,
    que: [],

    easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - (Math.cos(progress * Math.PI) / 2);
      }
      if (typeof easing === 'function') {
        return easing(progress);
      }
      return progress;
    },
    stop() {
      if (a.frameId) {
        cancelAnimationFrame(a.frameId);
      }
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done(complete) {
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);
      if (a.que.length > 0) {
        const que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }
      const elements = [];

      // Define & Cache Initials & Units
      a.elements.each((index, el) => {
        let initialFullValue;
        let initialValue;
        let unit;
        let finalValue;
        let finalFullValue;

        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;

        elements[index] = {
          container: el,
        };
        Object.keys(props).forEach((prop) => {
          initialFullValue = win.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue,
            initialValue,
            unit,
            finalValue,
            finalFullValue,
            currentValue: initialValue,
          };
        });
      });

      let startTime = null;
      let time;
      let elementsDone = 0;
      let propsDone = 0;
      let done;
      let began = false;

      a.animating = true;

      function render() {
        time = new Date().getTime();
        let progress;
        let easeProgress;
        // let el;
        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }
        if (startTime === null) {
          startTime = time;
        }
        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);
        }

        elements.forEach((element) => {
          const el = element;
          if (done || el.done) return;
          Object.keys(props).forEach((prop) => {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            const { initialValue, finalValue, unit } = el[prop];
            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));
            const currentValue = el[prop].currentValue;

            if (
              (finalValue > initialValue && currentValue >= finalValue) ||
              (finalValue < initialValue && currentValue <= finalValue)) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;
              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }
              if (elementsDone === elements.length) {
                done = true;
              }
            }
            if (done) {
              a.done(params.complete);
              return;
            }
            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return;
        // Then call
        a.frameId = requestAnimationFrame(render);
      }
      a.frameId = requestAnimationFrame(render);
      return a;
    },
  };

  if (a.elements.length === 0) {
    return els;
  }

  let animateInstance;
  for (let i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }
  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  const els = this;
  for (let i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}

var Animate = /*#__PURE__*/Object.freeze({
  animate: animate,
  stop: stop
});

const noTrigger = ('resize scroll').split(' ');
function eventShortcut(name, ...args) {
  if (typeof args[0] === 'undefined') {
    for (let i = 0; i < this.length; i += 1) {
      if (noTrigger.indexOf(name) < 0) {
        if (name in this[i]) this[i][name]();
        else {
          $(this[i]).trigger(name);
        }
      }
    }
    return this;
  }
  return this.on(name, ...args);
}

function click(...args) {
  return eventShortcut.bind(this)('click', ...args);
}
function blur(...args) {
  return eventShortcut.bind(this)('blur', ...args);
}
function focus(...args) {
  return eventShortcut.bind(this)('focus', ...args);
}
function focusin(...args) {
  return eventShortcut.bind(this)('focusin', ...args);
}
function focusout(...args) {
  return eventShortcut.bind(this)('focusout', ...args);
}
function keyup(...args) {
  return eventShortcut.bind(this)('keyup', ...args);
}
function keydown(...args) {
  return eventShortcut.bind(this)('keydown', ...args);
}
function keypress(...args) {
  return eventShortcut.bind(this)('keypress', ...args);
}
function submit(...args) {
  return eventShortcut.bind(this)('submit', ...args);
}
function change(...args) {
  return eventShortcut.bind(this)('change', ...args);
}
function mousedown(...args) {
  return eventShortcut.bind(this)('mousedown', ...args);
}
function mousemove(...args) {
  return eventShortcut.bind(this)('mousemove', ...args);
}
function mouseup(...args) {
  return eventShortcut.bind(this)('mouseup', ...args);
}
function mouseenter(...args) {
  return eventShortcut.bind(this)('mouseenter', ...args);
}
function mouseleave(...args) {
  return eventShortcut.bind(this)('mouseleave', ...args);
}
function mouseout(...args) {
  return eventShortcut.bind(this)('mouseout', ...args);
}
function mouseover(...args) {
  return eventShortcut.bind(this)('mouseover', ...args);
}
function touchstart(...args) {
  return eventShortcut.bind(this)('touchstart', ...args);
}
function touchend(...args) {
  return eventShortcut.bind(this)('touchend', ...args);
}
function touchmove(...args) {
  return eventShortcut.bind(this)('touchmove', ...args);
}
function resize(...args) {
  return eventShortcut.bind(this)('resize', ...args);
}
function scroll(...args) {
  return eventShortcut.bind(this)('scroll', ...args);
}

var eventShortcuts = /*#__PURE__*/Object.freeze({
  click: click,
  blur: blur,
  focus: focus,
  focusin: focusin,
  focusout: focusout,
  keyup: keyup,
  keydown: keydown,
  keypress: keypress,
  submit: submit,
  change: change,
  mousedown: mousedown,
  mousemove: mousemove,
  mouseup: mouseup,
  mouseenter: mouseenter,
  mouseleave: mouseleave,
  mouseout: mouseout,
  mouseover: mouseover,
  touchstart: touchstart,
  touchend: touchend,
  touchmove: touchmove,
  resize: resize,
  scroll: scroll
});

[Methods, Scroll, Animate, eventShortcuts].forEach((group) => {
  Object.keys(group).forEach((methodName) => {
    $.fn[methodName] = group[methodName];
  });
});

// Remove Diacritics
const defaultDiacriticsRemovalap = [
  { base: 'A', letters: '\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F' },
  { base: 'AA', letters: '\uA732' },
  { base: 'AE', letters: '\u00C6\u01FC\u01E2' },
  { base: 'AO', letters: '\uA734' },
  { base: 'AU', letters: '\uA736' },
  { base: 'AV', letters: '\uA738\uA73A' },
  { base: 'AY', letters: '\uA73C' },
  { base: 'B', letters: '\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181' },
  { base: 'C', letters: '\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E' },
  { base: 'D', letters: '\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779' },
  { base: 'DZ', letters: '\u01F1\u01C4' },
  { base: 'Dz', letters: '\u01F2\u01C5' },
  { base: 'E', letters: '\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E' },
  { base: 'F', letters: '\u0046\u24BB\uFF26\u1E1E\u0191\uA77B' },
  { base: 'G', letters: '\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E' },
  { base: 'H', letters: '\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D' },
  { base: 'I', letters: '\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197' },
  { base: 'J', letters: '\u004A\u24BF\uFF2A\u0134\u0248' },
  { base: 'K', letters: '\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2' },
  { base: 'L', letters: '\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780' },
  { base: 'LJ', letters: '\u01C7' },
  { base: 'Lj', letters: '\u01C8' },
  { base: 'M', letters: '\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C' },
  { base: 'N', letters: '\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4' },
  { base: 'NJ', letters: '\u01CA' },
  { base: 'Nj', letters: '\u01CB' },
  { base: 'O', letters: '\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C' },
  { base: 'OI', letters: '\u01A2' },
  { base: 'OO', letters: '\uA74E' },
  { base: 'OU', letters: '\u0222' },
  { base: 'OE', letters: '\u008C\u0152' },
  { base: 'oe', letters: '\u009C\u0153' },
  { base: 'P', letters: '\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754' },
  { base: 'Q', letters: '\u0051\u24C6\uFF31\uA756\uA758\u024A' },
  { base: 'R', letters: '\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782' },
  { base: 'S', letters: '\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784' },
  { base: 'T', letters: '\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786' },
  { base: 'TZ', letters: '\uA728' },
  { base: 'U', letters: '\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244' },
  { base: 'V', letters: '\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245' },
  { base: 'VY', letters: '\uA760' },
  { base: 'W', letters: '\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72' },
  { base: 'X', letters: '\u0058\u24CD\uFF38\u1E8A\u1E8C' },
  { base: 'Y', letters: '\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE' },
  { base: 'Z', letters: '\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762' },
  { base: 'a', letters: '\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250' },
  { base: 'aa', letters: '\uA733' },
  { base: 'ae', letters: '\u00E6\u01FD\u01E3' },
  { base: 'ao', letters: '\uA735' },
  { base: 'au', letters: '\uA737' },
  { base: 'av', letters: '\uA739\uA73B' },
  { base: 'ay', letters: '\uA73D' },
  { base: 'b', letters: '\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253' },
  { base: 'c', letters: '\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184' },
  { base: 'd', letters: '\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A' },
  { base: 'dz', letters: '\u01F3\u01C6' },
  { base: 'e', letters: '\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD' },
  { base: 'f', letters: '\u0066\u24D5\uFF46\u1E1F\u0192\uA77C' },
  { base: 'g', letters: '\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F' },
  { base: 'h', letters: '\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265' },
  { base: 'hv', letters: '\u0195' },
  { base: 'i', letters: '\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131' },
  { base: 'j', letters: '\u006A\u24D9\uFF4A\u0135\u01F0\u0249' },
  { base: 'k', letters: '\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3' },
  { base: 'l', letters: '\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747' },
  { base: 'lj', letters: '\u01C9' },
  { base: 'm', letters: '\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F' },
  { base: 'n', letters: '\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5' },
  { base: 'nj', letters: '\u01CC' },
  { base: 'o', letters: '\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275' },
  { base: 'oi', letters: '\u01A3' },
  { base: 'ou', letters: '\u0223' },
  { base: 'oo', letters: '\uA74F' },
  { base: 'p', letters: '\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755' },
  { base: 'q', letters: '\u0071\u24E0\uFF51\u024B\uA757\uA759' },
  { base: 'r', letters: '\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783' },
  { base: 's', letters: '\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B' },
  { base: 't', letters: '\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787' },
  { base: 'tz', letters: '\uA729' },
  { base: 'u', letters: '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289' },
  { base: 'v', letters: '\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C' },
  { base: 'vy', letters: '\uA761' },
  { base: 'w', letters: '\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73' },
  { base: 'x', letters: '\u0078\u24E7\uFF58\u1E8B\u1E8D' },
  { base: 'y', letters: '\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF' },
  { base: 'z', letters: '\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763' },
];

const diacriticsMap = {};
for (let i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
  const letters = defaultDiacriticsRemovalap[i].letters;
  for (let j = 0; j < letters.length; j += 1) {
    diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
  }
}

let uniqueNumber = 1;

const Utils = {
  uniqueNumber() {
    uniqueNumber += 1;
    return uniqueNumber;
  },
  id(mask = 'xxxxxxxxxx', map = '0123456789abcdef') {
    const length = map.length;
    return mask.replace(/x/g, () => map[Math.floor((Math.random() * length))]);
  },
  mdPreloaderContent: `
    <span class="preloader-inner">
      <span class="preloader-inner-gap"></span>
      <span class="preloader-inner-left">
          <span class="preloader-inner-half-circle"></span>
      </span>
      <span class="preloader-inner-right">
          <span class="preloader-inner-half-circle"></span>
      </span>
    </span>
  `.trim(),
  iosPreloaderContent: `
    <span class="preloader-inner">
      ${[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(() => '<span class="preloader-inner-line"></span>').join('')}
    </span>
  `.trim(),
  auroraPreloaderContent: `
    <span class="preloader-inner">
      <span class="preloader-inner-circle"></span>
    </span>
  `,
  eventNameToColonCase(eventName) {
    let hasColon;
    return eventName.split('').map((char, index) => {
      if (char.match(/[A-Z]/) && index !== 0 && !hasColon) {
        hasColon = true;
        return `:${char.toLowerCase()}`;
      }
      return char.toLowerCase();
    }).join('');
  },
  deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
        // no setter for object
      }
      try {
        delete object[key];
      } catch (e) {
        // something got wrong
      }
    });
  },
  nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  },
  nextFrame(callback) {
    return Utils.requestAnimationFrame(() => {
      Utils.requestAnimationFrame(callback);
    });
  },
  now() {
    return Date.now();
  },
  requestAnimationFrame(callback) {
    return win.requestAnimationFrame(callback);
  },
  cancelAnimationFrame(id) {
    return win.cancelAnimationFrame(id);
  },
  removeDiacritics(str) {
    return str.replace(/[^\u0000-\u007E]/g, a => diacriticsMap[a] || a);
  },
  parseUrlQuery(url) {
    const query = {};
    let urlToParse = url || win.location.href;
    let i;
    let params;
    let param;
    let length;
    if (typeof urlToParse === 'string' && urlToParse.length) {
      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
      params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');
      length = params.length;

      for (i = 0; i < length; i += 1) {
        param = params[i].replace(/#\S+/g, '').split('=');
        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param.slice(1).join('=')) || '';
      }
    }
    return query;
  },
  getTranslate(el, axis = 'x') {
    let matrix;
    let curTransform;
    let transformMatrix;

    const curStyle = win.getComputedStyle(el, null);

    if (win.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
      }
      // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case
      transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (win.WebKitCSSMatrix) curTransform = transformMatrix.m41;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (win.WebKitCSSMatrix) curTransform = transformMatrix.m42;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  },
  serializeObject(obj, parents = []) {
    if (typeof obj === 'string') return obj;
    const resultArray = [];
    const separator = '&';
    let newParents;
    function varName(name) {
      if (parents.length > 0) {
        let parentParts = '';
        for (let j = 0; j < parents.length; j += 1) {
          if (j === 0) parentParts += parents[j];
          else parentParts += `[${encodeURIComponent(parents[j])}]`;
        }
        return `${parentParts}[${encodeURIComponent(name)}]`;
      }
      return encodeURIComponent(name);
    }
    function varValue(value) {
      return encodeURIComponent(value);
    }
    Object.keys(obj).forEach((prop) => {
      let toPush;
      if (Array.isArray(obj[prop])) {
        toPush = [];
        for (let i = 0; i < obj[prop].length; i += 1) {
          if (!Array.isArray(obj[prop][i]) && typeof obj[prop][i] === 'object') {
            newParents = parents.slice();
            newParents.push(prop);
            newParents.push(String(i));
            toPush.push(Utils.serializeObject(obj[prop][i], newParents));
          } else {
            toPush.push(`${varName(prop)}[]=${varValue(obj[prop][i])}`);
          }
        }
        if (toPush.length > 0) resultArray.push(toPush.join(separator));
      } else if (obj[prop] === null || obj[prop] === '') {
        resultArray.push(`${varName(prop)}=`);
      } else if (typeof obj[prop] === 'object') {
        // Object, convert to named array
        newParents = parents.slice();
        newParents.push(prop);
        toPush = Utils.serializeObject(obj[prop], newParents);
        if (toPush !== '') resultArray.push(toPush);
      } else if (typeof obj[prop] !== 'undefined' && obj[prop] !== '') {
        // Should be string or plain value
        resultArray.push(`${varName(prop)}=${varValue(obj[prop])}`);
      } else if (obj[prop] === '') resultArray.push(varName(prop));
    });
    return resultArray.join(separator);
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  merge(...args) {
    const to = args[0];
    args.splice(0, 1);
    const from = args;

    for (let i = 0; i < from.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  },
  extend(...args) {
    let deep = true;
    let to;
    let from;
    if (typeof args[0] === 'boolean') {
      deep = args[0];
      to = args[1];
      args.splice(0, 2);
      from = args;
    } else {
      to = args[0];
      args.splice(0, 1);
      from = args;
    }
    for (let i = 0; i < from.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (!deep) {
              to[nextKey] = nextSource[nextKey];
            } else if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
  colorHexToRgb(hex) {
    const h = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
    return result
      ? result.slice(1).map(n => parseInt(n, 16))
      : null;
  },
  colorRgbToHex(r, g, b) {
    const result = [r, g, b].map((n) => {
      const hex = n.toString(16);
      return hex.length === 1 ? `0${hex}` : hex;
    }).join('');
    return `#${result}`;
  },
  colorRgbToHsl(r, g, b) {
    r /= 255; // eslint-disable-line
    g /= 255; // eslint-disable-line
    b /= 255; // eslint-disable-line
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    let h;
    if (d === 0) h = 0;
    else if (max === r) h = ((g - b) / d) % 6;
    else if (max === g) h = (b - r) / d + 2;
    else if (max === b) h = (r - g) / d + 4;
    const l = (min + max) / 2;
    const s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
    if (h < 0) h = 360 / 60 + h;
    return [h * 60, s, l];
  },
  colorHslToRgb(h, s, l) {
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const hp = h / 60;
    const x = c * (1 - Math.abs((hp % 2) - 1));
    let rgb1;
    if (Number.isNaN(h) || typeof h === 'undefined') {
      rgb1 = [0, 0, 0];
    } else if (hp <= 1) rgb1 = [c, x, 0];
    else if (hp <= 2) rgb1 = [x, c, 0];
    else if (hp <= 3) rgb1 = [0, c, x];
    else if (hp <= 4) rgb1 = [0, x, c];
    else if (hp <= 5) rgb1 = [x, 0, c];
    else if (hp <= 6) rgb1 = [c, 0, x];
    const m = l - (c / 2);
    return rgb1.map(n => Math.max(0, Math.min(255, Math.round(255 * (n + m)))));
  },
  colorHsbToHsl(h, s, b) {
    const HSL = {
      h,
      s: 0,
      l: 0,
    };
    const HSB = { h, s, b };

    HSL.l = (2 - HSB.s) * HSB.b / 2;
    HSL.s = HSL.l && HSL.l < 1 ? HSB.s * HSB.b / (HSL.l < 0.5 ? HSL.l * 2 : 2 - HSL.l * 2) : HSL.s;

    return [HSL.h, HSL.s, HSL.l];
  },
  colorHslToHsb(h, s, l) {
    const HSB = {
      h,
      s: 0,
      b: 0,
    };
    const HSL = { h, s, l };

    const t = HSL.s * (HSL.l < 0.5 ? HSL.l : 1 - HSL.l);
    HSB.b = HSL.l + t;
    HSB.s = HSL.l > 0 ? 2 * t / HSB.b : HSB.s;

    return [HSB.h, HSB.s, HSB.b];
  },
  colorThemeCSSProperties(...args) {
    let hex;
    let rgb;
    if (args.length === 1) {
      hex = args[0];
      rgb = Utils.colorHexToRgb(hex);
    } else if (args.length === 3) {
      rgb = args;
      hex = Utils.colorRgbToHex(...rgb);
    }
    if (!rgb) return {};
    const hsl = Utils.colorRgbToHsl(...rgb);
    const hslShade = [hsl[0], hsl[1], Math.max(0, (hsl[2] - 0.08))];
    const hslTint = [hsl[0], hsl[1], Math.max(0, (hsl[2] + 0.08))];
    const shade = Utils.colorRgbToHex(...Utils.colorHslToRgb(...hslShade));
    const tint = Utils.colorRgbToHex(...Utils.colorHslToRgb(...hslTint));
    return {
      '--f7-theme-color': hex,
      '--f7-theme-color-rgb': rgb.join(', '),
      '--f7-theme-color-shade': shade,
      '--f7-theme-color-tint': tint,
    };
  },
};

const Support = (function Support() {
  return {
    touch: !!(('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch)),

    pointerEvents: !!win.PointerEvent && ('maxTouchPoints' in win.navigator) && win.navigator.maxTouchPoints >= 0,

    observer: (function checkObserver() {
      return ('MutationObserver' in win || 'WebkitMutationObserver' in win);
    }()),

    passiveListener: (function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          },
        });
        win.addEventListener('testPassiveListener', null, opts);
      } catch (e) {
        // No support
      }
      return supportsPassive;
    }()),

    gestures: (function checkGestures() {
      return 'ongesturestart' in win;
    }()),

    intersectionObserver: (function checkObserver() {
      return ('IntersectionObserver' in win);
    }()),
  };
}());

const Device = (function Device() {
  const platform = win.navigator.platform;
  const ua = win.navigator.userAgent;

  const device = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    iphone: false,
    ipod: false,
    ipad: false,
    edge: false,
    ie: false,
    firefox: false,
    macos: false,
    windows: false,
    cordova: !!(win.cordova || win.phonegap),
    phonegap: !!(win.cordova || win.phonegap),
    electron: false,
    nwjs: false,
  };

  const screenWidth = win.screen.width;
  const screenHeight = win.screen.height;

  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
  const edge = ua.indexOf('Edge/') >= 0;
  const firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
  const windows = platform === 'Win32';
  const electron = ua.toLowerCase().indexOf('electron') >= 0;
  const nwjs = typeof nw !== 'undefined' && typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.nw !== 'undefined';
  let macos = platform === 'MacIntel';

  // iPadOs 13 fix
  const iPadScreens = [
    '1024x1366',
    '1366x1024',
    '834x1194',
    '1194x834',
    '834x1112',
    '1112x834',
    '768x1024',
    '1024x768',
  ];
  if (!ipad
    && macos
    && Support.touch
    && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0
  ) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  }

  device.ie = ie;
  device.edge = edge;
  device.firefox = firefox;

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.osVersion = android[2];
    device.android = true;
    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }
  // iOS
  if (iphone && !ipod) {
    device.osVersion = iphone[2].replace(/_/g, '.');
    device.iphone = true;
  }
  if (ipad) {
    device.osVersion = ipad[2].replace(/_/g, '.');
    device.ipad = true;
  }
  if (ipod) {
    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    device.ipod = true;
  }
  // iOS 8+ changed UA
  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
    if (device.osVersion.split('.')[0] === '10') {
      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
    }
  }

  // Webview
  device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win.navigator.standalone))
    || (win.matchMedia && win.matchMedia('(display-mode: standalone)').matches);
  device.webview = device.webView;
  device.standalone = device.webView;

  // Desktop
  device.desktop = !(device.ios || device.android) || electron || nwjs;
  if (device.desktop) {
    device.electron = electron;
    device.nwjs = nwjs;
    device.macos = macos;
    device.windows = windows;
    if (device.macos) {
      device.os = 'macos';
    }
    if (device.windows) {
      device.os = 'windows';
    }
  }

  // Pixel Ratio
  device.pixelRatio = win.devicePixelRatio || 1;

  // Color Scheme
  const DARK = '(prefers-color-scheme: dark)';
  const LIGHT = '(prefers-color-scheme: light)';
  device.prefersColorScheme = function prefersColorTheme() {
    let theme;
    if (win.matchMedia && win.matchMedia(LIGHT).matches) {
      theme = 'light';
    }
    if (win.matchMedia && win.matchMedia(DARK).matches) {
      theme = 'dark';
    }
    return theme;
  };

  // Export object
  return device;
}());

class EventsClass {
  constructor(parents = []) {
    const self = this;
    self.eventsParents = parents;
    self.eventsListeners = {};
  }

  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach((event) => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  }

  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    function onceHandler(...args) {
      self.off(events, onceHandler);
      if (onceHandler.f7proxy) {
        delete onceHandler.f7proxy;
      }
      handler.apply(self, args);
    }
    onceHandler.f7proxy = handler;
    return self.on(events, onceHandler, priority);
  }

  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach((event) => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  }

  emit(...args) {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    let eventsParents;
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
      eventsParents = self.eventsParents;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
      eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
    }
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    const localEvents = eventsArray.map(eventName => eventName.replace('local::', ''));
    const parentEvents = eventsArray.filter(eventName => eventName.indexOf('local::') < 0);

    localEvents.forEach((event) => {
      if (self.eventsListeners && self.eventsListeners[event]) {
        const handlers = [];
        self.eventsListeners[event].forEach((eventHandler) => {
          handlers.push(eventHandler);
        });
        handlers.forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    if (eventsParents && eventsParents.length > 0) {
      eventsParents.forEach((eventsParent) => {
        eventsParent.emit(parentEvents, ...data);
      });
    }
    return self;
  }
}

class Framework7Class extends EventsClass {
  constructor(params = {}, parents = []) {
    super(parents);
    const self = this;
    self.params = params;

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach((eventName) => {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  }

  // eslint-disable-next-line
  useModuleParams(module, instanceParams) {
    if (module.params) {
      const originalParams = {};
      Object.keys(module.params).forEach((paramKey) => {
        if (typeof instanceParams[paramKey] === 'undefined') return;
        originalParams[paramKey] = Utils.extend({}, instanceParams[paramKey]);
      });
      Utils.extend(instanceParams, module.params);
      Object.keys(originalParams).forEach((paramKey) => {
        Utils.extend(instanceParams[paramKey], originalParams[paramKey]);
      });
    }
  }

  useModulesParams(instanceParams) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      // Extend params
      if (module.params) {
        Utils.extend(instanceParams, module.params);
      }
    });
  }

  useModule(moduleName = '', moduleParams = {}) {
    const instance = this;
    if (!instance.modules) return;
    const module = typeof moduleName === 'string' ? instance.modules[moduleName] : moduleName;
    if (!module) return;

    // Extend instance methods and props
    if (module.instance) {
      Object.keys(module.instance).forEach((modulePropName) => {
        const moduleProp = module.instance[modulePropName];
        if (typeof moduleProp === 'function') {
          instance[modulePropName] = moduleProp.bind(instance);
        } else {
          instance[modulePropName] = moduleProp;
        }
      });
    }
    // Add event listeners
    if (module.on && instance.on) {
      Object.keys(module.on).forEach((moduleEventName) => {
        instance.on(moduleEventName, module.on[moduleEventName]);
      });
    }
    // Add vnode hooks
    if (module.vnode) {
      if (!instance.vnodeHooks) instance.vnodeHooks = {};
      Object.keys(module.vnode).forEach((vnodeId) => {
        Object.keys(module.vnode[vnodeId]).forEach((hookName) => {
          const handler = module.vnode[vnodeId][hookName];
          if (!instance.vnodeHooks[hookName]) instance.vnodeHooks[hookName] = {};
          if (!instance.vnodeHooks[hookName][vnodeId]) instance.vnodeHooks[hookName][vnodeId] = [];
          instance.vnodeHooks[hookName][vnodeId].push(handler.bind(instance));
        });
      });
    }
    // Module create callback
    if (module.create) {
      module.create.bind(instance)(moduleParams);
    }
  }

  useModules(modulesParams = {}) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const moduleParams = modulesParams[moduleName] || {};
      instance.useModule(moduleName, moduleParams);
    });
  }

  static set components(components) {
    const Class = this;
    if (!Class.use) return;
    Class.use(components);
  }

  static installModule(module, ...params) {
    const Class = this;
    if (!Class.prototype.modules) Class.prototype.modules = {};
    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);
    Class.prototype.modules[name] = module;
    // Prototype
    if (module.proto) {
      Object.keys(module.proto).forEach((key) => {
        Class.prototype[key] = module.proto[key];
      });
    }
    // Class
    if (module.static) {
      Object.keys(module.static).forEach((key) => {
        Class[key] = module.static[key];
      });
    }
    // Callback
    if (module.install) {
      module.install.apply(Class, params);
    }
    return Class;
  }

  static use(module, ...params) {
    const Class = this;
    if (Array.isArray(module)) {
      module.forEach(m => Class.installModule(m));
      return Class;
    }
    return Class.installModule(module, ...params);
  }
}

function ConstructorMethods (parameters = {}) {
  const {
    defaultSelector,
    constructor: Constructor,
    domProp,
    app,
    addMethods,
  } = parameters;
  const methods = {
    create(...args) {
      if (app) return new Constructor(app, ...args);
      return new Constructor(...args);
    },
    get(el = defaultSelector) {
      if (el instanceof Constructor) return el;
      const $el = $(el);
      if ($el.length === 0) return undefined;
      return $el[0][domProp];
    },
    destroy(el) {
      const instance = methods.get(el);
      if (instance && instance.destroy) return instance.destroy();
      return undefined;
    },
  };
  if (addMethods && Array.isArray(addMethods)) {
    addMethods.forEach((methodName) => {
      methods[methodName] = (el = defaultSelector, ...args) => {
        const instance = methods.get(el);
        if (instance && instance[methodName]) return instance[methodName](...args);
        return undefined;
      };
    });
  }
  return methods;
}

function ModalMethods (parameters = {}) {
  const { defaultSelector, constructor: Constructor, app } = parameters;
  const methods = Utils.extend(
    ConstructorMethods({
      defaultSelector,
      constructor: Constructor,
      app,
      domProp: 'f7Modal',
    }),
    {
      open(el, animate, targetEl) {
        let $el = $(el);
        if ($el.length > 1 && targetEl) {
          // check if same modal in other page
          const $targetPage = $(targetEl).parents('.page');
          if ($targetPage.length) {
            $el.each((index, modalEl) => {
              const $modalEl = $(modalEl);
              if ($modalEl.parents($targetPage)[0] === $targetPage[0]) {
                $el = $modalEl;
              }
            });
          }
        }
        if ($el.length > 1) {
          $el = $el.eq($el.length - 1);
        }
        if (!$el.length) return undefined;
        let instance = $el[0].f7Modal;
        if (!instance) {
          const params = $el.dataset();
          instance = new Constructor(app, { el: $el, ...params });
        }
        return instance.open(animate);
      },
      close(el = defaultSelector, animate, targetEl) {
        let $el = $(el);
        if (!$el.length) return undefined;
        if ($el.length > 1) {
          // check if close link (targetEl) in this modal
          let $parentEl;
          if (targetEl) {
            const $targetEl = $(targetEl);
            if ($targetEl.length) {
              $parentEl = $targetEl.parents($el);
            }
          }
          if ($parentEl && $parentEl.length > 0) {
            $el = $parentEl;
          } else {
            $el = $el.eq($el.length - 1);
          }
        }
        let instance = $el[0].f7Modal;
        if (!instance) {
          const params = $el.dataset();
          instance = new Constructor(app, { el: $el, ...params });
        }
        return instance.close(animate);
      },
    }
  );
  return methods;
}

const fetchedModules = [];
function loadModule(moduleToLoad) {
  const Framework7 = this;
  return new Promise((resolve, reject) => {
    const app = Framework7.instance;
    let modulePath;
    let moduleObj;
    let moduleFunc;
    if (!moduleToLoad) {
      reject(new Error('Framework7: Lazy module must be specified'));
      return;
    }

    function install(module) {
      Framework7.use(module);

      if (app) {
        app.useModuleParams(module, app.params);
        app.useModule(module);
      }
    }

    if (typeof moduleToLoad === 'string') {
      const matchNamePattern = moduleToLoad.match(/([a-z0-9-]*)/i);
      if (moduleToLoad.indexOf('.') < 0 && matchNamePattern && matchNamePattern[0].length === moduleToLoad.length) {
        if (!app || (app && !app.params.lazyModulesPath)) {
          reject(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name'));
          return;
        }
        modulePath = `${app.params.lazyModulesPath}/${moduleToLoad}.js`;
      } else {
        modulePath = moduleToLoad;
      }
    } else if (typeof moduleToLoad === 'function') {
      moduleFunc = moduleToLoad;
    } else {
      // considering F7-Plugin object
      moduleObj = moduleToLoad;
    }

    if (moduleFunc) {
      const module = moduleFunc(Framework7, false);
      if (!module) {
        reject(new Error('Framework7: Can\'t find Framework7 component in specified component function'));
        return;
      }
      // Check if it was added
      if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
        resolve();
        return;
      }
      // Install It
      install(module);

      resolve();
    }
    if (moduleObj) {
      const module = moduleObj;
      if (!module) {
        reject(new Error('Framework7: Can\'t find Framework7 component in specified component'));
        return;
      }
      // Check if it was added
      if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
        resolve();
        return;
      }
      // Install It
      install(module);

      resolve();
    }
    if (modulePath) {
      if (fetchedModules.indexOf(modulePath) >= 0) {
        resolve();
        return;
      }
      fetchedModules.push(modulePath);
      const scriptLoad = new Promise((resolveScript, rejectScript) => {
        Framework7.request.get(
          modulePath,
          (scriptContent) => {
            const id = Utils.id();
            const callbackLoadName = `f7_component_loader_callback_${id}`;

            const scriptEl = doc.createElement('script');
            scriptEl.innerHTML = `window.${callbackLoadName} = function (Framework7, Framework7AutoInstallComponent) {return ${scriptContent.trim()}}`;
            $('head').append(scriptEl);

            const componentLoader = win[callbackLoadName];
            delete win[callbackLoadName];
            $(scriptEl).remove();

            const module = componentLoader(Framework7, false);

            if (!module) {
              rejectScript(new Error(`Framework7: Can't find Framework7 component in ${modulePath} file`));
              return;
            }

            // Check if it was added
            if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
              resolveScript();
              return;
            }

            // Install It
            install(module);

            resolveScript();
          },
          (xhr, status) => {
            rejectScript(xhr, status);
          }
        );
      });
      const styleLoad = new Promise((resolveStyle) => {
        Framework7.request.get(
          modulePath.replace('.js', app.rtl ? '.rtl.css' : '.css'),
          (styleContent) => {
            const styleEl = doc.createElement('style');
            styleEl.innerHTML = styleContent;
            $('head').append(styleEl);

            resolveStyle();
          },
          () => {
            resolveStyle();
          }
        );
      });

      Promise.all([scriptLoad, styleLoad]).then(() => {
        resolve();
      }).catch((err) => {
        reject(err);
      });
    }
  });
}

class Framework7 extends Framework7Class {
  constructor(params) {
    super(params);
    if (Framework7.instance) {
      throw new Error('Framework7 is already initialized and can\'t be initialized more than once');
    }

    const passedParams = Utils.extend({}, params);

    // App Instance
    const app = this;

    Framework7.instance = app;

    // Default
    const defaults = {
      version: '1.0.0',
      id: 'io.framework7.testapp',
      root: 'body',
      theme: 'auto',
      language: win.navigator.language,
      routes: [],
      name: 'Framework7',
      lazyModulesPath: null,
      initOnDeviceReady: true,
      init: true,
      autoDarkTheme: false,
      iosTranslucentBars: true,
      iosTranslucentModals: true,
      component: undefined,
      componentUrl: undefined,
    };

    // Extend defaults with modules params
    app.useModulesParams(defaults);

    // Extend defaults with passed params
    app.params = Utils.extend(defaults, params);

    const $rootEl = $(app.params.root);

    Utils.extend(app, {
      // App Id
      id: app.params.id,
      // App Name
      name: app.params.name,
      // App version
      version: app.params.version,
      // Routes
      routes: app.params.routes,
      // Lang
      language: app.params.language,
      // Root
      root: $rootEl,
      // RTL
      rtl: $rootEl.css('direction') === 'rtl',
      // Theme
      theme: (function getTheme() {
        if (app.params.theme === 'auto') {
          if (Device.ios) return 'ios';
          if (Device.desktop && Device.electron) return 'aurora';
          return 'md';
        }
        return app.params.theme;
      }()),
      // Initially passed parameters
      passedParams,
      online: win.navigator.onLine,
    });

    // Save Root
    if (app.root && app.root[0]) {
      app.root[0].f7 = app;
    }

    // Install Modules
    app.useModules();

    // Init Data & Methods
    app.initData();

    // Auto Dark Theme
    const DARK = '(prefers-color-scheme: dark)';
    const LIGHT = '(prefers-color-scheme: light)';
    app.mq = {};
    if (win.matchMedia) {
      app.mq.dark = win.matchMedia(DARK);
      app.mq.light = win.matchMedia(LIGHT);
    }
    app.colorSchemeListener = function colorSchemeListener({ matches, media }) {
      if (!matches) {
        return;
      }
      const html = doc.querySelector('html');
      if (media === DARK) {
        html.classList.add('theme-dark');
        app.darkTheme = true;
        app.emit('darkThemeChange', true);
      } else if (media === LIGHT) {
        html.classList.remove('theme-dark');
        app.darkTheme = false;
        app.emit('darkThemeChange', false);
      }
    };

    // Init
    if (app.params.init) {
      if (Device.cordova && app.params.initOnDeviceReady) {
        $(doc).on('deviceready', () => {
          app.init();
        });
      } else {
        app.init();
      }
    }

    // Return app instance
    return app;
  }

  initData() {
    const app = this;

    // Data
    app.data = {};
    if (app.params.data && typeof app.params.data === 'function') {
      Utils.extend(app.data, app.params.data.bind(app)());
    } else if (app.params.data) {
      Utils.extend(app.data, app.params.data);
    }
    // Methods
    app.methods = {};
    if (app.params.methods) {
      Object.keys(app.params.methods).forEach((methodName) => {
        if (typeof app.params.methods[methodName] === 'function') {
          app.methods[methodName] = app.params.methods[methodName].bind(app);
        } else {
          app.methods[methodName] = app.params.methods[methodName];
        }
      });
    }
  }

  enableAutoDarkTheme() {
    if (!win.matchMedia) return;
    const app = this;
    const html = doc.querySelector('html');
    if (app.mq.dark && app.mq.light) {
      app.mq.dark.addListener(app.colorSchemeListener);
      app.mq.light.addListener(app.colorSchemeListener);
    }
    if (app.mq.dark && app.mq.dark.matches) {
      html.classList.add('theme-dark');
      app.darkTheme = true;
      app.emit('darkThemeChange', true);
    } else if (app.mq.light && app.mq.light.matches) {
      html.classList.remove('theme-dark');
      app.darkTheme = false;
      app.emit('darkThemeChange', false);
    }
  }

  disableAutoDarkTheme() {
    if (!win.matchMedia) return;
    const app = this;
    if (app.mq.dark) app.mq.dark.removeListener(app.colorSchemeListener);
    if (app.mq.light) app.mq.light.removeListener(app.colorSchemeListener);
  }

  initAppComponent(callback) {
    const app = this;
    app.router.componentLoader(
      app.params.component,
      app.params.componentUrl,
      { componentOptions: { el: app.root[0], root: true } },
      (el) => {
        app.root = $(el);
        app.root[0].f7 = app;
        app.rootComponent = el.f7Component;
        if (callback) callback();
      },
      () => {}
    );
  }

  // eslint-disable-next-line
  _init() {
    const app = this;
    if (app.initialized) return app;

    app.root.addClass('framework7-initializing');

    // RTL attr
    if (app.rtl) {
      $('html').attr('dir', 'rtl');
    }

    // Auto Dark Theme
    if (app.params.autoDarkTheme) {
      app.enableAutoDarkTheme();
    }

    // Watch for online/offline state
    win.addEventListener('offline', () => {
      app.online = false;
      app.emit('offline');
      app.emit('connection', false);
    });
    win.addEventListener('online', () => {
      app.online = true;
      app.emit('online');
      app.emit('connection', true);
    });

    // Root class
    app.root.addClass('framework7-root');

    // Theme class
    $('html').removeClass('ios md aurora').addClass(app.theme);

    // iOS Translucent
    if (app.params.iosTranslucentBars && app.theme === 'ios' && Device.ios) {
      $('html').addClass('ios-translucent-bars');
    }
    if (app.params.iosTranslucentModals && app.theme === 'ios' && Device.ios) {
      $('html').addClass('ios-translucent-modals');
    }

    // Init class
    Utils.nextFrame(() => {
      app.root.removeClass('framework7-initializing');
    });
    // Emit, init other modules
    app.initialized = true;
    app.emit('init');

    return app;
  }

  init() {
    const app = this;
    if (app.params.component || app.params.componentUrl) {
      app.initAppComponent(() => {
        app._init(); // eslint-disable-line
      });
    } else {
      app._init(); // eslint-disable-line
    }
  }

  // eslint-disable-next-line
  loadModule(...args) {
    return Framework7.loadModule(...args);
  }

  // eslint-disable-next-line
  loadModules(...args) {
    return Framework7.loadModules(...args);
  }

  getVnodeHooks(hook, id) {
    const app = this;
    if (!app.vnodeHooks || !app.vnodeHooks[hook]) return [];
    return app.vnodeHooks[hook][id] || [];
  }

  // eslint-disable-next-line
  get $() {
    return $;
  }
  // eslint-disable-next-line
  get t7() {
    return Template7;
  }

  static get Dom7() {
    return $;
  }

  static get $() {
    return $;
  }

  static get Template7() {
    return Template7;
  }

  static get Class() {
    return Framework7Class;
  }

  static get Events() {
    return EventsClass;
  }
}

Framework7.ModalMethods = ModalMethods;
Framework7.ConstructorMethods = ConstructorMethods;

Framework7.loadModule = loadModule;
Framework7.loadModules = function loadModules(modules) {
  return Promise.all(modules.map(module => Framework7.loadModule(module)));
};

const globals = {};
let jsonpRequests = 0;

function Request(requestOptions) {
  const globalsNoCallbacks = Utils.extend({}, globals);
  ('beforeCreate beforeOpen beforeSend error complete success statusCode').split(' ').forEach((callbackName) => {
    delete globalsNoCallbacks[callbackName];
  });
  const defaults = Utils.extend({
    url: win.location.toString(),
    method: 'GET',
    data: false,
    async: true,
    cache: true,
    user: '',
    password: '',
    headers: {},
    xhrFields: {},
    statusCode: {},
    processData: true,
    dataType: 'text',
    contentType: 'application/x-www-form-urlencoded',
    timeout: 0,
  }, globalsNoCallbacks);

  const options = Utils.extend({}, defaults, requestOptions);
  let proceedRequest;

  // Function to run XHR callbacks and events
  function fireCallback(callbackName, ...data) {
    /*
      Callbacks:
      beforeCreate (options),
      beforeOpen (xhr, options),
      beforeSend (xhr, options),
      error (xhr, status, message),
      complete (xhr, stautus),
      success (response, status, xhr),
      statusCode ()
    */
    let globalCallbackValue;
    let optionCallbackValue;
    if (globals[callbackName]) {
      globalCallbackValue = globals[callbackName](...data);
    }
    if (options[callbackName]) {
      optionCallbackValue = options[callbackName](...data);
    }
    if (typeof globalCallbackValue !== 'boolean') globalCallbackValue = true;
    if (typeof optionCallbackValue !== 'boolean') optionCallbackValue = true;
    return (globalCallbackValue && optionCallbackValue);
  }

  // Before create callback
  proceedRequest = fireCallback('beforeCreate', options);
  if (proceedRequest === false) return undefined;

  // For jQuery guys
  if (options.type) options.method = options.type;

  // Parameters Prefix
  let paramsPrefix = options.url.indexOf('?') >= 0 ? '&' : '?';

  // UC method
  const method = options.method.toUpperCase();

  // Data to modify GET URL
  if ((method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') && options.data) {
    let stringData;
    if (typeof options.data === 'string') {
      // Should be key=value string
      if (options.data.indexOf('?') >= 0) stringData = options.data.split('?')[1];
      else stringData = options.data;
    } else {
      // Should be key=value object
      stringData = Utils.serializeObject(options.data);
    }
    if (stringData.length) {
      options.url += paramsPrefix + stringData;
      if (paramsPrefix === '?') paramsPrefix = '&';
    }
  }

  // JSONP
  if (options.dataType === 'json' && options.url.indexOf('callback=') >= 0) {
    const callbackName = `f7jsonp_${Date.now() + ((jsonpRequests += 1))}`;
    let abortTimeout;
    const callbackSplit = options.url.split('callback=');
    let requestUrl = `${callbackSplit[0]}callback=${callbackName}`;
    if (callbackSplit[1].indexOf('&') >= 0) {
      const addVars = callbackSplit[1].split('&').filter(el => el.indexOf('=') > 0).join('&');
      if (addVars.length > 0) requestUrl += `&${addVars}`;
    }

    // Create script
    let script = doc.createElement('script');
    script.type = 'text/javascript';
    script.onerror = function onerror() {
      clearTimeout(abortTimeout);
      fireCallback('error', null, 'scripterror', 'scripterror');
      fireCallback('complete', null, 'scripterror');
    };
    script.src = requestUrl;

    // Handler
    win[callbackName] = function jsonpCallback(data) {
      clearTimeout(abortTimeout);
      fireCallback('success', data);
      script.parentNode.removeChild(script);
      script = null;
      delete win[callbackName];
    };
    doc.querySelector('head').appendChild(script);

    if (options.timeout > 0) {
      abortTimeout = setTimeout(() => {
        script.parentNode.removeChild(script);
        script = null;
        fireCallback('error', null, 'timeout', 'timeout');
      }, options.timeout);
    }

    return undefined;
  }

  // Cache for GET/HEAD requests
  if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') {
    if (options.cache === false) {
      options.url += `${paramsPrefix}_nocache${Date.now()}`;
    }
  }

  // Create XHR
  const xhr = new XMLHttpRequest();

  // Save Request URL
  xhr.requestUrl = options.url;
  xhr.requestParameters = options;

  // Before open callback
  proceedRequest = fireCallback('beforeOpen', xhr, options);
  if (proceedRequest === false) return xhr;

  // Open XHR
  xhr.open(method, options.url, options.async, options.user, options.password);

  // Create POST Data
  let postData = null;

  if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && options.data) {
    if (options.processData) {
      const postDataInstances = [ArrayBuffer, Blob, Document, FormData];
      // Post Data
      if (postDataInstances.indexOf(options.data.constructor) >= 0) {
        postData = options.data;
      } else {
        // POST Headers
        const boundary = `---------------------------${Date.now().toString(16)}`;

        if (options.contentType === 'multipart/form-data') {
          xhr.setRequestHeader('Content-Type', `multipart/form-data; boundary=${boundary}`);
        } else {
          xhr.setRequestHeader('Content-Type', options.contentType);
        }
        postData = '';
        let data = Utils.serializeObject(options.data);
        if (options.contentType === 'multipart/form-data') {
          data = data.split('&');
          const newData = [];
          for (let i = 0; i < data.length; i += 1) {
            newData.push(`Content-Disposition: form-data; name="${data[i].split('=')[0]}"\r\n\r\n${data[i].split('=')[1]}\r\n`);
          }
          postData = `--${boundary}\r\n${newData.join(`--${boundary}\r\n`)}--${boundary}--\r\n`;
        } else if (options.contentType === 'application/json') {
          postData = JSON.stringify(options.data);
        } else {
          postData = data;
        }
      }
    } else {
      postData = options.data;
      xhr.setRequestHeader('Content-Type', options.contentType);
    }
  }
  if (options.dataType === 'json' && (!options.headers || !options.headers.Accept)) {
    xhr.setRequestHeader('Accept', 'application/json');
  }

  // Additional headers
  if (options.headers) {
    Object.keys(options.headers).forEach((headerName) => {
      if (typeof options.headers[headerName] === 'undefined') return;
      xhr.setRequestHeader(headerName, options.headers[headerName]);
    });
  }

  // Check for crossDomain
  if (typeof options.crossDomain === 'undefined') {
    // eslint-disable-next-line
    options.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(options.url) && RegExp.$2 !== win.location.host;
  }

  if (!options.crossDomain) {
    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  }

  if (options.xhrFields) {
    Utils.extend(xhr, options.xhrFields);
  }


  // Handle XHR
  xhr.onload = function onload() {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) {
      let responseData;
      if (options.dataType === 'json') {
        let parseError;
        try {
          responseData = JSON.parse(xhr.responseText);
        } catch (err) {
          parseError = true;
        }
        if (!parseError) {
          fireCallback('success', responseData, xhr.status, xhr);
        } else {
          fireCallback('error', xhr, 'parseerror', 'parseerror');
        }
      } else {
        responseData = xhr.responseType === 'text' || xhr.responseType === '' ? xhr.responseText : xhr.response;
        fireCallback('success', responseData, xhr.status, xhr);
      }
    } else {
      fireCallback('error', xhr, xhr.status, xhr.statusText);
    }
    if (options.statusCode) {
      if (globals.statusCode && globals.statusCode[xhr.status]) globals.statusCode[xhr.status](xhr);
      if (options.statusCode[xhr.status]) options.statusCode[xhr.status](xhr);
    }
    fireCallback('complete', xhr, xhr.status);
  };

  xhr.onerror = function onerror() {
    fireCallback('error', xhr, xhr.status, xhr.status);
    fireCallback('complete', xhr, 'error');
  };

  // Timeout
  if (options.timeout > 0) {
    xhr.timeout = options.timeout;
    xhr.ontimeout = () => {
      fireCallback('error', xhr, 'timeout', 'timeout');
      fireCallback('complete', xhr, 'timeout');
    };
  }

  // Ajax start callback
  proceedRequest = fireCallback('beforeSend', xhr, options);
  if (proceedRequest === false) return xhr;

  // Send XHR
  xhr.send(postData);

  // Return XHR object
  return xhr;
}
function RequestShortcut(method, ...args) {
  let [url, data, success, error, dataType] = [];
  if (typeof args[1] === 'function') {
    [url, success, error, dataType] = args;
  } else {
    [url, data, success, error, dataType] = args;
  }
  [success, error].forEach((callback) => {
    if (typeof callback === 'string') {
      dataType = callback;
      if (callback === success) success = undefined;
      else error = undefined;
    }
  });
  dataType = dataType || (method === 'json' || method === 'postJSON' ? 'json' : undefined);
  const requestOptions = {
    url,
    method: method === 'post' || method === 'postJSON' ? 'POST' : 'GET',
    data,
    success,
    error,
    dataType,
  };
  if (method === 'postJSON') {
    Utils.extend(requestOptions, {
      contentType: 'application/json',
      processData: false,
      crossDomain: true,
      data: typeof data === 'string' ? data : JSON.stringify(data),
    });
  }
  return Request(requestOptions);
}
function RequestShortcutPromise(method, ...args) {
  const [url, data, dataType] = args;
  return new Promise((resolve, reject) => {
    RequestShortcut(
      method,
      url,
      data,
      (responseData, status, xhr) => {
        resolve({ data: responseData, status, xhr });
      },
      (xhr, status, message) => {
        // eslint-disable-next-line
        reject({ xhr, status, message });
      },
      dataType
    );
  });
}
Object.assign(Request, {
  get: (...args) => RequestShortcut('get', ...args),
  post: (...args) => RequestShortcut('post', ...args),
  json: (...args) => RequestShortcut('json', ...args),
  getJSON: (...args) => RequestShortcut('json', ...args),
  postJSON: (...args) => RequestShortcut('postJSON', ...args),
});

Request.promise = function requestPromise(requestOptions) {
  return new Promise((resolve, reject) => {
    Request(Object.assign(requestOptions, {
      success(data, status, xhr) {
        resolve({ data, status, xhr });
      },
      error(xhr, status, message) {
        // eslint-disable-next-line
        reject({ xhr, status, message });
      },
    }));
  });
};
Object.assign(Request.promise, {
  get: (...args) => RequestShortcutPromise('get', ...args),
  post: (...args) => RequestShortcutPromise('post', ...args),
  json: (...args) => RequestShortcutPromise('json', ...args),
  getJSON: (...args) => RequestShortcutPromise('json', ...args),
  postJSON: (...args) => RequestShortcutPromise('postJSON', ...args),
});

Request.setup = function setup(options) {
  if (options.type && !options.method) {
    Utils.extend(options, { method: options.type });
  }
  Utils.extend(globals, options);
};

var DeviceModule = {
  name: 'device',
  proto: {
    device: Device,
  },
  static: {
    device: Device,
  },
  on: {
    init() {
      const classNames = [];
      const html = doc.querySelector('html');
      const metaStatusbar = doc.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
      if (!html) return;
      if (Device.standalone && Device.ios && metaStatusbar && metaStatusbar.content === 'black-translucent') {
        classNames.push('device-full-viewport');
      }

      // Pixel Ratio
      classNames.push(`device-pixel-ratio-${Math.floor(Device.pixelRatio)}`);
      // OS classes
      if (Device.os && !Device.desktop) {
        classNames.push(
          `device-${Device.os}`,
        );
      } else if (Device.desktop) {
        classNames.push('device-desktop');
        if (Device.os) {
          classNames.push(`device-${Device.os}`);
        }
      }
      if (Device.cordova || Device.phonegap) {
        classNames.push('device-cordova');
      }

      // Add html classes
      classNames.forEach((className) => {
        html.classList.add(className);
      });
    },
  },
};

var SupportModule = {
  name: 'support',
  proto: {
    support: Support,
  },
  static: {
    support: Support,
  },
};

var UtilsModule = {
  name: 'utils',
  proto: {
    utils: Utils,
  },
  static: {
    utils: Utils,
  },
};

var ResizeModule = {
  name: 'resize',
  instance: {
    getSize() {
      const app = this;
      if (!app.root[0]) return { width: 0, height: 0, left: 0, top: 0 };
      const offset = app.root.offset();
      const [width, height, left, top] = [app.root[0].offsetWidth, app.root[0].offsetHeight, offset.left, offset.top];
      app.width = width;
      app.height = height;
      app.left = left;
      app.top = top;
      return { width, height, left, top };
    },
  },
  on: {
    init() {
      const app = this;

      // Get Size
      app.getSize();

      // Emit resize
      win.addEventListener('resize', () => {
        app.emit('resize');
      }, false);

      // Emit orientationchange
      win.addEventListener('orientationchange', () => {
        app.emit('orientationchange');
      });
    },
    orientationchange() {
      const app = this;
      // Fix iPad weird body scroll
      if (app.device.ipad) {
        doc.body.scrollLeft = 0;
        setTimeout(() => {
          doc.body.scrollLeft = 0;
        }, 0);
      }
    },
    resize() {
      const app = this;
      app.getSize();
    },
  },
};

var RequestModule = {
  name: 'request',
  proto: {
    request: Request,
  },
  static: {
    request: Request,
  },
};

function initTouch() {
  const app = this;
  const params = app.params.touch;
  const useRipple = params[`${app.theme}TouchRipple`];

  if (Device.ios && Device.webView) {
    // Strange hack required for iOS 8 webview to work on inputs
    win.addEventListener('touchstart', () => {});
  }

  let touchStartX;
  let touchStartY;
  let targetElement;
  let isMoved;
  let tapHoldFired;
  let tapHoldTimeout;
  let preventClick;

  let activableElement;
  let activeTimeout;

  let rippleWave;
  let rippleTarget;
  let rippleTimeout;

  function findActivableElement(el) {
    const target = $(el);
    const parents = target.parents(params.activeStateElements);
    if (target.closest('.no-active-state').length) {
      return null;
    }
    let activable;
    if (target.is(params.activeStateElements)) {
      activable = target;
    }
    if (parents.length > 0) {
      activable = activable ? activable.add(parents) : parents;
    }
    if (activable && activable.length > 1) {
      const newActivable = [];
      let preventPropagation;
      for (let i = 0; i < activable.length; i += 1) {
        if (!preventPropagation) {
          newActivable.push(activable[i]);
          if (activable.eq(i).hasClass('prevent-active-state-propagation')
            || activable.eq(i).hasClass('no-active-state-propagation')
          ) {
            preventPropagation = true;
          }
        }
      }
      activable = $(newActivable);
    }
    return activable || target;
  }

  function isInsideScrollableView(el) {
    const pageContent = el.parents('.page-content');
    return pageContent.length > 0;
  }

  function addActive() {
    if (!activableElement) return;
    activableElement.addClass('active-state');
  }
  function removeActive() {
    if (!activableElement) return;
    activableElement.removeClass('active-state');
    activableElement = null;
  }

  // Ripple handlers
  function findRippleElement(el) {
    const rippleElements = params.touchRippleElements;
    const $el = $(el);
    if ($el.is(rippleElements)) {
      if ($el.hasClass('no-ripple')) {
        return false;
      }
      return $el;
    }
    if ($el.parents(rippleElements).length > 0) {
      const rippleParent = $el.parents(rippleElements).eq(0);
      if (rippleParent.hasClass('no-ripple')) {
        return false;
      }
      return rippleParent;
    }
    return false;
  }
  function createRipple($el, x, y) {
    if (!$el) return;
    rippleWave = app.touchRipple.create($el, x, y);
  }

  function removeRipple() {
    if (!rippleWave) return;
    rippleWave.remove();
    rippleWave = undefined;
    rippleTarget = undefined;
  }
  function rippleTouchStart(el) {
    rippleTarget = findRippleElement(el);
    if (!rippleTarget || rippleTarget.length === 0) {
      rippleTarget = undefined;
      return;
    }
    const inScrollable = isInsideScrollableView(rippleTarget);

    if (!inScrollable) {
      removeRipple();
      createRipple(rippleTarget, touchStartX, touchStartY);
    } else {
      clearTimeout(rippleTimeout);
      rippleTimeout = setTimeout(() => {
        removeRipple();
        createRipple(rippleTarget, touchStartX, touchStartY);
      }, 80);
    }
  }
  function rippleTouchMove() {
    clearTimeout(rippleTimeout);
    removeRipple();
  }
  function rippleTouchEnd() {
    if (!rippleWave && rippleTarget && !isMoved) {
      clearTimeout(rippleTimeout);
      createRipple(rippleTarget, touchStartX, touchStartY);
      setTimeout(removeRipple, 0);
    } else {
      removeRipple();
    }
  }

  // Mouse Handlers
  function handleMouseDown(e) {
    const $activableEl = findActivableElement(e.target);
    if ($activableEl) {
      $activableEl.addClass('active-state');
      if ('which' in e && e.which === 3) {
        setTimeout(() => {
          $('.active-state').removeClass('active-state');
        }, 0);
      }
    }

    if (useRipple) {
      touchStartX = e.pageX;
      touchStartY = e.pageY;
      rippleTouchStart(e.target, e.pageX, e.pageY);
    }
  }
  function handleMouseMove() {
    if (!params.activeStateOnMouseMove) {
      $('.active-state').removeClass('active-state');
    }
    if (useRipple) {
      rippleTouchMove();
    }
  }
  function handleMouseUp() {
    $('.active-state').removeClass('active-state');
    if (useRipple) {
      rippleTouchEnd();
    }
  }

  function handleTouchCancel() {
    targetElement = null;

    // Remove Active State
    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);
    if (params.activeState) {
      removeActive();
    }

    // Remove Ripple
    if (useRipple) {
      rippleTouchEnd();
    }
  }

  function handleTouchStart(e) {
    isMoved = false;
    tapHoldFired = false;
    preventClick = false;
    if (e.targetTouches.length > 1) {
      if (activableElement) removeActive();
      return true;
    }
    if (e.touches.length > 1 && activableElement) {
      removeActive();
    }
    if (params.tapHold) {
      if (tapHoldTimeout) clearTimeout(tapHoldTimeout);
      tapHoldTimeout = setTimeout(() => {
        if (e && e.touches && e.touches.length > 1) return;
        tapHoldFired = true;
        e.preventDefault();
        preventClick = true;
        $(e.target).trigger('taphold', e);
        app.emit('taphold', e);
      }, params.tapHoldDelay);
    }
    targetElement = e.target;
    touchStartX = e.targetTouches[0].pageX;
    touchStartY = e.targetTouches[0].pageY;

    if (params.activeState) {
      activableElement = findActivableElement(targetElement);
      if (activableElement && !isInsideScrollableView(activableElement)) {
        addActive();
      } else if (activableElement) {
        activeTimeout = setTimeout(addActive, 80);
      }
    }
    if (useRipple) {
      rippleTouchStart(targetElement);
    }
    return true;
  }
  function handleTouchMove(e) {
    let touch;
    let distance;
    if (e.type === 'touchmove') {
      touch = e.targetTouches[0];
      distance = params.touchClicksDistanceThreshold;
    }

    if (distance && touch) {
      const pageX = touch.pageX;
      const pageY = touch.pageY;
      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
        isMoved = true;
      }
    } else {
      isMoved = true;
    }
    if (isMoved) {
      preventClick = true;
      if (params.tapHold) {
        clearTimeout(tapHoldTimeout);
      }
      if (params.activeState) {
        clearTimeout(activeTimeout);
        removeActive();
      }
      if (useRipple) {
        rippleTouchMove();
      }
    }
  }
  function handleTouchEnd(e) {
    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);
    if (doc.activeElement === e.target) {
      if (params.activeState) removeActive();
      if (useRipple) {
        rippleTouchEnd();
      }
      return true;
    }
    if (params.activeState) {
      addActive();
      setTimeout(removeActive, 0);
    }
    if (useRipple) {
      rippleTouchEnd();
    }
    if ((params.tapHoldPreventClicks && tapHoldFired) || preventClick) {
      if (e.cancelable) e.preventDefault();
      preventClick = true;
      return false;
    }
    return true;
  }
  function handleClick(e) {
    const isOverswipe = e && e.detail && e.detail === 'f7Overswipe';
    let localPreventClick = preventClick;
    if (targetElement && e.target !== targetElement) {
      if (isOverswipe) {
        localPreventClick = false;
      } else {
        localPreventClick = true;
      }
    }
    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
      localPreventClick = true;
    }
    if (localPreventClick) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();
    }

    if (params.tapHold) {
      tapHoldTimeout = setTimeout(
        () => {
          tapHoldFired = false;
        },
        (Device.ios || Device.androidChrome ? 100 : 400)
      );
    }
    preventClick = false;
    targetElement = null;

    return !localPreventClick;
  }

  function emitAppTouchEvent(name, e) {
    app.emit({
      events: name,
      data: [e],
    });
  }
  function appClick(e) {
    emitAppTouchEvent('click', e);
  }
  function appTouchStartActive(e) {
    emitAppTouchEvent('touchstart touchstart:active', e);
  }
  function appTouchMoveActive(e) {
    emitAppTouchEvent('touchmove touchmove:active', e);
  }
  function appTouchEndActive(e) {
    emitAppTouchEvent('touchend touchend:active', e);
  }
  function appTouchStartPassive(e) {
    emitAppTouchEvent('touchstart:passive', e);
  }
  function appTouchMovePassive(e) {
    emitAppTouchEvent('touchmove:passive', e);
  }
  function appTouchEndPassive(e) {
    emitAppTouchEvent('touchend:passive', e);
  }
  function appGestureActive(e) {
    emitAppTouchEvent(`${e.type} ${e.type}:active`, e);
  }
  function appGesturePassive(e) {
    emitAppTouchEvent(`${e.type}:passive`, e);
  }


  const passiveListener = Support.passiveListener ? { passive: true } : false;
  const passiveListenerCapture = Support.passiveListener ? { passive: true, capture: true } : true;
  const activeListener = Support.passiveListener ? { passive: false } : false;
  const activeListenerCapture = Support.passiveListener ? { passive: false, capture: true } : true;

  doc.addEventListener('click', appClick, true);

  if (Support.passiveListener) {
    doc.addEventListener(app.touchEvents.start, appTouchStartActive, activeListenerCapture);
    doc.addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);
    doc.addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);

    doc.addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListenerCapture);
    doc.addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);
    doc.addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);
    if (Support.touch && Support.gestures) {
      doc.addEventListener('gesturestart', appGestureActive, activeListener);
      doc.addEventListener('gesturechange', appGestureActive, activeListener);
      doc.addEventListener('gestureend', appGestureActive, activeListener);

      doc.addEventListener('gesturestart', appGesturePassive, passiveListener);
      doc.addEventListener('gesturechange', appGesturePassive, passiveListener);
      doc.addEventListener('gestureend', appGesturePassive, passiveListener);
    }
  } else {
    doc.addEventListener(app.touchEvents.start, (e) => {
      appTouchStartActive(e);
      appTouchStartPassive(e);
    }, true);
    doc.addEventListener(app.touchEvents.move, (e) => {
      appTouchMoveActive(e);
      appTouchMovePassive(e);
    }, false);
    doc.addEventListener(app.touchEvents.end, (e) => {
      appTouchEndActive(e);
      appTouchEndPassive(e);
    }, false);
    if (Support.touch && Support.gestures) {
      doc.addEventListener('gesturestart', (e) => {
        appGestureActive(e);
        appGesturePassive(e);
      }, false);
      doc.addEventListener('gesturechange', (e) => {
        appGestureActive(e);
        appGesturePassive(e);
      }, false);
      doc.addEventListener('gestureend', (e) => {
        appGestureActive(e);
        appGesturePassive(e);
      }, false);
    }
  }

  if (Support.touch) {
    app.on('click', handleClick);
    app.on('touchstart', handleTouchStart);
    app.on('touchmove', handleTouchMove);
    app.on('touchend', handleTouchEnd);
    doc.addEventListener('touchcancel', handleTouchCancel, { passive: true });
  } else if (params.activeState) {
    app.on('touchstart', handleMouseDown);
    app.on('touchmove', handleMouseMove);
    app.on('touchend', handleMouseUp);
    doc.addEventListener('pointercancel', handleMouseUp, { passive: true });
  }
  doc.addEventListener('contextmenu', (e) => {
    if (params.disableContextMenu && (Device.ios || Device.android || Device.cordova)) {
      e.preventDefault();
    }
    if (useRipple) {
      if (activableElement) removeActive();
      rippleTouchEnd();
    }
  });
}

var TouchModule = {
  name: 'touch',
  params: {
    touch: {
      // Clicks
      touchClicksDistanceThreshold: 5,
      // ContextMenu
      disableContextMenu: false,
      // Tap Hold
      tapHold: false,
      tapHoldDelay: 750,
      tapHoldPreventClicks: true,
      // Active State
      activeState: true,
      activeStateElements: 'a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .menu-item, .link, .item-link, .accordion-item-toggle',
      activeStateOnMouseMove: false,
      mdTouchRipple: true,
      iosTouchRipple: false,
      auroraTouchRipple: false,
      touchRippleElements: '.ripple, .link, .item-link, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .menu-item-content, .list.accordion-list .accordion-item-toggle',
    },
  },
  instance: {
    touchEvents: {
      start: Support.touch ? 'touchstart' : (Support.pointerEvents ? 'pointerdown' : 'mousedown'),
      move: Support.touch ? 'touchmove' : (Support.pointerEvents ? 'pointermove' : 'mousemove'),
      end: Support.touch ? 'touchend' : (Support.pointerEvents ? 'pointerup' : 'mouseup'),
    },
  },
  on: {
    init: initTouch,
  },
};

/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}

const History = {
  queue: [],
  clearQueue() {
    if (History.queue.length === 0) return;
    const currentQueue = History.queue.shift();
    currentQueue();
  },
  routerQueue: [],
  clearRouterQueue() {
    if (History.routerQueue.length === 0) return;
    const currentQueue = History.routerQueue.pop();
    const { router, stateUrl, action } = currentQueue;

    let animate = router.params.animate;
    if (router.params.pushStateAnimate === false) animate = false;

    if (action === 'back') {
      router.back({ animate, pushState: false });
    }
    if (action === 'load') {
      router.navigate(stateUrl, { animate, pushState: false });
    }
  },
  handle(e) {
    if (History.blockPopstate) return;
    const app = this;
    // const mainView = app.views.main;
    let state = e.state;
    History.previousState = History.state;
    History.state = state;

    History.allowChange = true;
    History.clearQueue();

    state = History.state;
    if (!state) state = {};

    app.views.forEach((view) => {
      const router = view.router;
      let viewState = state[view.id];
      if (!viewState && view.params.pushState) {
        viewState = {
          url: view.router.history[0],
        };
      }
      if (!viewState) return;
      const stateUrl = viewState.url || undefined;

      let animate = router.params.animate;
      if (router.params.pushStateAnimate === false) animate = false;

      if (stateUrl !== router.url) {
        if (router.history.indexOf(stateUrl) >= 0) {
          // Go Back
          if (router.allowPageChange) {
            router.back({ animate, pushState: false });
          } else {
            History.routerQueue.push({
              action: 'back',
              router,
            });
          }
        } else if (router.allowPageChange) {
          // Load page
          router.navigate(stateUrl, { animate, pushState: false });
        } else {
          History.routerQueue.unshift({
            action: 'load',
            stateUrl,
            router,
          });
        }
      }
    });
  },
  initViewState(viewId, viewState) {
    const newState = Utils.extend({}, (History.state || {}), {
      [viewId]: viewState,
    });
    History.state = newState;
    win.history.replaceState(newState, '');
  },
  push(viewId, viewState, url) {
    if (!History.allowChange) {
      History.queue.push(() => {
        History.push(viewId, viewState, url);
      });
      return;
    }
    History.previousState = History.state;
    const newState = Utils.extend({}, (History.previousState || {}), {
      [viewId]: viewState,
    });
    History.state = newState;
    win.history.pushState(newState, '', url);
  },
  replace(viewId, viewState, url) {
    if (!History.allowChange) {
      History.queue.push(() => {
        History.replace(viewId, viewState, url);
      });
      return;
    }
    History.previousState = History.state;
    const newState = Utils.extend({}, (History.previousState || {}), {
      [viewId]: viewState,
    });
    History.state = newState;
    win.history.replaceState(newState, '', url);
  },
  go(index) {
    History.allowChange = false;
    win.history.go(index);
  },
  back() {
    History.allowChange = false;
    win.history.back();
  },
  allowChange: true,
  previousState: {},
  state: win.history.state,
  blockPopstate: true,
  init(app) {
    $(win).on('load', () => {
      setTimeout(() => {
        History.blockPopstate = false;
      }, 0);
    });

    if (doc.readyState && doc.readyState === 'complete') {
      History.blockPopstate = false;
    }

    $(win).on('popstate', History.handle.bind(app));
  },
};

function SwipeBack(r) {
  const router = r;
  const { $el, $navbarsEl, app, params } = router;
  let isTouched = false;
  let isMoved = false;
  const touchesStart = {};
  let isScrolling;
  let $currentPageEl = [];
  let $previousPageEl = [];
  let viewContainerWidth;
  let touchesDiff;
  let allowViewTouchMove = true;
  let touchStartTime;
  let $currentNavbarEl = [];
  let $previousNavbarEl = [];
  let dynamicNavbar;
  let $pageShadowEl;
  let $pageOpacityEl;

  let animatableNavEls;

  const paramsSwipeBackAnimateShadow = params[`${app.theme}SwipeBackAnimateShadow`];
  const paramsSwipeBackAnimateOpacity = params[`${app.theme}SwipeBackAnimateOpacity`];
  const paramsSwipeBackActiveArea = params[`${app.theme}SwipeBackActiveArea`];
  const paramsSwipeBackThreshold = params[`${app.theme}SwipeBackThreshold`];

  const transformOrigin = app.rtl ? 'right center' : 'left center';
  const transformOriginTitleLarge = app.rtl
    ? 'calc(100% - var(--f7-navbar-large-title-padding-left) - var(--f7-safe-area-left)) center'
    : 'calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center';


  function animatableNavElements() {
    const els = [];
    const inverter = app.rtl ? -1 : 1;
    const currentNavIsTransparent = $currentNavbarEl.hasClass('navbar-transparent') && !$currentNavbarEl.hasClass('navbar-large') && !$currentNavbarEl.hasClass('navbar-transparent-visible');
    const currentNavIsLarge = $currentNavbarEl.hasClass('navbar-large');
    const currentNavIsCollapsed = $currentNavbarEl.hasClass('navbar-large-collapsed');
    const currentNavIsLargeTransparent = $currentNavbarEl.hasClass('navbar-large-transparent')
      || (
        $currentNavbarEl.hasClass('navbar-large')
        && $currentNavbarEl.hasClass('navbar-transparent')
      );
    const previousNavIsTransparent = $previousNavbarEl.hasClass('navbar-transparent') && !$previousNavbarEl.hasClass('navbar-large') && !$previousNavbarEl.hasClass('navbar-transparent-visible');
    const previousNavIsLarge = $previousNavbarEl.hasClass('navbar-large');
    const previousNavIsCollapsed = $previousNavbarEl.hasClass('navbar-large-collapsed');
    const previousNavIsLargeTransparent = $previousNavbarEl.hasClass('navbar-large-transparent')
      || (
        $previousNavbarEl.hasClass('navbar-large')
        && $previousNavbarEl.hasClass('navbar-transparent')
      );
    const fromLarge = currentNavIsLarge && !currentNavIsCollapsed;
    const toLarge = previousNavIsLarge && !previousNavIsCollapsed;
    const $currentNavElements = $currentNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
    const $previousNavElements = $previousNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
    let activeNavBackIconText;
    let previousNavBackIconText;

    if (params.iosAnimateNavbarBackIcon) {
      if ($currentNavbarEl.hasClass('sliding') || $currentNavbarEl.find('.navbar-inner.sliding').length) {
        activeNavBackIconText = $currentNavbarEl.find('.left').find('.back .icon + span').eq(0);
      } else {
        activeNavBackIconText = $currentNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
      }
      if ($previousNavbarEl.hasClass('sliding') || $previousNavbarEl.find('.navbar-inner.sliding').length) {
        previousNavBackIconText = $previousNavbarEl.find('.left').find('.back .icon + span').eq(0);
      } else {
        previousNavBackIconText = $previousNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
      }
      if (activeNavBackIconText.length) {
        $previousNavElements.each((index, el) => {
          if (!$(el).hasClass('title')) return;
          el.f7NavbarLeftOffset += activeNavBackIconText.prev('.icon')[0].offsetWidth;
        });
      }
    }
    $currentNavElements
      .each((index, navEl) => {
        const $navEl = $(navEl);
        const isSubnavbar = $navEl.hasClass('subnavbar');
        const isLeft = $navEl.hasClass('left');
        const isTitle = $navEl.hasClass('title');
        const isBg = $navEl.hasClass('navbar-bg');
        if ((isTitle || isBg) && currentNavIsTransparent) return;
        if (!fromLarge && $navEl.hasClass('.title-large')) return;
        const el = {
          el: navEl,
        };
        if (fromLarge) {
          if (isTitle) return;
          if ($navEl.hasClass('title-large')) {
            if (els.indexOf(el) < 0) els.push(el);
            el.overflow = 'visible';
            $navEl.find('.title-large-text').each((subIndex, subNavEl) => {
              els.push({
                el: subNavEl,
                transform: progress => `translateX(${progress * 100 * inverter}%)`,
              });
            });
            return;
          }
        }
        if (toLarge) {
          if (!fromLarge) {
            if ($navEl.hasClass('title-large')) {
              if (els.indexOf(el) < 0) els.push(el);
              el.opacity = 0;
            }
          }
          if (isLeft) {
            if (els.indexOf(el) < 0) els.push(el);
            el.opacity = progress => (1 - (progress ** 0.33));
            $navEl.find('.back span').each((subIndex, subNavEl) => {
              els.push({
                el: subNavEl,
                'transform-origin': transformOrigin,
                transform: progress => `translateX(calc(${progress} * (var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset)))) translateY(calc(${progress} * (var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2))) scale(${1 + (1 * progress)})`,
              });
            });
            return;
          }
        }
        if (isBg) {
          if (els.indexOf(el) < 0) els.push(el);
          if (!fromLarge && !toLarge) {
            if (currentNavIsCollapsed) {
              if (currentNavIsLargeTransparent) {
                el.className = 'ios-swipeback-navbar-bg-large';
              }
              el.transform = progress => `translateX(${100 * progress * inverter}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`;
            } else {
              el.transform = progress => `translateX(${100 * progress * inverter}%)`;
            }
          }
          if (!fromLarge && toLarge) {
            el.className = 'ios-swipeback-navbar-bg-large';
            el.transform = progress => `translateX(${100 * progress * inverter}%) translateY(calc(-1 * ${1 - progress} * var(--f7-navbar-large-title-height)))`;
          }
          if (fromLarge && toLarge) {
            el.transform = progress => `translateX(${100 * progress * inverter}%)`;
          }
          if (fromLarge && !toLarge) {
            el.transform = progress => `translateX(${100 * progress * inverter}%) translateY(calc(-${progress} * var(--f7-navbar-large-title-height)))`;
          }
          return;
        }
        if ($navEl.hasClass('title-large')) return;
        const isSliding = $navEl.hasClass('sliding') || $navEl.parents('.navbar-inner.sliding').length;
        if (els.indexOf(el) < 0) els.push(el);
        if (!isSubnavbar || (isSubnavbar && !isSliding)) {
          el.opacity = progress => (1 - (progress ** 0.33));
        }
        if (isSliding) {
          let transformTarget = el;
          if (isLeft && activeNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
            const textEl = { el: activeNavBackIconText[0] };
            transformTarget = textEl;
            els.push(textEl);
          }
          transformTarget.transform = (progress) => {
            let activeNavTranslate = progress * transformTarget.el.f7NavbarRightOffset;
            if (Device.pixelRatio === 1) activeNavTranslate = Math.round(activeNavTranslate);
            if (isSubnavbar && currentNavIsLarge) {
              return `translate3d(${activeNavTranslate}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`;
            }
            return `translate3d(${activeNavTranslate}px,0,0)`;
          };
        }
      });
    $previousNavElements
      .each((index, navEl) => {
        const $navEl = $(navEl);
        const isSubnavbar = $navEl.hasClass('subnavbar');
        const isLeft = $navEl.hasClass('left');
        const isTitle = $navEl.hasClass('title');
        const isBg = $navEl.hasClass('navbar-bg');
        if ((isTitle || isBg) && previousNavIsTransparent) return;
        const el = {
          el: navEl,
        };
        if (toLarge) {
          if (isTitle) return;
          if (els.indexOf(el) < 0) els.push(el);

          if ($navEl.hasClass('title-large')) {
            el.opacity = 1;
            el.overflow = 'visible';
            $navEl.find('.title-large-text').each((subIndex, subNavEl) => {
              els.push({
                el: subNavEl,
                'transform-origin': transformOriginTitleLarge,
                opacity: progress => (progress ** 3),
                transform: progress => `translateX(calc(${1 - progress} * (var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset)))) translateY(calc(${progress - 1} * var(--f7-navbar-large-title-height) + ${1 - progress} * var(--f7-navbar-large-title-padding-vertical))) scale(${0.5 + progress * 0.5})`,
              });
            });
            return;
          }
        }
        if (isBg) {
          if (els.indexOf(el) < 0) els.push(el);
          if (!fromLarge && !toLarge) {
            if (previousNavIsCollapsed) {
              if (previousNavIsLargeTransparent) {
                el.className = 'ios-swipeback-navbar-bg-large';
              }
              el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`;
            } else {
              el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%)`;
            }
          }
          if (!fromLarge && toLarge) {
            el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-1 * ${1 - progress} * var(--f7-navbar-large-title-height)))`;
          }
          if (fromLarge && !toLarge) {
            el.className = 'ios-swipeback-navbar-bg-large';
            el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-${progress} * var(--f7-navbar-large-title-height)))`;
          }
          if (fromLarge && toLarge) {
            el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%)`;
          }

          return;
        }
        if ($navEl.hasClass('title-large')) return;
        const isSliding = $navEl.hasClass('sliding') || $previousNavbarEl.children('.navbar-inner.sliding').length;
        if (els.indexOf(el) < 0) els.push(el);
        if (!isSubnavbar || (isSubnavbar && !isSliding)) {
          el.opacity = progress => (progress ** 3);
        }
        if (isSliding) {
          let transformTarget = el;
          if (isLeft && previousNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
            const textEl = { el: previousNavBackIconText[0] };
            transformTarget = textEl;
            els.push(textEl);
          }
          transformTarget.transform = (progress) => {
            let previousNavTranslate = transformTarget.el.f7NavbarLeftOffset * (1 - progress);
            if (Device.pixelRatio === 1) previousNavTranslate = Math.round(previousNavTranslate);
            if (isSubnavbar && previousNavIsLarge) {
              return `translate3d(${previousNavTranslate}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`;
            }
            return `translate3d(${previousNavTranslate}px,0,0)`;
          };
        }
      });
    return els;
  }

  function setAnimatableNavElements({ progress, reset, transition } = {}) {
    const styles = ['overflow', 'transform', 'transform-origin', 'opacity'];
    for (let i = 0; i < animatableNavEls.length; i += 1) {
      const el = animatableNavEls[i];
      if (el && el.el) {
        if (transition === true) el.el.classList.add('navbar-page-transitioning');
        if (transition === false) el.el.classList.remove('navbar-page-transitioning');
        if (el.className && !el.classNameSet && !reset) {
          el.el.classList.add(el.className);
          el.classNameSet = true;
        }
        if (el.className && reset) {
          el.el.classList.remove(el.className);
        }
        for (let j = 0; j < styles.length; j += 1) {
          const styleProp = styles[j];
          if (el[styleProp]) {
            if (reset) {
              el.el.style[styleProp] = '';
            } else if (typeof el[styleProp] === 'function') {
              el.el.style[styleProp] = el[styleProp](progress);
            } else {
              el.el.style[styleProp] = el[styleProp];
            }
          }
        }
      }
    }
  }

  function handleTouchStart(e) {
    const swipeBackEnabled = params[`${app.theme}SwipeBack`];
    if (!allowViewTouchMove || !swipeBackEnabled || isTouched || (app.swipeout && app.swipeout.el) || !router.allowPageChange) return;
    if ($(e.target).closest('.range-slider, .calendar-months').length > 0) return;
    if ($(e.target).closest('.page-master, .page-master-detail').length > 0 && params.masterDetailBreakpoint > 0 && app.width >= params.masterDetailBreakpoint) return;
    isMoved = false;
    isTouched = true;
    isScrolling = undefined;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    touchStartTime = Utils.now();
    dynamicNavbar = router.dynamicNavbar;
  }
  function handleTouchMove(e) {
    if (!isTouched) return;
    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === 'undefined') {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || (pageX < touchesStart.x && !app.rtl) || (pageX > touchesStart.x && app.rtl);
    }
    if (isScrolling || e.f7PreventSwipeBack || app.preventSwipeBack) {
      isTouched = false;
      return;
    }
    if (!isMoved) {
      // Calc values during first move fired
      let cancel = false;
      const target = $(e.target);

      const swipeout = target.closest('.swipeout');
      if (swipeout.length > 0) {
        if (!app.rtl && swipeout.find('.swipeout-actions-left').length > 0) cancel = true;
        if (app.rtl && swipeout.find('.swipeout-actions-right').length > 0) cancel = true;
      }

      $currentPageEl = target.closest('.page');
      if ($currentPageEl.hasClass('no-swipeback') || target.closest('.no-swipeback, .card-opened').length > 0) cancel = true;
      $previousPageEl = $el.find('.page-previous:not(.stacked)');
      if ($previousPageEl.length > 1) {
        $previousPageEl = $previousPageEl.eq($previousPageEl.length - 1);
      }
      let notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      viewContainerWidth = $el.width();
      if (app.rtl) {
        notFromBorder = touchesStart.x < ($el.offset().left - $el[0].scrollLeft) + (viewContainerWidth - paramsSwipeBackActiveArea);
      } else {
        notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      }
      if (notFromBorder) cancel = true;
      if ($previousPageEl.length === 0 || $currentPageEl.length === 0) cancel = true;
      if (cancel) {
        isTouched = false;
        return;
      }

      if (paramsSwipeBackAnimateShadow) {
        $pageShadowEl = $currentPageEl.find('.page-shadow-effect');
        if ($pageShadowEl.length === 0) {
          $pageShadowEl = $('<div class="page-shadow-effect"></div>');
          $currentPageEl.append($pageShadowEl);
        }
      }
      if (paramsSwipeBackAnimateOpacity) {
        $pageOpacityEl = $previousPageEl.find('.page-opacity-effect');
        if ($pageOpacityEl.length === 0) {
          $pageOpacityEl = $('<div class="page-opacity-effect"></div>');
          $previousPageEl.append($pageOpacityEl);
        }
      }

      if (dynamicNavbar) {
        $currentNavbarEl = $navbarsEl.find('.navbar-current:not(.stacked)');
        $previousNavbarEl = $navbarsEl.find('.navbar-previous:not(.stacked)');
        if ($previousNavbarEl.length > 1) {
          $previousNavbarEl = $previousNavbarEl.eq($previousNavbarEl.length - 1);
        }

        animatableNavEls = animatableNavElements();
      }

      // Close/Hide Any Picker
      if ($('.sheet.modal-in').length > 0 && app.sheet) {
        app.sheet.close($('.sheet.modal-in'));
      }
    }
    e.f7PreventSwipePanel = true;
    isMoved = true;
    app.preventSwipePanelBySwipeBack = true;
    e.preventDefault();

    // RTL inverter
    const inverter = app.rtl ? -1 : 1;

    // Touches diff
    touchesDiff = (pageX - touchesStart.x - paramsSwipeBackThreshold) * inverter;
    if (touchesDiff < 0) touchesDiff = 0;
    const percentage = Math.min(Math.max(touchesDiff / viewContainerWidth, 0), 1);

    // Swipe Back Callback
    const callbackData = {
      percentage,
      progress: percentage,
      currentPageEl: $currentPageEl[0],
      previousPageEl: $previousPageEl[0],
      currentNavbarEl: $currentNavbarEl[0],
      previousNavbarEl: $previousNavbarEl[0],
    };
    $el.trigger('swipeback:move', callbackData);
    router.emit('swipebackMove', callbackData);

    // Transform pages
    let currentPageTranslate = touchesDiff * inverter;
    let previousPageTranslate = ((touchesDiff / 5) - (viewContainerWidth / 5)) * inverter;
    if (!app.rtl) {
      currentPageTranslate = Math.min(currentPageTranslate, viewContainerWidth);
      previousPageTranslate = Math.min(previousPageTranslate, 0);
    } else {
      currentPageTranslate = Math.max(currentPageTranslate, -viewContainerWidth);
      previousPageTranslate = Math.max(previousPageTranslate, 0);
    }
    if (Device.pixelRatio === 1) {
      currentPageTranslate = Math.round(currentPageTranslate);
      previousPageTranslate = Math.round(previousPageTranslate);
    }

    router.swipeBackActive = true;
    $([$currentPageEl[0], $previousPageEl[0]]).addClass('page-swipeback-active');

    $currentPageEl.transform(`translate3d(${currentPageTranslate}px,0,0)`);
    if (paramsSwipeBackAnimateShadow) $pageShadowEl[0].style.opacity = 1 - (1 * percentage);

    if (app.theme === 'ios') {
      $previousPageEl.transform(`translate3d(${previousPageTranslate}px,0,0)`);
    }
    if (paramsSwipeBackAnimateOpacity) $pageOpacityEl[0].style.opacity = 1 - (1 * percentage);

    // Dynamic Navbars Animation
    if (!dynamicNavbar) return;

    setAnimatableNavElements({ progress: percentage });
  }
  function handleTouchEnd() {
    app.preventSwipePanelBySwipeBack = false;
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    router.swipeBackActive = false;
    $([$currentPageEl[0], $previousPageEl[0]]).removeClass('page-swipeback-active');
    if (touchesDiff === 0) {
      $([$currentPageEl[0], $previousPageEl[0]]).transform('');
      if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
      if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();
      if (dynamicNavbar) {
        setAnimatableNavElements({ reset: true });
      }
      return;
    }
    const timeDiff = Utils.now() - touchStartTime;
    let pageChanged = false;
    // Swipe back to previous page
    if (
      (timeDiff < 300 && touchesDiff > 10)
      || (timeDiff >= 300 && touchesDiff > viewContainerWidth / 2)
    ) {
      $currentPageEl.removeClass('page-current').addClass(`page-next${app.theme !== 'ios' ? ' page-next-on-right' : ''}`);
      $previousPageEl.removeClass('page-previous').addClass('page-current').removeAttr('aria-hidden');
      if ($pageShadowEl) $pageShadowEl[0].style.opacity = '';
      if ($pageOpacityEl) $pageOpacityEl[0].style.opacity = '';
      if (dynamicNavbar) {
        router.setNavbarPosition($currentNavbarEl, 'next');
        router.setNavbarPosition($previousNavbarEl, 'current', false);
      }
      pageChanged = true;
    }
    // Reset custom styles
    // Add transitioning class for transition-duration
    $([$currentPageEl[0], $previousPageEl[0]]).addClass('page-transitioning page-transitioning-swipeback').transform('');

    if (dynamicNavbar) {
      setAnimatableNavElements({ progress: pageChanged ? 1 : 0, transition: true });
    }
    allowViewTouchMove = false;
    router.allowPageChange = false;

    // Swipe Back Callback
    const callbackData = {
      currentPageEl: $currentPageEl[0],
      previousPageEl: $previousPageEl[0],
      currentNavbarEl: $currentNavbarEl[0],
      previousNavbarEl: $previousNavbarEl[0],
    };

    if (pageChanged) {
      // Update Route
      router.currentRoute = $previousPageEl[0].f7Page.route;
      router.currentPage = $previousPageEl[0];

      // Page before animation callback
      router.pageCallback('beforeOut', $currentPageEl, $currentNavbarEl, 'current', 'next', { route: $currentPageEl[0].f7Page.route, swipeBack: true });
      router.pageCallback('beforeIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', { route: $previousPageEl[0].f7Page.route, swipeBack: true }, $currentPageEl[0]);

      $el.trigger('swipeback:beforechange', callbackData);
      router.emit('swipebackBeforeChange', callbackData);
    } else {
      $el.trigger('swipeback:beforereset', callbackData);
      router.emit('swipebackBeforeReset', callbackData);
    }

    $currentPageEl.transitionEnd(() => {
      $([$currentPageEl[0], $previousPageEl[0]]).removeClass('page-transitioning page-transitioning-swipeback');
      if (dynamicNavbar) {
        setAnimatableNavElements({ reset: true, transition: false });
      }
      allowViewTouchMove = true;
      router.allowPageChange = true;
      if (pageChanged) {
        // Update History
        if (router.history.length === 1) {
          router.history.unshift(router.url);
        }
        router.history.pop();
        router.saveHistory();

        // Update push state
        if (params.pushState) {
          History.back();
        }

        // Page after animation callback
        router.pageCallback('afterOut', $currentPageEl, $currentNavbarEl, 'current', 'next', { route: $currentPageEl[0].f7Page.route, swipeBack: true });
        router.pageCallback('afterIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', { route: $previousPageEl[0].f7Page.route, swipeBack: true });

        // Remove Old Page
        if (params.stackPages && router.initialPages.indexOf($currentPageEl[0]) >= 0) {
          $currentPageEl.addClass('stacked');
          if (dynamicNavbar) {
            $currentNavbarEl.addClass('stacked');
          }
        } else {
          router.pageCallback('beforeRemove', $currentPageEl, $currentNavbarEl, 'next', { swipeBack: true });
          router.removePage($currentPageEl);
          if (dynamicNavbar) {
            router.removeNavbar($currentNavbarEl);
          }
        }

        $el.trigger('swipeback:afterchange', callbackData);
        router.emit('swipebackAfterChange', callbackData);

        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

        if (params.preloadPreviousPage) {
          router.back(router.history[router.history.length - 2], { preload: true });
        }
      } else {
        $el.trigger('swipeback:afterreset', callbackData);
        router.emit('swipebackAfterReset', callbackData);
      }
      if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
      if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();
    });
  }

  function attachEvents() {
    const passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
    $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
  }
  function detachEvents() {
    const passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
    $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
  }

  attachEvents();

  router.on('routerDestroy', detachEvents);
}

function redirect (direction, route, options) {
  const router = this;
  const redirect = route.route.redirect;
  if (options.initial && router.params.pushState) {
    options.replaceState = true; // eslint-disable-line
    options.history = true; // eslint-disable-line
  }
  function redirectResolve(redirectUrl, redirectOptions = {}) {
    router.allowPageChange = true;
    router[direction](redirectUrl, Utils.extend({}, options, redirectOptions));
  }
  function redirectReject() {
    router.allowPageChange = true;
  }
  if (typeof redirect === 'function') {
    router.allowPageChange = false;
    const redirectUrl = redirect.call(router, route, redirectResolve, redirectReject);
    if (redirectUrl && typeof redirectUrl === 'string') {
      router.allowPageChange = true;
      return router[direction](redirectUrl, options);
    }
    return router;
  }
  return router[direction](redirect, options);
}

function processQueue(router, routerQueue, routeQueue, to, from, resolve, reject) {
  const queue = [];

  if (Array.isArray(routeQueue)) {
    queue.push(...routeQueue);
  } else if (routeQueue && typeof routeQueue === 'function') {
    queue.push(routeQueue);
  }
  if (routerQueue) {
    if (Array.isArray(routerQueue)) {
      queue.push(...routerQueue);
    } else {
      queue.push(routerQueue);
    }
  }

  function next() {
    if (queue.length === 0) {
      resolve();
      return;
    }
    const queueItem = queue.shift();

    queueItem.call(
      router,
      to,
      from,
      () => {
        next();
      },
      () => {
        reject();
      }
    );
  }
  next();
}

function processRouteQueue (to, from, resolve, reject) {
  const router = this;
  function enterNextRoute() {
    if (to && to.route && (router.params.routesBeforeEnter || to.route.beforeEnter)) {
      router.allowPageChange = false;
      processQueue(
        router,
        router.params.routesBeforeEnter,
        to.route.beforeEnter,
        to,
        from,
        () => {
          router.allowPageChange = true;
          resolve();
        },
        () => {
          reject();
        },
      );
    } else {
      resolve();
    }
  }
  function leaveCurrentRoute() {
    if (from && from.route && (router.params.routesBeforeLeave || from.route.beforeLeave)) {
      router.allowPageChange = false;
      processQueue(
        router,
        router.params.routesBeforeLeave,
        from.route.beforeLeave,
        to,
        from,
        () => {
          router.allowPageChange = true;
          enterNextRoute();
        },
        () => {
          reject();
        },
      );
    } else {
      enterNextRoute();
    }
  }
  leaveCurrentRoute();
}

function appRouterCheck (router, method) {
  if (!router.view) {
    throw new Error(`Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router.${method}(...)`);
  }
}

function asyncComponent (router, asyncComponent, resolve, reject) {
  function resolvePromise(componentPromise) {
    componentPromise
      .then((c) => {
        // eslint-disable-next-line
        resolve({ component: c.default || c._default || c });
      })
      .catch((err) => {
        reject();
        throw new Error(err);
      });
  }
  if (asyncComponent instanceof Promise) {
    resolvePromise(asyncComponent);
    return;
  }
  const asyncComponentResult = asyncComponent.call(router);
  if (asyncComponentResult instanceof Promise) {
    resolvePromise(asyncComponentResult);
  } else {
    resolve({ component: asyncComponentResult });
  }
}

function refreshPage() {
  const router = this;
  appRouterCheck(router, 'refreshPage');
  return router.navigate(router.currentRoute.url, {
    ignoreCache: true,
    reloadCurrent: true,
  });
}

function forward(el, forwardOptions = {}) {
  const router = this;
  const $el = $(el);
  const app = router.app;
  const view = router.view;
  const options = Utils.extend(false, {
    animate: router.params.animate,
    pushState: true,
    replaceState: false,
    history: true,
    reloadCurrent: router.params.reloadPages,
    reloadPrevious: false,
    reloadAll: false,
    clearPreviousHistory: false,
    reloadDetail: router.params.reloadDetail,
    on: {},
  }, forwardOptions);

  const masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
  const isMaster = masterDetailEnabled && options.route && options.route.route && options.route.route.master === true;
  let masterPageEl;
  let otherDetailPageEl;

  let currentRouteIsModal = router.currentRoute.modal;
  let modalType;
  if (!currentRouteIsModal) {
    ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach((modalLoadProp) => {
      if (router.currentRoute && router.currentRoute.route && router.currentRoute.route[modalLoadProp]) {
        currentRouteIsModal = true;
        modalType = modalLoadProp;
      }
    });
  }

  if (currentRouteIsModal) {
    const modalToClose = router.currentRoute.modal
                         || router.currentRoute.route.modalInstance
                         || app[modalType].get();
    const previousUrl = router.history[router.history.length - 2];
    let previousRoute = router.findMatchingRoute(previousUrl);
    if (!previousRoute && previousUrl) {
      previousRoute = {
        url: previousUrl,
        path: previousUrl.split('?')[0],
        query: Utils.parseUrlQuery(previousUrl),
        route: {
          path: previousUrl.split('?')[0],
          url: previousUrl,
        },
      };
    }

    router.modalRemove(modalToClose);
  }

  const dynamicNavbar = router.dynamicNavbar;

  const $viewEl = router.$el;
  const $newPage = $el;
  const reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
  let $oldPage;

  let $navbarsEl;
  let $newNavbarEl;
  let $oldNavbarEl;

  router.allowPageChange = false;
  if ($newPage.length === 0) {
    router.allowPageChange = true;
    return router;
  }

  if ($newPage.length) {
    // Remove theme elements
    router.removeThemeElements($newPage);
  }

  if (dynamicNavbar) {
    $newNavbarEl = $newPage.children('.navbar');
    $navbarsEl = router.$navbarsEl;
    if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
      // Try from pageData
      $newNavbarEl = $newPage[0].f7Page.$navbarEl;
    }
  }

  // Save Keep Alive Cache
  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
    options.route.route.keepAliveData = {
      pageEl: $el[0],
    };
  }

  // Pages In View
  const $pagesInView = $viewEl
    .children('.page:not(.stacked)')
    .filter((index, pageInView) => pageInView !== $newPage[0]);

  // Navbars In View
  let $navbarsInView;
  if (dynamicNavbar) {
    $navbarsInView = $navbarsEl
      .children('.navbar:not(.stacked)')
      .filter((index, navbarInView) => navbarInView !== $newNavbarEl[0]);
  }

  // Exit when reload previous and only 1 page in view so nothing ro reload
  if (options.reloadPrevious && $pagesInView.length < 2) {
    router.allowPageChange = true;
    return router;
  }

  // Find Detail' master page
  let isDetail;
  let reloadDetail;
  let isDetailRoot;
  if (masterDetailEnabled && !options.reloadAll) {
    for (let i = 0; i < $pagesInView.length; i += 1) {
      if (!masterPageEl
        && $pagesInView[i].classList.contains('page-master')
      ) {
        masterPageEl = $pagesInView[i];
        continue; // eslint-disable-line
      }
    }
    isDetail = !isMaster && masterPageEl;

    if (isDetail) {
      // Find Other Detail
      if (masterPageEl) {
        for (let i = 0; i < $pagesInView.length; i += 1) {
          if ($pagesInView[i].classList.contains('page-master-detail')
          ) {
            otherDetailPageEl = $pagesInView[i];
            continue; // eslint-disable-line
          }
        }
      }
    }
    reloadDetail = isDetail && options.reloadDetail && app.width >= router.params.masterDetailBreakpoint && masterPageEl;
  }
  if (isDetail) {
    isDetailRoot = !otherDetailPageEl || reloadDetail || options.reloadAll || options.reloadCurrent;
  }

  // New Page
  let newPagePosition = 'next';
  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
    newPagePosition = 'current';
  } else if (options.reloadPrevious) {
    newPagePosition = 'previous';
  }
  $newPage
    .removeClass('page-previous page-current page-next')
    .addClass(`page-${newPagePosition}${isMaster ? ' page-master' : ''}${isDetail ? ' page-master-detail' : ''}${isDetailRoot ? ' page-master-detail-root' : ''}`)
    .removeClass('stacked')
    .trigger('page:unstack')
    .trigger('page:position', { position: newPagePosition });
  router.emit('pageUnstack', $newPage[0]);
  router.emit('pagePosition', $newPage[0], newPagePosition);

  if (isMaster || isDetail) {
    $newPage.trigger('page:role', { role: isMaster ? 'master' : 'detail', root: !!isDetailRoot });
    router.emit('pageRole', $newPage[0], { role: isMaster ? 'master' : 'detail', detailRoot: !!isDetailRoot });
  }

  if (dynamicNavbar && $newNavbarEl.length) {
    $newNavbarEl
      .removeClass('navbar-previous navbar-current navbar-next')
      .addClass(`navbar-${newPagePosition}${isMaster ? ' navbar-master' : ''}${isDetail ? ' navbar-master-detail' : ''}${isDetailRoot ? ' navbar-master-detail-root' : ''}`)
      .removeClass('stacked');
    $newNavbarEl.trigger('navbar:position', { position: newPagePosition });
    router.emit('navbarPosition', $newNavbarEl[0], newPagePosition);
    if (isMaster || isDetail) {
      router.emit('navbarRole', $newNavbarEl[0], { role: isMaster ? 'master' : 'detail', detailRoot: !!isDetailRoot });
    }
  }

  // Find Old Page
  if (options.reloadCurrent || reloadDetail) {
    $oldPage = $pagesInView.eq($pagesInView.length - 1);
    if (dynamicNavbar) {
      // $oldNavbarEl = $navbarsInView.eq($pagesInView.length - 1);
      $oldNavbarEl = $(app.navbar.getElByPage($oldPage));
    }
  } else if (options.reloadPrevious) {
    $oldPage = $pagesInView.eq($pagesInView.length - 2);
    if (dynamicNavbar) {
      // $oldNavbarEl = $navbarsInView.eq($pagesInView.length - 2);
      $oldNavbarEl = $(app.navbar.getElByPage($oldPage));
    }
  } else if (options.reloadAll) {
    $oldPage = $pagesInView.filter((index, pageEl) => pageEl !== $newPage[0]);
    if (dynamicNavbar) {
      $oldNavbarEl = $navbarsInView.filter((index, navbarEl) => navbarEl !== $newNavbarEl[0]);
    }
  } else {
    let removedPageEls = [];
    let removedNavbarEls = [];
    if ($pagesInView.length > 1) {
      let i = 0;
      for (i = 0; i < $pagesInView.length - 1; i += 1) {
        if (masterPageEl
          && $pagesInView[i] === masterPageEl
        ) {
          $pagesInView.eq(i).addClass('page-master-stacked');
          $pagesInView.eq(i).trigger('page:masterstack');
          router.emit('pageMasterStack', $pagesInView[i]);
          if (dynamicNavbar) {
            $(app.navbar.getElByPage(masterPageEl)).addClass('navbar-master-stacked');
            router.emit('navbarMasterStack', app.navbar.getElByPage(masterPageEl));
          }
          continue; // eslint-disable-line
        }
        const oldNavbarEl = app.navbar.getElByPage($pagesInView.eq(i));
        if (router.params.stackPages) {
          $pagesInView.eq(i).addClass('stacked');
          $pagesInView.eq(i).trigger('page:stack');
          router.emit('pageStack', $pagesInView[i]);
          if (dynamicNavbar) {
            $(oldNavbarEl).addClass('stacked');
          }
        } else {
          // Page remove event
          removedPageEls.push($pagesInView[i]);
          router.pageCallback('beforeRemove', $pagesInView[i], $navbarsInView && $navbarsInView[i], 'previous', undefined, options);
          router.removePage($pagesInView[i]);
          if (dynamicNavbar && oldNavbarEl) {
            removedNavbarEls.push(oldNavbarEl);
            router.removeNavbar(oldNavbarEl);
          }
        }
      }
    }
    $oldPage = $viewEl
      .children('.page:not(.stacked)')
      .filter((index, pageEl) => pageEl !== $newPage[0] && removedPageEls.indexOf(pageEl) < 0);
    if (dynamicNavbar) {
      $oldNavbarEl = $navbarsEl
        .children('.navbar:not(.stacked)')
        .filter((index, navbarEl) => navbarEl !== $newNavbarEl[0] && removedNavbarEls.indexOf(removedNavbarEls) < 0);
    }
    removedPageEls = [];
    removedNavbarEls = [];
  }

  if (isDetail && !options.reloadAll) {
    if ($oldPage.length > 1 || reloadDetail) {
      $oldPage = $oldPage.filter((pageIndex, pageEl) => !pageEl.classList.contains('page-master'));
    }
    if ($oldNavbarEl && ($oldNavbarEl.length > 1 || reloadDetail)) {
      $oldNavbarEl = $oldNavbarEl.filter((navbarIndex, navbarEl) => !navbarEl.classList.contains('navbar-master'));
    }
  }

  // Push State
  if (router.params.pushState && (options.pushState || options.replaceState) && !options.reloadPrevious) {
    const pushStateRoot = router.params.pushStateRoot || '';
    History[options.reloadCurrent || (reloadDetail && otherDetailPageEl) || options.reloadAll || options.replaceState ? 'replace' : 'push'](
      view.id,
      {
        url: options.route.url,
      },
      pushStateRoot + router.params.pushStateSeparator + options.route.url
    );
  }

  if (!options.reloadPrevious) {
    // Current Page & Navbar
    router.currentPageEl = $newPage[0];
    if (dynamicNavbar && $newNavbarEl.length) {
      router.currentNavbarEl = $newNavbarEl[0];
    } else {
      delete router.currentNavbarEl;
    }

    // Current Route
    router.currentRoute = options.route;
  }

  // Update router history
  const url = options.route.url;

  if (options.history) {
    if (((options.reloadCurrent || (reloadDetail && otherDetailPageEl)) && router.history.length) > 0 || options.replaceState) {
      router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
    } else if (options.reloadPrevious) {
      router.history[router.history.length - 2] = url;
    } else if (options.reloadAll) {
      router.history = [url];
    } else {
      router.history.push(url);
    }
  }
  router.saveHistory();

  // Insert new page and navbar
  const newPageInDom = $newPage.parents(doc).length > 0;
  const f7Component = $newPage[0].f7Component;
  if (options.reloadPrevious) {
    if (f7Component && !newPageInDom) {
      f7Component.$mount((componentEl) => {
        $(componentEl).insertBefore($oldPage);
      });
    } else {
      $newPage.insertBefore($oldPage);
    }
    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find('.title-large').length) {
        $newNavbarEl.addClass('navbar-large');
      }
      if ($oldNavbarEl.length) {
        $newNavbarEl.insertBefore($oldNavbarEl);
      } else {
        if (!router.$navbarsEl.parents(doc).length) {
          router.$el.prepend(router.$navbarsEl);
        }
        $navbarsEl.append($newNavbarEl);
      }
    }
  } else {
    if ($oldPage.next('.page')[0] !== $newPage[0]) {
      if (f7Component && !newPageInDom) {
        f7Component.$mount((componentEl) => {
          $viewEl.append(componentEl);
        });
      } else {
        $viewEl.append($newPage[0]);
      }
    }
    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find('.title-large').length) {
        $newNavbarEl.addClass('navbar-large');
      }
      if (!router.$navbarsEl.parents(doc).length) {
        router.$el.prepend(router.$navbarsEl);
      }
      $navbarsEl.append($newNavbarEl[0]);
    }
  }
  if (!newPageInDom) {
    router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, (reload ? newPagePosition : 'current'), options, $oldPage);
  } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
    $newPage[0].f7PageMounted = true;
    router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, (reload ? newPagePosition : 'current'), options, $oldPage);
  }

  // Remove old page
  if ((options.reloadCurrent || reloadDetail) && $oldPage.length > 0) {
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass('stacked');
      $oldPage.trigger('page:stack');
      router.emit('pageStack', $oldPage[0]);
      if (dynamicNavbar) {
        $oldNavbarEl.addClass('stacked');
      }
    } else {
      // Page remove event
      router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
      router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
      router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'current', undefined, options);
      router.removePage($oldPage);
      if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
  } else if (options.reloadAll) {
    $oldPage.each((index, pageEl) => {
      const $oldPageEl = $(pageEl);
      const $oldNavbarElEl = $(app.navbar.getElByPage($oldPageEl));
      if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
        $oldPageEl.addClass('stacked');
        $oldPageEl.trigger('page:stack');
        router.emit('pageStack', $oldPageEl[0]);
        if (dynamicNavbar) {
          $oldNavbarElEl.addClass('stacked');
        }
      } else {
        // Page remove event
        if ($oldPageEl.hasClass('page-current')) {
          router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
          router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
        }
        router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl && $oldNavbarEl.eq(index), 'previous', undefined, options);
        router.removePage($oldPageEl);
        if (dynamicNavbar && $oldNavbarElEl.length) {
          router.removeNavbar($oldNavbarElEl);
        }
      }
    });
  } else if (options.reloadPrevious) {
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass('stacked');
      $oldPage.trigger('page:stack');
      router.emit('pageStack', $oldPage[0]);
      if (dynamicNavbar) {
        $oldNavbarEl.addClass('stacked');
      }
    } else {
      // Page remove event
      router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
      router.removePage($oldPage);
      if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
  }

  // Load Tab
  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
      history: false,
      pushState: false,
    }));
  }

  // Check master detail
  if (masterDetailEnabled) {
    view.checkMasterDetailBreakpoint();
  }

  // Page init and before init events
  router.pageCallback('init', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);

  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
    router.allowPageChange = true;
    router.pageCallback('beforeIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
    $newPage.removeAttr('aria-hidden');
    if (dynamicNavbar && $newNavbarEl) {
      $newNavbarEl.removeAttr('aria-hidden');
    }
    router.pageCallback('afterIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
    if (options.reloadCurrent && options.clearPreviousHistory) router.clearPreviousHistory();
    if (reloadDetail) {
      router.setPagePosition($(masterPageEl), 'previous');
      if (masterPageEl.f7Page && masterPageEl.f7Page.navbarEl) {
        router.setNavbarPosition($(masterPageEl.f7Page.navbarEl), 'previous');
      }
    }
    return router;
  }
  if (options.reloadPrevious) {
    router.allowPageChange = true;
    return router;
  }

  // Before animation event
  router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
  router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'next', 'current', options);

  // Animation
  function afterAnimation() {
    router.setPagePosition($newPage, 'current', false);
    router.setPagePosition($oldPage, 'previous', !$oldPage.hasClass('page-master'));
    if (dynamicNavbar) {
      router.setNavbarPosition($newNavbarEl, 'current', false);
      router.setNavbarPosition($oldNavbarEl, 'previous', !$oldNavbarEl.hasClass('navbar-master'));
    }
    // After animation event
    router.allowPageChange = true;
    router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
    router.pageCallback('afterIn', $newPage, $newNavbarEl, 'next', 'current', options);

    let keepOldPage = (router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`]) && !isMaster;
    if (!keepOldPage) {
      if ($newPage.hasClass('smart-select-page') || $newPage.hasClass('photo-browser-page') || $newPage.hasClass('autocomplete-page') || $newPage.hasClass('color-picker-page')) {
        keepOldPage = true;
      }
    }
    if (!keepOldPage) {
      if (router.params.stackPages) {
        $oldPage.addClass('stacked');
        $oldPage.trigger('page:stack');
        router.emit('pageStack', $oldPage[0]);
        if (dynamicNavbar) {
          $oldNavbarEl.addClass('stacked');
        }
      } else if (!($newPage.attr('data-name') && $newPage.attr('data-name') === 'smart-select-page')) {
        // Remove event
        router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
        router.removePage($oldPage);
        if (dynamicNavbar && $oldNavbarEl.length) {
          router.removeNavbar($oldNavbarEl);
        }
      }
    }
    if (options.clearPreviousHistory) router.clearPreviousHistory();
    router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

    if (router.params.pushState) {
      History.clearRouterQueue();
    }
  }
  function setPositionClasses() {
    router.setPagePosition($oldPage, 'current', false);
    router.setPagePosition($newPage, 'next', false);
    if (dynamicNavbar) {
      router.setNavbarPosition($oldNavbarEl, 'current', false);
      router.setNavbarPosition($newNavbarEl, 'next', false);
    }
  }
  if (options.animate && !(isMaster && app.width >= router.params.masterDetailBreakpoint)) {
    const delay = router.params[`${router.app.theme}PageLoadDelay`];
    let transition = router.params.transition;
    if (options.transition) transition = options.transition;
    if (!transition && router.currentRoute && router.currentRoute.route) {
      transition = router.currentRoute.route.transition;
    }
    if (!transition && router.currentRoute && router.currentRoute.route.options) {
      transition = router.currentRoute.route.options.transition;
    }
    if (transition) {
      $newPage[0].f7PageTransition = transition;
    }

    if (delay) {
      setTimeout(() => {
        setPositionClasses();
        router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, () => {
          afterAnimation();
        });
      }, delay);
    } else {
      setPositionClasses();
      router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, () => {
        afterAnimation();
      });
    }
  } else {
    afterAnimation();
  }
  return router;
}
function load(loadParams = {}, loadOptions = {}, ignorePageChange) {
  const router = this;
  if (!router.allowPageChange && !ignorePageChange) return router;
  const params = loadParams;
  const options = loadOptions;
  const { url, content, el, pageName, template, templateUrl, component, componentUrl } = params;

  if (!options.reloadCurrent
    && options.route
    && options.route.route
    && options.route.route.parentPath
    && router.currentRoute.route
    && router.currentRoute.route.parentPath === options.route.route.parentPath) {
    // Do something nested
    if (options.route.url === router.url) {
      router.allowPageChange = true;
      return false;
    }
    // Check for same params
    let sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;
    if (sameParams) {
      // Check for equal params name
      Object.keys(options.route.params).forEach((paramName) => {
        if (
          !(paramName in router.currentRoute.params)
          || (router.currentRoute.params[paramName] !== options.route.params[paramName])
        ) {
          sameParams = false;
        }
      });
    }
    if (sameParams) {
      if (options.route.route.tab) {
        return router.tabLoad(options.route.route.tab, options);
      }
      return false;
    }
    if (!sameParams
      && options.route.route.tab
      && router.currentRoute.route.tab
      && router.currentRoute.parentPath === options.route.parentPath
    ) {
      return router.tabLoad(options.route.route.tab, options);
    }
  }

  if (
    options.route
    && options.route.url
    && router.url === options.route.url
    && !(options.reloadCurrent || options.reloadPrevious)
    && !router.params.allowDuplicateUrls
  ) {
    router.allowPageChange = true;
    return false;
  }

  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
    Utils.extend(options.route, { route: { url, path: url } });
  }

  // Component Callbacks
  function resolve(pageEl, newOptions) {
    return router.forward(pageEl, Utils.extend(options, newOptions));
  }
  function reject() {
    router.allowPageChange = true;
    return router;
  }

  if (url || templateUrl || componentUrl || component) {
    router.allowPageChange = false;
  }

  // Proceed
  if (content) {
    router.forward(router.getPageEl(content), options);
  } else if (template || templateUrl) {
    // Parse template and send page element
    try {
      router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (el) {
    // Load page from specified HTMLElement or by page name in pages container
    router.forward(router.getPageEl(el), options);
  } else if (pageName) {
    // Load page by page name in pages container
    router.forward(router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
  } else if (component || componentUrl) {
    // Load from component (F7/Vue/React/...)
    try {
      router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    // Load using XHR
    if (router.xhr) {
      router.xhr.abort();
      router.xhr = false;
    }
    router.xhrRequest(url, options)
      .then((pageContent) => {
        router.forward(router.getPageEl(pageContent), options);
      })
      .catch(() => {
        router.allowPageChange = true;
      });
  }
  return router;
}
function navigate(navigateParams, navigateOptions = {}) {
  const router = this;
  if (router.swipeBackActive) return router;
  let url;
  let createRoute;
  let name;
  let path;
  let query;
  let params;
  let route;
  if (typeof navigateParams === 'string') {
    url = navigateParams;
  } else {
    url = navigateParams.url;
    createRoute = navigateParams.route;
    name = navigateParams.name;
    path = navigateParams.path;
    query = navigateParams.query;
    params = navigateParams.params;
  }
  if (name || path) {
    url = router.generateUrl({ path, name, params, query });
    if (url) {
      return router.navigate(url, navigateOptions);
    }
    return router;
  }
  const app = router.app;
  appRouterCheck(router, 'navigate');
  if (url === '#' || url === '') {
    return router;
  }

  let navigateUrl = url.replace('./', '');
  if (navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
    const currentPath = router.currentRoute.parentPath || router.currentRoute.path;
    navigateUrl = ((currentPath ? `${currentPath}/` : '/') + navigateUrl)
      .replace('///', '/')
      .replace('//', '/');
  }
  if (createRoute) {
    route = Utils.extend(router.parseRouteUrl(navigateUrl), {
      route: Utils.extend({}, createRoute),
    });
  } else {
    route = router.findMatchingRoute(navigateUrl);
  }

  if (!route) {
    return router;
  }
  if (route.route && route.route.viewName) {
    const anotherViewName = route.route.viewName;
    const anotherView = app.views[anotherViewName];
    if (!anotherView) {
      throw new Error(`Framework7: There is no View with "${anotherViewName}" name that was specified in this route`);
    }
    if (anotherView !== router.view) {
      return anotherView.router.navigate(navigateParams, navigateOptions);
    }
  }

  if (route.route.redirect) {
    return redirect.call(router, 'navigate', route, navigateOptions);
  }


  const options = {};
  if (route.route.options) {
    Utils.extend(options, route.route.options, navigateOptions);
  } else {
    Utils.extend(options, navigateOptions);
  }
  options.route = route;

  if (options && options.context) {
    route.context = options.context;
    options.route.context = options.context;
  }

  function resolve() {
    let routerLoaded = false;
    ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach((modalLoadProp) => {
      if (route.route[modalLoadProp] && !routerLoaded) {
        routerLoaded = true;
        router.modalLoad(modalLoadProp, route, options);
      }
    });
    if (route.route.keepAlive && route.route.keepAliveData) {
      router.load({ el: route.route.keepAliveData.pageEl }, options, false);
      routerLoaded = true;
    }
    ('url content component pageName el componentUrl template templateUrl').split(' ').forEach((pageLoadProp) => {
      if (route.route[pageLoadProp] && !routerLoaded) {
        routerLoaded = true;
        router.load({ [pageLoadProp]: route.route[pageLoadProp] }, options, false);
      }
    });
    if (routerLoaded) return;
    // Async
    function asyncResolve(resolveParams, resolveOptions) {
      router.allowPageChange = false;
      let resolvedAsModal = false;
      if (resolveOptions && resolveOptions.context) {
        if (!route.context) route.context = resolveOptions.context;
        else route.context = Utils.extend({}, route.context, resolveOptions.context);
        options.route.context = route.context;
      }
      ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach((modalLoadProp) => {
        if (resolveParams[modalLoadProp]) {
          resolvedAsModal = true;
          const modalRoute = Utils.extend({}, route, { route: resolveParams });
          router.allowPageChange = true;
          router.modalLoad(modalLoadProp, modalRoute, Utils.extend(options, resolveOptions));
        }
      });
      if (resolvedAsModal) return;
      router.load(resolveParams, Utils.extend(options, resolveOptions), true);
    }
    function asyncReject() {
      router.allowPageChange = true;
    }
    if (route.route.async) {
      router.allowPageChange = false;
      route.route.async.call(router, options.route, router.currentRoute, asyncResolve, asyncReject);
    }
    if (route.route.asyncComponent) {
      asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
    }
  }
  function reject() {
    router.allowPageChange = true;
  }

  if (router.params.masterDetailBreakpoint > 0 && route.route.masterRoute) {
    // load detail route
    let preloadMaster = true;
    let masterLoaded = false;
    if (router.currentRoute && router.currentRoute.route) {
      if (
        router.currentRoute.route.master
        && (
          router.currentRoute.route === route.route.masterRoute
          || router.currentRoute.route.path === route.route.masterRoute.path
        )
      ) {
        preloadMaster = false;
      }
      if (
        router.currentRoute.route.masterRoute
        && (router.currentRoute.route.masterRoute === route.route.masterRoute
          || router.currentRoute.route.masterRoute.path === route.route.masterRoute.path
        )
      ) {
        preloadMaster = false;
        masterLoaded = true;
      }
    }
    if (preloadMaster || (masterLoaded && navigateOptions.reloadAll)) {
      router.navigate({ path: route.route.masterRoute.path, params: route.params || {} }, {
        animate: false,
        reloadAll: navigateOptions.reloadAll,
        reloadCurrent: navigateOptions.reloadCurrent,
        reloadPrevious: navigateOptions.reloadPrevious,
        pushState: !navigateOptions.initial,
        history: !navigateOptions.initial,
        once: {
          pageAfterIn() {
            router.navigate(navigateParams, Utils.extend({}, navigateOptions, {
              animate: false,
              reloadAll: false,
              reloadCurrent: false,
              reloadPrevious: false,
              history: !navigateOptions.initial,
              pushState: !navigateOptions.initial,
            }));
          },
        },
      });
      return router;
    }
  }

  processRouteQueue.call(
    router,
    route,
    router.currentRoute,
    () => {
      if (route.route.modules) {
        app
          .loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules])
          .then(() => {
            resolve();
          })
          .catch(() => {
            reject();
          });
      } else {
        resolve();
      }
    },
    () => {
      reject();
    },
  );

  // Return Router
  return router;
}

function tabLoad(tabRoute, loadOptions = {}) {
  const router = this;
  const options = Utils.extend({
    animate: router.params.animate,
    pushState: true,
    history: true,
    parentPageEl: null,
    preload: false,
    on: {},
  }, loadOptions);

  let currentRoute;
  let previousRoute;
  if (options.route) {
    // Set Route
    if (!options.preload && options.route !== router.currentRoute) {
      previousRoute = router.previousRoute;
      router.currentRoute = options.route;
    }
    if (options.preload) {
      currentRoute = options.route;
      previousRoute = router.currentRoute;
    } else {
      currentRoute = router.currentRoute;
      if (!previousRoute) previousRoute = router.previousRoute;
    }

    // Update Browser History
    if (router.params.pushState && options.pushState && !options.reloadPrevious) {
      History.replace(
        router.view.id,
        {
          url: options.route.url,
        },
        (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
      );
    }

    // Update Router History
    if (options.history) {
      router.history[Math.max(router.history.length - 1, 0)] = options.route.url;
      router.saveHistory();
    }
  }

  // Show Tab
  const $parentPageEl = $(options.parentPageEl || router.currentPageEl);
  let tabEl;
  if ($parentPageEl.length && $parentPageEl.find(`#${tabRoute.id}`).length) {
    tabEl = $parentPageEl.find(`#${tabRoute.id}`).eq(0);
  } else if (router.view.selector) {
    tabEl = `${router.view.selector} #${tabRoute.id}`;
  } else {
    tabEl = `#${tabRoute.id}`;
  }
  const tabShowResult = router.app.tab.show({
    tabEl,
    animate: options.animate,
    tabRoute: options.route,
  });

  const { $newTabEl, $oldTabEl, animated, onTabsChanged } = tabShowResult;

  if ($newTabEl && $newTabEl.parents('.page').length > 0 && options.route) {
    const tabParentPageData = $newTabEl.parents('.page')[0].f7Page;
    if (tabParentPageData && options.route) {
      tabParentPageData.route = options.route;
    }
  }

  // Tab Content Loaded
  function onTabLoaded(contentEl) {
    // Remove theme elements
    router.removeThemeElements($newTabEl);

    let tabEventTarget = $newTabEl;
    if (typeof contentEl !== 'string') tabEventTarget = $(contentEl);

    tabEventTarget.trigger('tab:init tab:mounted', tabRoute);
    router.emit('tabInit tabMounted', $newTabEl[0], tabRoute);

    if ($oldTabEl && $oldTabEl.length) {
      if (animated) {
        onTabsChanged(() => {
          router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
          if (router.params.unloadTabContent) {
            router.tabRemove($oldTabEl, $newTabEl, tabRoute);
          }
        });
      } else {
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
        if (router.params.unloadTabContent) {
          router.tabRemove($oldTabEl, $newTabEl, tabRoute);
        }
      }
    }
  }

  if ($newTabEl[0].f7RouterTabLoaded) {
    if (!$oldTabEl || !$oldTabEl.length) return router;
    if (animated) {
      onTabsChanged(() => {
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
      });
    } else {
      router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
    }
    return router;
  }

  // Load Tab Content
  function loadTab(loadTabParams, loadTabOptions) {
    // Load Tab Props
    const { url, content, el, template, templateUrl, component, componentUrl } = loadTabParams;
    // Component/Template Callbacks
    function resolve(contentEl) {
      router.allowPageChange = true;
      if (!contentEl) return;
      if (typeof contentEl === 'string') {
        $newTabEl.html(contentEl);
      } else {
        $newTabEl.html('');
        if (contentEl.f7Component) {
          contentEl.f7Component.$mount((componentEl) => {
            $newTabEl.append(componentEl);
          });
        } else {
          $newTabEl.append(contentEl);
        }
      }
      $newTabEl[0].f7RouterTabLoaded = true;
      onTabLoaded(contentEl);
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }

    if (content) {
      resolve(content);
    } else if (template || templateUrl) {
      try {
        router.tabTemplateLoader(template, templateUrl, loadTabOptions, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (el) {
      resolve(el);
    } else if (component || componentUrl) {
      // Load from component (F7/Vue/React/...)
      try {
        router.tabComponentLoader($newTabEl[0], component, componentUrl, loadTabOptions, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      // Load using XHR
      if (router.xhr) {
        router.xhr.abort();
        router.xhr = false;
      }
      router.xhrRequest(url, loadTabOptions)
        .then((tabContent) => {
          resolve(tabContent);
        })
        .catch(() => {
          router.allowPageChange = true;
        });
    }
  }

  let hasContentLoadProp;
  ('url content component el componentUrl template templateUrl').split(' ').forEach((tabLoadProp) => {
    if (tabRoute[tabLoadProp]) {
      hasContentLoadProp = true;
      loadTab({ [tabLoadProp]: tabRoute[tabLoadProp] }, options);
    }
  });

  // Async
  function asyncResolve(resolveParams, resolveOptions) {
    loadTab(resolveParams, Utils.extend(options, resolveOptions));
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (tabRoute.async) {
    tabRoute.async.call(router, currentRoute, previousRoute, asyncResolve, asyncReject);
  } else if (tabRoute.asyncComponent) {
    asyncComponent(router, tabRoute.asyncComponent, asyncResolve, asyncReject);
  } else if (!hasContentLoadProp) {
    router.allowPageChange = true;
  }

  return router;
}
function tabRemove($oldTabEl, $newTabEl, tabRoute) {
  const router = this;

  let hasTabComponentChild;
  if ($oldTabEl[0]) {
    $oldTabEl[0].f7RouterTabLoaded = false;
    delete $oldTabEl[0].f7RouterTabLoaded;
  }
  $oldTabEl.children().each((index, tabChild) => {
    if (tabChild.f7Component) {
      hasTabComponentChild = true;
      $(tabChild).trigger('tab:beforeremove', tabRoute);
      tabChild.f7Component.$destroy();
    }
  });
  if (!hasTabComponentChild) {
    $oldTabEl.trigger('tab:beforeremove', tabRoute);
  }
  router.emit('tabBeforeRemove', $oldTabEl[0], $newTabEl[0], tabRoute);
  router.removeTabContent($oldTabEl[0], tabRoute);
}

function modalLoad(modalType, route, loadOptions = {}) {
  const router = this;
  const app = router.app;
  const isPanel = modalType === 'panel';
  const modalOrPanel = isPanel ? 'panel' : 'modal';

  const options = Utils.extend({
    animate: router.params.animate,
    pushState: true,
    history: true,
    on: {},
  }, loadOptions);

  const modalParams = Utils.extend({}, route.route[modalType]);
  const modalRoute = route.route;

  function onModalLoaded() {
    // Create Modal
    const modal = app[modalType].create(modalParams);
    modalRoute.modalInstance = modal;

    const hasEl = modal.el;

    function closeOnSwipeBack() {
      modal.close();
    }
    modal.on(`${modalOrPanel}Open`, () => {
      if (!hasEl) {
        // Remove theme elements
        router.removeThemeElements(modal.el);

        // Emit events
        modal.$el.trigger(`${modalType.toLowerCase()}:init ${modalType.toLowerCase()}:mounted`, route, modal);
        router.emit(`${!isPanel ? 'modalInit' : ''} ${modalType}Init ${modalType}Mounted`, modal.el, route, modal);
      }
      router.once('swipeBackMove', closeOnSwipeBack);
    });
    modal.on(`${modalOrPanel}Close`, () => {
      router.off('swipeBackMove', closeOnSwipeBack);
      if (!modal.closeByRouter) {
        router.back();
      }
    });

    modal.on(`${modalOrPanel}Closed`, () => {
      modal.$el.trigger(`${modalType.toLowerCase()}:beforeremove`, route, modal);
      modal.emit(`${!isPanel ? 'modalBeforeRemove ' : ''}${modalType}BeforeRemove`, modal.el, route, modal);
      const modalComponent = modal.el.f7Component;
      if (modalComponent) {
        modalComponent.$destroy();
      }
      Utils.nextTick(() => {
        if (modalComponent || modalParams.component) {
          router.removeModal(modal.el);
        }
        modal.destroy();
        delete modal.route;
        delete modalRoute.modalInstance;
      });
    });

    if (options.route) {
      // Update Browser History
      if (router.params.pushState && options.pushState) {
        History.push(
          router.view.id,
          {
            url: options.route.url,
            modal: modalType,
          },
          (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
        );
      }

      // Set Route
      if (options.route !== router.currentRoute) {
        modal.route = Utils.extend(options.route, { modal });
        router.currentRoute = modal.route;
      }

      // Update Router History
      if (options.history) {
        router.history.push(options.route.url);
        router.saveHistory();
      }
    }

    if (hasEl) {
      // Remove theme elements
      router.removeThemeElements(modal.el);

      // Emit events
      modal.$el.trigger(`${modalType.toLowerCase()}:init ${modalType.toLowerCase()}:mounted`, route, modal);
      router.emit(`${modalOrPanel}Init ${modalType}Init ${modalType}Mounted`, modal.el, route, modal);
    }

    // Open
    modal.open();
  }

  // Load Modal Content
  function loadModal(loadModalParams, loadModalOptions) {
    // Load Modal Props
    const { url, content, template, templateUrl, component, componentUrl } = loadModalParams;

    // Component/Template Callbacks
    function resolve(contentEl) {
      if (contentEl) {
        if (typeof contentEl === 'string') {
          modalParams.content = contentEl;
        } else if (contentEl.f7Component) {
          contentEl.f7Component.$mount((componentEl) => {
            modalParams.el = componentEl;
            app.root.append(componentEl);
          });
        } else {
          modalParams.el = contentEl;
        }
        onModalLoaded();
      }
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }

    if (content) {
      resolve(content);
    } else if (template || templateUrl) {
      try {
        router.modalTemplateLoader(template, templateUrl, loadModalOptions, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (component || componentUrl) {
      // Load from component (F7/Vue/React/...)
      try {
        router.modalComponentLoader(app.root[0], component, componentUrl, loadModalOptions, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      // Load using XHR
      if (router.xhr) {
        router.xhr.abort();
        router.xhr = false;
      }
      router.xhrRequest(url, loadModalOptions)
        .then((modalContent) => {
          modalParams.content = modalContent;
          onModalLoaded();
        })
        .catch(() => {
          router.allowPageChange = true;
        });
    } else {
      onModalLoaded();
    }
  }

  let foundLoadProp;
  ('url content component el componentUrl template templateUrl').split(' ').forEach((modalLoadProp) => {
    if (modalParams[modalLoadProp] && !foundLoadProp) {
      foundLoadProp = true;
      loadModal({ [modalLoadProp]: modalParams[modalLoadProp] }, options);
    }
  });
  if (!foundLoadProp && modalType === 'actions') {
    onModalLoaded();
  }

  // Async
  function asyncResolve(resolveParams, resolveOptions) {
    loadModal(resolveParams, Utils.extend(options, resolveOptions));
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (modalParams.async) {
    modalParams.async.call(router, options.route, router.currentRoute, asyncResolve, asyncReject);
  }
  if (modalParams.asyncComponent) {
    asyncComponent(router, modalParams.asyncComponent, asyncResolve, asyncReject);
  }
  return router;
}
function modalRemove(modal) {
  Utils.extend(modal, { closeByRouter: true });
  modal.close();
}

function backward(el, backwardOptions) {
  const router = this;
  const $el = $(el);
  const app = router.app;
  const view = router.view;

  const options = Utils.extend({
    animate: router.params.animate,
    pushState: true,
    replaceState: false,
  }, backwardOptions);

  const masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
  const isMaster = masterDetailEnabled && options.route && options.route.route && options.route.route.master === true;
  let masterPageEl;
  let masterPageRemoved;

  const dynamicNavbar = router.dynamicNavbar;

  const $newPage = $el;
  const $oldPage = router.$el.children('.page-current');
  const currentIsMaster = masterDetailEnabled && $oldPage.hasClass('page-master');

  if ($newPage.length) {
    // Remove theme elements
    router.removeThemeElements($newPage);
  }

  let $navbarsEl;
  let $newNavbarEl;
  let $oldNavbarEl;

  if (dynamicNavbar) {
    $newNavbarEl = $newPage.children('.navbar');
    $navbarsEl = router.$navbarsEl;
    if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
      // Try from pageData
      $newNavbarEl = $newPage[0].f7Page.$navbarEl;
    }
    $oldNavbarEl = $navbarsEl.find('.navbar-current');
  }

  router.allowPageChange = false;
  if ($newPage.length === 0 || $oldPage.length === 0) {
    router.allowPageChange = true;
    return router;
  }

  // Remove theme elements
  router.removeThemeElements($newPage);

  // Save Keep Alive Cache
  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
    options.route.route.keepAliveData = {
      pageEl: $el[0],
    };
  }

  // Pages In View
  let isDetail;
  let isDetailRoot;
  if (masterDetailEnabled) {
    const $pagesInView = router.$el
      .children('.page:not(.stacked)')
      .filter((index, pageInView) => pageInView !== $newPage[0]);

    // Find Detail' master page
    for (let i = 0; i < $pagesInView.length; i += 1) {
      if (!masterPageEl
        && $pagesInView[i].classList.contains('page-master')
      ) {
        masterPageEl = $pagesInView[i];
        continue; // eslint-disable-line
      }
    }

    isDetail = !isMaster
      && masterPageEl
      && (router.history.indexOf(options.route.url) > router.history.indexOf(masterPageEl.f7Page.route.url));

    if (!isDetail && !isMaster && masterPageEl && masterPageEl.f7Page && options.route.route.masterRoute) {
      isDetail = options.route.route.masterRoute.path === masterPageEl.f7Page.route.route.path;
    }
  }
  if (isDetail && masterPageEl && masterPageEl.f7Page) {
    isDetailRoot = router.history.indexOf(options.route.url) - router.history.indexOf(masterPageEl.f7Page.route.url) === 1;
  }

  // New Page
  $newPage
    .addClass(`page-previous${isMaster ? ' page-master' : ''}${isDetail ? ' page-master-detail' : ''}${isDetailRoot ? ' page-master-detail-root' : ''}`)
    .removeClass('stacked')
    .removeAttr('aria-hidden')
    .trigger('page:unstack')
    .trigger('page:position', { position: 'previous' });
  router.emit('pageUnstack', $newPage[0]);
  router.emit('pagePosition', $newPage[0], 'previous');
  if (isMaster || isDetail) {
    $newPage.trigger('page:role', { role: isMaster ? 'master' : 'detail', root: !!isDetailRoot });
    router.emit('pageRole', $newPage[0], { role: isMaster ? 'master' : 'detail', detailRoot: !!isDetailRoot });
  }

  if (dynamicNavbar && $newNavbarEl.length > 0) {
    $newNavbarEl
      .addClass(`navbar-previous${isMaster ? ' navbar-master' : ''}${isDetail ? ' navbar-master-detail' : ''}${isDetailRoot ? ' navbar-master-detail-root' : ''}`)
      .removeClass('stacked')
      .removeAttr('aria-hidden');
    $newNavbarEl.trigger('navbar:position', { position: 'previous' });
    router.emit('navbarPosition', $newNavbarEl[0], 'previous');
    if (isMaster || isDetailRoot) {
      router.emit('navbarRole', $newNavbarEl[0], { role: isMaster ? 'master' : 'detail', detailRoot: !!isDetailRoot });
    }
  }

  // Remove previous page in case of "forced"
  let backIndex;
  if (options.force) {
    if ($oldPage.prev('.page-previous:not(.stacked)').length > 0 || $oldPage.prev('.page-previous').length === 0) {
      if (router.history.indexOf(options.route.url) >= 0) {
        backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
        router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
        view.history = router.history;
      } else if (router.history[[router.history.length - 2]]) {
        router.history[router.history.length - 2] = options.route.url;
      } else {
        router.history.unshift(router.url);
      }

      if (backIndex && router.params.stackPages) {
        $oldPage.prevAll('.page-previous').each((index, pageToRemove) => {
          const $pageToRemove = $(pageToRemove);
          let $navbarToRemove;
          if (dynamicNavbar) {
            // $navbarToRemove = $oldNavbarEl.prevAll('.navbar-previous').eq(index);
            $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
          }
          if ($pageToRemove[0] !== $newPage[0] && $pageToRemove.index() > $newPage.index()) {
            if (router.initialPages.indexOf($pageToRemove[0]) >= 0) {
              $pageToRemove.addClass('stacked');
              $pageToRemove.trigger('page:stack');
              router.emit('pageStack', $pageToRemove[0]);
              if (dynamicNavbar) {
                $navbarToRemove.addClass('stacked');
              }
            } else {
              router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
              if ($pageToRemove[0] === masterPageEl) {
                masterPageRemoved = true;
              }
              router.removePage($pageToRemove);
              if (dynamicNavbar && $navbarToRemove.length > 0) {
                router.removeNavbar($navbarToRemove);
              }
            }
          }
        });
      } else {
        const $pageToRemove = $oldPage.prev('.page-previous:not(.stacked)');
        let $navbarToRemove;
        if (dynamicNavbar) {
          // $navbarToRemove = $oldNavbarEl.prev('.navbar-inner:not(.stacked)');
          $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
        }
        if (router.params.stackPages && router.initialPages.indexOf($pageToRemove[0]) >= 0) {
          $pageToRemove.addClass('stacked');
          $pageToRemove.trigger('page:stack');
          router.emit('pageStack', $pageToRemove[0]);
          $navbarToRemove.addClass('stacked');
        } else if ($pageToRemove.length > 0) {
          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
          if ($pageToRemove[0] === masterPageEl) {
            masterPageRemoved = true;
          }
          router.removePage($pageToRemove);
          if (dynamicNavbar && $navbarToRemove.length) {
            router.removeNavbar($navbarToRemove);
          }
        }
      }
    }
  }

  // Insert new page
  const newPageInDom = $newPage.parents(doc).length > 0;
  const f7Component = $newPage[0].f7Component;

  function insertPage() {
    if ($newPage.next($oldPage).length === 0) {
      if (!newPageInDom && f7Component) {
        f7Component.$mount((componentEl) => {
          $(componentEl).insertBefore($oldPage);
        });
      } else {
        $newPage.insertBefore($oldPage);
      }
    }
    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find('.title-large').length) {
        $newNavbarEl.addClass('navbar-large');
      }
      $newNavbarEl.insertBefore($oldNavbarEl);
      if ($oldNavbarEl.length > 0) {
        $newNavbarEl.insertBefore($oldNavbarEl);
      } else {
        if (!router.$navbarsEl.parents(doc).length) {
          router.$el.prepend(router.$navbarsEl);
        }
        $navbarsEl.append($newNavbarEl);
      }
    }
    if (!newPageInDom) {
      router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
    } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
      $newPage[0].f7PageMounted = true;
      router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
    }
  }

  if (options.preload) {
    // Insert Page
    insertPage();
    // Tab route
    if (options.route.route.tab) {
      router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
        history: false,
        pushState: false,
        preload: true,
      }));
    }
    if (isMaster) {
      $newPage
        .removeClass('page-master-stacked')
        .trigger('page:masterunstack');
      router.emit('pageMasterUnstack', $newPage[0]);
      if (dynamicNavbar) {
        $(app.navbar.getElByPage($newPage)).removeClass('navbar-master-stacked');
        router.emit('navbarMasterUnstack', app.navbar.getElByPage($newPage));
      }
    }
    // Page init and before init events
    router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
    const $previousPages = $newPage.prevAll('.page-previous:not(.stacked):not(.page-master)');
    if ($previousPages.length > 0) {
      $previousPages.each((index, pageToRemove) => {
        const $pageToRemove = $(pageToRemove);
        let $navbarToRemove;
        if (dynamicNavbar) {
          // $navbarToRemove = $newNavbarEl.prevAll('.navbar-previous:not(.stacked)').eq(index);
          $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
        }
        if (router.params.stackPages && router.initialPages.indexOf(pageToRemove) >= 0) {
          $pageToRemove.addClass('stacked');
          $pageToRemove.trigger('page:stack');
          router.emit('pageStack', $pageToRemove[0]);
          if (dynamicNavbar) {
            $navbarToRemove.addClass('stacked');
          }
        } else {
          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined);
          router.removePage($pageToRemove);
          if (dynamicNavbar && $navbarToRemove.length) {
            router.removeNavbar($navbarToRemove);
          }
        }
      });
    }
    router.allowPageChange = true;
    return router;
  }

  // History State
  if (!(Device.ie || Device.edge || (Device.firefox && !Device.ios))) {
    if (router.params.pushState && options.pushState) {
      if (options.replaceState) {
        const pushStateRoot = router.params.pushStateRoot || '';
        History.replace(
          view.id,
          {
            url: options.route.url,
          },
          pushStateRoot + router.params.pushStateSeparator + options.route.url
        );
      } else if (backIndex) {
        History.go(-backIndex);
      } else {
        History.back();
      }
    }
  }

  // Update History
  if (options.replaceState) {
    router.history[router.history.length - 1] = options.route.url;
  } else {
    if (router.history.length === 1) {
      router.history.unshift(router.url);
    }
    router.history.pop();
  }
  router.saveHistory();

  // Current Page & Navbar
  router.currentPageEl = $newPage[0];
  if (dynamicNavbar && $newNavbarEl.length) {
    router.currentNavbarEl = $newNavbarEl[0];
  } else {
    delete router.currentNavbarEl;
  }

  // Current Route
  router.currentRoute = options.route;

  // History State
  if (Device.ie || Device.edge || (Device.firefox && !Device.ios)) {
    if (router.params.pushState && options.pushState) {
      if (options.replaceState) {
        const pushStateRoot = router.params.pushStateRoot || '';
        History.replace(
          view.id,
          {
            url: options.route.url,
          },
          pushStateRoot + router.params.pushStateSeparator + options.route.url
        );
      } else if (backIndex) {
        History.go(-backIndex);
      } else {
        History.back();
      }
    }
  }

  // Insert Page
  insertPage();

  // Load Tab
  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
      history: false,
      pushState: false,
    }));
  }

  // Check master detail

  if (masterDetailEnabled && (currentIsMaster || masterPageRemoved)) {
    view.checkMasterDetailBreakpoint(false);
  }

  // Page init and before init events
  router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);

  // Before animation callback
  router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
  router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'previous', 'current', options);

  // Animation
  function afterAnimation() {
    // Set classes
    router.setPagePosition($newPage, 'current', false);
    router.setPagePosition($oldPage, 'next', true);
    if (dynamicNavbar) {
      router.setNavbarPosition($newNavbarEl, 'current', false);
      router.setNavbarPosition($oldNavbarEl, 'next', true);
    }

    // After animation event
    router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
    router.pageCallback('afterIn', $newPage, $newNavbarEl, 'previous', 'current', options);

    // Remove Old Page
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass('stacked');
      $oldPage.trigger('page:stack');
      router.emit('pageStack', $oldPage[0]);
      if (dynamicNavbar) {
        $oldNavbarEl.addClass('stacked');
      }
    } else {
      router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'next', undefined, options);
      router.removePage($oldPage);
      if (dynamicNavbar && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }

    router.allowPageChange = true;
    router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

    // Preload previous page
    const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`];
    if (preloadPreviousPage && router.history[router.history.length - 2] && !isMaster) {
      router.back(router.history[router.history.length - 2], { preload: true });
    }
    if (router.params.pushState) {
      History.clearRouterQueue();
    }
  }

  function setPositionClasses() {
    router.setPagePosition($oldPage, 'current');
    router.setPagePosition($newPage, 'previous', false);
    if (dynamicNavbar) {
      router.setNavbarPosition($oldNavbarEl, 'current');
      router.setNavbarPosition($newNavbarEl, 'previous', false);
    }
  }

  if (options.animate && !(currentIsMaster && app.width >= router.params.masterDetailBreakpoint)) {
    let transition = router.params.transition;
    if ($oldPage[0] && $oldPage[0].f7PageTransition) {
      transition = $oldPage[0].f7PageTransition;
      delete $oldPage[0].f7PageTransition;
    }
    if (options.transition) transition = options.transition;
    if (!transition && router.previousRoute && router.previousRoute.route) {
      transition = router.previousRoute.route.transition;
    }
    if (!transition && router.previousRoute && router.previousRoute.route && router.previousRoute.route.options) {
      transition = router.previousRoute.route.options.transition;
    }
    setPositionClasses();
    router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'backward', transition, () => {
      afterAnimation();
    });
  } else {
    afterAnimation();
  }

  return router;
}
function loadBack(backParams, backOptions, ignorePageChange) {
  const router = this;

  if (!router.allowPageChange && !ignorePageChange) return router;
  const params = backParams;
  const options = backOptions;
  const { url, content, el, pageName, template, templateUrl, component, componentUrl } = params;

  if (
    options.route.url
    && router.url === options.route.url
    && !(options.reloadCurrent || options.reloadPrevious)
    && !router.params.allowDuplicateUrls
  ) {
    return false;
  }

  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
  }

  // Component Callbacks
  function resolve(pageEl, newOptions) {
    return router.backward(pageEl, Utils.extend(options, newOptions));
  }
  function reject() {
    router.allowPageChange = true;
    return router;
  }

  if (url || templateUrl || componentUrl || component) {
    router.allowPageChange = false;
  }

  // Proceed
  if (content) {
    router.backward(router.getPageEl(content), options);
  } else if (template || templateUrl) {
    // Parse template and send page element
    try {
      router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (el) {
    // Load page from specified HTMLElement or by page name in pages container
    router.backward(router.getPageEl(el), options);
  } else if (pageName) {
    // Load page by page name in pages container
    router.backward(router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
  } else if (component || componentUrl) {
    // Load from component (F7/Vue/React/...)
    try {
      router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    // Load using XHR
    if (router.xhr) {
      router.xhr.abort();
      router.xhr = false;
    }
    router.xhrRequest(url, options)
      .then((pageContent) => {
        router.backward(router.getPageEl(pageContent), options);
      })
      .catch(() => {
        router.allowPageChange = true;
      });
  }
  return router;
}
function back(...args) {
  const router = this;
  if (router.swipeBackActive) return router;
  let navigateUrl;
  let navigateOptions;
  let route;
  if (typeof args[0] === 'object') {
    navigateOptions = args[0] || {};
  } else {
    navigateUrl = args[0];
    navigateOptions = args[1] || {};
  }

  const { name, params, query } = navigateOptions;
  if (name) {
    navigateUrl = router.generateUrl({ name, params, query });
    if (navigateUrl) {
      return router.back(navigateUrl, Utils.extend({}, navigateOptions, {
        name: null,
        params: null,
        query: null,
      }));
    }
    return router;
  }

  const app = router.app;
  appRouterCheck(router, 'back');

  let currentRouteIsModal = router.currentRoute.modal;
  let modalType;
  if (!currentRouteIsModal) {
    ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach((modalLoadProp) => {
      if (router.currentRoute.route[modalLoadProp]) {
        currentRouteIsModal = true;
        modalType = modalLoadProp;
      }
    });
  }
  if (currentRouteIsModal) {
    const modalToClose = router.currentRoute.modal
                         || router.currentRoute.route.modalInstance
                         || app[modalType].get();
    const previousUrl = router.history[router.history.length - 2];
    let previousRoute;
    // check if previous route is modal too
    if (modalToClose && modalToClose.$el) {
      const prevOpenedModals = modalToClose.$el.prevAll('.modal-in');
      if (prevOpenedModals.length && prevOpenedModals[0].f7Modal) {
        const modalEl = prevOpenedModals[0];
        // check if current router not inside of the modalEl
        if (!router.$el.parents(modalEl).length) {
          previousRoute = modalEl.f7Modal.route;
        }
      }
    }
    if (!previousRoute) {
      previousRoute = router.findMatchingRoute(previousUrl);
    }

    if (!previousRoute && previousUrl) {
      previousRoute = {
        url: previousUrl,
        path: previousUrl.split('?')[0],
        query: Utils.parseUrlQuery(previousUrl),
        route: {
          path: previousUrl.split('?')[0],
          url: previousUrl,
        },
      };
    }
    if (!navigateUrl || navigateUrl.replace(/[# ]/g, '').trim().length === 0) {
      if (!previousRoute || !modalToClose) {
        return router;
      }
    }
    const forceOtherUrl = navigateOptions.force && previousRoute && navigateUrl;
    if (previousRoute && modalToClose) {
      const isBrokenPushState = Device.ie || Device.edge || (Device.firefox && !Device.ios);
      const needHistoryBack = router.params.pushState && navigateOptions.pushState !== false;
      if (needHistoryBack && !isBrokenPushState) {
        History.back();
      }
      router.currentRoute = previousRoute;
      router.history.pop();
      router.saveHistory();

      if (needHistoryBack && isBrokenPushState) {
        History.back();
      }

      router.modalRemove(modalToClose);
      if (forceOtherUrl) {
        router.navigate(navigateUrl, { reloadCurrent: true });
      }
    } else if (modalToClose) {
      router.modalRemove(modalToClose);
      if (navigateUrl) {
        router.navigate(navigateUrl, { reloadCurrent: true });
      }
    }
    return router;
  }
  let $previousPage = router.$el.children('.page-current').prevAll('.page-previous:not(.page-master)').eq(0);

  let skipMaster;
  if (router.params.masterDetailBreakpoint > 0) {
    const classes = [];
    router.$el.children('.page').each((index, pageEl) => {
      classes.push(pageEl.className);
    });

    const $previousMaster = router.$el.children('.page-current').prevAll('.page-master').eq(0);
    if ($previousMaster.length) {
      const expectedPreviousPageUrl = router.history[router.history.length - 2];
      const expectedPreviousPageRoute = router.findMatchingRoute(expectedPreviousPageUrl);
      if (expectedPreviousPageRoute && $previousMaster[0].f7Page && expectedPreviousPageRoute.route === $previousMaster[0].f7Page.route.route) {
        $previousPage = $previousMaster;
        if (!navigateOptions.preload) {
          skipMaster = app.width >= router.params.masterDetailBreakpoint;
        }
      }
    }
  }

  if (!navigateOptions.force && $previousPage.length && !skipMaster) {
    if (router.params.pushState
      && $previousPage[0].f7Page
      && router.history[router.history.length - 2] !== $previousPage[0].f7Page.route.url
    ) {
      router.back(
        router.history[router.history.length - 2],
        Utils.extend(navigateOptions, { force: true })
      );
      return router;
    }
    const previousPageRoute = $previousPage[0].f7Page.route;

    processRouteQueue.call(
      router,
      previousPageRoute,
      router.currentRoute,
      () => {
        router.loadBack({ el: $previousPage }, Utils.extend(navigateOptions, {
          route: previousPageRoute,
        }));
      },
      () => {}
    );

    return router;
  }

  // Navigate URL
  if (navigateUrl === '#') {
    navigateUrl = undefined;
  }
  if (navigateUrl && navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
    navigateUrl = ((router.path || '/') + navigateUrl).replace('//', '/');
  }
  if (!navigateUrl && router.history.length > 1) {
    navigateUrl = router.history[router.history.length - 2];
  }
  if (skipMaster && !navigateOptions.force && router.history[router.history.length - 3]) {
    return router.back(router.history[router.history.length - 3], Utils.extend({}, navigateOptions || {}, {
      force: true,
      animate: false,
    }));
  }
  if (skipMaster && !navigateOptions.force) {
    return router;
  }

  // Find route to load
  route = router.findMatchingRoute(navigateUrl);
  if (!route) {
    if (navigateUrl) {
      route = {
        url: navigateUrl,
        path: navigateUrl.split('?')[0],
        query: Utils.parseUrlQuery(navigateUrl),
        route: {
          path: navigateUrl.split('?')[0],
          url: navigateUrl,
        },
      };
    }
  }
  if (!route) {
    return router;
  }

  if (route.route.redirect) {
    return redirect.call(router, 'back', route, navigateOptions);
  }

  const options = {};
  if (route.route.options) {
    Utils.extend(options, route.route.options, navigateOptions);
  } else {
    Utils.extend(options, navigateOptions);
  }
  options.route = route;

  if (options && options.context) {
    route.context = options.context;
    options.route.context = options.context;
  }

  let backForceLoaded;
  if (options.force && router.params.stackPages) {
    router.$el.children('.page-previous.stacked').each((index, pageEl) => {
      if (pageEl.f7Page && pageEl.f7Page.route && pageEl.f7Page.route.url === route.url) {
        backForceLoaded = true;
        router.loadBack({ el: pageEl }, options);
      }
    });
    if (backForceLoaded) {
      return router;
    }
  }
  function resolve() {
    let routerLoaded = false;
    if (route.route.keepAlive && route.route.keepAliveData) {
      router.loadBack({ el: route.route.keepAliveData.pageEl }, options);
      routerLoaded = true;
    }
    ('url content component pageName el componentUrl template templateUrl').split(' ').forEach((pageLoadProp) => {
      if (route.route[pageLoadProp] && !routerLoaded) {
        routerLoaded = true;
        router.loadBack({ [pageLoadProp]: route.route[pageLoadProp] }, options);
      }
    });
    if (routerLoaded) return;
    // Async
    function asyncResolve(resolveParams, resolveOptions) {
      router.allowPageChange = false;
      if (resolveOptions && resolveOptions.context) {
        if (!route.context) route.context = resolveOptions.context;
        else route.context = Utils.extend({}, route.context, resolveOptions.context);
        options.route.context = route.context;
      }
      router.loadBack(resolveParams, Utils.extend(options, resolveOptions), true);
    }
    function asyncReject() {
      router.allowPageChange = true;
    }
    if (route.route.async) {
      router.allowPageChange = false;
      route.route.async.call(router, route, router.currentRoute, asyncResolve, asyncReject);
    }
    if (route.route.asyncComponent) {
      asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
    }
  }
  function reject() {
    router.allowPageChange = true;
  }

  if (options.preload) {
    resolve();
  } else {
    processRouteQueue.call(
      router,
      route,
      router.currentRoute,
      () => {
        if (route.route.modules) {
          app
            .loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules])
            .then(() => {
              resolve();
            })
            .catch(() => {
              reject();
            });
        } else {
          resolve();
        }
      },
      () => {
        reject();
      },
    );
  }

  // Return Router
  return router;
}

function clearPreviousPages(router) {
  appRouterCheck(router, 'clearPreviousPages');
  const app = router.app;
  const dynamicNavbar = router.dynamicNavbar;

  const $pagesToRemove = router.$el
    .children('.page')
    .filter((index, pageInView) => {
      if (router.currentRoute && (router.currentRoute.modal || router.currentRoute.panel)) return true;
      return pageInView !== router.currentPageEl;
    });

  $pagesToRemove.each((index, pageEl) => {
    const $oldPageEl = $(pageEl);
    const $oldNavbarEl = $(app.navbar.getElByPage($oldPageEl));
    if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
      $oldPageEl.addClass('stacked');
      if (dynamicNavbar) {
        $oldNavbarEl.addClass('stacked');
      }
    } else {
      // Page remove event
      router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl, 'previous', undefined, {});
      router.removePage($oldPageEl);
      if (dynamicNavbar && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
  });
}

function clearPreviousHistory() {
  const router = this;
  appRouterCheck(router, 'clearPreviousHistory');
  const url = router.history[router.history.length - 1];

  clearPreviousPages(router);

  router.history = [url];
  router.view.history = [url];
  router.saveHistory();
}

class Router extends Framework7Class {
  constructor(app, view) {
    super({}, [typeof view === 'undefined' ? app : view]);
    const router = this;

    // Is App Router
    router.isAppRouter = typeof view === 'undefined';

    if (router.isAppRouter) {
      // App Router
      Utils.extend(false, router, {
        app,
        params: app.params.view,
        routes: app.routes || [],
        cache: app.cache,
      });
    } else {
      // View Router
      Utils.extend(false, router, {
        app,
        view,
        viewId: view.id,
        params: view.params,
        routes: view.routes,
        $el: view.$el,
        el: view.el,
        $navbarsEl: view.$navbarsEl,
        navbarsEl: view.navbarsEl,
        history: view.history,
        scrollHistory: view.scrollHistory,
        cache: app.cache,
        dynamicNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar,
        initialPages: [],
        initialNavbars: [],
      });
    }

    // Install Modules
    router.useModules();

    // Temporary Dom
    router.tempDom = doc.createElement('div');

    // AllowPageChage
    router.allowPageChange = true;

    // Current Route
    let currentRoute = {};
    let previousRoute = {};
    Object.defineProperty(router, 'currentRoute', {
      enumerable: true,
      configurable: true,
      set(newRoute = {}) {
        previousRoute = Utils.extend({}, currentRoute);
        currentRoute = newRoute;
        if (!currentRoute) return;
        router.url = currentRoute.url;
        router.emit('routeChange', newRoute, previousRoute, router);
      },
      get() {
        return currentRoute;
      },
    });
    Object.defineProperty(router, 'previousRoute', {
      enumerable: true,
      configurable: true,
      get() {
        return previousRoute;
      },
      set(newRoute) {
        previousRoute = newRoute;
      },
    });

    return router;
  }

  animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction) {
    const router = this;
    const dynamicNavbar = router.dynamicNavbar;
    const animateIcon = router.params.iosAnimateNavbarBackIcon;

    let newNavEls;
    let oldNavEls;
    function animatableNavEl($el, $navbarInner) {
      const isSliding = $el.hasClass('sliding') || $navbarInner.hasClass('sliding');
      const isSubnavbar = $el.hasClass('subnavbar');
      const needsOpacityTransition = isSliding ? !isSubnavbar : true;
      const $iconEl = $el.find('.back .icon');
      let isIconLabel;
      if (isSliding && animateIcon && $el.hasClass('left') && $iconEl.length > 0 && $iconEl.next('span').length) {
        $el = $iconEl.next('span'); // eslint-disable-line
        isIconLabel = true;
      }
      return {
        $el,
        isIconLabel,
        leftOffset: $el[0].f7NavbarLeftOffset,
        rightOffset: $el[0].f7NavbarRightOffset,
        isSliding,
        isSubnavbar,
        needsOpacityTransition,
      };
    }
    if (dynamicNavbar) {
      newNavEls = [];
      oldNavEls = [];
      $newNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each((index, navEl) => {
        const $navEl = $(navEl);
        if ($navEl.hasClass('left') && fromLarge && direction === 'forward') return;
        if ($navEl.hasClass('title') && toLarge) return;
        newNavEls.push(animatableNavEl($navEl, $newNavbarEl.children('.navbar-inner')));
      });
      if (!($oldNavbarEl.hasClass('navbar-master') && router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint)) {
        $oldNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each((index, navEl) => {
          const $navEl = $(navEl);
          if ($navEl.hasClass('left') && toLarge && !fromLarge && direction === 'forward') return;
          if ($navEl.hasClass('left') && toLarge && direction === 'backward') return;
          if ($navEl.hasClass('title') && fromLarge) {
            return;
          }
          oldNavEls.push(animatableNavEl($navEl, $oldNavbarEl.children('.navbar-inner')));
        });
      }
      [oldNavEls, newNavEls].forEach((navEls) => {
        navEls.forEach((navEl) => {
          const n = navEl;
          const { isSliding, $el } = navEl;
          const otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
          if (!(isSliding && $el.hasClass('title') && otherEls)) return;
          otherEls.forEach((otherNavEl) => {
            if (otherNavEl.isIconLabel) {
              const iconTextEl = otherNavEl.$el[0];
              n.leftOffset += iconTextEl ? (iconTextEl.offsetLeft || 0) : 0;
            }
          });
        });
      });
    }

    return { newNavEls, oldNavEls };
  }

  animate($oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, transition, callback) {
    const router = this;
    if (router.params.animateCustom) {
      router.params.animateCustom.apply(router, [$oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, callback]);
      return;
    }
    const dynamicNavbar = router.dynamicNavbar;
    const ios = router.app.theme === 'ios';
    if (transition) {
      const routerCustomTransitionClass = `router-transition-custom router-transition-${transition}-${direction}`;
      // Animate
      const onCustomTransitionDone = () => {
        router.$el.removeClass(routerCustomTransitionClass);
        if (dynamicNavbar && router.$navbarsEl.length) {
          if ($newNavbarEl) {
            router.$navbarsEl.prepend($newNavbarEl);
          }
          if ($oldNavbarEl) {
            router.$navbarsEl.prepend($oldNavbarEl);
          }
        }
        if (callback) callback();
      };

      (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(onCustomTransitionDone);
      if (dynamicNavbar) {
        if ($newNavbarEl && $newPageEl) {
          router.setNavbarPosition($newNavbarEl, '');
          $newNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
          $newPageEl.prepend($newNavbarEl);
        }
        if ($oldNavbarEl && $oldPageEl) {
          router.setNavbarPosition($oldNavbarEl, '');
          $oldNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
          $oldPageEl.prepend($oldNavbarEl);
        }
      }

      router.$el.addClass(routerCustomTransitionClass);
      return;
    }


    // Router Animation class
    const routerTransitionClass = `router-transition-${direction} router-transition`;

    let newNavEls;
    let oldNavEls;

    let fromLarge;
    let toLarge;

    let oldIsLarge;
    let newIsLarge;

    if (ios && dynamicNavbar) {
      const betweenMasterAndDetail = router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint
        && (
          ($oldNavbarEl.hasClass('navbar-master') && $newNavbarEl.hasClass('navbar-master-detail'))
          || ($oldNavbarEl.hasClass('navbar-master-detail') && $newNavbarEl.hasClass('navbar-master'))
        );
      if (!betweenMasterAndDetail) {
        oldIsLarge = $oldNavbarEl && $oldNavbarEl.hasClass('navbar-large');
        newIsLarge = $newNavbarEl && $newNavbarEl.hasClass('navbar-large');
        fromLarge = oldIsLarge && !$oldNavbarEl.hasClass('navbar-large-collapsed');
        toLarge = newIsLarge && !$newNavbarEl.hasClass('navbar-large-collapsed');
      }
      const navEls = router.animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction);
      newNavEls = navEls.newNavEls;
      oldNavEls = navEls.oldNavEls;
    }

    function animateNavbars(progress) {
      if (!(ios && dynamicNavbar)) return;
      if (progress === 1) {
        if (toLarge) {
          $newNavbarEl.addClass('router-navbar-transition-to-large');
          $oldNavbarEl.addClass('router-navbar-transition-to-large');
        }
        if (fromLarge) {
          $newNavbarEl.addClass('router-navbar-transition-from-large');
          $oldNavbarEl.addClass('router-navbar-transition-from-large');
        }
      }
      newNavEls.forEach((navEl) => {
        const $el = navEl.$el;
        const offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;
        if (navEl.isSliding) {
          if (navEl.isSubnavbar && newIsLarge) {
            $el[0].style.setProperty('transform', `translate3d(${offset * (1 - progress)}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`, 'important');
          } else {
            $el.transform(`translate3d(${offset * (1 - progress)}px,0,0)`);
          }
        }
      });
      oldNavEls.forEach((navEl) => {
        const $el = navEl.$el;
        const offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;
        if (navEl.isSliding) {
          if (navEl.isSubnavbar && oldIsLarge) {
            $el.transform(`translate3d(${offset * (progress)}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`);
          } else {
            $el.transform(`translate3d(${offset * (progress)}px,0,0)`);
          }
        }
      });
    }

    // AnimationEnd Callback
    function onDone() {
      if (router.dynamicNavbar) {
        if ($newNavbarEl) {
          $newNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
          $newNavbarEl.addClass('navbar-no-title-large-transition');
          Utils.nextFrame(() => {
            $newNavbarEl.removeClass('navbar-no-title-large-transition');
          });
        }
        if ($oldNavbarEl) {
          $oldNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
        }
        if ($newNavbarEl.hasClass('sliding') || $newNavbarEl.children('.navbar-inner.sliding').length) {
          $newNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
        } else {
          $newNavbarEl.find('.sliding').transform('');
        }
        if ($oldNavbarEl.hasClass('sliding') || $oldNavbarEl.children('.navbar-inner.sliding').length) {
          $oldNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
        } else {
          $oldNavbarEl.find('.sliding').transform('');
        }
      }
      router.$el.removeClass(routerTransitionClass);
      if (callback) callback();
    }

    (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(() => {
      onDone();
    });

    // Animate
    if (dynamicNavbar) {
      // Prepare Navbars
      animateNavbars(0);
      Utils.nextFrame(() => {
        // Add class, start animation
        animateNavbars(1);
        router.$el.addClass(routerTransitionClass);
      });
    } else {
      // Add class, start animation
      router.$el.addClass(routerTransitionClass);
    }
  }

  removeModal(modalEl) {
    const router = this;
    router.removeEl(modalEl);
  }
  // eslint-disable-next-line
  removeTabContent(tabEl) {
    const $tabEl = $(tabEl);
    $tabEl.html('');
  }

  removeNavbar(el) {
    const router = this;
    router.removeEl(el);
  }

  removePage(el) {
    const $el = $(el);
    const f7Page = $el && $el[0] && $el[0].f7Page;
    const router = this;
    if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
      $el.remove();
      return;
    }
    router.removeEl(el);
  }

  removeEl(el) {
    if (!el) return;
    const router = this;
    const $el = $(el);
    if ($el.length === 0) return;
    $el.find('.tab').each((tabIndex, tabEl) => {
      $(tabEl).children().each((index, tabChild) => {
        if (tabChild.f7Component) {
          $(tabChild).trigger('tab:beforeremove');
          tabChild.f7Component.$destroy();
        }
      });
    });
    if ($el[0].f7Component && $el[0].f7Component.$destroy) {
      $el[0].f7Component.$destroy();
    }
    if (!router.params.removeElements) {
      return;
    }
    if (router.params.removeElementsWithTimeout) {
      setTimeout(() => {
        $el.remove();
      }, router.params.removeElementsTimeout);
    } else {
      $el.remove();
    }
  }

  getPageEl(content) {
    const router = this;
    if (typeof content === 'string') {
      router.tempDom.innerHTML = content;
    } else {
      if ($(content).hasClass('page')) {
        return content;
      }
      router.tempDom.innerHTML = '';
      $(router.tempDom).append(content);
    }

    return router.findElement('.page', router.tempDom);
  }

  findElement(stringSelector, container, notStacked) {
    const router = this;
    const view = router.view;
    const app = router.app;

    // Modals Selector
    const modalsSelector = '.popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page';

    const $container = $(container);
    let selector = stringSelector;
    if (notStacked) selector += ':not(.stacked)';

    let found = $container
      .find(selector)
      .filter((index, el) => $(el).parents(modalsSelector).length === 0);

    if (found.length > 1) {
      if (typeof view.selector === 'string') {
        // Search in related view
        found = $container.find(`${view.selector} ${selector}`);
      }
      if (found.length > 1) {
        // Search in main view
        found = $container.find(`.${app.params.viewMainClass} ${selector}`);
      }
    }
    if (found.length === 1) return found;

    // Try to find not stacked
    if (!notStacked) found = router.findElement(selector, $container, true);
    if (found && found.length === 1) return found;
    if (found && found.length > 1) return $(found[0]);
    return undefined;
  }

  flattenRoutes(routes = this.routes) {
    const router = this;
    let flattenedRoutes = [];
    routes.forEach((route) => {
      let hasTabRoutes = false;
      if ('tabs' in route && route.tabs) {
        const mergedPathsRoutes = route.tabs.map((tabRoute) => {
          const tRoute = Utils.extend({}, route, {
            path: (`${route.path}/${tabRoute.path}`).replace('///', '/').replace('//', '/'),
            parentPath: route.path,
            tab: tabRoute,
          });
          delete tRoute.tabs;
          delete tRoute.routes;
          return tRoute;
        });
        hasTabRoutes = true;
        flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
      }
      if ('detailRoutes' in route) {
        const mergedPathsRoutes = route.detailRoutes.map((detailRoute) => {
          const dRoute = Utils.extend({}, detailRoute);
          dRoute.masterRoute = route;
          dRoute.masterRoutePath = route.path;
          return dRoute;
        });
        flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes));
      }
      if ('routes' in route) {
        const mergedPathsRoutes = route.routes.map((childRoute) => {
          const cRoute = Utils.extend({}, childRoute);
          cRoute.path = (`${route.path}/${cRoute.path}`).replace('///', '/').replace('//', '/');
          return cRoute;
        });
        if (hasTabRoutes) {
          flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
        } else {
          flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes));
        }
      }
      if (!('routes' in route) && !('tabs' in route && route.tabs) && !('detailRoutes' in route)) {
        flattenedRoutes.push(route);
      }
    });
    return flattenedRoutes;
  }

  // eslint-disable-next-line
  parseRouteUrl(url) {
    if (!url) return {};
    const query = Utils.parseUrlQuery(url);
    const hash = url.split('#')[1];
    const params = {};
    const path = url.split('#')[0].split('?')[0];
    return {
      query,
      hash,
      params,
      url,
      path,
    };
  }

  generateUrl(parameters = {}) {
    if (typeof parameters === 'string') {
      return parameters;
    }
    const { name, path, params, query } = parameters;
    if (!name && !path) {
      throw new Error('Framework7: "name" or "path" parameter is required');
    }
    const router = this;
    const route = name
      ? router.findRouteByKey('name', name)
      : router.findRouteByKey('path', path);

    if (!route) {
      if (name) {
        throw new Error(`Framework7: route with name "${name}" not found`);
      } else {
        throw new Error(`Framework7: route with path "${path}" not found`);
      }
    }
    const url = router.constructRouteUrl(route, { params, query });
    if (!url) {
      throw new Error(`Framework7: can't construct URL for route with name "${name}"`);
    }
    return url;
  }

  // eslint-disable-next-line
  constructRouteUrl(route, { params, query } = {}) {
    const { path } = route;
    const toUrl = compile(path);
    let url;
    try {
      url = toUrl(params || {});
    } catch (error) {
      throw new Error(`Framework7: error constructing route URL from passed params:\nRoute: ${path}\n${error.toString()}`);
    }

    if (query) {
      if (typeof query === 'string') url += `?${query}`;
      else url += `?${Utils.serializeObject(query)}`;
    }

    return url;
  }

  findTabRoute(tabEl) {
    const router = this;
    const $tabEl = $(tabEl);
    const parentPath = router.currentRoute.route.parentPath;
    const tabId = $tabEl.attr('id');
    const flattenedRoutes = router.flattenRoutes(router.routes);
    let foundTabRoute;
    flattenedRoutes.forEach((route) => {
      if (
        route.parentPath === parentPath
        && route.tab
        && route.tab.id === tabId
      ) {
        foundTabRoute = route;
      }
    });
    return foundTabRoute;
  }

  findRouteByKey(key, value) {
    const router = this;
    const routes = router.routes;
    const flattenedRoutes = router.flattenRoutes(routes);
    let matchingRoute;

    flattenedRoutes.forEach((route) => {
      if (matchingRoute) return;
      if (route[key] === value) {
        matchingRoute = route;
      }
    });
    return matchingRoute;
  }

  findMatchingRoute(url) {
    if (!url) return undefined;
    const router = this;
    const routes = router.routes;
    const flattenedRoutes = router.flattenRoutes(routes);
    const { path, query, hash, params } = router.parseRouteUrl(url);
    let matchingRoute;
    flattenedRoutes.forEach((route) => {
      if (matchingRoute) return;
      const keys = [];

      const pathsToMatch = [route.path];
      if (route.alias) {
        if (typeof route.alias === 'string') pathsToMatch.push(route.alias);
        else if (Array.isArray(route.alias)) {
          route.alias.forEach((aliasPath) => {
            pathsToMatch.push(aliasPath);
          });
        }
      }

      let matched;
      pathsToMatch.forEach((pathToMatch) => {
        if (matched) return;
        matched = pathToRegexp(pathToMatch, keys).exec(path);
      });

      if (matched) {
        keys.forEach((keyObj, index) => {
          if (typeof keyObj.name === 'number') return;
          const paramValue = matched[index + 1];
          if (typeof paramValue === 'undefined' || paramValue === null) {
            params[keyObj.name] = paramValue;
          } else {
            params[keyObj.name] = decodeURIComponent(paramValue);
          }
        });

        let parentPath;
        if (route.parentPath) {
          parentPath = path.split('/').slice(0, route.parentPath.split('/').length - 1).join('/');
        }

        matchingRoute = {
          query,
          hash,
          params,
          url,
          path,
          parentPath,
          route,
          name: route.name,
        };
      }
    });
    return matchingRoute;
  }

  // eslint-disable-next-line
  replaceRequestUrlParams(url = '', options = {}) {
    let compiledUrl = url;
    if (typeof compiledUrl === 'string'
      && compiledUrl.indexOf('{{') >= 0
      && options
      && options.route
      && options.route.params
      && Object.keys(options.route.params).length
    ) {
      Object.keys(options.route.params).forEach((paramName) => {
        const regExp = new RegExp(`{{${paramName}}}`, 'g');
        compiledUrl = compiledUrl.replace(regExp, options.route.params[paramName] || '');
      });
    }
    return compiledUrl;
  }

  removeFromXhrCache(url) {
    const router = this;
    const xhrCache = router.cache.xhr;
    let index = false;
    for (let i = 0; i < xhrCache.length; i += 1) {
      if (xhrCache[i].url === url) index = i;
    }
    if (index !== false) xhrCache.splice(index, 1);
  }

  xhrRequest(requestUrl, options) {
    const router = this;
    const params = router.params;
    const { ignoreCache } = options;
    let url = requestUrl;

    let hasQuery = url.indexOf('?') >= 0;
    if (params.passRouteQueryToRequest
      && options
      && options.route
      && options.route.query
      && Object.keys(options.route.query).length
    ) {
      url += `${hasQuery ? '&' : '?'}${Utils.serializeObject(options.route.query)}`;
      hasQuery = true;
    }

    if (params.passRouteParamsToRequest
      && options
      && options.route
      && options.route.params
      && Object.keys(options.route.params).length
    ) {
      url += `${hasQuery ? '&' : '?'}${Utils.serializeObject(options.route.params)}`;
      hasQuery = true;
    }

    if (url.indexOf('{{') >= 0) {
      url = router.replaceRequestUrlParams(url, options);
    }
    // should we ignore get params or not
    if (params.xhrCacheIgnoreGetParameters && url.indexOf('?') >= 0) {
      url = url.split('?')[0];
    }
    return new Promise((resolve, reject) => {
      if (params.xhrCache && !ignoreCache && url.indexOf('nocache') < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
        for (let i = 0; i < router.cache.xhr.length; i += 1) {
          const cachedUrl = router.cache.xhr[i];
          if (cachedUrl.url === url) {
            // Check expiration
            if (Utils.now() - cachedUrl.time < params.xhrCacheDuration) {
              // Load from cache
              resolve(cachedUrl.content);
              return;
            }
          }
        }
      }
      router.xhr = router.app.request({
        url,
        method: 'GET',
        beforeSend(xhr) {
          router.emit('routerAjaxStart', xhr, options);
        },
        complete(xhr, status) {
          router.emit('routerAjaxComplete', xhr);
          if ((status !== 'error' && status !== 'timeout' && (xhr.status >= 200 && xhr.status < 300)) || xhr.status === 0) {
            if (params.xhrCache && xhr.responseText !== '') {
              router.removeFromXhrCache(url);
              router.cache.xhr.push({
                url,
                time: Utils.now(),
                content: xhr.responseText,
              });
            }
            router.emit('routerAjaxSuccess', xhr, options);
            resolve(xhr.responseText);
          } else {
            router.emit('routerAjaxError', xhr, options);
            reject(xhr);
          }
        },
        error(xhr) {
          router.emit('routerAjaxError', xhr, options);
          reject(xhr);
        },
      });
    });
  }

  setNavbarPosition($el, position, ariaHidden) {
    const router = this;
    $el.removeClass('navbar-previous navbar-current navbar-next');
    if (position) {
      $el.addClass(`navbar-${position}`);
    }

    if (ariaHidden === false) {
      $el.removeAttr('aria-hidden');
    } else if (ariaHidden === true) {
      $el.attr('aria-hidden', 'true');
    }
    $el.trigger('navbar:position', { position });
    router.emit('navbarPosition', $el[0], position);
  }

  setPagePosition($el, position, ariaHidden) {
    const router = this;
    $el.removeClass('page-previous page-current page-next');
    $el.addClass(`page-${position}`);
    if (ariaHidden === false) {
      $el.removeAttr('aria-hidden');
    } else if (ariaHidden === true) {
      $el.attr('aria-hidden', 'true');
    }
    $el.trigger('page:position', { position });
    router.emit('pagePosition', $el[0], position);
  }

  // Remove theme elements
  removeThemeElements(el) {
    const router = this;
    const theme = router.app.theme;
    let toRemove;
    if (theme === 'ios') {
      toRemove = '.md-only, .aurora-only, .if-md, .if-aurora, .if-not-ios, .not-ios';
    } else if (theme === 'md') {
      toRemove = '.ios-only, .aurora-only, .if-ios, .if-aurora, .if-not-md, .not-md';
    } else if (theme === 'aurora') {
      toRemove = '.ios-only, .md-only, .if-ios, .if-md, .if-not-aurora, .not-aurora';
    }
    $(el).find(toRemove).remove();
  }

  getPageData(pageEl, navbarEl, from, to, route = {}, pageFromEl) {
    const router = this;
    const $pageEl = $(pageEl).eq(0);
    const $navbarEl = $(navbarEl).eq(0);
    const currentPage = $pageEl[0].f7Page || {};
    let direction;
    let pageFrom;
    if ((from === 'next' && to === 'current') || (from === 'current' && to === 'previous')) direction = 'forward';
    if ((from === 'current' && to === 'next') || (from === 'previous' && to === 'current')) direction = 'backward';
    if (currentPage && !currentPage.fromPage) {
      const $pageFromEl = $(pageFromEl);
      if ($pageFromEl.length) {
        pageFrom = $pageFromEl[0].f7Page;
      }
    }
    pageFrom = currentPage.pageFrom || pageFrom;
    if (pageFrom && pageFrom.pageFrom) {
      pageFrom.pageFrom = null;
    }
    const page = {
      app: router.app,
      view: router.view,
      router,
      $el: $pageEl,
      el: $pageEl[0],
      $pageEl,
      pageEl: $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl[0],
      name: $pageEl.attr('data-name'),
      position: from,
      from,
      to,
      direction,
      route: currentPage.route ? currentPage.route : route,
      pageFrom,
    };

    $pageEl[0].f7Page = page;
    return page;
  }

  // Callbacks
  pageCallback(callback, pageEl, navbarEl, from, to, options = {}, pageFromEl) {
    if (!pageEl) return;
    const router = this;
    const $pageEl = $(pageEl);
    if (!$pageEl.length) return;
    const $navbarEl = $(navbarEl);
    const { route } = options;
    const restoreScrollTopOnBack = router.params.restoreScrollTopOnBack
      && !(
        router.params.masterDetailBreakpoint > 0
        && $pageEl.hasClass('page-master')
        && router.app.width >= router.params.masterDetailBreakpoint
      );
    const keepAlive = $pageEl[0].f7Page && $pageEl[0].f7Page.route && $pageEl[0].f7Page.route.route && $pageEl[0].f7Page.route.route.keepAlive;

    if (callback === 'beforeRemove' && keepAlive) {
      callback = 'beforeUnmount'; // eslint-disable-line
    }

    const camelName = `page${callback[0].toUpperCase() + callback.slice(1, callback.length)}`;
    const colonName = `page:${callback.toLowerCase()}`;

    let page = {};
    if (callback === 'beforeRemove' && $pageEl[0].f7Page) {
      page = Utils.extend($pageEl[0].f7Page, { from, to, position: from });
    } else {
      page = router.getPageData($pageEl[0], $navbarEl[0], from, to, route, pageFromEl);
    }
    page.swipeBack = !!options.swipeBack;

    const { on = {}, once = {} } = options.route ? options.route.route : {};
    if (options.on) {
      Utils.extend(on, options.on);
    }
    if (options.once) {
      Utils.extend(once, options.once);
    }

    function attachEvents() {
      if ($pageEl[0].f7RouteEventsAttached) return;
      $pageEl[0].f7RouteEventsAttached = true;
      if (on && Object.keys(on).length > 0) {
        $pageEl[0].f7RouteEventsOn = on;
        Object.keys(on).forEach((eventName) => {
          on[eventName] = on[eventName].bind(router);
          $pageEl.on(Utils.eventNameToColonCase(eventName), on[eventName]);
        });
      }
      if (once && Object.keys(once).length > 0) {
        $pageEl[0].f7RouteEventsOnce = once;
        Object.keys(once).forEach((eventName) => {
          once[eventName] = once[eventName].bind(router);
          $pageEl.once(Utils.eventNameToColonCase(eventName), once[eventName]);
        });
      }
    }

    function detachEvents() {
      if (!$pageEl[0].f7RouteEventsAttached) return;
      if ($pageEl[0].f7RouteEventsOn) {
        Object.keys($pageEl[0].f7RouteEventsOn).forEach((eventName) => {
          $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
        });
      }
      if ($pageEl[0].f7RouteEventsOnce) {
        Object.keys($pageEl[0].f7RouteEventsOnce).forEach((eventName) => {
          $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
        });
      }
      $pageEl[0].f7RouteEventsAttached = null;
      $pageEl[0].f7RouteEventsOn = null;
      $pageEl[0].f7RouteEventsOnce = null;
      delete $pageEl[0].f7RouteEventsAttached;
      delete $pageEl[0].f7RouteEventsOn;
      delete $pageEl[0].f7RouteEventsOnce;
    }

    if (callback === 'mounted') {
      attachEvents();
    }
    if (callback === 'init') {
      if (restoreScrollTopOnBack && (from === 'previous' || !from) && to === 'current' && router.scrollHistory[page.route.url] && !$pageEl.hasClass('no-restore-scroll')) {
        let $pageContent = $pageEl.find('.page-content');
        if ($pageContent.length > 0) {
          // eslint-disable-next-line
          $pageContent = $pageContent.filter((pageContentIndex, pageContentEl) => {
            return (
              $(pageContentEl).parents('.tab:not(.tab-active)').length === 0
              && !$(pageContentEl).is('.tab:not(.tab-active)')
            );
          });
        }
        $pageContent.scrollTop(router.scrollHistory[page.route.url]);
      }
      attachEvents();
      if ($pageEl[0].f7PageInitialized) {
        $pageEl.trigger('page:reinit', page);
        router.emit('pageReinit', page);
        return;
      }
      $pageEl[0].f7PageInitialized = true;
    }
    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'previous') {
      // Save scroll position
      let $pageContent = $pageEl.find('.page-content');
      if ($pageContent.length > 0) {
        // eslint-disable-next-line
        $pageContent = $pageContent.filter((pageContentIndex, pageContentEl) => {
          return (
            $(pageContentEl).parents('.tab:not(.tab-active)').length === 0
            && !$(pageContentEl).is('.tab:not(.tab-active)')
          );
        });
      }
      router.scrollHistory[page.route.url] = $pageContent.scrollTop();
    }
    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'next') {
      // Delete scroll position
      delete router.scrollHistory[page.route.url];
    }

    $pageEl.trigger(colonName, page);
    router.emit(camelName, page);

    if (callback === 'beforeRemove' || callback === 'beforeUnmount') {
      detachEvents();
      if (!keepAlive) {
        if ($pageEl[0].f7Page && $pageEl[0].f7Page.navbarEl) {
          delete $pageEl[0].f7Page.navbarEl.f7Page;
        }
        $pageEl[0].f7Page = null;
      }
    }
  }

  saveHistory() {
    const router = this;
    router.view.history = router.history;
    if (router.params.pushState) {
      win.localStorage[`f7router-${router.view.id}-history`] = JSON.stringify(router.history);
    }
  }

  restoreHistory() {
    const router = this;
    if (router.params.pushState && win.localStorage[`f7router-${router.view.id}-history`]) {
      router.history = JSON.parse(win.localStorage[`f7router-${router.view.id}-history`]);
      router.view.history = router.history;
    }
  }

  clearHistory() {
    const router = this;
    router.history = [];
    if (router.view) router.view.history = [];
    router.saveHistory();
  }

  updateCurrentUrl(newUrl) {
    const router = this;
    appRouterCheck(router, 'updateCurrentUrl');
    // Update history
    if (router.history.length) {
      router.history[router.history.length - 1] = newUrl;
    } else {
      router.history.push(newUrl);
    }

    // Update current route params
    const { query, hash, params, url, path } = router.parseRouteUrl(newUrl);
    if (router.currentRoute) {
      Utils.extend(router.currentRoute, {
        query,
        hash,
        params,
        url,
        path,
      });
    }

    if (router.params.pushState) {
      const pushStateRoot = router.params.pushStateRoot || '';
      History.replace(
        router.view.id,
        {
          url: newUrl,
        },
        pushStateRoot + router.params.pushStateSeparator + newUrl
      );
    }

    // Save History
    router.saveHistory();

    router.emit('routeUrlUpdate', router.currentRoute, router);
  }

  init() {
    const router = this;
    const { app, view } = router;

    // Init Swipeback
    if (
      (view && router.params.iosSwipeBack && app.theme === 'ios')
      || (view && router.params.mdSwipeBack && app.theme === 'md')
      || (view && router.params.auroraSwipeBack && app.theme === 'aurora')
    ) {
      SwipeBack(router);
    }

    let initUrl = router.params.url;
    let documentUrl = doc.location.href.split(doc.location.origin)[1];
    let historyRestored;
    const { pushState, pushStateOnLoad, pushStateSeparator, pushStateAnimateOnLoad } = router.params;
    let { pushStateRoot } = router.params;
    if (win.cordova && pushState && !pushStateSeparator && !pushStateRoot && doc.location.pathname.indexOf('index.html')) {
      // eslint-disable-next-line
      console.warn('Framework7: wrong or not complete pushState configuration, trying to guess pushStateRoot');
      pushStateRoot = doc.location.pathname.split('index.html')[0];
    }
    if (!pushState || !pushStateOnLoad) {
      if (!initUrl) {
        initUrl = documentUrl;
      }
      if (doc.location.search && initUrl.indexOf('?') < 0) {
        initUrl += doc.location.search;
      }
      if (doc.location.hash && initUrl.indexOf('#') < 0) {
        initUrl += doc.location.hash;
      }
    } else {
      if (pushStateRoot && documentUrl.indexOf(pushStateRoot) >= 0) {
        documentUrl = documentUrl.split(pushStateRoot)[1];
        if (documentUrl === '') documentUrl = '/';
      }
      if (pushStateSeparator.length > 0 && documentUrl.indexOf(pushStateSeparator) >= 0) {
        initUrl = documentUrl.split(pushStateSeparator)[1];
      } else {
        initUrl = documentUrl;
      }
      router.restoreHistory();
      if (router.history.indexOf(initUrl) >= 0) {
        router.history = router.history.slice(0, router.history.indexOf(initUrl) + 1);
      } else if (router.params.url === initUrl) {
        router.history = [initUrl];
      } else if (History.state && History.state[view.id] && History.state[view.id].url === router.history[router.history.length - 1]) {
        initUrl = router.history[router.history.length - 1];
      } else {
        router.history = [documentUrl.split(pushStateSeparator)[0] || '/', initUrl];
      }
      if (router.history.length > 1) {
        historyRestored = true;
      } else {
        router.history = [];
      }
      router.saveHistory();
    }
    let currentRoute;
    if (router.history.length > 1) {
      // Will load page
      currentRoute = router.findMatchingRoute(router.history[0]);
      if (!currentRoute) {
        currentRoute = Utils.extend(router.parseRouteUrl(router.history[0]), {
          route: {
            url: router.history[0],
            path: router.history[0].split('?')[0],
          },
        });
      }
    } else {
      // Don't load page
      currentRoute = router.findMatchingRoute(initUrl);
      if (!currentRoute) {
        currentRoute = Utils.extend(router.parseRouteUrl(initUrl), {
          route: {
            url: initUrl,
            path: initUrl.split('?')[0],
          },
        });
      }
    }

    if (router.params.stackPages) {
      router.$el.children('.page').each((index, pageEl) => {
        const $pageEl = $(pageEl);
        router.initialPages.push($pageEl[0]);
        if (router.dynamicNavbar && $pageEl.children('.navbar').length > 0) {
          router.initialNavbars.push($pageEl.children('.navbar')[0]);
        }
      });
    }

    if (router.$el.children('.page:not(.stacked)').length === 0 && initUrl && router.params.loadInitialPage) {
      // No pages presented in DOM, reload new page
      router.navigate(initUrl, {
        initial: true,
        reloadCurrent: true,
        pushState: false,
      });
    } else if (router.$el.children('.page:not(.stacked)').length) {
      // Init current DOM page
      let hasTabRoute;
      router.currentRoute = currentRoute;
      router.$el.children('.page:not(.stacked)').each((index, pageEl) => {
        const $pageEl = $(pageEl);
        let $navbarEl;
        router.setPagePosition($pageEl, 'current');
        if (router.dynamicNavbar) {
          $navbarEl = $pageEl.children('.navbar');
          if ($navbarEl.length > 0) {
            if (!router.$navbarsEl.parents(doc).length) {
              router.$el.prepend(router.$navbarsEl);
            }
            router.setNavbarPosition($navbarEl, 'current');
            router.$navbarsEl.append($navbarEl);
            if ($navbarEl.children('.title-large').length) {
              $navbarEl.addClass('navbar-large');
            }
            $pageEl.children('.navbar').remove();
          } else {
            router.$navbarsEl.addClass('navbar-hidden');
            if ($navbarEl.children('.title-large').length) {
              router.$navbarsEl.addClass('navbar-hidden navbar-large-hidden');
            }
          }
        }
        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.master && router.params.masterDetailBreakpoint > 0) {
          $pageEl.addClass('page-master');
          $pageEl.trigger('page:role', { role: 'master' });
          if ($navbarEl && $navbarEl.length) {
            $navbarEl.addClass('navbar-master');
          }
          view.checkMasterDetailBreakpoint();
        }
        const initOptions = {
          route: router.currentRoute,
        };
        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
          Utils.extend(initOptions, router.currentRoute.route.options);
        }
        router.currentPageEl = $pageEl[0];
        if (router.dynamicNavbar && $navbarEl.length) {
          router.currentNavbarEl = $navbarEl[0];
        }
        router.removeThemeElements($pageEl);
        if (router.dynamicNavbar && $navbarEl.length) {
          router.removeThemeElements($navbarEl);
        }
        if (initOptions.route.route.tab) {
          hasTabRoute = true;
          router.tabLoad(initOptions.route.route.tab, Utils.extend({}, initOptions));
        }
        router.pageCallback('init', $pageEl, $navbarEl, 'current', undefined, initOptions);
      });
      if (historyRestored) {
        router.navigate(initUrl, {
          initial: true,
          pushState: false,
          history: false,
          animate: pushStateAnimateOnLoad,
          once: {
            pageAfterIn() {
              const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`];
              if (preloadPreviousPage && router.history.length > 2) {
                router.back({ preload: true });
              }
            },
          },
        });
      }
      if (!historyRestored && !hasTabRoute) {
        router.history.push(initUrl);
        router.saveHistory();
      }
    }
    if (initUrl && pushState && pushStateOnLoad && (!History.state || !History.state[view.id])) {
      History.initViewState(view.id, {
        url: initUrl,
      });
    }
    router.emit('local::init routerInit', router);
  }

  destroy() {
    let router = this;

    router.emit('local::destroy routerDestroy', router);

    // Delete props & methods
    Object.keys(router).forEach((routerProp) => {
      router[routerProp] = null;
      delete router[routerProp];
    });

    router = null;
  }
}

// Load
Router.prototype.forward = forward;
Router.prototype.load = load;
Router.prototype.navigate = navigate;
Router.prototype.refreshPage = refreshPage;
// Tab
Router.prototype.tabLoad = tabLoad;
Router.prototype.tabRemove = tabRemove;
// Modal
Router.prototype.modalLoad = modalLoad;
Router.prototype.modalRemove = modalRemove;
// Back
Router.prototype.backward = backward;
Router.prototype.loadBack = loadBack;
Router.prototype.back = back;
// Clear history
Router.prototype.clearPreviousHistory = clearPreviousHistory;

var RouterModule = {
  name: 'router',
  static: {
    Router,
  },
  instance: {
    cache: {
      xhr: [],
      templates: [],
      components: [],
    },
  },
  create() {
    const instance = this;
    if (instance.app) {
      // View Router
      if (instance.params.router) {
        instance.router = new Router(instance.app, instance);
      }
    } else {
      // App Router
      instance.router = new Router(instance);
    }
  },
};

function resizableView(view) {
  const app = view.app;
  if (view.resizableInitialized) return;
  Utils.extend(view, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true,
  });
  const $htmlEl = $('html');
  const { $el } = view;
  if (!$el) return;

  let $resizeHandlerEl;

  let isTouched;
  let isMoved;
  const touchesStart = {};
  let touchesDiff;
  let width;

  let minWidth;
  let maxWidth;

  function transformCSSWidth(v) {
    if (!v) return null;
    if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
      return parseInt(v, 10) / 100 * app.width;
    }
    const newV = parseInt(v, 10);
    if (Number.isNaN(newV)) return null;
    return newV;
  }

  function isResizable() {
    return view.resizable && $el.hasClass('view-resizable') && $el.hasClass('view-master-detail');
  }

  function handleTouchStart(e) {
    if (!isResizable()) return;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    const $pageMasterEl = $el.children('.page-master');
    minWidth = transformCSSWidth($pageMasterEl.css('min-width'));
    maxWidth = transformCSSWidth($pageMasterEl.css('max-width'));
  }
  function handleTouchMove(e) {
    if (!isTouched) return;
    e.f7PreventSwipePanel = true;
    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

    if (!isMoved) {
      width = $resizeHandlerEl[0].offsetLeft + $resizeHandlerEl[0].offsetWidth;
      $el.addClass('view-resizing');
      $htmlEl.css('cursor', 'col-resize');
    }

    isMoved = true;

    e.preventDefault();

    touchesDiff = (pageX - touchesStart.x);

    let newWidth = width + touchesDiff;
    if (minWidth && !Number.isNaN(minWidth)) {
      newWidth = Math.max(newWidth, minWidth);
    }
    if (maxWidth && !Number.isNaN(maxWidth)) {
      newWidth = Math.min(newWidth, maxWidth);
    }
    newWidth = Math.min(Math.max(newWidth, 0), app.width);

    view.resizableWidth = newWidth;
    $htmlEl[0].style.setProperty('--f7-page-master-width', `${newWidth}px`);

    $el.trigger('view:resize', newWidth);
    view.emit('local::resize viewResize', view, newWidth);
  }
  function handleTouchEnd() {
    $('html').css('cursor', '');
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;

    $htmlEl[0].style.setProperty('--f7-page-master-width', `${view.resizableWidth}px`);
    $el.removeClass('view-resizing');
  }

  function handleResize() {
    if (!view.resizableWidth) return;
    minWidth = transformCSSWidth($resizeHandlerEl.css('min-width'));
    maxWidth = transformCSSWidth($resizeHandlerEl.css('max-width'));

    if (minWidth && !Number.isNaN(minWidth) && view.resizableWidth < minWidth) {
      view.resizableWidth = Math.max(view.resizableWidth, minWidth);
    }
    if (maxWidth && !Number.isNaN(maxWidth) && view.resizableWidth > maxWidth) {
      view.resizableWidth = Math.min(view.resizableWidth, maxWidth);
    }
    view.resizableWidth = Math.min(Math.max(view.resizableWidth, 0), app.width);

    $htmlEl[0].style.setProperty('--f7-page-master-width', `${view.resizableWidth}px`);
  }

  $resizeHandlerEl = view.$el.children('.view-resize-handler');
  if (!$resizeHandlerEl.length) {
    view.$el.append('<div class="view-resize-handler"></div>');
    $resizeHandlerEl = view.$el.children('.view-resize-handler');
  }
  view.$resizeHandlerEl = $resizeHandlerEl;

  $el.addClass('view-resizable');

  // Add Events
  const passive = Support.passiveListener ? { passive: true } : false;

  view.$el.on(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
  app.on('touchmove:active', handleTouchMove);
  app.on('touchend:passive', handleTouchEnd);
  app.on('resize', handleResize);
  view.on('beforeOpen', handleResize);

  view.once('viewDestroy', () => {
    $el.removeClass('view-resizable');
    view.$resizeHandlerEl.remove();
    view.$el.off(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
    app.off('resize', handleResize);
    view.off('beforeOpen', handleResize);
  });
}

class View extends Framework7Class {
  constructor(appInstance, el, viewParams = {}) {
    super(viewParams, [appInstance]);

    const app = appInstance;
    const $el = $(el);
    const view = this;

    const defaults = {
      routes: [],
      routesAdd: [],
    };

    if ($el.length === 0) {
      let message = 'Framework7: can\'t create a View instance because ';
      message += (typeof el === 'string')
        ? `the selector "${el}" didn't match any element`
        : 'el must be an HTMLElement or Dom7 object';

      throw new Error(message);
    }

    // Default View params
    view.params = Utils.extend(defaults, app.params.view, viewParams);

    // Routes
    if (view.params.routes.length > 0) {
      view.routes = view.params.routes;
    } else {
      view.routes = [].concat(app.routes, view.params.routesAdd);
    }

    // Selector
    let selector;
    if (typeof el === 'string') selector = el;
    else {
      // Supposed to be HTMLElement or Dom7
      selector = ($el.attr('id') ? `#${$el.attr('id')}` : '') + ($el.attr('class') ? `.${$el.attr('class').replace(/ /g, '.').replace('.active', '')}` : '');
    }

    // DynamicNavbar
    let $navbarsEl;
    if (app.theme === 'ios' && view.params.iosDynamicNavbar) {
      $navbarsEl = $el.children('.navbars').eq(0);
      if ($navbarsEl.length === 0) {
        $navbarsEl = $('<div class="navbars"></div>');
      }
    }

    // View Props
    Utils.extend(false, view, {
      app,
      $el,
      el: $el[0],
      name: view.params.name,
      main: view.params.main || $el.hasClass('view-main'),
      $navbarsEl,
      navbarsEl: $navbarsEl ? $navbarsEl[0] : undefined,
      selector,
      history: [],
      scrollHistory: {},
    });

    // Save in DOM
    $el[0].f7View = view;

    // Install Modules
    view.useModules();

    // Add to app
    app.views.push(view);
    if (view.main) {
      app.views.main = view;
    }
    if (view.name) {
      app.views[view.name] = view;
    }

    // Index
    view.index = app.views.indexOf(view);

    // View ID
    let viewId;
    if (view.name) {
      viewId = `view_${view.name}`;
    } else if (view.main) {
      viewId = 'view_main';
    } else {
      viewId = `view_${view.index}`;
    }
    view.id = viewId;

    // Init View
    if (app.initialized) {
      view.init();
    } else {
      app.on('init', () => {
        view.init();
      });
    }

    return view;
  }

  destroy() {
    let view = this;
    const app = view.app;

    view.$el.trigger('view:beforedestroy');
    view.emit('local::beforeDestroy viewBeforeDestroy', view);

    app.off('resize', view.checkMasterDetailBreakpoint);

    if (view.main) {
      app.views.main = null;
      delete app.views.main;
    } else if (view.name) {
      app.views[view.name] = null;
      delete app.views[view.name];
    }
    view.$el[0].f7View = null;
    delete view.$el[0].f7View;

    app.views.splice(app.views.indexOf(view), 1);

    // Destroy Router
    if (view.params.router && view.router) {
      view.router.destroy();
    }

    view.emit('local::destroy viewDestroy', view);

    // Delete props & methods
    Object.keys(view).forEach((viewProp) => {
      view[viewProp] = null;
      delete view[viewProp];
    });

    view = null;
  }

  checkMasterDetailBreakpoint(force) {
    const view = this;
    const app = view.app;
    const wasMasterDetail = view.$el.hasClass('view-master-detail');
    const isMasterDetail = app.width >= view.params.masterDetailBreakpoint && view.$el.children('.page-master').length;
    if ((typeof force === 'undefined' && isMasterDetail) || force === true) {
      view.$el.addClass('view-master-detail');
      if (!wasMasterDetail) {
        view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
        view.$el.trigger('view:masterDetailBreakpoint');
      }
    } else {
      view.$el.removeClass('view-master-detail');
      if (wasMasterDetail) {
        view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
        view.$el.trigger('view:masterDetailBreakpoint');
      }
    }
  }

  initMasterDetail() {
    const view = this;
    const app = view.app;
    view.checkMasterDetailBreakpoint = view.checkMasterDetailBreakpoint.bind(view);
    view.checkMasterDetailBreakpoint();
    if (view.params.masterDetailResizable) {
      resizableView(view);
    }
    app.on('resize', view.checkMasterDetailBreakpoint);
  }

  init() {
    const view = this;
    if (view.params.router) {
      if (view.params.masterDetailBreakpoint > 0) {
        view.initMasterDetail();
      }
      view.router.init();
      view.$el.trigger('view:init');
      view.emit('local::init viewInit', view);
    }
  }
}

// Use Router
View.use(RouterModule);

function initClicks(app) {
  function handleClicks(e) {
    const $clickedEl = $(e.target);
    const $clickedLinkEl = $clickedEl.closest('a');
    const isLink = $clickedLinkEl.length > 0;
    const url = isLink && $clickedLinkEl.attr('href');
    // const isTabLink = isLink && $clickedLinkEl.hasClass('tab-link') && ($clickedLinkEl.attr('data-tab') || (url && url.indexOf('#') === 0));

    // Check if link is external
    if (isLink) {
      // eslint-disable-next-line
      if ($clickedLinkEl.is(app.params.clicks.externalLinks) || (url && url.indexOf('javascript:') >= 0)) {
        const target = $clickedLinkEl.attr('target');
        if (
          url
          && win.cordova
          && win.cordova.InAppBrowser
          && (target === '_system' || target === '_blank')
        ) {
          e.preventDefault();
          win.cordova.InAppBrowser.open(url, target);
        }
        return;
      }
    }

    // Modules Clicks
    Object.keys(app.modules).forEach((moduleName) => {
      const moduleClicks = app.modules[moduleName].clicks;
      if (!moduleClicks) return;
      if (e.preventF7Router) return;
      Object.keys(moduleClicks).forEach((clickSelector) => {
        const matchingClickedElement = $clickedEl.closest(clickSelector).eq(0);
        if (matchingClickedElement.length > 0) {
          moduleClicks[clickSelector].call(app, matchingClickedElement, matchingClickedElement.dataset(), e);
        }
      });
    });

    // Load Page
    let clickedLinkData = {};
    if (isLink) {
      e.preventDefault();
      clickedLinkData = $clickedLinkEl.dataset();
    }

    // Prevent Router
    if (e.preventF7Router) return;
    if ($clickedLinkEl.hasClass('prevent-router') || $clickedLinkEl.hasClass('router-prevent')) return;

    const validUrl = url && url.length > 0 && url[0] !== '#';
    if (validUrl || $clickedLinkEl.hasClass('back')) {
      let view;
      if (clickedLinkData.view && clickedLinkData.view === 'current') {
        view = app.views.current;
      } else if (clickedLinkData.view) {
        view = $(clickedLinkData.view)[0].f7View;
      } else {
        view = $clickedEl.parents('.view')[0] && $clickedEl.parents('.view')[0].f7View;
        if (!$clickedLinkEl.hasClass('back') && view && view.params.linksView) {
          if (typeof view.params.linksView === 'string') view = $(view.params.linksView)[0].f7View;
          else if (view.params.linksView instanceof View) view = view.params.linksView;
        }
      }
      if (!view) {
        if (app.views.main) view = app.views.main;
      }
      if (!view || !view.router) return;
      if (clickedLinkData.context && typeof clickedLinkData.context === 'string') {
        try {
          clickedLinkData.context = JSON.parse(clickedLinkData.context);
        } catch (err) {
          // something wrong there
        }
      }
      if ($clickedLinkEl[0].f7RouteProps) {
        clickedLinkData.props = $clickedLinkEl[0].f7RouteProps;
      }
      if ($clickedLinkEl.hasClass('back')) view.router.back(url, clickedLinkData);
      else view.router.navigate(url, clickedLinkData);
    }
  }

  app.on('click', handleClicks);
}
var ClicksModule = {
  name: 'clicks',
  params: {
    clicks: {
      // External Links
      externalLinks: '.external',
    },
  },
  on: {
    init() {
      const app = this;
      initClicks(app);
    },
  },
};

var HistoryModule = {
  name: 'history',
  static: {
    history: History,
  },
  on: {
    init() {
      History.init(this);
    },
  },
};

const SW = {
  registrations: [],
  register(path, scope) {
    const app = this;
    if (!('serviceWorker' in win.navigator) || !app.serviceWorker.container) {
      return new Promise((resolve, reject) => {
        reject(new Error('Service worker is not supported'));
      });
    }
    return new Promise((resolve, reject) => {
      app.serviceWorker.container.register(path, (scope ? { scope } : {}))
        .then((reg) => {
          SW.registrations.push(reg);
          app.emit('serviceWorkerRegisterSuccess', reg);
          resolve(reg);
        }).catch((error) => {
          app.emit('serviceWorkerRegisterError', error);
          reject(error);
        });
    });
  },
  unregister(registration) {
    const app = this;
    if (!('serviceWorker' in win.navigator) || !app.serviceWorker.container) {
      return new Promise((resolve, reject) => {
        reject(new Error('Service worker is not supported'));
      });
    }
    let registrations;
    if (!registration) registrations = SW.registrations;
    else if (Array.isArray(registration)) registrations = registration;
    else registrations = [registration];
    return Promise.all(registrations.map(reg => new Promise((resolve, reject) => {
      reg.unregister()
        .then(() => {
          if (SW.registrations.indexOf(reg) >= 0) {
            SW.registrations.splice(SW.registrations.indexOf(reg), 1);
          }
          app.emit('serviceWorkerUnregisterSuccess', reg);
          resolve();
        })
        .catch((error) => {
          app.emit('serviceWorkerUnregisterError', reg, error);
          reject(error);
        });
    })));
  },
};

var ServiceWorkerModule = {
  name: 'sw',
  params: {
    serviceWorker: {
      path: undefined,
      scope: undefined,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      serviceWorker: {
        container: ('serviceWorker' in win.navigator) ? win.navigator.serviceWorker : undefined,
        registrations: SW.registrations,
        register: SW.register.bind(app),
        unregister: SW.unregister.bind(app),
      },
    });
  },
  on: {
    init() {
      if (!('serviceWorker' in win.navigator)) return;
      const app = this;
      if (!app.serviceWorker.container) return;
      const paths = app.params.serviceWorker.path;
      const scope = app.params.serviceWorker.scope;
      if (!paths || (Array.isArray(paths) && !paths.length)) return;
      const toRegister = Array.isArray(paths) ? paths : [paths];
      toRegister.forEach((path) => {
        app.serviceWorker.register(path, scope);
      });
    },
  },
};

const Statusbar = {
  hide() {
    if (Device.cordova && win.StatusBar) {
      win.StatusBar.hide();
    }
  },
  show() {
    if (Device.cordova && win.StatusBar) {
      win.StatusBar.show();
    }
  },
  onClick() {
    const app = this;
    let pageContent;
    if ($('.popup.modal-in').length > 0) {
      // Check for opened popup
      pageContent = $('.popup.modal-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else if ($('.panel.panel-in').length > 0) {
      // Check for opened panel
      pageContent = $('.panel.panel-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else if ($('.views > .view.tab-active').length > 0) {
      // View in tab bar app layout
      pageContent = $('.views > .view.tab-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else if ($('.views').length > 0) {
      pageContent = $('.views').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else {
      pageContent = app.root.children('.view').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    }

    if (pageContent && pageContent.length > 0) {
      // Check for tab
      if (pageContent.hasClass('tab')) {
        pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
      }
      if (pageContent.length > 0) pageContent.scrollTop(0, 300);
    }
  },
  setTextColor(color) {
    if (Device.cordova && win.StatusBar) {
      if (color === 'white') {
        win.StatusBar.styleLightContent();
      } else {
        win.StatusBar.styleDefault();
      }
    }
  },
  setBackgroundColor(color) {
    if (Device.cordova && win.StatusBar) {
      win.StatusBar.backgroundColorByHexString(color);
    }
  },
  isVisible() {
    if (Device.cordova && win.StatusBar) {
      return win.StatusBar.isVisible;
    }
    return false;
  },
  overlaysWebView(overlays = true) {
    if (Device.cordova && win.StatusBar) {
      win.StatusBar.overlaysWebView(overlays);
    }
  },
  init() {
    const app = this;
    const params = app.params.statusbar;
    if (!params.enabled) return;

    if (Device.cordova && win.StatusBar) {
      if (params.scrollTopOnClick) {
        $(win).on('statusTap', Statusbar.onClick.bind(app));
      }
      if (Device.ios) {
        if (params.iosOverlaysWebView) {
          win.StatusBar.overlaysWebView(true);
        } else {
          win.StatusBar.overlaysWebView(false);
        }
        if (params.iosTextColor === 'white') {
          win.StatusBar.styleLightContent();
        } else {
          win.StatusBar.styleDefault();
        }
      }
      if (Device.android) {
        if (params.androidOverlaysWebView) {
          win.StatusBar.overlaysWebView(true);
        } else {
          win.StatusBar.overlaysWebView(false);
        }
        if (params.androidTextColor === 'white') {
          win.StatusBar.styleLightContent();
        } else {
          win.StatusBar.styleDefault();
        }
      }
    }
    if (params.iosBackgroundColor && Device.ios) {
      Statusbar.setBackgroundColor(params.iosBackgroundColor);
    }
    if (params.androidBackgroundColor && Device.android) {
      Statusbar.setBackgroundColor(params.androidBackgroundColor);
    }
  },
};

var Statusbar$1 = {
  name: 'statusbar',
  params: {
    statusbar: {
      enabled: true,

      scrollTopOnClick: true,

      iosOverlaysWebView: true,
      iosTextColor: 'black',
      iosBackgroundColor: null,

      androidOverlaysWebView: false,
      androidTextColor: 'black',
      androidBackgroundColor: null,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      statusbar: {
        hide: Statusbar.hide,
        show: Statusbar.show,
        overlaysWebView: Statusbar.overlaysWebView,
        setTextColor: Statusbar.setTextColor,
        setBackgroundColor: Statusbar.setBackgroundColor,
        isVisible: Statusbar.isVisible,
        init: Statusbar.init.bind(app),
      },
    });
  },
  on: {
    init() {
      const app = this;
      Statusbar.init.call(app);
    },
  },
};

function getCurrentView(app) {
  const $popoverView = $('.popover.modal-in .view');
  const $popupView = $('.popup.modal-in .view');
  const $panelView = $('.panel.panel-in .view');
  let $viewsEl = $('.views');
  if ($viewsEl.length === 0) $viewsEl = app.root;
  // Find active view as tab
  let $viewEl = $viewsEl.children('.view');
  if ($viewEl.length === 0) {
    $viewEl = $viewsEl.children('.tabs').children('.view');
  }
  // Propably in tabs or split view
  if ($viewEl.length > 1) {
    if ($viewEl.hasClass('tab')) {
      // Tabs
      $viewEl = $viewsEl.children('.view.tab-active');
      if ($viewEl.length === 0) {
        $viewEl = $viewsEl.children('.tabs').children('.view.tab-active');
      }
    }
  }
  if ($popoverView.length > 0 && $popoverView[0].f7View) return $popoverView[0].f7View;
  if ($popupView.length > 0 && $popupView[0].f7View) return $popupView[0].f7View;
  if ($panelView.length > 0 && $panelView[0].f7View) return $panelView[0].f7View;
  if ($viewEl.length > 0) {
    if ($viewEl.length === 1 && $viewEl[0].f7View) return $viewEl[0].f7View;
    if ($viewEl.length > 1) {
      return app.views.main;
    }
  }
  return undefined;
}

var View$1 = {
  name: 'view',
  params: {
    view: {
      name: undefined,
      main: false,
      router: true,
      linksView: null,
      stackPages: false,
      xhrCache: true,
      xhrCacheIgnore: [],
      xhrCacheIgnoreGetParameters: false,
      xhrCacheDuration: 1000 * 60 * 10, // Ten minutes
      componentCache: true,
      preloadPreviousPage: true,
      allowDuplicateUrls: false,
      reloadPages: false,
      reloadDetail: false,
      masterDetailBreakpoint: 0,
      masterDetailResizable: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
      restoreScrollTopOnBack: true,
      unloadTabContent: true,
      passRouteQueryToRequest: true,
      passRouteParamsToRequest: false,
      loadInitialPage: true,
      // Swipe Back
      iosSwipeBack: true,
      iosSwipeBackAnimateShadow: true,
      iosSwipeBackAnimateOpacity: true,
      iosSwipeBackActiveArea: 30,
      iosSwipeBackThreshold: 0,
      mdSwipeBack: false,
      mdSwipeBackAnimateShadow: true,
      mdSwipeBackAnimateOpacity: false,
      mdSwipeBackActiveArea: 30,
      mdSwipeBackThreshold: 0,
      auroraSwipeBack: false,
      auroraSwipeBackAnimateShadow: false,
      auroraSwipeBackAnimateOpacity: true,
      auroraSwipeBackActiveArea: 30,
      auroraSwipeBackThreshold: 0,
      // Push State
      pushState: false,
      pushStateRoot: undefined,
      pushStateAnimate: true,
      pushStateAnimateOnLoad: false,
      pushStateSeparator: '#!',
      pushStateOnLoad: true,
      // Animate Pages
      animate: true,
      // iOS Dynamic Navbar
      iosDynamicNavbar: true,
      // Animate iOS Navbar Back Icon
      iosAnimateNavbarBackIcon: true,
      // Delays
      iosPageLoadDelay: 0,
      mdPageLoadDelay: 0,
      auroraPageLoadDelay: 0,
      // Routes hooks
      routesBeforeEnter: null,
      routesBeforeLeave: null,
    },
  },
  static: {
    View,
  },
  create() {
    const app = this;
    Utils.extend(app, {
      views: Utils.extend([], {
        create(el, params) {
          return new View(app, el, params);
        },
        get(viewEl) {
          const $viewEl = $(viewEl);
          if ($viewEl.length && $viewEl[0].f7View) return $viewEl[0].f7View;
          return undefined;
        },
      }),
    });
    Object.defineProperty(app.views, 'current', {
      enumerable: true,
      configurable: true,
      get() {
        return getCurrentView(app);
      },
    });
    // Alias
    app.view = app.views;
  },
  on: {
    init() {
      const app = this;
      $('.view-init').each((index, viewEl) => {
        if (viewEl.f7View) return;
        const viewParams = $(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      });
    },
    'modalOpen panelOpen': function onOpen(instance) {
      const app = this;
      instance.$el.find('.view-init').each((index, viewEl) => {
        if (viewEl.f7View) return;
        const viewParams = $(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      });
    },
    'modalBeforeDestroy panelBeforeDestroy': function onClose(instance) {
      if (!instance || !instance.$el) return;
      instance.$el.find('.view-init').each((index, viewEl) => {
        const view = viewEl.f7View;
        if (!view) return;
        view.destroy();
      });
    },
  },
  vnode: {
    'view-init': {
      insert(vnode) {
        const app = this;
        const viewEl = vnode.elm;
        if (viewEl.f7View) return;
        const viewParams = $(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      },
      destroy(vnode) {
        const viewEl = vnode.elm;
        const view = viewEl.f7View;
        if (!view) return;
        view.destroy();
      },
    },
  },
};

const Navbar = {
  size(el) {
    const app = this;

    let $el = $(el);

    if ($el.hasClass('navbars')) {
      $el = $el.children('.navbar').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
      return;
    }

    const $innerEl = $el.children('.navbar-inner');
    if (!$innerEl.length) return;

    const needCenterTitle = (
      $innerEl.hasClass('navbar-inner-centered-title')
      || app.params.navbar[`${app.theme}CenterTitle`]
    );
    const needLeftTitle = app.theme === 'ios' && !app.params.navbar[`${app.theme}CenterTitle`];

    if (!needCenterTitle && !needLeftTitle) return;

    if (
      $el.hasClass('stacked')
      || $el.parents('.stacked').length > 0
      || $el.parents('.tab:not(.tab-active)').length > 0
      || $el.parents('.popup:not(.modal-in)').length > 0
    ) {
      return;
    }

    if (app.theme !== 'ios' && app.params.navbar[`${app.theme}CenterTitle`]) {
      $innerEl.addClass('navbar-inner-centered-title');
    }
    if (app.theme === 'ios' && !app.params.navbar.iosCenterTitle) {
      $innerEl.addClass('navbar-inner-left-title');
    }

    const $viewEl = $el.parents('.view').eq(0);
    const left = app.rtl ? $innerEl.children('.right') : $innerEl.children('.left');
    const right = app.rtl ? $innerEl.children('.left') : $innerEl.children('.right');
    const title = $innerEl.children('.title');
    const subnavbar = $innerEl.children('.subnavbar');
    const noLeft = left.length === 0;
    const noRight = right.length === 0;
    const leftWidth = noLeft ? 0 : left.outerWidth(true);
    const rightWidth = noRight ? 0 : right.outerWidth(true);
    const titleWidth = title.outerWidth(true);
    const navbarStyles = $innerEl.styles();
    const navbarWidth = $innerEl[0].offsetWidth;
    const navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
    const isPrevious = $el.hasClass('navbar-previous');
    const sliding = $innerEl.hasClass('sliding');

    let router;
    let dynamicNavbar;

    if ($viewEl.length > 0 && $viewEl[0].f7View) {
      router = $viewEl[0].f7View.router;
      dynamicNavbar = router && router.dynamicNavbar;
    }

    let currLeft;
    let diff;
    if (noRight) {
      currLeft = navbarInnerWidth - titleWidth;
    }
    if (noLeft) {
      currLeft = 0;
    }
    if (!noLeft && !noRight) {
      currLeft = ((navbarInnerWidth - rightWidth - titleWidth) + leftWidth) / 2;
    }
    let requiredLeft = (navbarInnerWidth - titleWidth) / 2;
    if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
      if (requiredLeft < leftWidth) {
        requiredLeft = leftWidth;
      }
      if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
        requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
      }
      diff = requiredLeft - currLeft;
    } else {
      diff = 0;
    }

    // RTL inverter
    const inverter = app.rtl ? -1 : 1;

    if (dynamicNavbar && app.theme === 'ios') {
      if (title.hasClass('sliding') || (title.length > 0 && sliding)) {
        let titleLeftOffset = -(currLeft + diff) * inverter;
        const titleRightOffset = (navbarInnerWidth - currLeft - diff - titleWidth) * inverter;

        if (isPrevious) {
          if (router && router.params.iosAnimateNavbarBackIcon) {
            const activeNavbarBackLink = $el.parent().find('.navbar-current').children('.left.sliding').find('.back .icon ~ span');
            if (activeNavbarBackLink.length > 0) {
              titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
            }
          }
        }
        title[0].f7NavbarLeftOffset = titleLeftOffset;
        title[0].f7NavbarRightOffset = titleRightOffset;
      }
      if (!noLeft && (left.hasClass('sliding') || sliding)) {
        if (app.rtl) {
          left[0].f7NavbarLeftOffset = (-(navbarInnerWidth - left[0].offsetWidth) / 2) * inverter;
          left[0].f7NavbarRightOffset = leftWidth * inverter;
        } else {
          left[0].f7NavbarLeftOffset = -leftWidth;
          left[0].f7NavbarRightOffset = ((navbarInnerWidth - left[0].offsetWidth) / 2);
          if (router && router.params.iosAnimateNavbarBackIcon && left.find('.back .icon').length > 0) {
            if (left.find('.back .icon ~ span').length) {
              const leftOffset = left[0].f7NavbarLeftOffset;
              const rightOffset = left[0].f7NavbarRightOffset;
              left[0].f7NavbarLeftOffset = 0;
              left[0].f7NavbarRightOffset = 0;
              left.find('.back .icon ~ span')[0].f7NavbarLeftOffset = leftOffset;
              left.find('.back .icon ~ span')[0].f7NavbarRightOffset = rightOffset - left.find('.back .icon')[0].offsetWidth;
            }
          }
        }
      }
      if (!noRight && (right.hasClass('sliding') || sliding)) {
        if (app.rtl) {
          right[0].f7NavbarLeftOffset = -rightWidth * inverter;
          right[0].f7NavbarRightOffset = ((navbarInnerWidth - right[0].offsetWidth) / 2) * inverter;
        } else {
          right[0].f7NavbarLeftOffset = -(navbarInnerWidth - right[0].offsetWidth) / 2;
          right[0].f7NavbarRightOffset = rightWidth;
        }
      }
      if (subnavbar.length && (subnavbar.hasClass('sliding') || sliding)) {
        subnavbar[0].f7NavbarLeftOffset = app.rtl ? subnavbar[0].offsetWidth : -subnavbar[0].offsetWidth;
        subnavbar[0].f7NavbarRightOffset = -subnavbar[0].f7NavbarLeftOffset;
      }
    }

    // Center title
    if (needCenterTitle) {
      let titleLeft = diff;
      if (app.rtl && noLeft && noRight && title.length > 0) titleLeft = -titleLeft;
      title.css({ left: `${titleLeft}px` });
    }
  },
  hide(el, animate = true, hideStatusbar = false) {
    const app = this;
    let $el = $(el);
    const isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length;
    if (isDynamic) $el = $el.parents('.navbars');
    if (!$el.length) return;
    if ($el.hasClass('navbar-hidden')) return;
    let className = `navbar-hidden${animate ? ' navbar-transitioning' : ''}`;
    const currentIsLarge = isDynamic
      ? $el.find('.navbar-current .title-large').length
      : $el.find('.title-large').length;
    if (currentIsLarge) {
      className += ' navbar-large-hidden';
    }
    if (hideStatusbar) {
      className += ' navbar-hidden-statusbar';
    }
    $el.transitionEnd(() => {
      $el.removeClass('navbar-transitioning');
    });
    $el.addClass(className);
    if (isDynamic) {
      $el.children('.navbar').each((index, subEl) => {
        $(subEl).trigger('navbar:hide');
        app.emit('navbarHide', subEl);
      });
    } else {
      $el.trigger('navbar:hide');
      app.emit('navbarHide', $el[0]);
    }
  },
  show(el = '.navbar-hidden', animate = true) {
    const app = this;
    let $el = $(el);
    const isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length;
    if (isDynamic) $el = $el.parents('.navbars');
    if (!$el.length) return;
    if (!$el.hasClass('navbar-hidden')) return;
    if (animate) {
      $el.addClass('navbar-transitioning');
      $el.transitionEnd(() => {
        $el.removeClass('navbar-transitioning');
      });
    }
    $el.removeClass('navbar-hidden navbar-large-hidden navbar-hidden-statusbar');
    if (isDynamic) {
      $el.children('.navbar').each((index, subEl) => {
        $(subEl).trigger('navbar:show');
        app.emit('navbarShow', subEl);
      });
    } else {
      $el.trigger('navbar:show');
      app.emit('navbarShow', $el[0]);
    }
  },
  getElByPage(page) {
    let $pageEl;
    let $navbarEl;
    let pageData;
    if (page.$navbarEl || page.$el) {
      pageData = page;
      $pageEl = page.$el;
    } else {
      $pageEl = $(page);
      if ($pageEl.length > 0) pageData = $pageEl[0].f7Page;
    }
    if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
      $navbarEl = pageData.$navbarEl;
    } else if ($pageEl) {
      $navbarEl = $pageEl.children('.navbar');
    }
    if (!$navbarEl || ($navbarEl && $navbarEl.length === 0)) return undefined;
    return $navbarEl[0];
  },
  getPageByEl(navbarEl) {
    const $navbarEl = $(navbarEl);
    if ($navbarEl.parents('.page').length) {
      return $navbarEl.parents('.page')[0];
    }
    let pageEl;
    $navbarEl.parents('.view').find('.page').each((index, el) => {
      if (el && el.f7Page && el.f7Page.navbarEl && $navbarEl[0] === el.f7Page.navbarEl) {
        pageEl = el;
      }
    });
    return pageEl;
  },

  collapseLargeTitle(navbarEl) {
    const app = this;
    let $navbarEl = $(navbarEl);
    if ($navbarEl.hasClass('navbars')) {
      $navbarEl = $navbarEl.find('.navbar');
      if ($navbarEl.length > 1) {
        $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
      }
      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }
    const $pageEl = $(app.navbar.getPageByEl($navbarEl));
    $navbarEl.addClass('navbar-large-collapsed');
    $pageEl.eq(0).addClass('page-with-navbar-large-collapsed').trigger('page:navbarlargecollapsed');
    app.emit('pageNavbarLargeCollapsed', $pageEl[0]);
    $navbarEl.trigger('navbar:collapse');
    app.emit('navbarCollapse', $navbarEl[0]);
  },
  expandLargeTitle(navbarEl) {
    const app = this;
    let $navbarEl = $(navbarEl);
    if ($navbarEl.hasClass('navbars')) {
      $navbarEl = $navbarEl.find('.navbar-large');
      if ($navbarEl.length > 1) {
        $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
      }
      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }
    const $pageEl = $(app.navbar.getPageByEl($navbarEl));
    $navbarEl.removeClass('navbar-large-collapsed');
    $pageEl.eq(0).removeClass('page-with-navbar-large-collapsed').trigger('page:navbarlargeexpanded');
    app.emit('pageNavbarLargeExpanded', $pageEl[0]);
    $navbarEl.trigger('navbar:expand');
    app.emit('navbarExpand', $navbarEl[0]);
  },
  toggleLargeTitle(navbarEl) {
    const app = this;
    let $navbarEl = $(navbarEl);
    if ($navbarEl.hasClass('navbars')) {
      $navbarEl = $navbarEl.find('.navbar-large');
      if ($navbarEl.length > 1) {
        $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
      }
      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }
    if ($navbarEl.hasClass('navbar-large-collapsed')) {
      app.navbar.expandLargeTitle($navbarEl);
    } else {
      app.navbar.collapseLargeTitle($navbarEl);
    }
  },
  initNavbarOnScroll(pageEl, navbarEl, needHide, needCollapse, needTransparent) {
    const app = this;
    const $pageEl = $(pageEl);
    const $navbarEl = $(navbarEl);
    const $titleLargeEl = $navbarEl.find('.title-large');
    const isLarge = $titleLargeEl.length || $navbarEl.hasClass('.navbar-large');
    let navbarHideHeight = 44;
    const snapPageScrollToLargeTitle = app.params.navbar.snapPageScrollToLargeTitle;
    const snapPageScrollToTransparentNavbar = app.params.navbar.snapPageScrollToTransparentNavbar;

    let previousScrollTop;
    let currentScrollTop;

    let scrollHeight;
    let offsetHeight;
    let reachEnd;
    let action;
    let navbarHidden;

    let navbarCollapsed;
    let navbarTitleLargeHeight;

    let navbarOffsetHeight;

    if (needCollapse || (needHide && isLarge)) {
      navbarTitleLargeHeight = $navbarEl.css('--f7-navbar-large-title-height');

      if (navbarTitleLargeHeight && navbarTitleLargeHeight.indexOf('px') >= 0) {
        navbarTitleLargeHeight = parseInt(navbarTitleLargeHeight, 10);
        if (Number.isNaN(navbarTitleLargeHeight) && $titleLargeEl.length) {
          navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
        } else if (Number.isNaN(navbarTitleLargeHeight)) {
          if (app.theme === 'ios') navbarTitleLargeHeight = 52;
          else if (app.theme === 'md') navbarTitleLargeHeight = 48;
          else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
        }
      } else if ($titleLargeEl.length) {
        navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
      } else { // eslint-disable-next-line
        if (app.theme === 'ios') navbarTitleLargeHeight = 52;
        else if (app.theme === 'md') navbarTitleLargeHeight = 48;
        else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
      }
    }

    if (needHide && isLarge) {
      navbarHideHeight += navbarTitleLargeHeight;
    }

    let scrollChanged;
    let scrollContent;
    let scrollTimeoutId;
    let touchEndTimeoutId;
    const touchSnapTimeout = 70;
    const desktopSnapTimeout = 300;

    function snapLargeNavbar() {
      const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
      if (inSearchbarExpanded) return;
      if (!scrollContent || currentScrollTop < 0) return;
      if (currentScrollTop >= navbarTitleLargeHeight / 2 && currentScrollTop < navbarTitleLargeHeight) {
        $(scrollContent).scrollTop(navbarTitleLargeHeight, 100);
      } else if (currentScrollTop < navbarTitleLargeHeight) {
        $(scrollContent).scrollTop(0, 200);
      }
    }

    function snapTransparentNavbar() {
      const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
      if (inSearchbarExpanded) return;
      if (!scrollContent || currentScrollTop < 0) return;
      if (currentScrollTop >= navbarOffsetHeight / 2 && currentScrollTop < navbarOffsetHeight) {
        $(scrollContent).scrollTop(navbarOffsetHeight, 100);
      } else if (currentScrollTop < navbarOffsetHeight) {
        $(scrollContent).scrollTop(0, 200);
      }
    }

    function handleNavbarTransparent() {
      const isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
      const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
      if (inSearchbarExpanded || isHidden) return;
      if (!navbarOffsetHeight) {
        navbarOffsetHeight = navbarEl.offsetHeight;
      }
      let opacity = currentScrollTop / navbarOffsetHeight;
      const notTransparent = $navbarEl.hasClass('navbar-transparent-visible');
      opacity = Math.max(Math.min(opacity, 1), 0);

      if ((notTransparent && opacity === 1) || (!notTransparent && opacity === 0)) {
        $navbarEl.find('.navbar-bg, .title').css('opacity', '');
        return;
      }
      if (notTransparent && opacity === 0) {
        $navbarEl.trigger('navbar:transparenthide');
        app.emit('navbarTransparentHide', $navbarEl[0]);
        $navbarEl.removeClass('navbar-transparent-visible');
        $navbarEl.find('.navbar-bg, .title').css('opacity', '');
        return;
      }
      if (!notTransparent && opacity === 1) {
        $navbarEl.trigger('navbar:transparentshow');
        app.emit('navbarTransparentShow', $navbarEl[0]);
        $navbarEl.addClass('navbar-transparent-visible');
        $navbarEl.find('.navbar-bg, .title').css('opacity', '');
        return;
      }

      $navbarEl.find('.navbar-bg, .title').css('opacity', opacity);

      if (snapPageScrollToTransparentNavbar) {
        if (!Support.touch) {
          clearTimeout(scrollTimeoutId);
          scrollTimeoutId = setTimeout(() => {
            snapTransparentNavbar();
          }, desktopSnapTimeout);
        } else if (touchEndTimeoutId) {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(() => {
            snapTransparentNavbar();
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
          }, touchSnapTimeout);
        }
      }
    }

    let previousCollapseProgress = null;
    let collapseProgress = null;
    function handleLargeNavbarCollapse() {
      const isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
      if (isHidden) return;
      const isLargeTransparent = $navbarEl.hasClass('navbar-large-transparent')
        || (
          $navbarEl.hasClass('navbar-large')
          && $navbarEl.hasClass('navbar-transparent')
        );
      previousCollapseProgress = collapseProgress;
      collapseProgress = Math.min(Math.max((currentScrollTop / navbarTitleLargeHeight), 0), 1);
      const previousCollapseWasInMiddle = previousCollapseProgress > 0 && previousCollapseProgress < 1;
      const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
      if (inSearchbarExpanded) return;
      navbarCollapsed = $navbarEl.hasClass('navbar-large-collapsed');
      if (collapseProgress === 0 && navbarCollapsed) {
        app.navbar.expandLargeTitle($navbarEl[0]);
      } else if (collapseProgress === 1 && !navbarCollapsed) {
        app.navbar.collapseLargeTitle($navbarEl[0]);
      }
      if (
        (collapseProgress === 0 && navbarCollapsed)
        || (collapseProgress === 0 && previousCollapseWasInMiddle)
        || (collapseProgress === 1 && !navbarCollapsed)
        || (collapseProgress === 1 && previousCollapseWasInMiddle)
      ) {
        if (app.theme === 'md') {
          $navbarEl.find('.navbar-inner').css('overflow', '');
        }
        $navbarEl.find('.title').css('opacity', '');
        $navbarEl.find('.title-large-text, .subnavbar').css('transform', '');
        if (isLargeTransparent) {
          $navbarEl.find('.navbar-bg').css('opacity', '');
        } else {
          $navbarEl.find('.navbar-bg').css('transform', '');
        }
      } else if (collapseProgress > 0 && collapseProgress < 1) {
        if (app.theme === 'md') {
          $navbarEl.find('.navbar-inner').css('overflow', 'visible');
        }
        $navbarEl.find('.title').css('opacity', collapseProgress);
        $navbarEl.find('.title-large-text, .subnavbar').css('transform', `translate3d(0px, ${-1 * collapseProgress * navbarTitleLargeHeight}px, 0)`);
        if (isLargeTransparent) {
          $navbarEl.find('.navbar-bg').css('opacity', collapseProgress);
        } else {
          $navbarEl.find('.navbar-bg').css('transform', `translate3d(0px, ${-1 * collapseProgress * navbarTitleLargeHeight}px, 0)`);
        }
      }

      if (snapPageScrollToLargeTitle) {
        if (!Support.touch) {
          clearTimeout(scrollTimeoutId);
          scrollTimeoutId = setTimeout(() => {
            snapLargeNavbar();
          }, desktopSnapTimeout);
        } else if (touchEndTimeoutId) {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(() => {
            snapLargeNavbar();
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
          }, touchSnapTimeout);
        }
      }
    }

    function handleTitleHideShow() {
      if ($pageEl.hasClass('page-with-card-opened')) return;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      navbarHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
      if (reachEnd) {
        if (app.params.navbar.showOnPageScrollEnd) {
          action = 'show';
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app.params.navbar.showOnPageScrollTop || currentScrollTop <= navbarHideHeight) {
          action = 'show';
        } else {
          action = 'hide';
        }
      } else if (currentScrollTop > navbarHideHeight) {
        action = 'hide';
      } else {
        action = 'show';
      }

      if (action === 'show' && navbarHidden) {
        app.navbar.show($navbarEl);
        navbarHidden = false;
      } else if (action === 'hide' && !navbarHidden) {
        app.navbar.hide($navbarEl);
        navbarHidden = true;
      }
      previousScrollTop = currentScrollTop;
    }

    function handleScroll(e) {
      scrollContent = this;
      if (e && e.target && e.target !== scrollContent) {
        return;
      }
      currentScrollTop = scrollContent.scrollTop;
      scrollChanged = currentScrollTop;
      if (needCollapse) {
        handleLargeNavbarCollapse();
      } else if (needTransparent) {
        handleNavbarTransparent();
      }
      if ($pageEl.hasClass('page-previous')) return;
      if (needHide) {
        handleTitleHideShow();
      }
    }
    function handeTouchStart() {
      scrollChanged = false;
    }
    function handleTouchEnd() {
      clearTimeout(touchEndTimeoutId);
      touchEndTimeoutId = null;
      touchEndTimeoutId = setTimeout(() => {
        if (scrollChanged !== false) {
          if (needTransparent && !needCollapse) {
            snapTransparentNavbar();
          } else {
            snapLargeNavbar();
          }
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
        }
      }, touchSnapTimeout);
    }
    $pageEl.on('scroll', '.page-content', handleScroll, true);
    if (Support.touch && ((needCollapse && snapPageScrollToLargeTitle) || (needTransparent && snapPageScrollToTransparentNavbar))) {
      app.on('touchstart:passive', handeTouchStart);
      app.on('touchend:passive', handleTouchEnd);
    }
    if (needCollapse) {
      $pageEl.find('.page-content').each((pageContentIndex, pageContentEl) => {
        if (pageContentEl.scrollTop > 0) handleScroll.call(pageContentEl);
      });
    } else if (needTransparent) {
      $pageEl.find('.page-content').each((pageContentIndex, pageContentEl) => {
        if (pageContentEl.scrollTop > 0) handleScroll.call(pageContentEl);
      });
    }
    $pageEl[0].f7DetachNavbarScrollHandlers = function f7DetachNavbarScrollHandlers() {
      delete $pageEl[0].f7DetachNavbarScrollHandlers;
      $pageEl.off('scroll', '.page-content', handleScroll, true);
      if (Support.touch && ((needCollapse && snapPageScrollToLargeTitle) || (needTransparent && snapPageScrollToTransparentNavbar))) {
        app.off('touchstart:passive', handeTouchStart);
        app.off('touchend:passive', handleTouchEnd);
      }
    };
  },
};
var Navbar$1 = {
  name: 'navbar',
  create() {
    const app = this;
    Utils.extend(app, {
      navbar: {
        size: Navbar.size.bind(app),
        hide: Navbar.hide.bind(app),
        show: Navbar.show.bind(app),
        getElByPage: Navbar.getElByPage.bind(app),
        getPageByEl: Navbar.getPageByEl.bind(app),
        collapseLargeTitle: Navbar.collapseLargeTitle.bind(app),
        expandLargeTitle: Navbar.expandLargeTitle.bind(app),
        toggleLargeTitle: Navbar.toggleLargeTitle.bind(app),
        initNavbarOnScroll: Navbar.initNavbarOnScroll.bind(app),
      },
    });
  },
  params: {
    navbar: {
      scrollTopOnTitleClick: true,
      iosCenterTitle: true,
      mdCenterTitle: false,
      auroraCenterTitle: true,
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true,
      collapseLargeTitleOnScroll: true,
      snapPageScrollToLargeTitle: true,
      snapPageScrollToTransparentNavbar: true,
    },
  },
  on: {
    'panelBreakpoint panelCollapsedBreakpoint panelResize viewResize resize viewMasterDetailBreakpoint': function onPanelResize() {
      const app = this;
      $('.navbar').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
    },
    pageBeforeRemove(page) {
      if (page.$el[0].f7DetachNavbarScrollHandlers) {
        page.$el[0].f7DetachNavbarScrollHandlers();
      }
    },
    pageBeforeIn(page) {
      const app = this;
      if (app.theme !== 'ios') return;
      let $navbarsEl;
      const view = page.$el.parents('.view')[0].f7View;
      const navbarEl = app.navbar.getElByPage(page);
      if (!navbarEl) {
        $navbarsEl = page.$el.parents('.view').children('.navbars');
      } else {
        $navbarsEl = $(navbarEl).parents('.navbars');
      }
      if (page.$el.hasClass('no-navbar') || (view.router.dynamicNavbar && !navbarEl)) {
        const animate = !!(page.pageFrom && page.router.history.length > 0);
        app.navbar.hide($navbarsEl, animate);
      } else {
        app.navbar.show($navbarsEl);
      }
    },
    pageReinit(page) {
      const app = this;
      const $navbarEl = $(app.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0) return;
      app.navbar.size($navbarEl);
    },
    pageInit(page) {
      const app = this;
      const $navbarEl = $(app.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0) return;

      // Size
      app.navbar.size($navbarEl);

      // Need Collapse On Scroll
      let needCollapseOnScrollHandler;
      if ($navbarEl.find('.title-large').length > 0) {
        $navbarEl.addClass('navbar-large');
      }
      if ($navbarEl.hasClass('navbar-large')) {
        if (app.params.navbar.collapseLargeTitleOnScroll) needCollapseOnScrollHandler = true;
        page.$el.addClass('page-with-navbar-large');
      }

      // Need transparent on scroll
      let needTransparentOnScroll;
      if (!needCollapseOnScrollHandler && $navbarEl.hasClass('navbar-transparent')) {
        needTransparentOnScroll = true;
      }

      // Need Hide On Scroll
      let needHideOnScrollHandler;
      if (
        app.params.navbar.hideOnPageScroll
        || page.$el.find('.hide-navbar-on-scroll').length
        || page.$el.hasClass('hide-navbar-on-scroll')
        || page.$el.find('.hide-bars-on-scroll').length
        || page.$el.hasClass('hide-bars-on-scroll')
      ) {
        if (
          page.$el.find('.keep-navbar-on-scroll').length
          || page.$el.hasClass('keep-navbar-on-scroll')
          || page.$el.find('.keep-bars-on-scroll').length
          || page.$el.hasClass('keep-bars-on-scroll')
        ) {
          needHideOnScrollHandler = false;
        } else {
          needHideOnScrollHandler = true;
        }
      }

      if (needCollapseOnScrollHandler || needHideOnScrollHandler || needTransparentOnScroll) {
        app.navbar.initNavbarOnScroll(page.el, $navbarEl[0], needHideOnScrollHandler, needCollapseOnScrollHandler, needTransparentOnScroll);
      }
    },
    'panelOpen panelSwipeOpen modalOpen': function onPanelModalOpen(instance) {
      const app = this;
      instance.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
    },
    tabShow(tabEl) {
      const app = this;
      $(tabEl).find('.navbar:not(.navbar-previous):not(.stacked)').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
    },
  },
  clicks: {
    '.navbar .title': function onTitleClick($clickedEl) {
      const app = this;
      if (!app.params.navbar.scrollTopOnTitleClick) return;
      if ($clickedEl.closest('a').length > 0) {
        return;
      }
      let $pageContentEl;

      // Find active page
      const $navbarEl = $clickedEl.parents('.navbar');
      const $navbarsEl = $navbarEl.parents('.navbars');

      // Static Layout
      $pageContentEl = $navbarEl.parents('.page-content');

      if ($pageContentEl.length === 0) {
        // Fixed Layout
        if ($navbarEl.parents('.page').length > 0) {
          $pageContentEl = $navbarEl.parents('.page').find('.page-content');
        }
        // Through Layout iOS
        if ($pageContentEl.length === 0 && $navbarsEl.length) {
          if ($navbarsEl.nextAll('.page-current:not(.stacked)').length > 0) {
            $pageContentEl = $navbarsEl.nextAll('.page-current:not(.stacked)').find('.page-content');
          }
        }
        // Through Layout
        if ($pageContentEl.length === 0) {
          if ($navbarEl.nextAll('.page-current:not(.stacked)').length > 0) {
            $pageContentEl = $navbarEl.nextAll('.page-current:not(.stacked)').find('.page-content');
          }
        }
      }
      if ($pageContentEl && $pageContentEl.length > 0) {
        // Check for tab
        if ($pageContentEl.hasClass('tab')) {
          $pageContentEl = $pageContentEl.parent('.tabs').children('.page-content.tab-active');
        }
        if ($pageContentEl.length > 0) $pageContentEl.scrollTop(0, 300);
      }
    },
  },
  vnode: {
    navbar: {
      postpatch(vnode) {
        const app = this;
        app.navbar.size(vnode.elm);
      },
    },
  },
};

const Toolbar = {
  setHighlight(tabbarEl) {
    const app = this;
    if (app.theme !== 'md') return;

    const $tabbarEl = $(tabbarEl);

    if ($tabbarEl.length === 0 || !($tabbarEl.hasClass('tabbar') || $tabbarEl.hasClass('tabbar-labels'))) return;

    let $highlightEl = $tabbarEl.find('.tab-link-highlight');
    const tabLinksCount = $tabbarEl.find('.tab-link').length;
    if (tabLinksCount === 0) {
      $highlightEl.remove();
      return;
    }

    if ($highlightEl.length === 0) {
      $tabbarEl.children('.toolbar-inner').append('<span class="tab-link-highlight"></span>');
      $highlightEl = $tabbarEl.find('.tab-link-highlight');
    } else if ($highlightEl.next().length) {
      $tabbarEl.children('.toolbar-inner').append($highlightEl);
    }

    const $activeLink = $tabbarEl.find('.tab-link-active');
    let highlightWidth;
    let highlightTranslate;

    if ($tabbarEl.hasClass('tabbar-scrollable') && $activeLink && $activeLink[0]) {
      highlightWidth = `${$activeLink[0].offsetWidth}px`;
      highlightTranslate = `${$activeLink[0].offsetLeft}px`;
    } else {
      const activeIndex = $activeLink.index();
      highlightWidth = `${100 / tabLinksCount}%`;
      highlightTranslate = `${(app.rtl ? -activeIndex : activeIndex) * 100}%`;
    }

    Utils.nextFrame(() => {
      $highlightEl
        .css('width', highlightWidth)
        .transform(`translate3d(${highlightTranslate},0,0)`);
    });
  },
  init(tabbarEl) {
    const app = this;
    app.toolbar.setHighlight(tabbarEl);
  },
  hide(el, animate = true) {
    const app = this;
    const $el = $(el);
    if ($el.hasClass('toolbar-hidden')) return;
    const className = `toolbar-hidden${animate ? ' toolbar-transitioning' : ''}`;
    $el.transitionEnd(() => {
      $el.removeClass('toolbar-transitioning');
    });
    $el.addClass(className);
    $el.trigger('toolbar:hide');
    app.emit('toolbarHide', $el[0]);
  },
  show(el, animate = true) {
    const app = this;
    const $el = $(el);
    if (!$el.hasClass('toolbar-hidden')) return;
    if (animate) {
      $el.addClass('toolbar-transitioning');
      $el.transitionEnd(() => {
        $el.removeClass('toolbar-transitioning');
      });
    }
    $el.removeClass('toolbar-hidden');
    $el.trigger('toolbar:show');
    app.emit('toolbarShow', $el[0]);
  },
  initToolbarOnScroll(pageEl) {
    const app = this;
    const $pageEl = $(pageEl);
    let $toolbarEl = $pageEl.parents('.view').children('.toolbar');
    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.find('.toolbar');
    }
    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.parents('.views').children('.tabbar, .tabbar-labels');
    }
    if ($toolbarEl.length === 0) {
      return;
    }

    let previousScrollTop;
    let currentScrollTop;

    let scrollHeight;
    let offsetHeight;
    let reachEnd;
    let action;
    let toolbarHidden;
    function handleScroll(e) {
      if ($pageEl.hasClass('page-with-card-opened')) return;
      if ($pageEl.hasClass('page-previous')) return;
      const scrollContent = this;
      if (e && e.target && e.target !== scrollContent) {
        return;
      }
      currentScrollTop = scrollContent.scrollTop;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      toolbarHidden = $toolbarEl.hasClass('toolbar-hidden');

      if (reachEnd) {
        if (app.params.toolbar.showOnPageScrollEnd) {
          action = 'show';
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
          action = 'show';
        } else {
          action = 'hide';
        }
      } else if (currentScrollTop > 44) {
        action = 'hide';
      } else {
        action = 'show';
      }

      if (action === 'show' && toolbarHidden) {
        app.toolbar.show($toolbarEl);
        toolbarHidden = false;
      } else if (action === 'hide' && !toolbarHidden) {
        app.toolbar.hide($toolbarEl);
        toolbarHidden = true;
      }

      previousScrollTop = currentScrollTop;
    }
    $pageEl.on('scroll', '.page-content', handleScroll, true);
    $pageEl[0].f7ScrollToolbarHandler = handleScroll;
  },
};
var Toolbar$1 = {
  name: 'toolbar',
  create() {
    const app = this;
    Utils.extend(app, {
      toolbar: {
        hide: Toolbar.hide.bind(app),
        show: Toolbar.show.bind(app),
        setHighlight: Toolbar.setHighlight.bind(app),
        initToolbarOnScroll: Toolbar.initToolbarOnScroll.bind(app),
        init: Toolbar.init.bind(app),
      },
    });
  },
  params: {
    toolbar: {
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true,
    },
  },
  on: {
    pageBeforeRemove(page) {
      if (page.$el[0].f7ScrollToolbarHandler) {
        page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollToolbarHandler, true);
      }
    },
    pageBeforeIn(page) {
      const app = this;
      let $toolbarEl = page.$el.parents('.view').children('.toolbar');
      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.parents('.views').children('.tabbar, .tabbar-labels');
      }
      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.find('.toolbar');
      }
      if ($toolbarEl.length === 0) {
        return;
      }
      if (page.$el.hasClass('no-toolbar')) {
        app.toolbar.hide($toolbarEl);
      } else {
        app.toolbar.show($toolbarEl);
      }
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.tabbar, .tabbar-labels').each((index, tabbarEl) => {
        app.toolbar.init(tabbarEl);
      });
      if (
        app.params.toolbar.hideOnPageScroll
        || page.$el.find('.hide-toolbar-on-scroll').length
        || page.$el.hasClass('hide-toolbar-on-scroll')
        || page.$el.find('.hide-bars-on-scroll').length
        || page.$el.hasClass('hide-bars-on-scroll')
      ) {
        if (
          page.$el.find('.keep-toolbar-on-scroll').length
          || page.$el.hasClass('keep-toolbar-on-scroll')
          || page.$el.find('.keep-bars-on-scroll').length
          || page.$el.hasClass('keep-bars-on-scroll')
        ) {
          return;
        }
        app.toolbar.initToolbarOnScroll(page.el);
      }
    },
    init() {
      const app = this;
      app.root.find('.tabbar, .tabbar-labels').each((index, tabbarEl) => {
        app.toolbar.init(tabbarEl);
      });
    },
  },
  vnode: {
    tabbar: {
      insert(vnode) {
        const app = this;
        app.toolbar.init(vnode.elm);
      },
    },
  },
};

var Subnavbar = {
  name: 'subnavbar',
  on: {
    pageInit(page) {
      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length) {
        page.$el.addClass('page-with-subnavbar');
      }
      if (page.$el.find('.subnavbar').length) {
        page.$el.addClass('page-with-subnavbar');
      }
    },
  },
};

class TouchRipple {
  constructor($el, x, y) {
    const ripple = this;
    if (!$el) return undefined;
    const box = $el[0].getBoundingClientRect();
    const center = {
      x: x - box.left,
      y: y - box.top,
    };
    const width = box.width;
    const height = box.height;
    const diameter = Math.max((((height ** 2) + (width ** 2)) ** 0.5), 48);

    ripple.$rippleWaveEl = $(`<div class="ripple-wave" style="width: ${diameter}px; height: ${diameter}px; margin-top:-${diameter / 2}px; margin-left:-${diameter / 2}px; left:${center.x}px; top:${center.y}px;"></div>`);

    $el.prepend(ripple.$rippleWaveEl);

    ripple.rippleTransform = `translate3d(${-center.x + (width / 2)}px, ${-center.y + (height / 2)}px, 0) scale(1)`;

    Utils.nextFrame(() => {
      if (!ripple || !ripple.$rippleWaveEl) return;
      ripple.$rippleWaveEl.transform(ripple.rippleTransform);
    });

    return ripple;
  }

  destroy() {
    let ripple = this;
    if (ripple.$rippleWaveEl) {
      ripple.$rippleWaveEl.remove();
    }
    Object.keys(ripple).forEach((key) => {
      ripple[key] = null;
      delete ripple[key];
    });
    ripple = null;
  }

  remove() {
    const ripple = this;
    if (ripple.removing) return;
    const $rippleWaveEl = this.$rippleWaveEl;
    const rippleTransform = this.rippleTransform;
    let removeTimeout = Utils.nextTick(() => {
      ripple.destroy();
    }, 400);
    ripple.removing = true;
    $rippleWaveEl
      .addClass('ripple-wave-fill')
      .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'))
      .transitionEnd(() => {
        clearTimeout(removeTimeout);
        Utils.nextFrame(() => {
          $rippleWaveEl
            .addClass('ripple-wave-out')
            .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'));

          removeTimeout = Utils.nextTick(() => {
            ripple.destroy();
          }, 700);

          $rippleWaveEl.transitionEnd(() => {
            clearTimeout(removeTimeout);
            ripple.destroy();
          });
        });
      });
  }
}

var TouchRipple$1 = {
  name: 'touch-ripple',
  static: {
    TouchRipple,
  },
  create() {
    const app = this;
    app.touchRipple = {
      create(...args) {
        return new TouchRipple(...args);
      },
    };
  },
};

const openedModals = [];
const dialogsQueue = [];
function clearDialogsQueue() {
  if (dialogsQueue.length === 0) return;
  const dialog = dialogsQueue.shift();
  dialog.open();
}
class Modal extends Framework7Class {
  constructor(app, params) {
    super(params, [app]);

    const modal = this;

    const defaults = {};

    // Extend defaults with modules params
    modal.useModulesParams(defaults);

    modal.params = Utils.extend(defaults, params);
    modal.opened = false;

    // Install Modules
    modal.useModules();

    return this;
  }

  onOpen() {
    const modal = this;
    modal.opened = true;
    openedModals.push(modal);
    $('html').addClass(`with-modal-${modal.type.toLowerCase()}`);
    modal.$el.trigger(`modal:open ${modal.type.toLowerCase()}:open`);
    modal.emit(`local::open modalOpen ${modal.type}Open`, modal);
  }

  onOpened() {
    const modal = this;
    modal.$el.trigger(`modal:opened ${modal.type.toLowerCase()}:opened`);
    modal.emit(`local::opened modalOpened ${modal.type}Opened`, modal);
  }

  onClose() {
    const modal = this;
    modal.opened = false;
    if (!modal.type || !modal.$el) return;
    openedModals.splice(openedModals.indexOf(modal), 1);
    $('html').removeClass(`with-modal-${modal.type.toLowerCase()}`);
    modal.$el.trigger(`modal:close ${modal.type.toLowerCase()}:close`);
    modal.emit(`local::close modalClose ${modal.type}Close`, modal);
  }

  onClosed() {
    const modal = this;
    if (!modal.type || !modal.$el) return;
    modal.$el.removeClass('modal-out');
    modal.$el.hide();
    modal.$el.trigger(`modal:closed ${modal.type.toLowerCase()}:closed`);
    modal.emit(`local::closed modalClosed ${modal.type}Closed`, modal);
  }

  open(animateModal) {
    const modal = this;
    const app = modal.app;
    const $el = modal.$el;
    const $backdropEl = modal.$backdropEl;
    const type = modal.type;
    let animate = true;
    if (typeof animateModal !== 'undefined') animate = animateModal;
    else if (typeof modal.params.animate !== 'undefined') {
      animate = modal.params.animate;
    }

    if (!$el || $el.hasClass('modal-in')) {
      return modal;
    }

    if (type === 'dialog' && app.params.modal.queueDialogs) {
      let pushToQueue;
      if ($('.dialog.modal-in').length > 0) {
        pushToQueue = true;
      } else if (openedModals.length > 0) {
        openedModals.forEach((openedModal) => {
          if (openedModal.type === 'dialog') pushToQueue = true;
        });
      }
      if (pushToQueue) {
        dialogsQueue.push(modal);
        return modal;
      }
    }

    const $modalParentEl = $el.parent();
    const wasInDom = $el.parents(doc).length > 0;
    if (app.params.modal.moveToRoot && !$modalParentEl.is(app.root)) {
      app.root.append($el);
      modal.once(`${type}Closed`, () => {
        if (wasInDom) {
          $modalParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
    // Show Modal
    $el.show();

    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
    modal._clientLeft = $el[0].clientLeft;

    // Modal
    function transitionEnd() {
      if ($el.hasClass('modal-out')) {
        modal.onClosed();
      } else if ($el.hasClass('modal-in')) {
        modal.onOpened();
      }
    }
    if (animate) {
      if ($backdropEl) {
        $backdropEl.removeClass('not-animated');
        $backdropEl.addClass('backdrop-in');
      }
      $el
        .animationEnd(() => {
          transitionEnd();
        });
      $el
        .transitionEnd(() => {
          transitionEnd();
        });
      $el
        .removeClass('modal-out not-animated')
        .addClass('modal-in');
      modal.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass('backdrop-in not-animated');
      }
      $el.removeClass('modal-out').addClass('modal-in not-animated');
      modal.onOpen();
      modal.onOpened();
    }

    return modal;
  }

  close(animateModal) {
    const modal = this;
    const $el = modal.$el;
    const $backdropEl = modal.$backdropEl;

    let animate = true;
    if (typeof animateModal !== 'undefined') animate = animateModal;
    else if (typeof modal.params.animate !== 'undefined') {
      animate = modal.params.animate;
    }

    if (!$el || !$el.hasClass('modal-in')) {
      if (dialogsQueue.indexOf(modal) >= 0) {
        dialogsQueue.splice(dialogsQueue.indexOf(modal), 1);
      }
      return modal;
    }

    // backdrop
    if ($backdropEl) {
      let needToHideBackdrop = true;
      if (modal.type === 'popup') {
        modal.$el.prevAll('.popup.modal-in').each((index, popupEl) => {
          const popupInstance = popupEl.f7Modal;
          if (!popupInstance) return;
          if (
            popupInstance.params.closeByBackdropClick
            && popupInstance.params.backdrop
            && popupInstance.backdropEl === modal.backdropEl
          ) {
            needToHideBackdrop = false;
          }
        });
      }
      if (needToHideBackdrop) {
        $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
        $backdropEl.removeClass('backdrop-in');
      }
    }

    // Modal
    $el[animate ? 'removeClass' : 'addClass']('not-animated');
    function transitionEnd() {
      if ($el.hasClass('modal-out')) {
        modal.onClosed();
      } else if ($el.hasClass('modal-in')) {
        modal.onOpened();
      }
    }
    if (animate) {
      $el
        .animationEnd(() => {
          transitionEnd();
        });
      $el
        .transitionEnd(() => {
          transitionEnd();
        });
      $el
        .removeClass('modal-in')
        .addClass('modal-out');
      // Emit close
      modal.onClose();
    } else {
      $el
        .addClass('not-animated')
        .removeClass('modal-in')
        .addClass('modal-out');
      // Emit close
      modal.onClose();
      modal.onClosed();
    }

    if (modal.type === 'dialog') {
      clearDialogsQueue();
    }

    return modal;
  }

  destroy() {
    const modal = this;
    if (modal.destroyed) return;
    modal.emit(`local::beforeDestroy modalBeforeDestroy ${modal.type}BeforeDestroy`, modal);
    if (modal.$el) {
      modal.$el.trigger(`modal:beforedestroy ${modal.type.toLowerCase()}:beforedestroy`);
      if (modal.$el.length && modal.$el[0].f7Modal) {
        delete modal.$el[0].f7Modal;
      }
    }
    Utils.deleteProps(modal);
    modal.destroyed = true;
  }
}

class CustomModal extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      backdrop: true,
      closeByBackdropClick: true,
      on: {},
    }, params);

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const customModal = this;

    customModal.params = extendedParams;

    // Find Element
    let $el;
    if (!customModal.params.el) {
      $el = $(customModal.params.content);
    } else {
      $el = $(customModal.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return customModal.destroy();
    }
    let $backdropEl;
    if (customModal.params.backdrop) {
      $backdropEl = app.root.children('.custom-modal-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="custom-modal-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    function handleClick(e) {
      if (!customModal || customModal.destroyed) return;
      if ($backdropEl && e.target === $backdropEl[0]) {
        customModal.close();
      }
    }

    customModal.on('customModalOpened', () => {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app.on('click', handleClick);
      }
    });
    customModal.on('customModalClose', () => {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app.off('click', handleClick);
      }
    });

    Utils.extend(customModal, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'customModal',
    });

    $el[0].f7Modal = customModal;

    return customModal;
  }
}

var Modal$1 = {
  name: 'modal',
  static: {
    Modal,
    CustomModal,
  },
  create() {
    const app = this;
    app.customModal = {
      create(params) {
        return new CustomModal(app, params);
      },
    };
  },
  params: {
    modal: {
      moveToRoot: true,
      queueDialogs: true,
    },
  },
};

var Appbar = {
  name: 'appbar',
};

class Dialog extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      title: app.params.dialog.title,
      text: undefined,
      content: '',
      buttons: [],
      verticalButtons: false,
      onClick: undefined,
      cssClass: undefined,
      destroyOnClose: false,
      on: {},
    }, params);
    if (typeof extendedParams.closeByBackdropClick === 'undefined') {
      extendedParams.closeByBackdropClick = app.params.dialog.closeByBackdropClick;
    }
    if (typeof extendedParams.backdrop === 'undefined') {
      extendedParams.backdrop = app.params.dialog.backdrop;
    }

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const dialog = this;

    const { title, text, content, buttons, verticalButtons, cssClass, backdrop } = extendedParams;

    dialog.params = extendedParams;

    // Find Element
    let $el;
    if (!dialog.params.el) {
      const dialogClasses = ['dialog'];
      if (buttons.length === 0) dialogClasses.push('dialog-no-buttons');
      if (buttons.length > 0) dialogClasses.push(`dialog-buttons-${buttons.length}`);
      if (verticalButtons) dialogClasses.push('dialog-buttons-vertical');
      if (cssClass) dialogClasses.push(cssClass);

      let buttonsHTML = '';
      if (buttons.length > 0) {
        buttonsHTML = `
          <div class="dialog-buttons">
            ${buttons.map(button => `
              <span class="dialog-button${button.bold ? ' dialog-button-bold' : ''}${button.color ? ` color-${button.color}` : ''}${button.cssClass ? ` ${button.cssClass}` : ''}">${button.text}</span>
            `).join('')}
          </div>
        `;
      }

      const dialogHtml = `
        <div class="${dialogClasses.join(' ')}">
          <div class="dialog-inner">
            ${title ? `<div class="dialog-title">${title}</div>` : ''}
            ${text ? `<div class="dialog-text">${text}</div>` : ''}
            ${content}
          </div>
          ${buttonsHTML}
        </div>
      `;
      $el = $(dialogHtml);
    } else {
      $el = $(dialog.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return dialog.destroy();
    }

    let $backdropEl;
    if (backdrop) {
      $backdropEl = app.root.children('.dialog-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="dialog-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    // Assign events
    function buttonOnClick(e) {
      const buttonEl = this;
      const index = $(buttonEl).index();
      const button = buttons[index];
      if (button.onClick) button.onClick(dialog, e);
      if (dialog.params.onClick) dialog.params.onClick(dialog, index);
      if (button.close !== false) dialog.close();
    }
    let addKeyboardHander;
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      buttons.forEach((button, index) => {
        if (button.keyCodes && button.keyCodes.indexOf(keyCode) >= 0) {
          if (doc.activeElement) doc.activeElement.blur();
          if (button.onClick) button.onClick(dialog, e);
          if (dialog.params.onClick) dialog.params.onClick(dialog, index);
          if (button.close !== false) dialog.close();
        }
      });
    }
    if (buttons && buttons.length > 0) {
      dialog.on('open', () => {
        $el.find('.dialog-button').each((index, buttonEl) => {
          const button = buttons[index];
          if (button.keyCodes) addKeyboardHander = true;
          $(buttonEl).on('click', buttonOnClick);
        });
        if (
          addKeyboardHander
          && !app.device.ios
          && !app.device.android
          && !app.device.cordova
        ) {
          $(doc).on('keydown', onKeyDown);
        }
      });
      dialog.on('close', () => {
        $el.find('.dialog-button').each((index, buttonEl) => {
          $(buttonEl).off('click', buttonOnClick);
        });
        if (
          addKeyboardHander
          && !app.device.ios
          && !app.device.android
          && !app.device.cordova
        ) {
          $(doc).off('keydown', onKeyDown);
        }
        addKeyboardHander = false;
      });
    }
    Utils.extend(dialog, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'dialog',
      setProgress(progress, duration) {
        app.progressbar.set($el.find('.progressbar'), progress, duration);
        return dialog;
      },
      setText(newText) {
        let $textEl = $el.find('.dialog-text');
        if ($textEl.length === 0) {
          $textEl = $('<div class="dialog-text"></div>');
          if (typeof title !== 'undefined') {
            $textEl.insertAfter($el.find('.dialog-title'));
          } else {
            $el.find('.dialog-inner').prepend($textEl);
          }
        }
        $textEl.html(newText);
        dialog.params.text = newText;
        return dialog;
      },
      setTitle(newTitle) {
        let $titleEl = $el.find('.dialog-title');
        if ($titleEl.length === 0) {
          $titleEl = $('<div class="dialog-title"></div>');
          $el.find('.dialog-inner').prepend($titleEl);
        }
        $titleEl.html(newTitle);
        dialog.params.title = newTitle;
        return dialog;
      },
    });

    function handleClick(e) {
      const target = e.target;
      const $target = $(target);
      if ($target.closest(dialog.el).length === 0) {
        if (
          dialog.params.closeByBackdropClick
          && dialog.backdropEl
          && dialog.backdropEl === target
        ) {
          dialog.close();
        }
      }
    }

    dialog.on('opened', () => {
      if (dialog.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    dialog.on('close', () => {
      if (dialog.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }
    });

    $el[0].f7Modal = dialog;

    if (dialog.params.destroyOnClose) {
      dialog.once('closed', () => {
        setTimeout(() => {
          dialog.destroy();
        }, 0);
      });
    }

    return dialog;
  }
}

var Dialog$1 = {
  name: 'dialog',
  params: {
    dialog: {
      title: undefined,
      buttonOk: 'OK',
      buttonCancel: 'Cancel',
      usernamePlaceholder: 'Username',
      passwordPlaceholder: 'Password',
      preloaderTitle: 'Loading... ',
      progressTitle: 'Loading... ',
      backdrop: true,
      closeByBackdropClick: false,
      destroyPredefinedDialogs: true,
      keyboardActions: true,
      autoFocus: true,
    },
  },
  static: {
    Dialog,
  },
  create() {
    const app = this;
    function defaultDialogTitle() {
      return app.params.dialog.title || app.name;
    }
    const destroyOnClose = app.params.dialog.destroyPredefinedDialogs;
    const keyboardActions = app.params.dialog.keyboardActions;
    const autoFocus = app.params.dialog.autoFocus;
    const autoFocusHandler = (autoFocus ? {
      on: {
        opened(dialog) {
          dialog.$el.find('input').eq(0).focus();
        },
      },
    } : {});

    app.dialog = Utils.extend(
      ModalMethods({
        app,
        constructor: Dialog,
        defaultSelector: '.dialog.modal-in',
      }),
      {
        // Shortcuts
        alert(...args) {
          let [text, title, callbackOk] = args;
          if (args.length === 2 && typeof args[1] === 'function') {
            [text, callbackOk, title] = args;
          }
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
            text,
            buttons: [{
              text: app.params.dialog.buttonOk,
              bold: true,
              onClick: callbackOk,
              keyCodes: keyboardActions ? [13, 27] : null,
            }],
            destroyOnClose,
          }).open();
        },
        prompt(...args) {
          let [text, title, callbackOk, callbackCancel, defaultValue] = args;
          if (typeof args[1] === 'function') {
            [text, callbackOk, callbackCancel, defaultValue, title] = args;
          }
          defaultValue = typeof defaultValue === 'undefined' || defaultValue === null ? '' : defaultValue;
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
            text,
            content: `<div class="dialog-input-field input"><input type="text" class="dialog-input" value="${defaultValue}"></div>`,
            buttons: [
              {
                text: app.params.dialog.buttonCancel,
                keyCodes: keyboardActions ? [27] : null,
                color: app.theme === 'aurora' ? 'gray' : null,
              },
              {
                text: app.params.dialog.buttonOk,
                bold: true,
                keyCodes: keyboardActions ? [13] : null,
              },
            ],
            onClick(dialog, index) {
              const inputValue = dialog.$el.find('.dialog-input').val();
              if (index === 0 && callbackCancel) callbackCancel(inputValue);
              if (index === 1 && callbackOk) callbackOk(inputValue);
            },
            destroyOnClose,
            ...autoFocusHandler,
          }).open();
        },
        confirm(...args) {
          let [text, title, callbackOk, callbackCancel] = args;
          if (typeof args[1] === 'function') {
            [text, callbackOk, callbackCancel, title] = args;
          }
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
            text,
            buttons: [
              {
                text: app.params.dialog.buttonCancel,
                onClick: callbackCancel,
                keyCodes: keyboardActions ? [27] : null,
                color: app.theme === 'aurora' ? 'gray' : null,
              },
              {
                text: app.params.dialog.buttonOk,
                bold: true,
                onClick: callbackOk,
                keyCodes: keyboardActions ? [13] : null,
              },
            ],
            destroyOnClose,
          }).open();
        },
        login(...args) {
          let [text, title, callbackOk, callbackCancel] = args;
          if (typeof args[1] === 'function') {
            [text, callbackOk, callbackCancel, title] = args;
          }
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
            text,
            content: `
              <div class="dialog-input-field dialog-input-double input">
                <input type="text" name="dialog-username" placeholder="${app.params.dialog.usernamePlaceholder}" class="dialog-input">
              </div>
              <div class="dialog-input-field dialog-input-double input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
            buttons: [
              {
                text: app.params.dialog.buttonCancel,
                keyCodes: keyboardActions ? [27] : null,
                color: app.theme === 'aurora' ? 'gray' : null,
              },
              {
                text: app.params.dialog.buttonOk,
                bold: true,
                keyCodes: keyboardActions ? [13] : null,
              },
            ],
            onClick(dialog, index) {
              const username = dialog.$el.find('[name="dialog-username"]').val();
              const password = dialog.$el.find('[name="dialog-password"]').val();
              if (index === 0 && callbackCancel) callbackCancel(username, password);
              if (index === 1 && callbackOk) callbackOk(username, password);
            },
            destroyOnClose,
            ...autoFocusHandler,
          }).open();
        },
        password(...args) {
          let [text, title, callbackOk, callbackCancel] = args;
          if (typeof args[1] === 'function') {
            [text, callbackOk, callbackCancel, title] = args;
          }
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
            text,
            content: `
              <div class="dialog-input-field input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
            buttons: [
              {
                text: app.params.dialog.buttonCancel,
                keyCodes: keyboardActions ? [27] : null,
                color: app.theme === 'aurora' ? 'gray' : null,
              },
              {
                text: app.params.dialog.buttonOk,
                bold: true,
                keyCodes: keyboardActions ? [13] : null,
              },
            ],
            onClick(dialog, index) {
              const password = dialog.$el.find('[name="dialog-password"]').val();
              if (index === 0 && callbackCancel) callbackCancel(password);
              if (index === 1 && callbackOk) callbackOk(password);
            },
            destroyOnClose,
            ...autoFocusHandler,
          }).open();
        },
        preloader(title, color) {
          const preloaderInner = Utils[`${app.theme}PreloaderContent`] || '';
          return new Dialog(app, {
            title: typeof title === 'undefined' || title === null ? app.params.dialog.preloaderTitle : title,
            content: `<div class="preloader${color ? ` color-${color}` : ''}">${preloaderInner}</div>`,
            cssClass: 'dialog-preloader',
            destroyOnClose,
          }).open();
        },
        progress(...args) {
          let [title, progress, color] = args;
          if (args.length === 2) {
            if (typeof args[0] === 'number') {
              [progress, color, title] = args;
            } else if (typeof args[0] === 'string' && typeof args[1] === 'string') {
              [title, color, progress] = args;
            }
          } else if (args.length === 1) {
            if (typeof args[0] === 'number') {
              [progress, title, color] = args;
            }
          }
          const infinite = typeof progress === 'undefined';
          const dialog = new Dialog(app, {
            title: typeof title === 'undefined' ? app.params.dialog.progressTitle : title,
            cssClass: 'dialog-progress',
            content: `
              <div class="progressbar${infinite ? '-infinite' : ''}${color ? ` color-${color}` : ''}">
                ${!infinite ? '<span></span>' : ''}
              </div>
            `,
            destroyOnClose,
          });
          if (!infinite) dialog.setProgress(progress);
          return dialog.open();
        },
      }
    );
  },
};

class Popup extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend(
      { on: {} },
      app.params.popup,
      params
    );

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const popup = this;

    popup.params = extendedParams;

    // Find Element
    let $el;
    if (!popup.params.el) {
      $el = $(popup.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
    } else {
      $el = $(popup.params.el).eq(0);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return popup.destroy();
    }

    let $backdropEl;
    if (popup.params.backdrop && popup.params.backdropEl) {
      $backdropEl = $(popup.params.backdropEl);
    } else if (popup.params.backdrop) {
      $backdropEl = app.root.children('.popup-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="popup-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    Utils.extend(popup, {
      app,
      push: $el.hasClass('popup-push') || popup.params.push,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'popup',
      $htmlEl: $('html'),
    });

    if (popup.params.push) {
      $el.addClass('popup-push');
    }

    function handleClick(e) {
      const target = e.target;
      const $target = $(target);
      const keyboardOpened = !app.device.desktop && app.device.cordova && ((win.Keyboard && win.Keyboard.isVisible) || (win.cordova.plugins && win.cordova.plugins.Keyboard && win.cordova.plugins.Keyboard.isVisible));
      if (keyboardOpened) return;
      if ($target.closest(popup.el).length === 0) {
        if (
          popup.params
          && popup.params.closeByBackdropClick
          && popup.params.backdrop
          && popup.backdropEl
          && popup.backdropEl === target
        ) {
          let needToClose = true;
          popup.$el.nextAll('.popup.modal-in').each((index, popupEl) => {
            const popupInstance = popupEl.f7Modal;
            if (!popupInstance) return;
            if (
              popupInstance.params.closeByBackdropClick
              && popupInstance.params.backdrop
              && popupInstance.backdropEl === popup.backdropEl
            ) {
              needToClose = false;
            }
          });
          if (needToClose) {
            popup.close();
          }
        }
      }
    }

    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && popup.params.closeOnEscape) {
        popup.close();
      }
    }

    let pushOffset;
    let isPush;

    function pushViewScale(offset) {
      return (app.height - offset * 2) / app.height;
    }

    let allowSwipeToClose = true;
    let isTouched = false;
    let startTouch;
    let currentTouch;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let isMoved = false;
    let pageContentEl;
    let pageContentScrollTop;
    let pageContentOffsetHeight;
    let pageContentScrollHeight;
    let popupHeight;
    let $pushEl;

    function handleTouchStart(e) {
      if (isTouched || !allowSwipeToClose || !popup.params.swipeToClose) return;
      if (popup.params.swipeHandler && $(e.target).closest(popup.params.swipeHandler).length === 0) {
        return;
      }
      isTouched = true;
      isMoved = false;
      startTouch = {
        x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY,
      };
      touchStartTime = Utils.now();
      isScrolling = undefined;
      if (!popup.params.swipeHandler && e.type === 'touchstart') {
        pageContentEl = $(e.target).closest('.page-content')[0];
      }
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      currentTouch = {
        x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY,
      };

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }

      touchesDiff = startTouch.y - currentTouch.y;
      if (isPush && pushOffset && touchesDiff > 0) {
        touchesDiff = 0;
      }
      const direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';
      $el.transition(0);

      if (typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose) {
        $el.transform('');
        $el.transition('');
        return;
      }

      if (!isMoved) {
        if (isPush && pushOffset) {
          popupHeight = $el[0].offsetHeight;
          $pushEl = $el.prevAll('.popup.modal-in').eq(0);
          if ($pushEl.length === 0) {
            $pushEl = app.root.children('.view, .views');
          }
        }
        if (pageContentEl) {
          pageContentScrollTop = pageContentEl.scrollTop;
          pageContentScrollHeight = pageContentEl.scrollHeight;
          pageContentOffsetHeight = pageContentEl.offsetHeight;
          if (
            !(pageContentScrollHeight === pageContentOffsetHeight)
            && !(direction === 'to-bottom' && pageContentScrollTop === 0)
            && !(direction === 'to-top' && pageContentScrollTop === (pageContentScrollHeight - pageContentOffsetHeight))
          ) {
            $el.transform('');
            $el.transition('');
            isTouched = false;
            isMoved = false;
            return;
          }
        }
        isMoved = true;
        popup.emit('local::swipeStart popupSwipeStart', popup);
        popup.$el.trigger('popup:swipestart');
      } else {
        popup.emit('local::swipeMove popupSwipeMove', popup);
        popup.$el.trigger('popup:swipemove');
      }

      e.preventDefault();
      if (isPush && pushOffset) {
        const pushProgress = 1 - Math.abs(touchesDiff / popupHeight);
        const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
        if ($pushEl.hasClass('popup')) {
          if ($pushEl.hasClass('popup-push')) {
            $pushEl.transition(0).transform(
              `translate3d(0, calc(-1 * ${pushProgress} * (var(--f7-popup-push-offset) + 10px)) , 0px) scale(${scale})`
            );
          } else {
            $pushEl.transition(0).transform(
              `translate3d(0, 0px , 0px) scale(${scale})`
            );
          }
        } else {
          $pushEl.transition(0).transform(`translate3d(0,0,0) scale(${scale})`);
        }
      }
      $el.transition(0).transform(`translate3d(0,${-touchesDiff}px,0)`);
    }
    function handleTouchEnd() {
      isTouched = false;
      if (!isMoved) {
        return;
      }
      popup.emit('local::swipeEnd popupSwipeEnd', popup);
      popup.$el.trigger('popup:swipeend');
      isMoved = false;
      allowSwipeToClose = false;
      $el.transition('');
      if (isPush && pushOffset) {
        $pushEl.transition('').transform('');
      }
      const direction = touchesDiff <= 0 ? 'to-bottom' : 'to-top';
      if ((typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose)) {
        $el.transform('');
        allowSwipeToClose = true;
        return;
      }
      const diff = Math.abs(touchesDiff);
      const timeDiff = (new Date()).getTime() - touchStartTime;
      if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > 100)) {
        Utils.nextTick(() => {
          if (direction === 'to-bottom') {
            $el.addClass('swipe-close-to-bottom');
          } else {
            $el.addClass('swipe-close-to-top');
          }
          $el.transform('');
          popup.emit('local::swipeclose popupSwipeClose', popup);
          popup.$el.trigger('popup:swipeclose');
          popup.close();
          allowSwipeToClose = true;
        });
        return;
      }
      allowSwipeToClose = true;
      $el.transform('');
    }

    const passive = Support.passiveListener ? { passive: true } : false;
    if (popup.params.swipeToClose) {
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      popup.once('popupDestroy', () => {
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off('touchmove', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      });
    }

    let hasPreviousPushPopup;

    popup.on('open', () => {
      hasPreviousPushPopup = false;
      if (popup.params.closeOnEscape) {
        $(doc).on('keydown', onKeyDown);
      }
      $el.prevAll('.popup.modal-in').addClass('popup-behind');
      if (popup.push) {
        isPush = popup.push && (
          (app.width < 630 || app.height < 630)
          || $el.hasClass('popup-tablet-fullscreen')
        );
      }
      if (isPush) {
        pushOffset = parseInt($el.css('--f7-popup-push-offset'), 10);
        if (Number.isNaN(pushOffset)) pushOffset = 0;
        if (pushOffset) {
          $el.addClass('popup-push');
          popup.$htmlEl.addClass('with-modal-popup-push');
          popup.$htmlEl[0].style.setProperty('--f7-popup-push-scale', pushViewScale(pushOffset));
        }
      }
    });
    popup.on('opened', () => {
      $el.removeClass('swipe-close-to-bottom swipe-close-to-top');
      if (popup.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    popup.on('close', () => {
      hasPreviousPushPopup = popup.$el.prevAll('.popup-push.modal-in').length > 0;
      if (popup.params.closeOnEscape) {
        $(doc).off('keydown', onKeyDown);
      }
      if (popup.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }
      $el.prevAll('.popup.modal-in').eq(0).removeClass('popup-behind');
      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass('with-modal-popup-push');
        popup.$htmlEl.addClass('with-modal-popup-push-closing');
      }
    });
    popup.on('closed', () => {
      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass('with-modal-popup-push-closing');
        popup.$htmlEl[0].style.removeProperty('--f7-popup-push-scale');
      }
    });

    $el[0].f7Modal = popup;

    return popup;
  }
}

var Popup$1 = {
  name: 'popup',
  params: {
    popup: {
      backdrop: true,
      backdropEl: undefined,
      closeByBackdropClick: true,
      closeOnEscape: false,
      swipeToClose: false,
      swipeHandler: null,
      push: false,
    },
  },
  static: {
    Popup,
  },
  create() {
    const app = this;
    app.popup = ModalMethods({
      app,
      constructor: Popup,
      defaultSelector: '.popup.modal-in',
      parentSelector: '.popup',
    });
  },
  clicks: {
    '.popup-open': function openPopup($clickedEl, data = {}) {
      const app = this;
      app.popup.open(data.popup, data.animate, $clickedEl);
    },
    '.popup-close': function closePopup($clickedEl, data = {}) {
      const app = this;
      app.popup.close(data.popup, data.animate, $clickedEl);
    },
  },
};

class LoginScreen extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      on: {},
    }, params);

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const loginScreen = this;

    loginScreen.params = extendedParams;

    // Find Element
    let $el;
    if (!loginScreen.params.el) {
      $el = $(loginScreen.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
    } else {
      $el = $(loginScreen.params.el).eq(0);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return loginScreen.destroy();
    }

    Utils.extend(loginScreen, {
      app,
      $el,
      el: $el[0],
      type: 'loginScreen',
    });

    $el[0].f7Modal = loginScreen;

    return loginScreen;
  }
}

var LoginScreen$1 = {
  name: 'loginScreen',
  static: {
    LoginScreen,
  },
  create() {
    const app = this;
    app.loginScreen = ModalMethods({
      app,
      constructor: LoginScreen,
      defaultSelector: '.login-screen.modal-in',
    });
  },
  clicks: {
    '.login-screen-open': function openLoginScreen($clickedEl, data = {}) {
      const app = this;
      app.loginScreen.open(data.loginScreen, data.animate, $clickedEl);
    },
    '.login-screen-close': function closeLoginScreen($clickedEl, data = {}) {
      const app = this;
      app.loginScreen.close(data.loginScreen, data.animate, $clickedEl);
    },
  },
};

class Popover extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend(
      { on: {} },
      app.params.popover,
      params
    );

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const popover = this;

    popover.params = extendedParams;

    // Find Element
    let $el;
    if (!popover.params.el) {
      $el = $(popover.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
    } else {
      $el = $(popover.params.el).eq(0);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    // Find Target
    const $targetEl = $(popover.params.targetEl).eq(0);

    if ($el.length === 0) {
      return popover.destroy();
    }

    // Backdrop
    let $backdropEl;
    if (popover.params.backdrop && popover.params.backdropEl) {
      $backdropEl = $(popover.params.backdropEl);
    } else if (popover.params.backdrop) {
      $backdropEl = app.root.children('.popover-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="popover-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    // Find Angle
    let $angleEl;
    if ($el.find('.popover-angle').length === 0) {
      $angleEl = $('<div class="popover-angle"></div>');
      $el.prepend($angleEl);
    } else {
      $angleEl = $el.find('.popover-angle');
    }

    // Open
    const originalOpen = popover.open;

    Utils.extend(popover, {
      app,
      $el,
      el: $el[0],
      $targetEl,
      targetEl: $targetEl[0],
      $angleEl,
      angleEl: $angleEl[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'popover',
      open(...args) {
        let [targetEl, animate] = args;
        if (typeof args[0] === 'boolean') [animate, targetEl] = args;
        if (targetEl) {
          popover.$targetEl = $(targetEl);
          popover.targetEl = popover.$targetEl[0];
        }
        return originalOpen.call(popover, animate);
      },
    });

    function handleResize() {
      popover.resize();
    }
    popover.on('popoverOpen', () => {
      popover.resize();
      app.on('resize', handleResize);
      $(win).on('keyboardDidShow keyboardDidHide', handleResize);
      popover.on('popoverClose popoverBeforeDestroy', () => {
        app.off('resize', handleResize);
        $(win).off('keyboardDidShow keyboardDidHide', handleResize);
      });
    });

    function handleClick(e) {
      const target = e.target;
      const $target = $(target);
      const keyboardOpened = !app.device.desktop && app.device.cordova && ((win.Keyboard && win.Keyboard.isVisible) || (win.cordova.plugins && win.cordova.plugins.Keyboard && win.cordova.plugins.Keyboard.isVisible));
      if (keyboardOpened) return;
      if ($target.closest(popover.el).length === 0) {
        if (
          popover.params.closeByBackdropClick
          && popover.params.backdrop
          && popover.backdropEl
          && popover.backdropEl === target
        ) {
          popover.close();
        } else if (popover.params.closeByOutsideClick) {
          popover.close();
        }
      }
    }

    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && popover.params.closeOnEscape) {
        popover.close();
      }
    }

    if (popover.params.closeOnEscape) {
      popover.on('popoverOpen', () => {
        $(doc).on('keydown', onKeyDown);
      });
      popover.on('popoverClose', () => {
        $(doc).off('keydown', onKeyDown);
      });
    }

    popover.on('popoverOpened', () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    popover.on('popoverClose', () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }
    });

    $el[0].f7Modal = popover;

    return popover;
  }

  resize() {
    const popover = this;
    const { app, $el, $targetEl, $angleEl } = popover;
    const { targetX, targetY } = popover.params;
    $el.css({ left: '', top: '' });
    const [width, height] = [$el.width(), $el.height()];
    let angleSize = 0;
    let angleLeft;
    let angleTop;
    if (app.theme === 'ios' || app.theme === 'aurora') {
      $angleEl.removeClass('on-left on-right on-top on-bottom').css({ left: '', top: '' });
      angleSize = $angleEl.width() / 2;
    } else {
      $el.removeClass('popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle').css({ left: '', top: '' });
    }

    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    let safeAreaTop = parseInt($('html').css('--f7-safe-area-top'), 10);
    if (Number.isNaN(safeAreaTop)) safeAreaTop = 0;
    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();

      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - app.left;
      targetOffsetTop = targetOffset.top - app.top;

      const targetParentPage = $targetEl.parents('.page');
      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    } else if (typeof targetX !== 'undefined' && targetY !== 'undefined') {
      targetOffsetLeft = targetX;
      targetOffsetTop = targetY;
      targetWidth = popover.params.targetWidth || 0;
      targetHeight = popover.params.targetHeight || 0;
    }

    let [left, top, diff] = [0, 0, 0];
    // Top Position
    let position = app.theme === 'md' ? 'bottom' : 'top';
    if (app.theme === 'md') {
      if (height < app.height - targetOffsetTop - targetHeight) {
        // On bottom
        position = 'bottom';
        top = targetOffsetTop + targetHeight;
      } else if (height < targetOffsetTop - safeAreaTop) {
        // On top
        top = targetOffsetTop - height;
        position = 'top';
      } else {
        // On middle
        position = 'middle';
        top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
      }
      top = Math.max(8, Math.min(top, app.height - height - 8));

      // Horizontal Position
      let hPosition;
      if (targetOffsetLeft < app.width / 2) {
        hPosition = 'right';
        left = position === 'middle'
          ? targetOffsetLeft + targetWidth
          : targetOffsetLeft;
      } else {
        hPosition = 'left';
        left = position === 'middle'
          ? targetOffsetLeft - width
          : (targetOffsetLeft + targetWidth) - width;
      }
      left = Math.max(8, Math.min(left, app.width - width - 8));
      $el.addClass(`popover-on-${position} popover-on-${hPosition}`);
    } else {
      // ios and aurora
      if ((height + angleSize) < targetOffsetTop - safeAreaTop) {
        // On top
        top = targetOffsetTop - height - angleSize;
      } else if ((height + angleSize) < app.height - targetOffsetTop - targetHeight) {
        // On bottom
        position = 'bottom';
        top = targetOffsetTop + targetHeight + angleSize;
      } else {
        // On middle
        position = 'middle';
        top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
        diff = top;
        top = Math.max(5, Math.min(top, app.height - height - 5));
        diff -= top;
      }

      // Horizontal Position
      if (position === 'top' || position === 'bottom') {
        left = ((targetWidth / 2) + targetOffsetLeft) - (width / 2);
        diff = left;
        left = Math.max(5, Math.min(left, app.width - width - 5));
        if (position === 'top') {
          $angleEl.addClass('on-bottom');
        }
        if (position === 'bottom') {
          $angleEl.addClass('on-top');
        }
        diff -= left;
        angleLeft = ((width / 2) - angleSize) + diff;
        angleLeft = Math.max(Math.min(angleLeft, width - (angleSize * 2) - 13), 13);
        $angleEl.css({ left: `${angleLeft}px` });
      } else if (position === 'middle') {
        left = targetOffsetLeft - width - angleSize;
        $angleEl.addClass('on-right');
        if (left < 5 || (left + width > app.width)) {
          if (left < 5) left = targetOffsetLeft + targetWidth + angleSize;
          if (left + width > app.width) left = app.width - width - 5;
          $angleEl.removeClass('on-right').addClass('on-left');
        }
        angleTop = ((height / 2) - angleSize) + diff;
        angleTop = Math.max(Math.min(angleTop, height - (angleSize * 2) - 13), 13);
        $angleEl.css({ top: `${angleTop}px` });
      }
    }

    // Apply Styles
    $el.css({ top: `${top}px`, left: `${left}px` });
  }
}

var Popover$1 = {
  name: 'popover',
  params: {
    popover: {
      backdrop: true,
      backdropEl: undefined,
      closeByBackdropClick: true,
      closeByOutsideClick: true,
      closeOnEscape: false,
    },
  },
  static: {
    Popover,
  },
  create() {
    const app = this;
    app.popover = Utils.extend(
      ModalMethods({
        app,
        constructor: Popover,
        defaultSelector: '.popover.modal-in',
      }),
      {
        open(popoverEl, targetEl, animate) {
          let $popoverEl = $(popoverEl);
          if ($popoverEl.length > 1) {
            // check if same popover in other page
            const $targetPage = $(targetEl).parents('.page');
            if ($targetPage.length) {
              $popoverEl.each((index, el) => {
                const $el = $(el);
                if ($el.parents($targetPage)[0] === $targetPage[0]) {
                  $popoverEl = $el;
                }
              });
            }
          }
          if ($popoverEl.length > 1) {
            $popoverEl = $popoverEl.eq($popoverEl.length - 1);
          }
          let popover = $popoverEl[0].f7Modal;
          const data = $popoverEl.dataset();
          if (!popover) {
            popover = new Popover(app, Object.assign(
              {
                el: $popoverEl,
                targetEl,
              },
              data
            ));
          }
          return popover.open(targetEl, animate);
        },
      }
    );
  },
  clicks: {
    '.popover-open': function openPopover($clickedEl, data = {}) {
      const app = this;
      app.popover.open(data.popover, $clickedEl, data.animate);
    },
    '.popover-close': function closePopover($clickedEl, data = {}) {
      const app = this;
      app.popover.close(data.popover, data.animate, $clickedEl);
    },
  },
};

class Actions extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend(
      { on: {} },
      app.params.actions,
      params
    );

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const actions = this;

    actions.params = extendedParams;

    // Buttons
    let groups;
    if (actions.params.buttons) {
      groups = actions.params.buttons;
      if (!Array.isArray(groups[0])) groups = [groups];
    }
    actions.groups = groups;

    // Find Element
    let $el;
    if (actions.params.el) {
      $el = $(actions.params.el).eq(0);
    } else if (actions.params.content) {
      $el = $(actions.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
    } else if (actions.params.buttons) {
      if (actions.params.convertToPopover) {
        actions.popoverHtml = actions.renderPopover();
      }
      actions.actionsHtml = actions.render();
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el && $el.length === 0 && !(actions.actionsHtml || actions.popoverHtml)) {
      return actions.destroy();
    }

    // Backdrop
    let $backdropEl;
    if (actions.params.backdrop && actions.params.backdropEl) {
      $backdropEl = $(actions.params.backdropEl);
    } else if (actions.params.backdrop) {
      $backdropEl = app.root.children('.actions-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="actions-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    const originalOpen = actions.open;
    const originalClose = actions.close;

    let popover;
    function buttonOnClick(e) {
      const $buttonEl = $(this);
      let buttonIndex;
      let groupIndex;
      if ($buttonEl.hasClass('list-button') || $buttonEl.hasClass('item-link')) {
        buttonIndex = $buttonEl.parents('li').index();
        groupIndex = $buttonEl.parents('.list').index();
      } else {
        buttonIndex = $buttonEl.index();
        groupIndex = $buttonEl.parents('.actions-group').index();
      }
      if (typeof groups !== 'undefined') {
        const button = groups[groupIndex][buttonIndex];
        if (button.onClick) button.onClick(actions, e);
        if (actions.params.onClick) actions.params.onClick(actions, e);
        if (button.close !== false) actions.close();
      }
    }
    actions.open = function open(animate) {
      let convertToPopover = false;
      const { targetEl, targetX, targetY, targetWidth, targetHeight } = actions.params;
      if (actions.params.convertToPopover && (targetEl || (targetX !== undefined && targetY !== undefined))) {
        // Popover
        if (
          actions.params.forceToPopover
          || (app.device.ios && app.device.ipad)
          || app.width >= 768
          || (app.device.desktop && app.theme === 'aurora')
        ) {
          convertToPopover = true;
        }
      }
      if (convertToPopover && actions.popoverHtml) {
        popover = app.popover.create({
          content: actions.popoverHtml,
          backdrop: actions.params.backdrop,
          targetEl,
          targetX,
          targetY,
          targetWidth,
          targetHeight,
          on: {
            open() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:open ${actions.type.toLowerCase()}:open`);
              actions.emit(`local::open modalOpen ${actions.type}Open`, actions);
            },
            opened() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:opened ${actions.type.toLowerCase()}:opened`);
              actions.emit(`local::opened modalOpened ${actions.type}Opened`, actions);
            },
            close() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:close ${actions.type.toLowerCase()}:close`);
              actions.emit(`local::close modalClose ${actions.type}Close`, actions);
            },
            closed() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:closed ${actions.type.toLowerCase()}:closed`);
              actions.emit(`local::closed modalClosed ${actions.type}Closed`, actions);
            },
          },
        });
        popover.open(animate);
        popover.once('popoverOpened', () => {
          popover.$el.find('.list-button, .item-link').each((groupIndex, buttonEl) => {
            $(buttonEl).on('click', buttonOnClick);
          });
        });
        popover.once('popoverClosed', () => {
          popover.$el.find('.list-button, .item-link').each((groupIndex, buttonEl) => {
            $(buttonEl).off('click', buttonOnClick);
          });
          Utils.nextTick(() => {
            popover.destroy();
            popover = undefined;
          });
        });
      } else {
        actions.$el = actions.actionsHtml ? $(actions.actionsHtml) : actions.$el;
        actions.$el[0].f7Modal = actions;
        if (actions.groups) {
          actions.$el.find('.actions-button').each((groupIndex, buttonEl) => {
            $(buttonEl).on('click', buttonOnClick);
          });
          actions.once('actionsClosed', () => {
            actions.$el.find('.actions-button').each((groupIndex, buttonEl) => {
              $(buttonEl).off('click', buttonOnClick);
            });
          });
        }
        actions.el = actions.$el[0];
        originalOpen.call(actions, animate);
      }
      return actions;
    };

    actions.close = function close(animate) {
      if (popover) {
        popover.close(animate);
      } else {
        originalClose.call(actions, animate);
      }
      return actions;
    };

    Utils.extend(actions, {
      app,
      $el,
      el: $el ? $el[0] : undefined,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'actions',
    });

    function handleClick(e) {
      const target = e.target;
      const $target = $(target);
      const keyboardOpened = !app.device.desktop && app.device.cordova && ((win.Keyboard && win.Keyboard.isVisible) || (win.cordova.plugins && win.cordova.plugins.Keyboard && win.cordova.plugins.Keyboard.isVisible));
      if (keyboardOpened) return;
      if ($target.closest(actions.el).length === 0) {
        if (
          actions.params.closeByBackdropClick
          && actions.params.backdrop
          && actions.backdropEl
          && actions.backdropEl === target
        ) {
          actions.close();
        } else if (actions.params.closeByOutsideClick) {
          actions.close();
        }
      }
    }

    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && actions.params.closeOnEscape) {
        actions.close();
      }
    }

    if (actions.params.closeOnEscape) {
      actions.on('open', () => {
        $(doc).on('keydown', onKeyDown);
      });
      actions.on('close', () => {
        $(doc).off('keydown', onKeyDown);
      });
    }

    actions.on('opened', () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.on('click', handleClick);
      }
    });
    actions.on('close', () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.off('click', handleClick);
      }
    });

    if ($el) {
      $el[0].f7Modal = actions;
    }

    return actions;
  }

  render() {
    const actions = this;
    if (actions.params.render) return actions.params.render.call(actions, actions);
    const { groups } = actions;
    const cssClass = actions.params.cssClass;
    return `
      <div class="actions-modal${actions.params.grid ? ' actions-grid' : ''} ${cssClass || ''}">
        ${groups.map(group => `<div class="actions-group">
            ${group.map((button) => {
              const buttonClasses = [`actions-${button.label ? 'label' : 'button'}`];
              const { color, bg, bold, disabled, label, text, icon } = button;
              if (color) buttonClasses.push(`color-${color}`);
              if (bg) buttonClasses.push(`bg-color-${bg}`);
              if (bold) buttonClasses.push('actions-button-bold');
              if (disabled) buttonClasses.push('disabled');
              if (label) {
                return `<div class="${buttonClasses.join(' ')}">${text}</div>`;
              }
              return `
                <div class="${buttonClasses.join(' ')}">
                  ${icon ? `<div class="actions-button-media">${icon}</div>` : ''}
                  <div class="actions-button-text">${text}</div>
                </div>`.trim();
            }).join('')}
          </div>`).join('')}
      </div>
    `.trim();
  }

  renderPopover() {
    const actions = this;
    if (actions.params.renderPopover) return actions.params.renderPopover.call(actions, actions);
    const { groups } = actions;
    const cssClass = actions.params.cssClass;
    return `
      <div class="popover popover-from-actions ${cssClass || ''}">
        <div class="popover-inner">
          ${groups.map(group => `
            <div class="list">
              <ul>
                ${group.map((button) => {
                  const itemClasses = [];
                  const { color, bg, bold, disabled, label, text, icon } = button;
                  if (color) itemClasses.push(`color-${color}`);
                  if (bg) itemClasses.push(`bg-color-${bg}`);
                  if (bold) itemClasses.push('popover-from-actions-bold');
                  if (disabled) itemClasses.push('disabled');
                  if (label) {
                    itemClasses.push('popover-from-actions-label');
                    return `<li class="${itemClasses.join(' ')}">${text}</li>`;
                  }
                  if (icon) {
                    itemClasses.push('item-link item-content');
                    return `
                      <li>
                        <a class="${itemClasses.join(' ')}">
                          <div class="item-media">
                            ${icon}
                          </div>
                          <div class="item-inner">
                            <div class="item-title">
                              ${text}
                            </div>
                          </div>
                        </a>
                      </li>
                    `;
                  }
                  itemClasses.push('list-button');
                  return `
                    <li>
                      <a class="${itemClasses.join(' ')}">${text}</a>
                    </li>
                  `;
                }).join('')}
              </ul>
            </div>
          `).join('')}
        </div>
      </div>
    `.trim();
  }
}

var Actions$1 = {
  name: 'actions',
  params: {
    actions: {
      convertToPopover: true,
      forceToPopover: false,
      backdrop: true,
      backdropEl: undefined,
      cssClass: null,
      closeByBackdropClick: true,
      closeOnEscape: false,
      render: null,
      renderPopover: null,
    },
  },
  static: {
    Actions,
  },
  create() {
    const app = this;
    app.actions = ModalMethods({
      app,
      constructor: Actions,
      defaultSelector: '.actions-modal.modal-in',
    });
  },
  clicks: {
    '.actions-open': function openActions($clickedEl, data = {}) {
      const app = this;
      app.actions.open(data.actions, data.animate, $clickedEl);
    },
    '.actions-close': function closeActions($clickedEl, data = {}) {
      const app = this;
      app.actions.close(data.actions, data.animate, $clickedEl);
    },
  },
};

class Sheet extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend(
      { on: {} },
      app.params.sheet,
      params
    );

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const sheet = this;

    sheet.params = extendedParams;
    if (typeof sheet.params.backdrop === 'undefined') {
      sheet.params.backdrop = app.theme !== 'ios';
    }

    // Find Element
    let $el;
    if (!sheet.params.el) {
      $el = $(sheet.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
    } else {
      $el = $(sheet.params.el).eq(0);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return sheet.destroy();
    }
    let $backdropEl;

    if (sheet.params.backdrop && sheet.params.backdropEl) {
      $backdropEl = $(sheet.params.backdropEl);
    } else if (sheet.params.backdrop) {
      $backdropEl = app.root.children('.sheet-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="sheet-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    Utils.extend(sheet, {
      app,
      push: $el.hasClass('sheet-modal-push') || sheet.params.push,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'sheet',
      $htmlEl: $('html'),
    });

    if (sheet.params.push) {
      $el.addClass('sheet-modal-push');
    }

    let $pageContentEl;
    function scrollToElementOnOpen() {
      const $scrollEl = $(sheet.params.scrollToEl).eq(0);
      if ($scrollEl.length === 0) return;
      $pageContentEl = $scrollEl.parents('.page-content');
      if ($pageContentEl.length === 0) return;

      const paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
      const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
      const pageHeight = $pageContentEl[0].offsetHeight - paddingTop - $el.height();
      const pageScrollHeight = $pageContentEl[0].scrollHeight - paddingTop - $el.height();
      const pageScroll = $pageContentEl.scrollTop();

      let newPaddingBottom;

      const scrollElTop = ($scrollEl.offset().top - paddingTop) + $scrollEl[0].offsetHeight;
      if (scrollElTop > pageHeight) {
        const scrollTop = (pageScroll + scrollElTop) - pageHeight;
        if (scrollTop + pageHeight > pageScrollHeight) {
          newPaddingBottom = ((scrollTop + pageHeight) - pageScrollHeight) + paddingBottom;
          if (pageHeight === pageScrollHeight) {
            newPaddingBottom = $el.height();
          }
          $pageContentEl.css({
            'padding-bottom': `${newPaddingBottom}px`,
          });
        }
        $pageContentEl.scrollTop(scrollTop, 300);
      }
    }

    function scrollToElementOnClose() {
      if ($pageContentEl && $pageContentEl.length > 0) {
        $pageContentEl.css({
          'padding-bottom': '',
        });
      }
    }
    function handleClick(e) {
      const target = e.target;
      const $target = $(target);
      const keyboardOpened = !app.device.desktop && app.device.cordova && ((win.Keyboard && win.Keyboard.isVisible) || (win.cordova.plugins && win.cordova.plugins.Keyboard && win.cordova.plugins.Keyboard.isVisible));
      if (keyboardOpened) return;
      if ($target.closest(sheet.el).length === 0) {
        if (
          sheet.params.closeByBackdropClick
          && sheet.params.backdrop
          && sheet.backdropEl
          && sheet.backdropEl === target
        ) {
          sheet.close();
        } else if (sheet.params.closeByOutsideClick) {
          sheet.close();
        }
      }
    }

    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && sheet.params.closeOnEscape) {
        sheet.close();
      }
    }

    let pushOffset;

    function pushViewScale(offset) {
      return (app.height - offset * 2) / app.height;
    }


    let isTouched = false;
    let startTouch;
    let currentTouch;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let isMoved = false;
    let isTopSheetModal;
    let swipeStepTranslate;
    let startTranslate;
    let currentTranslate;
    let sheetElOffsetHeight;
    let minTranslate;
    let maxTranslate;
    let $pushViewEl;
    let pushBorderRadius;
    let sheetPageContentEl;
    let sheetPageContentScrollTop;
    let sheetPageContentScrollHeight;
    let sheetPageContentOffsetHeight;

    function handleTouchStart(e) {
      if (isTouched || !(sheet.params.swipeToClose || sheet.params.swipeToStep)) return;
      if (sheet.params.swipeHandler && $(e.target).closest(sheet.params.swipeHandler).length === 0) {
        return;
      }
      isTouched = true;
      isMoved = false;
      startTouch = {
        x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY,
      };
      touchStartTime = Utils.now();
      isScrolling = undefined;
      isTopSheetModal = $el.hasClass('sheet-modal-top');
      if (!sheet.params.swipeHandler && e.type === 'touchstart') {
        sheetPageContentEl = $(e.target).closest('.page-content')[0];
      }
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      currentTouch = {
        x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY,
      };

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }

      touchesDiff = startTouch.y - currentTouch.y;

      const direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';

      if (!isMoved) {
        if (sheetPageContentEl && !$el.hasClass('modal-in-swipe-step')) {
          sheetPageContentScrollTop = sheetPageContentEl.scrollTop;
          sheetPageContentScrollHeight = sheetPageContentEl.scrollHeight;
          sheetPageContentOffsetHeight = sheetPageContentEl.offsetHeight;
          if (
            !(sheetPageContentScrollHeight === sheetPageContentOffsetHeight)
            && !(direction === 'to-bottom' && sheetPageContentScrollTop === 0)
            && !(direction === 'to-top' && sheetPageContentScrollTop === (sheetPageContentScrollHeight - sheetPageContentOffsetHeight))
          ) {
            $el.transform('');
            isTouched = false;
            isMoved = false;
            return;
          }
        }
        if (sheet.push && pushOffset) {
          $pushViewEl = app.root.children('.view, .views');
        }
        sheetElOffsetHeight = $el[0].offsetHeight;
        startTranslate = Utils.getTranslate($el[0], 'y');
        if (isTopSheetModal) {
          minTranslate = sheet.params.swipeToClose ? -sheetElOffsetHeight : -swipeStepTranslate;
          maxTranslate = 0;
        } else {
          minTranslate = 0;
          maxTranslate = sheet.params.swipeToClose ? sheetElOffsetHeight : swipeStepTranslate;
        }
        isMoved = true;
      }
      currentTranslate = startTranslate - touchesDiff;
      currentTranslate = Math.min(Math.max(currentTranslate, minTranslate), maxTranslate);
      e.preventDefault();
      if (sheet.push && pushOffset) {
        let progress = (currentTranslate - startTranslate) / sheetElOffsetHeight;
        if (sheet.params.swipeToStep) {
          if (isTopSheetModal) {
            progress = (currentTranslate / swipeStepTranslate);
          } else {
            progress = 1 - (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
          }
        }
        progress = Math.abs(progress);
        progress = Math.min(Math.max(progress, 0), 1);
        const pushProgress = 1 - progress;
        const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
        $pushViewEl.transition(0).transform(`translate3d(0,0,0) scale(${scale})`);
        if (sheet.params.swipeToStep) {
          $pushViewEl.css('border-radius', `${pushBorderRadius * pushProgress}px`);
        }
      }
      $el
        .transition(0)
        .transform(`translate3d(0,${currentTranslate}px,0)`);
      if (sheet.params.swipeToStep) {
        let progress;
        if (isTopSheetModal) {
          progress = 1 - (currentTranslate / swipeStepTranslate);
        } else {
          progress = (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
        }
        progress = Math.min(Math.max(progress, 0), 1);
        $el.trigger('sheet:stepprogress', progress);
        sheet.emit('local::stepProgress sheetStepProgress', sheet, progress);
      }
    }
    function handleTouchEnd() {
      isTouched = false;
      if (!isMoved) {
        return;
      }
      isMoved = false;
      $el.transform('').transition('');
      if (sheet.push && pushOffset) {
        $pushViewEl.transition('').transform('');
        $pushViewEl.css('border-radius', '');
      }

      const direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';

      const diff = Math.abs(touchesDiff);
      if (diff === 0 || currentTranslate === startTranslate) return;

      const timeDiff = (new Date()).getTime() - touchStartTime;

      if (!sheet.params.swipeToStep) {
        if (direction !== (isTopSheetModal ? 'to-top' : 'to-bottom')) {
          return;
        }
        if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > (sheetElOffsetHeight / 2))) {
          sheet.close();
        }
        return;
      }

      const openDirection = isTopSheetModal ? 'to-bottom' : 'to-top';
      const closeDirection = isTopSheetModal ? 'to-top' : 'to-bottom';
      const absCurrentTranslate = Math.abs(currentTranslate);
      const absSwipeStepTranslate = Math.abs(swipeStepTranslate);

      if (timeDiff < 300 && diff > 10) {
        if (direction === openDirection && absCurrentTranslate < absSwipeStepTranslate) {
          // open step
          $el.removeClass('modal-in-swipe-step');
          $el.trigger('sheet:stepprogress', 1);
          sheet.emit('local::stepProgress sheetStepProgress', sheet, 1);
          $el.trigger('sheet:stepopen');
          sheet.emit('local::stepOpen sheetStepOpen', sheet);
          if (sheet.push && pushOffset) {
            sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
            $pushViewEl.css('border-radius', '');
          }
        }
        if (direction === closeDirection && absCurrentTranslate > absSwipeStepTranslate) {
          // close sheet
          if (sheet.params.swipeToClose) {
            sheet.close();
          } else {
            // close step
            $el.addClass('modal-in-swipe-step');
            $el.trigger('sheet:stepprogress', 0);
            sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
            $el.trigger('sheet:stepclose');
            sheet.emit('local::stepClose sheetStepClose', sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
              $pushViewEl.css('border-radius', '0px');
            }
          }
        }
        if (direction === closeDirection && absCurrentTranslate <= absSwipeStepTranslate) {
          // close step
          $el.addClass('modal-in-swipe-step');
          $el.trigger('sheet:stepprogress', 0);
          sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
          $el.trigger('sheet:stepclose');
          sheet.emit('local::stepClose sheetStepClose', sheet);
          if (sheet.push && pushOffset) {
            sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
            $pushViewEl.css('border-radius', '0px');
          }
        }
        return;
      }
      if (timeDiff >= 300) {
        const stepOpened = !$el.hasClass('modal-in-swipe-step');
        if (!stepOpened) {
          if (absCurrentTranslate < (absSwipeStepTranslate / 2)) {
            // open step
            $el.removeClass('modal-in-swipe-step');
            $el.trigger('sheet:stepprogress', 1);
            sheet.emit('local::stepProgress sheetStepProgress', sheet, 1);
            $el.trigger('sheet:stepopen');
            sheet.emit('local::stepOpen sheetStepOpen', sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
              $pushViewEl.css('border-radius', '');
            }
          } else if ((absCurrentTranslate - absSwipeStepTranslate) > (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
            // close sheet
            if (sheet.params.swipeToClose) sheet.close();
          }
        } else if (stepOpened) {
          if (absCurrentTranslate > absSwipeStepTranslate + (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
            // close sheet
            if (sheet.params.swipeToClose) sheet.close();
          } else if (absCurrentTranslate > absSwipeStepTranslate / 2) {
            // close step
            $el.addClass('modal-in-swipe-step');
            $el.trigger('sheet:stepprogress', 0);
            sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
            $el.trigger('sheet:stepclose');
            sheet.emit('local::stepClose sheetStepClose', sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
              $pushViewEl.css('border-radius', '0px');
            }
          }
        }
      }
    }

    sheet.setSwipeStep = function setSwipeStep(byResize = true) {
      const $swipeStepEl = $el.find('.sheet-modal-swipe-step').eq(0);
      if (!$swipeStepEl.length) return;
      if ($el.hasClass('sheet-modal-top')) {
        swipeStepTranslate = -($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
      } else {
        swipeStepTranslate = $el[0].offsetHeight - ($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
      }
      $el[0].style.setProperty('--f7-sheet-swipe-step', `${swipeStepTranslate}px`);
      if (!byResize) {
        $el.addClass('modal-in-swipe-step');
      }
    };

    function onResize() {
      sheet.setSwipeStep(true);
    }

    const passive = Support.passiveListener ? { passive: true } : false;
    if (sheet.params.swipeToClose || sheet.params.swipeToStep) {
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      sheet.once('sheetDestroy', () => {
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off('touchmove', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      });
    }

    sheet.on('open', () => {
      if (sheet.params.closeOnEscape) {
        $(doc).on('keydown', onKeyDown);
      }
      $el.prevAll('.popup.modal-in').addClass('popup-behind');
      if (sheet.params.swipeToStep) {
        sheet.setSwipeStep(false);
        app.on('resize', onResize);
      }
      if (sheet.params.scrollToEl) {
        scrollToElementOnOpen();
      }

      if (sheet.push) {
        pushOffset = parseInt($el.css('--f7-sheet-push-offset'), 10);
        if (Number.isNaN(pushOffset)) pushOffset = 0;
        if (pushOffset) {
          $el.addClass('sheet-modal-push');
          sheet.$htmlEl.addClass('with-modal-sheet-push');
          if (!sheet.params.swipeToStep) {
            sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
          } else {
            $pushViewEl = app.root.children('.view, .views');
            pushBorderRadius = parseFloat($el.css(`border-${isTopSheetModal ? 'bottom' : 'top'}-left-radius`));
            $pushViewEl.css('border-radius', '0px');
          }
        }
      }
    });
    sheet.on('opened', () => {
      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    sheet.on('close', () => {
      if (sheet.params.swipeToStep) {
        $el.removeClass('modal-in-swipe-step');
        app.off('resize', onResize);
      }
      if (sheet.params.closeOnEscape) {
        $(doc).off('keydown', onKeyDown);
      }
      if (sheet.params.scrollToEl) {
        scrollToElementOnClose();
      }
      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }
      $el.prevAll('.popup.modal-in').eq(0).removeClass('popup-behind');
      if (sheet.push && pushOffset) {
        sheet.$htmlEl.removeClass('with-modal-sheet-push');
        sheet.$htmlEl.addClass('with-modal-sheet-push-closing');
      }
    });
    sheet.on('closed', () => {
      if (sheet.push && pushOffset) {
        sheet.$htmlEl.removeClass('with-modal-sheet-push-closing');
        sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
      }
    });

    sheet.stepOpen = function stepOpen() {
      $el.removeClass('modal-in-swipe-step');
      if (sheet.push) {
        if (!pushOffset) {
          pushOffset = parseInt($el.css('--f7-sheet-push-offset'), 10);
          if (Number.isNaN(pushOffset)) pushOffset = 0;
        }
        if (pushOffset) {
          sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
        }
      }
    };
    sheet.stepClose = function stepClose() {
      $el.addClass('modal-in-swipe-step');
      if (sheet.push) {
        sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
      }
    };
    sheet.stepToggle = function stepToggle() {
      $el.toggleClass('modal-in-swipe-step');
    };

    $el[0].f7Modal = sheet;

    return sheet;
  }
}

var Sheet$1 = {
  name: 'sheet',
  params: {
    sheet: {
      push: false,
      backdrop: undefined,
      backdropEl: undefined,
      closeByBackdropClick: true,
      closeByOutsideClick: false,
      closeOnEscape: false,
      swipeToClose: false,
      swipeToStep: false,
      swipeHandler: null,
    },
  },
  static: {
    Sheet,
  },
  create() {
    const app = this;
    app.sheet = Utils.extend(
      {},
      ModalMethods({
        app,
        constructor: Sheet,
        defaultSelector: '.sheet-modal.modal-in',
      }),
      {
        stepOpen(sheet) {
          const sheetInstance = app.sheet.get(sheet);
          if (sheetInstance && sheetInstance.stepOpen) return sheetInstance.stepOpen();
          return undefined;
        },
        stepClose(sheet) {
          const sheetInstance = app.sheet.get(sheet);
          if (sheetInstance && sheetInstance.stepClose) return sheetInstance.stepClose();
          return undefined;
        },
        stepToggle(sheet) {
          const sheetInstance = app.sheet.get(sheet);
          if (sheetInstance && sheetInstance.stepToggle) return sheetInstance.stepToggle();
          return undefined;
        },
      },
    );
  },
  clicks: {
    '.sheet-open': function openSheet($clickedEl, data = {}) {
      const app = this;
      if ($('.sheet-modal.modal-in').length > 0 && data.sheet && $(data.sheet)[0] !== $('.sheet-modal.modal-in')[0]) {
        app.sheet.close('.sheet-modal.modal-in');
      }
      app.sheet.open(data.sheet, data.animate, $clickedEl);
    },
    '.sheet-close': function closeSheet($clickedEl, data = {}) {
      const app = this;
      app.sheet.close(data.sheet, data.animate, $clickedEl);
    },
  },
};

class Toast extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      on: {},
    }, app.params.toast, params);

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const toast = this;

    toast.app = app;

    toast.params = extendedParams;

    const { closeButton, closeTimeout } = toast.params;

    let $el;
    if (!toast.params.el) {
      // Find Element
      const toastHtml = toast.render();

      $el = $(toastHtml);
    } else {
      $el = $(toast.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return toast.destroy();
    }

    Utils.extend(toast, {
      $el,
      el: $el[0],
      type: 'toast',
    });

    $el[0].f7Modal = toast;

    if (closeButton) {
      $el.find('.toast-button').on('click', () => {
        toast.emit('local::closeButtonClick toastCloseButtonClick', toast);
        toast.close();
      });

      toast.on('beforeDestroy', () => {
        $el.find('.toast-button').off('click');
      });
    }

    let timeoutId;
    toast.on('open', () => {
      $('.toast.modal-in').each((index, openedEl) => {
        const toastInstance = app.toast.get(openedEl);
        if (openedEl !== toast.el && toastInstance) {
          toastInstance.close();
        }
      });
      if (closeTimeout) {
        timeoutId = Utils.nextTick(() => {
          toast.close();
        }, closeTimeout);
      }
    });
    toast.on('close', () => {
      win.clearTimeout(timeoutId);
    });

    if (toast.params.destroyOnClose) {
      toast.once('closed', () => {
        setTimeout(() => {
          toast.destroy();
        }, 0);
      });
    }

    return toast;
  }

  render() {
    const toast = this;
    if (toast.params.render) return toast.params.render.call(toast, toast);
    const { position, horizontalPosition, cssClass, icon, text, closeButton, closeButtonColor, closeButtonText } = toast.params;
    const horizontalClass = position === 'top' || position === 'bottom'
      ? `toast-horizontal-${horizontalPosition}`
      : '';
    return `
      <div class="toast toast-${position} ${horizontalClass} ${cssClass || ''} ${icon ? 'toast-with-icon' : ''}">
        <div class="toast-content">
          ${icon ? `<div class="toast-icon">${icon}</div>` : ''}
          <div class="toast-text">${text}</div>
          ${closeButton && !icon ? `
          <a class="toast-button button ${closeButtonColor ? `color-${closeButtonColor}` : ''}">${closeButtonText}</a>
          `.trim() : ''}
        </div>
      </div>
    `.trim();
  }
}

var Toast$1 = {
  name: 'toast',
  static: {
    Toast,
  },
  create() {
    const app = this;
    app.toast = Utils.extend(
      {},
      ModalMethods({
        app,
        constructor: Toast,
        defaultSelector: '.toast.modal-in',
      }),
      {
        // Shortcuts
        show(params) {
          Utils.extend(params, {
            destroyOnClose: true,
          });
          return new Toast(app, params).open();
        },
      }
    );
  },
  params: {
    toast: {
      icon: null,
      text: null,
      position: 'bottom',
      horizontalPosition: 'left',
      closeButton: false,
      closeButtonColor: null,
      closeButtonText: 'Ok',
      closeTimeout: null,
      cssClass: null,
      render: null,
    },
  },
};

const Preloader = {
  init(el) {
    const app = this;
    const $el = $(el);
    if ($el.length === 0 || $el.children('.preloader-inner').length > 0 || $el.children('.preloader-inner-line').length > 0) return;
    $el.append(Utils[`${app.theme}PreloaderContent`]);
  },
  // Modal
  visible: false,
  show(color = 'white') {
    const app = this;
    if (Preloader.visible) return;
    const preloaderInner = Utils[`${app.theme}PreloaderContent`] || '';
    $('html').addClass('with-modal-preloader');
    app.root.append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
    Preloader.visible = true;
  },
  showIn(el, color = 'white') {
    const app = this;
    const preloaderInner = Utils[`${app.theme}PreloaderContent`] || '';
    $(el || 'html').addClass('with-modal-preloader');
    $(el || app.root).append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
  },
  hide() {
    const app = this;
    if (!Preloader.visible) return;
    $('html').removeClass('with-modal-preloader');
    app.root.find('.preloader-backdrop, .preloader-modal').remove();
    Preloader.visible = false;
  },
  hideIn(el) {
    const app = this;
    $(el || 'html').removeClass('with-modal-preloader');
    $(el || app.root).find('.preloader-backdrop, .preloader-modal').remove();
  },
};
var Preloader$1 = {
  name: 'preloader',
  create() {
    const app = this;
    Utils.extend(app, {
      preloader: {
        init: Preloader.init.bind(app),
        show: Preloader.show.bind(app),
        hide: Preloader.hide.bind(app),
        showIn: Preloader.showIn.bind(app),
        hideIn: Preloader.hideIn.bind(app),
      },
    });
  },
  on: {
    photoBrowserOpen(pb) {
      const app = this;
      pb.$el.find('.preloader').each((index, preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.preloader').each((index, preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.preloader').each((index, preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    },
  },
  vnode: {
    preloader: {
      insert(vnode) {
        const app = this;
        const preloaderEl = vnode.elm;
        app.preloader.init(preloaderEl);
      },
    },
  },
};

const Progressbar = {
  set(...args) {
    const app = this;
    let [el, progress, duration] = args;
    if (typeof args[0] === 'number') {
      [progress, duration] = args;
      el = app.root;
    }
    if (typeof progress === 'undefined' || progress === null) return el;
    if (!progress) progress = 0;

    const $el = $(el || app.root);
    if ($el.length === 0) {
      return el;
    }
    const progressNormalized = Math.min(Math.max(progress, 0), 100);
    let $progressbarEl;
    if ($el.hasClass('progressbar')) $progressbarEl = $el.eq(0);
    else {
      $progressbarEl = $el.children('.progressbar');
    }
    if ($progressbarEl.length === 0 || $progressbarEl.hasClass('progressbar-infinite')) {
      return $progressbarEl;
    }
    let $progressbarLine = $progressbarEl.children('span');
    if ($progressbarLine.length === 0) {
      $progressbarLine = $('<span></span>');
      $progressbarEl.append($progressbarLine);
    }
    $progressbarLine
      .transition(typeof duration !== 'undefined' ? duration : '')
      .transform(`translate3d(${(-100 + progressNormalized)}%,0,0)`);

    return $progressbarEl[0];
  },
  show(...args) {
    const app = this;

    // '.page', 50, 'multi'
    let [el, progress, color] = args;
    let type = 'determined';

    if (args.length === 2) {
      if ((typeof args[0] === 'string' || typeof args[0] === 'object') && typeof args[1] === 'string') {
        // '.page', 'multi'
        [el, color, progress] = args;
        type = 'infinite';
      } else if (typeof args[0] === 'number' && typeof args[1] === 'string') {
        // 50, 'multi'
        [progress, color] = args;
        el = app.root;
      }
    } else if (args.length === 1) {
      if (typeof args[0] === 'number') {
        el = app.root;
        progress = args[0];
      } else if (typeof args[0] === 'string') {
        type = 'infinite';
        el = app.root;
        color = args[0];
      }
    } else if (args.length === 0) {
      type = 'infinite';
      el = app.root;
    }

    const $el = $(el);
    if ($el.length === 0) return undefined;

    let $progressbarEl;
    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children('.progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)');
      if ($progressbarEl.length === 0) {
        $progressbarEl = $(`
          <span class="progressbar${type === 'infinite' ? '-infinite' : ''}${color ? ` color-${color}` : ''} progressbar-in">
            ${type === 'infinite' ? '' : '<span></span>'}
          </span>`);
        $el.append($progressbarEl);
      }
    }

    if (typeof progress !== 'undefined') {
      app.progressbar.set($progressbarEl, progress);
    }

    return $progressbarEl[0];
  },
  hide(el, removeAfterHide = true) {
    const app = this;
    const $el = $(el || app.root);
    if ($el.length === 0) return undefined;
    let $progressbarEl;
    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children('.progressbar, .progressbar-infinite');
    }
    if ($progressbarEl.length === 0 || !$progressbarEl.hasClass('progressbar-in') || $progressbarEl.hasClass('progressbar-out')) {
      return $progressbarEl;
    }
    $progressbarEl
      .removeClass('progressbar-in')
      .addClass('progressbar-out')
      .animationEnd(() => {
        if (removeAfterHide) {
          $progressbarEl.remove();
        }
      });
    return $progressbarEl;
  },
};

var Progressbar$1 = {
  name: 'progressbar',
  create() {
    const app = this;
    Utils.extend(app, {
      progressbar: {
        set: Progressbar.set.bind(app),
        show: Progressbar.show.bind(app),
        hide: Progressbar.hide.bind(app),
      },
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.progressbar').each((index, progressbarEl) => {
        const $progressbarEl = $(progressbarEl);
        app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.progressbar').each((index, progressbarEl) => {
        const $progressbarEl = $(progressbarEl);
        app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
      });
    },
  },
  vnode: {
    progressbar: {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        app.progressbar.set(el, el.getAttribute('data-progress'));
      },
      update(vnode) {
        const app = this;
        const el = vnode.elm;
        app.progressbar.set(el, el.getAttribute('data-progress'));
      },
    },
  },
};

const Sortable = {
  init() {
    const app = this;
    let isTouched;
    let isMoved;
    let touchStartY;
    let touchesDiff;
    let $sortingEl;
    let $sortingItems;
    let $sortableContainer;
    let sortingElHeight;
    let minTop;
    let maxTop;
    let $insertAfterEl;
    let $insertBeforeEl;
    let indexFrom;
    let $pageEl;
    let $pageContentEl;
    let pageHeight;
    let pageOffset;
    let sortingElOffsetLocal;
    let sortingElOffsetTop;
    let initialScrollTop;
    let wasTapHold;

    function handleTouchStart(e, isTapHold) {
      isMoved = false;
      isTouched = true;
      wasTapHold = false;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      $sortingEl = $(e.target).closest('li').eq(0);
      indexFrom = $sortingEl.index();
      $sortableContainer = $sortingEl.parents('.sortable');
      const $listGroup = $sortingEl.parents('.list-group');
      if ($listGroup.length && $listGroup.parents($sortableContainer).length) {
        $sortableContainer = $listGroup;
      }
      $sortingItems = $sortableContainer.children('ul').children('li:not(.disallow-sorting):not(.no-sorting)');
      if (app.panel) app.panel.allowOpen = false;
      if (app.swipeout) app.swipeout.allow = false;
      if (isTapHold) {
        $sortingEl.addClass('sorting');
        $sortableContainer.addClass('sortable-sorting');
        wasTapHold = true;
      }
    }
    function handleTouchMove(e) {
      if (!isTouched || !$sortingEl) return;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (!isMoved) {
        $pageEl = $sortingEl.parents('.page');
        $pageContentEl = $sortingEl.parents('.page-content');
        const paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
        const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
        initialScrollTop = $pageContentEl[0].scrollTop;
        pageOffset = $pageEl.offset().top + paddingTop;
        pageHeight = $pageEl.height() - paddingTop - paddingBottom;
        $sortingEl.addClass('sorting');
        $sortableContainer.addClass('sortable-sorting');
        sortingElOffsetLocal = $sortingEl[0].offsetTop;
        minTop = $sortingEl[0].offsetTop;
        maxTop = $sortingEl.parent().height() - sortingElOffsetLocal - $sortingEl.height();
        sortingElHeight = $sortingEl[0].offsetHeight;
        sortingElOffsetTop = $sortingEl.offset().top;
      }
      isMoved = true;

      e.preventDefault();
      e.f7PreventSwipePanel = true;

      touchesDiff = pageY - touchStartY;

      const translateScrollOffset = $pageContentEl[0].scrollTop - initialScrollTop;
      const translate = Math.min(Math.max(touchesDiff + translateScrollOffset, -minTop), maxTop);
      $sortingEl.transform(`translate3d(0,${translate}px,0)`);

      const scrollAddition = 44;
      let allowScroll = true;
      if ((touchesDiff + translateScrollOffset) + scrollAddition < -minTop) {
        allowScroll = false;
      }
      if ((touchesDiff + translateScrollOffset) - scrollAddition > maxTop) {
        allowScroll = false;
      }

      $insertBeforeEl = undefined;
      $insertAfterEl = undefined;

      let scrollDiff;
      if (allowScroll) {
        if (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition > pageOffset + pageHeight) {
          // To Bottom
          scrollDiff = (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition) - (pageOffset + pageHeight);
        }
        if (sortingElOffsetTop + touchesDiff < pageOffset + scrollAddition) {
          // To Top
          scrollDiff = (sortingElOffsetTop + touchesDiff) - pageOffset - scrollAddition;
        }
        if (scrollDiff) {
          $pageContentEl[0].scrollTop += scrollDiff;
        }
      }

      $sortingItems.each((index, el) => {
        const $currentEl = $(el);
        if ($currentEl[0] === $sortingEl[0]) return;
        const currentElOffset = $currentEl[0].offsetTop;
        const currentElHeight = $currentEl.height();
        const sortingElOffset = sortingElOffsetLocal + translate;

        if ((sortingElOffset >= currentElOffset - (currentElHeight / 2)) && $sortingEl.index() < $currentEl.index()) {
          $currentEl.transform(`translate3d(0, ${-sortingElHeight}px,0)`);
          $insertAfterEl = $currentEl;
          $insertBeforeEl = undefined;
        } else if ((sortingElOffset <= currentElOffset + (currentElHeight / 2)) && $sortingEl.index() > $currentEl.index()) {
          $currentEl.transform(`translate3d(0, ${sortingElHeight}px,0)`);
          $insertAfterEl = undefined;
          if (!$insertBeforeEl) $insertBeforeEl = $currentEl;
        } else {
          $currentEl.transform('translate3d(0, 0%,0)');
        }
      });
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        if (isTouched && !isMoved) {
          if (app.panel) app.panel.allowOpen = true;
          if (app.swipeout) app.swipeout.allow = true;
          if (wasTapHold) {
            $sortingEl.removeClass('sorting');
            $sortableContainer.removeClass('sortable-sorting');
          }
        }
        isTouched = false;
        isMoved = false;
        return;
      }
      if (app.panel) app.panel.allowOpen = true;
      if (app.swipeout) app.swipeout.allow = true;

      $sortingItems.transform('');
      $sortingEl.removeClass('sorting');
      $sortableContainer.removeClass('sortable-sorting');

      let indexTo;
      if ($insertAfterEl) indexTo = $insertAfterEl.index();
      else if ($insertBeforeEl) indexTo = $insertBeforeEl.index();

      let moveElements = $sortableContainer.dataset().sortableMoveElements;
      if (typeof moveElements === 'undefined') {
        moveElements = app.params.sortable.moveElements;
      }

      if (moveElements) {
        if ($insertAfterEl) {
          $sortingEl.insertAfter($insertAfterEl);
        }
        if ($insertBeforeEl) {
          $sortingEl.insertBefore($insertBeforeEl);
        }
      }

      if (($insertAfterEl || $insertBeforeEl)
         && $sortableContainer.hasClass('virtual-list')
      ) {
        indexFrom = $sortingEl[0].f7VirtualListIndex;
        if (typeof indexFrom === 'undefined') indexFrom = $sortingEl.attr('data-virtual-list-index');
        if ($insertBeforeEl) {
          indexTo = $insertBeforeEl[0].f7VirtualListIndex;
          if (typeof indexTo === 'undefined') indexTo = $insertBeforeEl.attr('data-virtual-list-index');
        } else {
          indexTo = $insertAfterEl[0].f7VirtualListIndex;
          if (typeof indexTo === 'undefined') indexTo = $insertAfterEl.attr('data-virtual-list-index');
        }
        if (indexTo !== null) indexTo = parseInt(indexTo, 10);
        else indexTo = undefined;

        const virtualList = $sortableContainer[0].f7VirtualList;

        if (indexFrom) indexFrom = parseInt(indexFrom, 10);
        if (indexTo) indexTo = parseInt(indexTo, 10);
        if (virtualList) virtualList.moveItem(indexFrom, indexTo);
      }
      if (typeof indexTo !== 'undefined' && !Number.isNaN(indexTo) && indexTo !== indexFrom) {
        $sortingEl.trigger('sortable:sort', { from: indexFrom, to: indexTo });
        app.emit('sortableSort', $sortingEl[0], { from: indexFrom, to: indexTo, el: $sortingEl[0] }, $sortableContainer[0]);
      }

      $insertBeforeEl = undefined;
      $insertAfterEl = undefined;
      isTouched = false;
      isMoved = false;
    }

    const activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;

    $(doc).on(app.touchEvents.start, '.list.sortable .sortable-handler', handleTouchStart, activeListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);

    $(doc).on('taphold', '.sortable-tap-hold', (e, pointerEvent) => {
      handleTouchStart(pointerEvent, true);
    });
  },
  enable(el = '.list.sortable') {
    const app = this;
    const $el = $(el);
    if ($el.length === 0) return;
    $el.addClass('sortable-enabled');
    $el.trigger('sortable:enable');
    app.emit('sortableEnable', $el[0]);
  },
  disable(el = '.list.sortable') {
    const app = this;
    const $el = $(el);
    if ($el.length === 0) return;
    $el.removeClass('sortable-enabled');
    $el.trigger('sortable:disable');
    app.emit('sortableDisable', $el[0]);
  },
  toggle(el = '.list.sortable') {
    const app = this;
    const $el = $(el);
    if ($el.length === 0) return;
    if ($el.hasClass('sortable-enabled')) {
      app.sortable.disable($el);
    } else {
      app.sortable.enable($el);
    }
  },
};
var Sortable$1 = {
  name: 'sortable',
  params: {
    sortable: {
      moveElements: true,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      sortable: {
        init: Sortable.init.bind(app),
        enable: Sortable.enable.bind(app),
        disable: Sortable.disable.bind(app),
        toggle: Sortable.toggle.bind(app),
      },
    });
  },
  on: {
    init() {
      const app = this;
      if (!app.params.sortable) return;
      app.sortable.init();
    },
  },
  clicks: {
    '.sortable-enable': function enable($clickedEl, data = {}) {
      const app = this;
      app.sortable.enable(data.sortable);
    },
    '.sortable-disable': function disable($clickedEl, data = {}) {
      const app = this;
      app.sortable.disable(data.sortable);
    },
    '.sortable-toggle': function toggle($clickedEl, data = {}) {
      const app = this;
      app.sortable.toggle(data.sortable);
    },
  },
};

const Swipeout = {
  init() {
    const app = this;
    const touchesStart = {};
    let isTouched;
    let isMoved;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let $swipeoutEl;
    let $swipeoutContent;
    let $actionsRight;
    let $actionsLeft;
    let actionsLeftWidth;
    let actionsRightWidth;
    let translate;
    let opened;
    let openedActionsSide;
    let $leftButtons;
    let $rightButtons;
    let direction;
    let $overswipeLeftButton;
    let $overswipeRightButton;
    let overswipeLeft;
    let overswipeRight;

    function handleTouchStart(e) {
      if (!Swipeout.allow) return;
      isMoved = false;
      isTouched = true;
      isScrolling = undefined;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchStartTime = (new Date()).getTime();
      $swipeoutEl = $(this);
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }

      if (!isMoved) {
        if ($('.list.sortable-opened').length > 0) return;
        $swipeoutContent = $swipeoutEl.find('.swipeout-content');
        $actionsRight = $swipeoutEl.find('.swipeout-actions-right');
        $actionsLeft = $swipeoutEl.find('.swipeout-actions-left');
        actionsLeftWidth = null;
        actionsRightWidth = null;
        $leftButtons = null;
        $rightButtons = null;
        $overswipeRightButton = null;
        $overswipeLeftButton = null;
        if ($actionsLeft.length > 0) {
          actionsLeftWidth = $actionsLeft.outerWidth();
          $leftButtons = $actionsLeft.children('a');
          $overswipeLeftButton = $actionsLeft.find('.swipeout-overswipe');
        }
        if ($actionsRight.length > 0) {
          actionsRightWidth = $actionsRight.outerWidth();
          $rightButtons = $actionsRight.children('a');
          $overswipeRightButton = $actionsRight.find('.swipeout-overswipe');
        }
        opened = $swipeoutEl.hasClass('swipeout-opened');
        if (opened) {
          openedActionsSide = $swipeoutEl.find('.swipeout-actions-left.swipeout-actions-opened').length > 0 ? 'left' : 'right';
        }
        $swipeoutEl.removeClass('swipeout-transitioning');
        if (!app.params.swipeout.noFollow) {
          $swipeoutEl.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
          $swipeoutEl.removeClass('swipeout-opened');
        }
      }
      isMoved = true;
      e.preventDefault();

      touchesDiff = pageX - touchesStart.x;
      translate = touchesDiff;

      if (opened) {
        if (openedActionsSide === 'right') translate -= actionsRightWidth;
        else translate += actionsLeftWidth;
      }

      if (
        (translate > 0 && $actionsLeft.length === 0)
        || (translate < 0 && $actionsRight.length === 0)
      ) {
        if (!opened) {
          isTouched = false;
          isMoved = false;
          $swipeoutContent.transform('');
          if ($rightButtons && $rightButtons.length > 0) {
            $rightButtons.transform('');
          }
          if ($leftButtons && $leftButtons.length > 0) {
            $leftButtons.transform('');
          }
          return;
        }
        translate = 0;
      }

      if (translate < 0) direction = 'to-left';
      else if (translate > 0) direction = 'to-right';
      else if (!direction) direction = 'to-left';

      let buttonOffset;
      let progress;

      e.f7PreventSwipePanel = true;
      if (app.params.swipeout.noFollow) {
        if (opened) {
          if (openedActionsSide === 'right' && touchesDiff > 0) {
            app.swipeout.close($swipeoutEl);
          }
          if (openedActionsSide === 'left' && touchesDiff < 0) {
            app.swipeout.close($swipeoutEl);
          }
        } else {
          if (touchesDiff < 0 && $actionsRight.length > 0) {
            app.swipeout.open($swipeoutEl, 'right');
          }
          if (touchesDiff > 0 && $actionsLeft.length > 0) {
            app.swipeout.open($swipeoutEl, 'left');
          }
        }
        isTouched = false;
        isMoved = false;
        return;
      }
      overswipeLeft = false;
      overswipeRight = false;
      if ($actionsRight.length > 0) {
        // Show right actions
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsRightWidth;
        if (buttonTranslate < -actionsRightWidth) {
          buttonTranslate = -actionsRightWidth - ((-buttonTranslate - actionsRightWidth) ** 0.8);
          translate = buttonTranslate;
          if ($overswipeRightButton.length > 0) {
            overswipeRight = true;
          }
        }
        if (direction !== 'to-left') {
          progress = 0;
          buttonTranslate = 0;
        }
        $rightButtons.each((index, buttonEl) => {
          const $buttonEl = $(buttonEl);
          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if ($overswipeRightButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-left') {
            $buttonEl.css({ left: `${overswipeRight ? -buttonOffset : 0}px` });
            if (overswipeRight) {
              if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
                $swipeoutEl.trigger('swipeout:overswipeenter');
                app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
              }
              $buttonEl.addClass('swipeout-overswipe-active');
            } else {
              if ($buttonEl.hasClass('swipeout-overswipe-active')) {
                $swipeoutEl.trigger('swipeout:overswipeexit');
                app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
              }
              $buttonEl.removeClass('swipeout-overswipe-active');
            }
          }
          $buttonEl.transform(`translate3d(${buttonTranslate - (buttonOffset * (1 + Math.max(progress, -1)))}px,0,0)`);
        });
      }
      if ($actionsLeft.length > 0) {
        // Show left actions
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsLeftWidth;
        if (buttonTranslate > actionsLeftWidth) {
          buttonTranslate = actionsLeftWidth + ((buttonTranslate - actionsLeftWidth) ** 0.8);
          translate = buttonTranslate;
          if ($overswipeLeftButton.length > 0) {
            overswipeLeft = true;
          }
        }
        if (direction !== 'to-right') {
          buttonTranslate = 0;
          progress = 0;
        }
        $leftButtons.each((index, buttonEl) => {
          const $buttonEl = $(buttonEl);
          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if ($overswipeLeftButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-right') {
            $buttonEl.css({ left: `${overswipeLeft ? buttonOffset : 0}px` });
            if (overswipeLeft) {
              if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
                $swipeoutEl.trigger('swipeout:overswipeenter');
                app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
              }
              $buttonEl.addClass('swipeout-overswipe-active');
            } else {
              if ($buttonEl.hasClass('swipeout-overswipe-active')) {
                $swipeoutEl.trigger('swipeout:overswipeexit');
                app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
              }
              $buttonEl.removeClass('swipeout-overswipe-active');
            }
          }
          if ($leftButtons.length > 1) {
            $buttonEl.css('z-index', $leftButtons.length - index);
          }
          $buttonEl.transform(`translate3d(${buttonTranslate + (buttonOffset * (1 - Math.min(progress, 1)))}px,0,0)`);
        });
      }
      $swipeoutEl.trigger('swipeout', progress);
      app.emit('swipeout', $swipeoutEl[0], progress);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }

      isTouched = false;
      isMoved = false;
      const timeDiff = (new Date()).getTime() - touchStartTime;
      const $actions = direction === 'to-left' ? $actionsRight : $actionsLeft;
      const actionsWidth = direction === 'to-left' ? actionsRightWidth : actionsLeftWidth;
      let action;
      let $buttons;
      let i;

      if (
        (
          timeDiff < 300
          && (
            (touchesDiff < -10 && direction === 'to-left')
            || (touchesDiff > 10 && direction === 'to-right')
          )
        )
        || (
          timeDiff >= 300
          && (Math.abs(translate) > actionsWidth / 2)
        )
      ) {
        action = 'open';
      } else {
        action = 'close';
      }
      if (timeDiff < 300) {
        if (Math.abs(translate) === 0) action = 'close';
        if (Math.abs(translate) === actionsWidth) action = 'open';
      }

      if (action === 'open') {
        Swipeout.el = $swipeoutEl[0];
        $swipeoutEl.trigger('swipeout:open');
        app.emit('swipeoutOpen', $swipeoutEl[0]);
        $swipeoutEl.addClass('swipeout-opened swipeout-transitioning');
        const newTranslate = direction === 'to-left' ? -actionsWidth : actionsWidth;
        $swipeoutContent.transform(`translate3d(${newTranslate}px,0,0)`);
        $actions.addClass('swipeout-actions-opened');
        $buttons = direction === 'to-left' ? $rightButtons : $leftButtons;
        if ($buttons) {
          for (i = 0; i < $buttons.length; i += 1) {
            $($buttons[i]).transform(`translate3d(${newTranslate}px,0,0)`);
          }
        }
        if (overswipeRight) {
          $actionsRight.find('.swipeout-overswipe').trigger('click', 'f7Overswipe');
        }
        if (overswipeLeft) {
          $actionsLeft.find('.swipeout-overswipe').trigger('click', 'f7Overswipe');
        }
      } else {
        $swipeoutEl.trigger('swipeout:close');
        app.emit('swipeoutClose', $swipeoutEl[0]);
        Swipeout.el = undefined;
        $swipeoutEl.addClass('swipeout-transitioning').removeClass('swipeout-opened');
        $swipeoutContent.transform('');
        $actions.removeClass('swipeout-actions-opened');
      }

      let buttonOffset;
      if ($leftButtons && $leftButtons.length > 0 && $leftButtons !== $buttons) {
        $leftButtons.each((index, buttonEl) => {
          const $buttonEl = $(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if (typeof buttonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }
          $buttonEl.transform(`translate3d(${buttonOffset}px,0,0)`);
        });
      }
      if ($rightButtons && $rightButtons.length > 0 && $rightButtons !== $buttons) {
        $rightButtons.each((index, buttonEl) => {
          const $buttonEl = $(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if (typeof buttonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }
          $buttonEl.transform(`translate3d(${-buttonOffset}px,0,0)`);
        });
      }
      $swipeoutContent.transitionEnd(() => {
        if ((opened && action === 'open') || (!opened && action === 'close')) return;
        $swipeoutEl.trigger(action === 'open' ? 'swipeout:opened' : 'swipeout:closed');
        app.emit(action === 'open' ? 'swipeoutOpened' : 'swipeoutClosed', $swipeoutEl[0]);
        $swipeoutEl.removeClass('swipeout-transitioning');
        if (opened && action === 'close') {
          if ($actionsRight.length > 0) {
            $rightButtons.transform('');
          }
          if ($actionsLeft.length > 0) {
            $leftButtons.transform('');
          }
        }
      });
    }

    const passiveListener = app.support.passiveListener ? { passive: true } : false;

    app.on('touchstart', (e) => {
      if (Swipeout.el) {
        const $targetEl = $(e.target);
        if (!(
          $(Swipeout.el).is($targetEl[0])
          || $targetEl.parents('.swipeout').is(Swipeout.el)
          || $targetEl.hasClass('modal-in')
          || ($targetEl.attr('class') || '').indexOf('-backdrop') > 0
          || $targetEl.hasClass('actions-modal')
          || $targetEl.parents('.actions-modal.modal-in, .dialog.modal-in').length > 0
        )) {
          app.swipeout.close(Swipeout.el);
        }
      }
    });
    $(doc).on(app.touchEvents.start, 'li.swipeout', handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
  },
  allow: true,
  el: undefined,
  open(...args) {
    const app = this;
    let [el, side, callback] = args;
    if (typeof args[1] === 'function') {
      [el, callback, side] = args;
    }
    const $el = $(el).eq(0);

    if ($el.length === 0) return;
    if (!$el.hasClass('swipeout') || $el.hasClass('swipeout-opened')) return;
    if (!side) {
      if ($el.find('.swipeout-actions-right').length > 0) side = 'right';
      else side = 'left';
    }
    const $swipeoutActions = $el.find(`.swipeout-actions-${side}`);
    const $swipeoutContent = $el.find('.swipeout-content');
    if ($swipeoutActions.length === 0) return;
    $el.trigger('swipeout:open').addClass('swipeout-opened').removeClass('swipeout-transitioning');
    app.emit('swipeoutOpen', $el[0]);
    $swipeoutActions.addClass('swipeout-actions-opened');
    const $buttons = $swipeoutActions.children('a');
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    const translate = side === 'right' ? -swipeoutActionsWidth : swipeoutActionsWidth;
    if ($buttons.length > 1) {
      $buttons.each((buttonIndex, buttonEl) => {
        const $buttonEl = $(buttonEl);
        if (side === 'right') {
          $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
        } else {
          $buttonEl.css('z-index', $buttons.length - buttonIndex).transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
        }
      });
    }
    $el.addClass('swipeout-transitioning');
    $swipeoutContent.transitionEnd(() => {
      $el.trigger('swipeout:opened');
      app.emit('swipeoutOpened', $el[0]);
      if (callback) callback.call($el[0]);
    });
    Utils.nextFrame(() => {
      $buttons.transform(`translate3d(${translate}px,0,0)`);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    });
    Swipeout.el = $el[0];
  },
  close(el, callback) {
    const app = this;
    const $el = $(el).eq(0);
    if ($el.length === 0) return;
    if (!$el.hasClass('swipeout-opened')) return;
    const side = $el.find('.swipeout-actions-opened').hasClass('swipeout-actions-right') ? 'right' : 'left';
    const $swipeoutActions = $el.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
    const $buttons = $swipeoutActions.children('a');
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    Swipeout.allow = false;
    $el.trigger('swipeout:close');
    app.emit('swipeoutClose', $el[0]);
    $el.removeClass('swipeout-opened').addClass('swipeout-transitioning');

    let closeTimeout;
    function onSwipeoutClose() {
      Swipeout.allow = true;
      if ($el.hasClass('swipeout-opened')) return;
      $el.removeClass('swipeout-transitioning');
      $buttons.transform('');
      $el.trigger('swipeout:closed');
      app.emit('swipeoutClosed', $el[0]);
      if (callback) callback.call($el[0]);
      if (closeTimeout) clearTimeout(closeTimeout);
    }
    $el.find('.swipeout-content').transform('').transitionEnd(onSwipeoutClose);
    closeTimeout = setTimeout(onSwipeoutClose, 500);

    $buttons.each((index, buttonEl) => {
      const $buttonEl = $(buttonEl);
      if (side === 'right') {
        $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
      } else {
        $buttonEl.transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
      }
      $buttonEl.css({ left: '0px' }).removeClass('swipeout-overswipe-active');
    });
    if (Swipeout.el && Swipeout.el === $el[0]) Swipeout.el = undefined;
  },
  delete(el, callback) {
    const app = this;
    const $el = $(el).eq(0);
    if ($el.length === 0) return;
    Swipeout.el = undefined;
    $el.trigger('swipeout:delete');
    app.emit('swipeoutDelete', $el[0]);
    $el.css({ height: `${$el.outerHeight()}px` });
    $el.transitionEnd(() => {
      $el.trigger('swipeout:deleted');
      app.emit('swipeoutDeleted', $el[0]);
      if (callback) callback.call($el[0]);
      if ($el.parents('.virtual-list').length > 0) {
        const virtualList = $el.parents('.virtual-list')[0].f7VirtualList;
        const virtualIndex = $el[0].f7VirtualListIndex;
        if (virtualList && typeof virtualIndex !== 'undefined') virtualList.deleteItem(virtualIndex);
      } else if (app.params.swipeout.removeElements) {
        if (app.params.swipeout.removeElementsWithTimeout) {
          setTimeout(() => {
            $el.remove();
          }, app.params.swipeout.removeElementsTimeout);
        } else {
          $el.remove();
        }
      } else {
        $el.removeClass('swipeout-deleting swipeout-transitioning');
      }
    });
    // eslint-disable-next-line
    // $el[0]._clientLeft = $el[0].clientLeft;
    Utils.nextFrame(() => {
      $el
        .addClass('swipeout-deleting swipeout-transitioning')
        .css({ height: '0px' })
        .find('.swipeout-content')
        .transform('translate3d(-100%,0,0)');
    });
  },
};
var Swipeout$1 = {
  name: 'swipeout',
  params: {
    swipeout: {
      actionsNoFold: false,
      noFollow: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      swipeout: {
        init: Swipeout.init.bind(app),
        open: Swipeout.open.bind(app),
        close: Swipeout.close.bind(app),
        delete: Swipeout.delete.bind(app),
      },
    });
    Object.defineProperty(app.swipeout, 'el', {
      enumerable: true,
      configurable: true,
      get: () => Swipeout.el,
      set(el) {
        Swipeout.el = el;
      },
    });
    Object.defineProperty(app.swipeout, 'allow', {
      enumerable: true,
      configurable: true,
      get: () => Swipeout.allow,
      set(allow) {
        Swipeout.allow = allow;
      },
    });
  },
  clicks: {
    '.swipeout-open': function openSwipeout($clickedEl, data = {}) {
      const app = this;
      app.swipeout.open(data.swipeout, data.side);
    },
    '.swipeout-close': function closeSwipeout($clickedEl) {
      const app = this;
      const $swipeoutEl = $clickedEl.closest('.swipeout');
      if ($swipeoutEl.length === 0) return;
      app.swipeout.close($swipeoutEl);
    },
    '.swipeout-delete': function deleteSwipeout($clickedEl, data = {}) {
      const app = this;
      const $swipeoutEl = $clickedEl.closest('.swipeout');
      if ($swipeoutEl.length === 0) return;
      const { confirm, confirmTitle } = data;
      if (data.confirm) {
        app.dialog.confirm(confirm, confirmTitle, () => {
          app.swipeout.delete($swipeoutEl);
        });
      } else {
        app.swipeout.delete($swipeoutEl);
      }
    },
  },
  on: {
    init() {
      const app = this;
      if (!app.params.swipeout) return;
      app.swipeout.init();
    },
  },
};

const Accordion = {
  toggleClicked($clickedEl) {
    const app = this;
    let $accordionItemEl = $clickedEl.closest('.accordion-item').eq(0);
    if (!$accordionItemEl.length) $accordionItemEl = $clickedEl.parents('li').eq(0);

    const $accordionContent = $clickedEl.parents('.accordion-item-content').eq(0);
    if ($accordionContent.length) {
      if ($accordionContent.parents($accordionItemEl).length) return;
    }

    if ($clickedEl.parents('li').length > 1 && $clickedEl.parents('li')[0] !== $accordionItemEl[0]) return;
    app.accordion.toggle($accordionItemEl);
  },
  open(el) {
    const app = this;
    const $el = $(el);
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    $el.trigger('accordion:beforeopen', { prevent }, prevent);
    app.emit('accordionBeforeOpen', $el[0], prevent);
    if (prevented) return;
    const $list = $el.parents('.accordion-list').eq(0);
    let $contentEl = $el.children('.accordion-item-content');
    $contentEl.removeAttr('aria-hidden');
    if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
    if ($contentEl.length === 0) return;
    const $openedItem = $list.length > 0 && $el.parent().children('.accordion-item-opened');
    if ($openedItem.length > 0) {
      app.accordion.close($openedItem);
    }
    $contentEl.transitionEnd(() => {
      if ($el.hasClass('accordion-item-opened')) {
        $contentEl.transition(0);
        $contentEl.css('height', 'auto');
        Utils.nextFrame(() => {
          $contentEl.transition('');
          $el.trigger('accordion:opened');
          app.emit('accordionOpened', $el[0]);
        });
      } else {
        $contentEl.css('height', '');
        $el.trigger('accordion:closed');
        app.emit('accordionClosed', $el[0]);
      }
    });
    $contentEl.css('height', `${$contentEl[0].scrollHeight}px`);
    $el.trigger('accordion:open');
    $el.addClass('accordion-item-opened');
    app.emit('accordionOpen', $el[0]);
  },
  close(el) {
    const app = this;
    const $el = $(el);
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    $el.trigger('accordion:beforeclose', { prevent }, prevent);
    app.emit('accordionBeforeClose', $el[0], prevent);
    if (prevented) return;
    let $contentEl = $el.children('.accordion-item-content');
    if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
    $el.removeClass('accordion-item-opened');
    $contentEl.attr('aria-hidden', true);
    $contentEl.transition(0);
    $contentEl.css('height', `${$contentEl[0].scrollHeight}px`);
    // Close
    $contentEl.transitionEnd(() => {
      if ($el.hasClass('accordion-item-opened')) {
        $contentEl.transition(0);
        $contentEl.css('height', 'auto');
        Utils.nextFrame(() => {
          $contentEl.transition('');
          $el.trigger('accordion:opened');
          app.emit('accordionOpened', $el[0]);
        });
      } else {
        $contentEl.css('height', '');
        $el.trigger('accordion:closed');
        app.emit('accordionClosed', $el[0]);
      }
    });
    Utils.nextFrame(() => {
      $contentEl.transition('');
      $contentEl.css('height', '');
      $el.trigger('accordion:close');
      app.emit('accordionClose', $el[0]);
    });
  },
  toggle(el) {
    const app = this;
    const $el = $(el);
    if ($el.length === 0) return;
    if ($el.hasClass('accordion-item-opened')) app.accordion.close(el);
    else app.accordion.open(el);
  },
};

var Accordion$1 = {
  name: 'accordion',
  create() {
    const app = this;
    Utils.extend(app, {
      accordion: {
        open: Accordion.open.bind(app),
        close: Accordion.close.bind(app),
        toggle: Accordion.toggle.bind(app),
      },
    });
  },
  clicks: {
    '.accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a': function open($clickedEl) {
      const app = this;
      Accordion.toggleClicked.call(app, $clickedEl);
    },
  },
};

var ContactsList = {
  name: 'contactsList',
};

class VirtualList extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const vl = this;

    let defaultHeight;
    if (app.theme === 'md') {
      defaultHeight = 48;
    } else if (app.theme === 'ios') {
      defaultHeight = 44;
    } else if (app.theme === 'aurora') {
      defaultHeight = 38;
    }

    const defaults = {
      cols: 1,
      height: defaultHeight,
      cache: true,
      dynamicHeightBufferSize: 1,
      showFilteredItemsOnly: false,
      renderExternal: undefined,
      setListHeight: true,
      searchByItem: undefined,
      searchAll: undefined,
      itemTemplate: undefined,
      ul: null,
      createUl: true,
      scrollableParentEl: undefined,
      renderItem(item) {
        return `
          <li>
            <div class="item-content">
              <div class="item-inner">
                <div class="item-title">${item}</div>
              </div>
            </div>
          </li>
        `.trim();
      },
      on: {},
    };

    // Extend defaults with modules params
    vl.useModulesParams(defaults);

    vl.params = Utils.extend(defaults, params);
    if (vl.params.height === undefined || !vl.params.height) {
      vl.params.height = defaultHeight;
    }

    vl.$el = $(params.el);
    vl.el = vl.$el[0];

    if (vl.$el.length === 0) return undefined;
    vl.$el[0].f7VirtualList = vl;

    vl.items = vl.params.items;
    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    }
    if (vl.params.itemTemplate) {
      if (typeof vl.params.itemTemplate === 'string') vl.renderItem = app.t7.compile(vl.params.itemTemplate);
      else if (typeof vl.params.itemTemplate === 'function') vl.renderItem = vl.params.itemTemplate;
    } else if (vl.params.renderItem) {
      vl.renderItem = vl.params.renderItem;
    }
    vl.$pageContentEl = vl.$el.parents('.page-content');
    vl.pageContentEl = vl.$pageContentEl[0];

    vl.$scrollableParentEl = vl.params.scrollableParentEl ? $(vl.params.scrollableParentEl).eq(0) : vl.$pageContentEl;
    if (!vl.$scrollableParentEl.length && vl.$pageContentEl.length) {
      vl.$scrollableParentEl = vl.$pageContentEl;
    }
    vl.scrollableParentEl = vl.$scrollableParentEl[0];

    // Bad scroll
    if (typeof vl.params.updatableScroll !== 'undefined') {
      vl.updatableScroll = vl.params.updatableScroll;
    } else {
      vl.updatableScroll = true;
      if (Device.ios && Device.osVersion.split('.')[0] < 8) {
        vl.updatableScroll = false;
      }
    }

    // Append <ul>
    const ul = vl.params.ul;
    vl.$ul = ul ? $(vl.params.ul) : vl.$el.children('ul');
    if (vl.$ul.length === 0 && vl.params.createUl) {
      vl.$el.append('<ul></ul>');
      vl.$ul = vl.$el.children('ul');
    }
    vl.ul = vl.$ul[0];

    let $itemsWrapEl;
    if (!vl.ul && !vl.params.createUl) $itemsWrapEl = vl.$el;
    else $itemsWrapEl = vl.$ul;

    Utils.extend(vl, {
      $itemsWrapEl,
      itemsWrapEl: $itemsWrapEl[0],
      // DOM cached items
      domCache: {},
      displayDomCache: {},
      // Temporary DOM Element
      tempDomElement: doc.createElement('ul'),
      // Last repain position
      lastRepaintY: null,
      // Fragment
      fragment: doc.createDocumentFragment(),
      // Props
      pageHeight: undefined,
      rowsPerScreen: undefined,
      rowsBefore: undefined,
      rowsAfter: undefined,
      rowsToRender: undefined,
      maxBufferHeight: 0,
      listHeight: undefined,
      dynamicHeight: typeof vl.params.height === 'function',
    });

    // Install Modules
    vl.useModules();

    // Attach events
    const handleScrollBound = vl.handleScroll.bind(vl);
    const handleResizeBound = vl.handleResize.bind(vl);
    let $pageEl;
    let $tabEl;
    let $panelEl;
    let $popupEl;
    vl.attachEvents = function attachEvents() {
      $pageEl = vl.$el.parents('.page').eq(0);
      $tabEl = vl.$el.parents('.tab').filter((tabElIndex, tabEl) => {
        return $(tabEl).parent('.tabs').parent('.tabs-animated-wrap, .tabs-swipeable-wrap').length === 0;
      }).eq(0);
      $panelEl = vl.$el.parents('.panel').eq(0);
      $popupEl = vl.$el.parents('.popup').eq(0);

      vl.$scrollableParentEl.on('scroll', handleScrollBound);
      if ($pageEl.length) $pageEl.on('page:reinit', handleResizeBound);
      if ($tabEl.length) $tabEl.on('tab:show', handleResizeBound);
      if ($panelEl.length) $panelEl.on('panel:open', handleResizeBound);
      if ($popupEl.length) $popupEl.on('popup:open', handleResizeBound);
      app.on('resize', handleResizeBound);
    };
    vl.detachEvents = function attachEvents() {
      vl.$scrollableParentEl.off('scroll', handleScrollBound);
      if ($pageEl.length) $pageEl.off('page:reinit', handleResizeBound);
      if ($tabEl.length) $tabEl.off('tab:show', handleResizeBound);
      if ($panelEl.length) $panelEl.off('panel:open', handleResizeBound);
      if ($popupEl.length) $popupEl.off('popup:open', handleResizeBound);
      app.off('resize', handleResizeBound);
    };
    // Init
    vl.init();

    return vl;
  }

  setListSize() {
    const vl = this;
    const items = vl.filteredItems || vl.items;
    vl.pageHeight = vl.$scrollableParentEl[0].offsetHeight;
    if (vl.dynamicHeight) {
      vl.listHeight = 0;
      vl.heights = [];
      for (let i = 0; i < items.length; i += 1) {
        const itemHeight = vl.params.height(items[i]);
        vl.listHeight += itemHeight;
        vl.heights.push(itemHeight);
      }
    } else {
      vl.listHeight = Math.ceil(items.length / vl.params.cols) * vl.params.height;
      vl.rowsPerScreen = Math.ceil(vl.pageHeight / vl.params.height);
      vl.rowsBefore = vl.params.rowsBefore || vl.rowsPerScreen * 2;
      vl.rowsAfter = vl.params.rowsAfter || vl.rowsPerScreen;
      vl.rowsToRender = (vl.rowsPerScreen + vl.rowsBefore + vl.rowsAfter);
      vl.maxBufferHeight = (vl.rowsBefore / 2) * vl.params.height;
    }

    if (vl.updatableScroll || vl.params.setListHeight) {
      vl.$itemsWrapEl.css({ height: `${vl.listHeight}px` });
    }
  }

  render(force, forceScrollTop) {
    const vl = this;
    if (force) vl.lastRepaintY = null;

    let scrollTop = -(vl.$el[0].getBoundingClientRect().top - vl.$scrollableParentEl[0].getBoundingClientRect().top);

    if (typeof forceScrollTop !== 'undefined') scrollTop = forceScrollTop;
    if (vl.lastRepaintY === null || Math.abs(scrollTop - vl.lastRepaintY) > vl.maxBufferHeight || (!vl.updatableScroll && (vl.$scrollableParentEl[0].scrollTop + vl.pageHeight >= vl.$scrollableParentEl[0].scrollHeight))) {
      vl.lastRepaintY = scrollTop;
    } else {
      return;
    }

    const items = vl.filteredItems || vl.items;
    let fromIndex;
    let toIndex;
    let heightBeforeFirstItem = 0;
    let heightBeforeLastItem = 0;
    if (vl.dynamicHeight) {
      let itemTop = 0;
      let itemHeight;
      vl.maxBufferHeight = vl.pageHeight;

      for (let j = 0; j < vl.heights.length; j += 1) {
        itemHeight = vl.heights[j];
        if (typeof fromIndex === 'undefined') {
          if (itemTop + itemHeight >= scrollTop - (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize)) fromIndex = j;
          else heightBeforeFirstItem += itemHeight;
        }

        if (typeof toIndex === 'undefined') {
          if (itemTop + itemHeight >= scrollTop + (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize) || j === vl.heights.length - 1) toIndex = j + 1;
          heightBeforeLastItem += itemHeight;
        }
        itemTop += itemHeight;
      }
      toIndex = Math.min(toIndex, items.length);
    } else {
      fromIndex = (parseInt(scrollTop / vl.params.height, 10) - vl.rowsBefore) * vl.params.cols;
      if (fromIndex < 0) {
        fromIndex = 0;
      }
      toIndex = Math.min(fromIndex + (vl.rowsToRender * vl.params.cols), items.length);
    }

    let topPosition;
    const renderExternalItems = [];
    vl.reachEnd = false;
    let i;
    for (i = fromIndex; i < toIndex; i += 1) {
      let itemEl;
      // Define real item index
      const index = vl.items.indexOf(items[i]);

      if (i === fromIndex) vl.currentFromIndex = index;
      if (i === toIndex - 1) vl.currentToIndex = index;
      if (vl.filteredItems) {
        if (vl.items[index] === vl.filteredItems[vl.filteredItems.length - 1]) vl.reachEnd = true;
      } else if (index === vl.items.length - 1) vl.reachEnd = true;

      // Find items
      if (vl.params.renderExternal) {
        renderExternalItems.push(items[i]);
      } else if (vl.domCache[index]) {
        itemEl = vl.domCache[index];
        itemEl.f7VirtualListIndex = index;
      } else {
        if (vl.renderItem) {
          vl.tempDomElement.innerHTML = vl.renderItem(items[i], index).trim();
        } else {
          vl.tempDomElement.innerHTML = items[i].toString().trim();
        }
        itemEl = vl.tempDomElement.childNodes[0];
        if (vl.params.cache) vl.domCache[index] = itemEl;
        itemEl.f7VirtualListIndex = index;
      }

      // Set item top position
      if (i === fromIndex) {
        if (vl.dynamicHeight) {
          topPosition = heightBeforeFirstItem;
        } else {
          topPosition = ((i * vl.params.height) / vl.params.cols);
        }
      }
      if (!vl.params.renderExternal) {
        itemEl.style.top = `${topPosition}px`;

        // Before item insert
        vl.emit('local::itemBeforeInsert vlItemBeforeInsert', vl, itemEl, items[i]);

        // Append item to fragment
        vl.fragment.appendChild(itemEl);
      }
    }

    // Update list height with not updatable scroll
    if (!vl.updatableScroll) {
      if (vl.dynamicHeight) {
        vl.itemsWrapEl.style.height = `${heightBeforeLastItem}px`;
      } else {
        vl.itemsWrapEl.style.height = `${(i * vl.params.height) / vl.params.cols}px`;
      }
    }

    // Update list html
    if (vl.params.renderExternal) {
      if (items && items.length === 0) {
        vl.reachEnd = true;
      }
    } else {
      vl.emit('local::beforeClear vlBeforeClear', vl, vl.fragment);
      vl.itemsWrapEl.innerHTML = '';

      vl.emit('local::itemsBeforeInsert vlItemsBeforeInsert', vl, vl.fragment);

      if (items && items.length === 0) {
        vl.reachEnd = true;
        if (vl.params.emptyTemplate) vl.itemsWrapEl.innerHTML = vl.params.emptyTemplate;
      } else {
        vl.itemsWrapEl.appendChild(vl.fragment);
      }

      vl.emit('local::itemsAfterInsert vlItemsAfterInsert', vl, vl.fragment);
    }

    if (typeof forceScrollTop !== 'undefined' && force) {
      vl.$scrollableParentEl.scrollTop(forceScrollTop, 0);
    }
    if (vl.params.renderExternal) {
      vl.params.renderExternal(vl, {
        fromIndex,
        toIndex,
        listHeight: vl.listHeight,
        topPosition,
        items: renderExternalItems,
      });
    }
  }

  // Filter
  filterItems(indexes, resetScrollTop = true) {
    const vl = this;
    vl.filteredItems = [];
    for (let i = 0; i < indexes.length; i += 1) {
      vl.filteredItems.push(vl.items[indexes[i]]);
    }
    if (resetScrollTop) {
      vl.$scrollableParentEl[0].scrollTop = 0;
    }
    vl.update();
  }

  resetFilter() {
    const vl = this;
    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    } else {
      vl.filteredItems = null;
      delete vl.filteredItems;
    }
    vl.update();
  }

  scrollToItem(index) {
    const vl = this;
    if (index > vl.items.length) return false;
    let itemTop = 0;
    if (vl.dynamicHeight) {
      for (let i = 0; i < index; i += 1) {
        itemTop += vl.heights[i];
      }
    } else {
      itemTop = index * vl.params.height;
    }
    const listTop = vl.$el[0].offsetTop;
    vl.render(true, (listTop + itemTop) - parseInt(vl.$scrollableParentEl.css('padding-top'), 10));
    return true;
  }

  handleScroll() {
    const vl = this;
    vl.render();
  }

  // Handle resize event
  isVisible() {
    const vl = this;
    return !!(vl.el.offsetWidth || vl.el.offsetHeight || vl.el.getClientRects().length);
  }

  handleResize() {
    const vl = this;
    if (vl.isVisible()) {
      vl.setListSize();
      vl.render(true);
    }
  }

  // Append
  appendItems(items) {
    const vl = this;
    for (let i = 0; i < items.length; i += 1) {
      vl.items.push(items[i]);
    }
    vl.update();
  }

  appendItem(item) {
    const vl = this;
    vl.appendItems([item]);
  }

  // Replace
  replaceAllItems(items) {
    const vl = this;
    vl.items = items;
    delete vl.filteredItems;
    vl.domCache = {};
    vl.update();
  }

  replaceItem(index, item) {
    const vl = this;
    vl.items[index] = item;
    if (vl.params.cache) delete vl.domCache[index];
    vl.update();
  }

  // Prepend
  prependItems(items) {
    const vl = this;
    for (let i = items.length - 1; i >= 0; i -= 1) {
      vl.items.unshift(items[i]);
    }
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        newCache[parseInt(cached, 10) + items.length] = vl.domCache[cached];
      });
      vl.domCache = newCache;
    }
    vl.update();
  }

  prependItem(item) {
    const vl = this;
    vl.prependItems([item]);
  }

  // Move
  moveItem(from, to) {
    const vl = this;
    const fromIndex = from;
    let toIndex = to;
    if (fromIndex === toIndex) return;
    // remove item from array
    const item = vl.items.splice(fromIndex, 1)[0];
    if (toIndex >= vl.items.length) {
      // Add item to the end
      vl.items.push(item);
      toIndex = vl.items.length - 1;
    } else {
    // Add item to new index
      vl.items.splice(toIndex, 0, item);
    }
    // Update cache
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        const cachedIndex = parseInt(cached, 10);
        const leftIndex = fromIndex < toIndex ? fromIndex : toIndex;
        const rightIndex = fromIndex < toIndex ? toIndex : fromIndex;
        const indexShift = fromIndex < toIndex ? -1 : 1;
        if (cachedIndex < leftIndex || cachedIndex > rightIndex) newCache[cachedIndex] = vl.domCache[cachedIndex];
        if (cachedIndex === leftIndex) newCache[rightIndex] = vl.domCache[cachedIndex];
        if (cachedIndex > leftIndex && cachedIndex <= rightIndex) newCache[cachedIndex + indexShift] = vl.domCache[cachedIndex];
      });
      vl.domCache = newCache;
    }
    vl.update();
  }

  // Insert before
  insertItemBefore(index, item) {
    const vl = this;
    if (index === 0) {
      vl.prependItem(item);
      return;
    }
    if (index >= vl.items.length) {
      vl.appendItem(item);
      return;
    }
    vl.items.splice(index, 0, item);
    // Update cache
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        const cachedIndex = parseInt(cached, 10);
        if (cachedIndex >= index) {
          newCache[cachedIndex + 1] = vl.domCache[cachedIndex];
        }
      });
      vl.domCache = newCache;
    }
    vl.update();
  }

  // Delete
  deleteItems(indexes) {
    const vl = this;
    let prevIndex;
    let indexShift = 0;
    for (let i = 0; i < indexes.length; i += 1) {
      let index = indexes[i];
      if (typeof prevIndex !== 'undefined') {
        if (index > prevIndex) {
          indexShift = -i;
        }
      }
      index += indexShift;
      prevIndex = indexes[i];
      // Delete item
      const deletedItem = vl.items.splice(index, 1)[0];

      // Delete from filtered
      if (vl.filteredItems && vl.filteredItems.indexOf(deletedItem) >= 0) {
        vl.filteredItems.splice(vl.filteredItems.indexOf(deletedItem), 1);
      }
      // Update cache
      if (vl.params.cache) {
        const newCache = {};
        Object.keys(vl.domCache).forEach((cached) => {
          const cachedIndex = parseInt(cached, 10);
          if (cachedIndex === index) {
            delete vl.domCache[index];
          } else if (parseInt(cached, 10) > index) {
            newCache[cachedIndex - 1] = vl.domCache[cached];
          } else {
            newCache[cachedIndex] = vl.domCache[cached];
          }
        });
        vl.domCache = newCache;
      }
    }
    vl.update();
  }

  deleteAllItems() {
    const vl = this;
    vl.items = [];
    delete vl.filteredItems;
    if (vl.params.cache) vl.domCache = {};
    vl.update();
  }

  deleteItem(index) {
    const vl = this;
    vl.deleteItems([index]);
  }

  // Clear cache
  clearCache() {
    const vl = this;
    vl.domCache = {};
  }

  // Update Virtual List
  update(deleteCache) {
    const vl = this;
    if (deleteCache && vl.params.cache) {
      vl.domCache = {};
    }
    vl.setListSize();
    vl.render(true);
  }

  init() {
    const vl = this;
    vl.attachEvents();
    vl.setListSize();
    vl.render();
  }

  destroy() {
    let vl = this;
    vl.detachEvents();
    vl.$el[0].f7VirtualList = null;
    delete vl.$el[0].f7VirtualList;
    Utils.deleteProps(vl);
    vl = null;
  }
}

var VirtualList$1 = {
  name: 'virtualList',
  static: {
    VirtualList,
  },
  create() {
    const app = this;
    app.virtualList = ConstructorMethods({
      defaultSelector: '.virtual-list',
      constructor: VirtualList,
      app,
      domProp: 'f7VirtualList',
    });
  },
};

class ListIndex extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const index = this;

    const defaults = {
      el: null, // where to render indexes
      listEl: null, // list el to generate indexes
      indexes: 'auto', // or array of indexes
      iosItemHeight: 14,
      mdItemHeight: 14,
      auroraItemHeight: 14,
      scrollList: true,
      label: false,
      // eslint-disable-next-line
      renderItem(itemContent, itemIndex) {
        return `
          <li>${itemContent}</li>
        `.trim();
      },
      renderSkipPlaceholder() {
        return '<li class="list-index-skip-placeholder"></li>';
      },
      on: {},
    };

    // Extend defaults with modules params
    index.useModulesParams(defaults);

    index.params = Utils.extend(defaults, params);

    let $el;
    let $listEl;
    let $pageContentEl;
    let $ul;

    if (index.params.el) {
      $el = $(index.params.el);
    } else {
      return index;
    }

    if ($el[0].f7ListIndex) {
      return $el[0].f7ListIndex;
    }

    $ul = $el.find('ul');
    if ($ul.length === 0) {
      $ul = $('<ul></ul>');
      $el.append($ul);
    }

    if (index.params.listEl) {
      $listEl = $(index.params.listEl);
    }

    if (index.params.indexes === 'auto' && !$listEl) {
      return index;
    }

    if ($listEl) {
      $pageContentEl = $listEl.parents('.page-content').eq(0);
    } else {
      $pageContentEl = $el.siblings('.page-content').eq(0);
      if ($pageContentEl.length === 0) {
        $pageContentEl = $el.parents('.page').eq(0).find('.page-content').eq(0);
      }
    }

    $el[0].f7ListIndex = index;

    Utils.extend(index, {
      app,
      $el,
      el: $el && $el[0],
      $ul,
      ul: $ul && $ul[0],
      $listEl,
      listEl: $listEl && $listEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl && $pageContentEl[0],
      indexes: params.indexes,
      height: 0,
      skipRate: 0,
    });

    // Install Modules
    index.useModules();

    // Attach events
    function handleResize() {
      const height = { index };
      index.calcSize();
      if (height !== index.height) {
        index.render();
      }
    }

    function handleClick(e) {
      const $clickedLi = $(e.target).closest('li');
      if (!$clickedLi.length) return;

      let itemIndex = $clickedLi.index();
      if (index.skipRate > 0) {
        const percentage = itemIndex / ($clickedLi.siblings('li').length - 1);
        itemIndex = Math.round((index.indexes.length - 1) * percentage);
      }
      const itemContent = index.indexes[itemIndex];

      index.$el.trigger('listindex:click', { content: itemContent, index: itemIndex });
      index.emit('local::click listIndexClick', index, itemContent, itemIndex);
      index.$el.trigger('listindex:select', { content: itemContent, index: itemIndex });
      index.emit('local::select listIndexSelect', index, itemContent, itemIndex);

      if (index.$listEl && index.params.scrollList) {
        index.scrollListToIndex(itemContent, itemIndex);
      }
    }

    const touchesStart = {};
    let isTouched;
    let isMoved;
    let topPoint;
    let bottomPoint;
    let $labelEl;
    let previousIndex = null;
    function handleTouchStart(e) {
      const $children = $ul.children();
      if (!$children.length) return;
      topPoint = $children[0].getBoundingClientRect().top;
      bottomPoint = $children[$children.length - 1].getBoundingClientRect().top + $children[0].offsetHeight;

      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isMoved = false;
      previousIndex = null;
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      if (!isMoved && index.params.label) {
        $labelEl = $('<span class="list-index-label"></span>');
        $el.append($labelEl);
      }
      isMoved = true;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();

      let percentage = (pageY - topPoint) / (bottomPoint - topPoint);
      percentage = Math.min(Math.max(percentage, 0), 1);

      const itemIndex = Math.round((index.indexes.length - 1) * percentage);
      const itemContent = index.indexes[itemIndex];


      const ulHeight = bottomPoint - topPoint;
      const bubbleBottom = ((index.height - ulHeight) / 2) + ((1 - percentage) * ulHeight);

      if (itemIndex !== previousIndex) {
        if (index.params.label) {
          $labelEl.html(itemContent).transform(`translateY(-${bubbleBottom}px)`);
        }

        if (index.$listEl && index.params.scrollList) {
          index.scrollListToIndex(itemContent, itemIndex);
        }
      }

      previousIndex = itemIndex;

      index.$el.trigger('listindex:select');
      index.emit('local::select listIndexSelect', index, itemContent, itemIndex);
    }
    function handleTouchEnd() {
      if (!isTouched) return;
      isTouched = false;
      isMoved = false;
      if (index.params.label) {
        if ($labelEl) $labelEl.remove();
        $labelEl = undefined;
      }
    }
    const passiveListener = app.support.passiveListener ? { passive: true } : false;
    index.attachEvents = function attachEvents() {
      $el.parents('.tab').on('tab:show', handleResize);
      $el.parents('.page').on('page:reinit', handleResize);
      $el.parents('.panel').on('panel:open', handleResize);
      $el
        .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
        .on('modal:open', handleResize);
      app.on('resize', handleResize);

      $el.on('click', handleClick);
      $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
    };
    index.detachEvents = function attachEvents() {
      $el.parents('.tab').off('tab:show', handleResize);
      $el.parents('.page').off('page:reinit', handleResize);
      $el.parents('.panel').off('panel:open', handleResize);
      $el
        .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
        .off('modal:open', handleResize);
      app.off('resize', handleResize);

      $el.off('click', handleClick);
      $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
    };
    // Init
    index.init();

    return index;
  }
  // eslint-disable-next-line
  scrollListToIndex(itemContent, itemIndex) {
    const index = this;
    const { $listEl, $pageContentEl, app } = index;
    if (!$listEl || !$pageContentEl || $pageContentEl.length === 0) return index;

    let $scrollToEl;
    $listEl.find('.list-group-title, .item-divider').each((elIndex, el) => {
      if ($scrollToEl) return;
      const $el = $(el);
      if ($el.text() === itemContent) {
        $scrollToEl = $el;
      }
    });
    if (!$scrollToEl || $scrollToEl.length === 0) return index;

    const parentTop = $scrollToEl.parent().offset().top;
    let paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
    const scrollTop = $pageContentEl[0].scrollTop;
    const scrollToElTop = $scrollToEl.offset().top;
    if ($pageContentEl.parents('.page-with-navbar-large').length) {
      const navbarInnerEl = app.navbar.getElByPage($pageContentEl.parents('.page-with-navbar-large').eq(0));
      const $titleLargeEl = $(navbarInnerEl).find('.title-large');
      if ($titleLargeEl.length) {
        paddingTop -= $titleLargeEl[0].offsetHeight || 0;
      }
    }

    if (parentTop <= paddingTop) {
      $pageContentEl.scrollTop((parentTop + scrollTop) - paddingTop);
    } else {
      $pageContentEl.scrollTop((scrollToElTop + scrollTop) - paddingTop);
    }
    return index;
  }

  renderSkipPlaceholder() {
    const index = this;
    return index.params.renderSkipPlaceholder.call(index);
  }

  renderItem(itemContent, itemIndex) {
    const index = this;
    return index.params.renderItem.call(index, itemContent, itemIndex);
  }

  render() {
    const index = this;
    const { $ul, indexes, skipRate } = index;
    let wasSkipped;

    const html = indexes.map((itemContent, itemIndex) => {
      if (itemIndex % skipRate !== 0 && skipRate > 0) {
        wasSkipped = true;
        return '';
      }
      let itemHtml = index.renderItem(itemContent, itemIndex);
      if (wasSkipped) {
        itemHtml = index.renderSkipPlaceholder() + itemHtml;
      }
      wasSkipped = false;
      return itemHtml;
    }).join('');

    $ul.html(html);

    return index;
  }

  calcSize() {
    const index = this;
    const { app, params, el, indexes } = index;
    const height = el.offsetHeight;
    const itemHeight = params[`${app.theme}ItemHeight`];
    const maxItems = Math.floor(height / itemHeight);
    const items = indexes.length;
    let skipRate = 0;
    if (items > maxItems) {
      skipRate = Math.ceil(((items * 2) - 1) / maxItems);
    }

    index.height = height;
    index.skipRate = skipRate;

    return index;
  }

  calcIndexes() {
    const index = this;
    if (index.params.indexes === 'auto') {
      index.indexes = [];

      index.$listEl.find('.list-group-title, .item-divider').each((elIndex, el) => {
        const elContent = $(el).text();
        if (index.indexes.indexOf(elContent) < 0) {
          index.indexes.push(elContent);
        }
      });
    } else {
      index.indexes = index.params.indexes;
    }
    return index;
  }

  update() {
    const index = this;
    index.calcIndexes();
    index.calcSize();
    index.render();

    return index;
  }

  init() {
    const index = this;
    index.calcIndexes();
    index.calcSize();
    index.render();
    index.attachEvents();
  }

  destroy() {
    let index = this;
    index.$el.trigger('listindex:beforedestroy', index);
    index.emit('local::beforeDestroy listIndexBeforeDestroy');
    index.detachEvents();
    if (index.$el[0]) {
      index.$el[0].f7ListIndex = null;
      delete index.$el[0].f7ListIndex;
    }
    Utils.deleteProps(index);
    index = null;
  }
}

var ListIndex$1 = {
  name: 'listIndex',
  static: {
    ListIndex,
  },
  create() {
    const app = this;
    app.listIndex = ConstructorMethods({
      defaultSelector: '.list-index',
      constructor: ListIndex,
      app,
      domProp: 'f7ListIndex',
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.list-index-init').each((index, listIndexEl) => {
        const params = Utils.extend($(listIndexEl).dataset(), { el: listIndexEl });
        app.listIndex.create(params);
      });
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find('.list-index-init').each((index, listIndexEl) => {
        if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.list-index-init').each((index, listIndexEl) => {
        const params = Utils.extend($(listIndexEl).dataset(), { el: listIndexEl });
        app.listIndex.create(params);
      });
    },
    pageBeforeRemove(page) {
      page.$el.find('.list-index-init').each((index, listIndexEl) => {
        if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
      });
    },
  },
  vnode: {
    'list-index-init': {
      insert(vnode) {
        const app = this;
        const listIndexEl = vnode.elm;
        const params = Utils.extend($(listIndexEl).dataset(), { el: listIndexEl });
        app.listIndex.create(params);
      },
      destroy(vnode) {
        const listIndexEl = vnode.elm;
        if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
      },
    },
  },
};

var Timeline = {
  name: 'timeline',
};

const Tab = {
  show(...args) {
    const app = this;

    let tabEl;
    let tabLinkEl;
    let animate;
    let tabRoute;
    let animatedInit;
    if (args.length === 1 && args[0] && args[0].constructor === Object) {
      tabEl = args[0].tabEl;
      tabLinkEl = args[0].tabLinkEl;
      animate = args[0].animate;
      tabRoute = args[0].tabRoute;
      animatedInit = args[0].animatedInit;
    } else {
      [tabEl, tabLinkEl, animate, tabRoute] = args;
      if (typeof args[1] === 'boolean') {
        [tabEl, animate, tabLinkEl, tabRoute] = args;
        if (args.length > 2 && tabLinkEl.constructor === Object) {
          [tabEl, animate, tabRoute, tabLinkEl] = args;
        }
      }
    }
    if (typeof animate === 'undefined') animate = true;

    const $newTabEl = $(tabEl);
    if (tabRoute && $newTabEl[0]) {
      $newTabEl[0].f7TabRoute = tabRoute;
    }

    if (!animatedInit && ($newTabEl.length === 0 || $newTabEl.hasClass('tab-active'))) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0],
      };
    }

    let $tabLinkEl;
    if (tabLinkEl) $tabLinkEl = $(tabLinkEl);

    const $tabsEl = $newTabEl.parent('.tabs');
    if ($tabsEl.length === 0) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0],
      };
    }

    // Release swipeouts in hidden tabs
    if (app.swipeout) app.swipeout.allowOpen = true;

    // Animated tabs
    const tabsChangedCallbacks = [];

    function onTabsChanged(callback) {
      tabsChangedCallbacks.push(callback);
    }
    function tabsChanged() {
      tabsChangedCallbacks.forEach((callback) => {
        callback();
      });
    }

    let animated = false;

    if ($tabsEl.parent().hasClass('tabs-animated-wrap')) {
      $tabsEl.parent()[animate ? 'removeClass' : 'addClass']('not-animated');

      const transitionDuration = parseFloat($tabsEl.css('transition-duration').replace(',', '.'));
      if (animate && transitionDuration) {
        $tabsEl.transitionEnd(tabsChanged);
        animated = true;
      }

      const tabsTranslate = (app.rtl ? $newTabEl.index() : -$newTabEl.index()) * 100;
      $tabsEl.transform(`translate3d(${tabsTranslate}%,0,0)`);
    }

    // Swipeable tabs
    let swiper;
    if ($tabsEl.parent().hasClass('tabs-swipeable-wrap') && app.swiper) {
      swiper = $tabsEl.parent()[0].swiper;
      if (swiper && swiper.activeIndex !== $newTabEl.index()) {
        animated = true;
        swiper
          .once('slideChangeTransitionEnd', () => {
            tabsChanged();
          })
          .slideTo($newTabEl.index(), animate ? undefined : 0);
      } else if (swiper && swiper.animating) {
        animated = true;
        swiper
          .once('slideChangeTransitionEnd', () => {
            tabsChanged();
          });
      }
    }

    // Remove active class from old tabs
    const $oldTabEl = $tabsEl.children('.tab-active');
    $oldTabEl.removeClass('tab-active');
    if (!animatedInit && (!swiper || (swiper && !swiper.animating) || (swiper && tabRoute))) {
      if ($oldTabEl.hasClass('view') && $oldTabEl.children('.page').length) {
        $oldTabEl.children('.page').each((pageIndex, pageEl) => {
          $(pageEl).trigger('page:tabhide');
          app.emit('pageTabHide', pageEl);
        });
      }
      $oldTabEl.trigger('tab:hide');
      app.emit('tabHide', $oldTabEl[0]);
    }

    // Trigger 'show' event on new tab
    $newTabEl.addClass('tab-active');
    if (!animatedInit && (!swiper || (swiper && !swiper.animating) || (swiper && tabRoute))) {
      if ($newTabEl.hasClass('view') && $newTabEl.children('.page').length) {
        $newTabEl.children('.page').each((pageIndex, pageEl) => {
          $(pageEl).trigger('page:tabshow');
          app.emit('pageTabShow', pageEl);
        });
      }
      $newTabEl.trigger('tab:show');
      app.emit('tabShow', $newTabEl[0]);
    }

    // Find related link for new tab
    if (!$tabLinkEl) {
      // Search by id
      if (typeof tabEl === 'string') $tabLinkEl = $(`.tab-link[href="${tabEl}"]`);
      else $tabLinkEl = $(`.tab-link[href="#${$newTabEl.attr('id')}"]`);
      // Search by data-tab
      if (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0)) {
        $('[data-tab]').each((index, el) => {
          if ($newTabEl.is($(el).attr('data-tab'))) $tabLinkEl = $(el);
        });
      }
      if (tabRoute && (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0))) {
        $tabLinkEl = $(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
        if ($tabLinkEl.length === 0) {
          $tabLinkEl = $(`.tab-link[href="${tabRoute.url}"]`);
        }
      }
      if ($tabLinkEl.length > 1 && $newTabEl.parents('.page').length) {
        // eslint-disable-next-line
        $tabLinkEl = $tabLinkEl.filter((index, tabLinkElement) => {
          return $(tabLinkElement).parents('.page')[0] === $newTabEl.parents('.page')[0];
        });
        if (app.theme === 'ios' && $tabLinkEl.length === 0 && tabRoute) {
          const $pageEl = $newTabEl.parents('.page');
          const $navbarEl = $(app.navbar.getElByPage($pageEl));
          $tabLinkEl = $navbarEl.find(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
          if ($tabLinkEl.length === 0) {
            $tabLinkEl = $navbarEl.find(`.tab-link[href="${tabRoute.url}"]`);
          }
        }
      }
    }
    if ($tabLinkEl.length > 0) {
      // Find related link for old tab
      let $oldTabLinkEl;
      if ($oldTabEl && $oldTabEl.length > 0) {
        // Search by id
        const oldTabId = $oldTabEl.attr('id');
        if (oldTabId) {
          $oldTabLinkEl = $(`.tab-link[href="#${oldTabId}"]`);
          // Search by data-route-tab-id
          if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
            $oldTabLinkEl = $(`.tab-link[data-route-tab-id="${oldTabId}"]`);
          }
        }
        // Search by data-tab
        if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
          $('[data-tab]').each((index, tabLinkElement) => {
            if ($oldTabEl.is($(tabLinkElement).attr('data-tab'))) $oldTabLinkEl = $(tabLinkElement);
          });
        }
        if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
          $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
        }
      } else if (tabRoute) {
        $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
      }

      if ($oldTabLinkEl && $oldTabLinkEl.length > 1 && $oldTabEl && $oldTabEl.parents('.page').length) {
        // eslint-disable-next-line
        $oldTabLinkEl = $oldTabLinkEl.filter((index, tabLinkElement) => {
          return $(tabLinkElement).parents('.page')[0] === $oldTabEl.parents('.page')[0];
        });
      }

      if ($oldTabLinkEl && $oldTabLinkEl.length > 0) $oldTabLinkEl.removeClass('tab-link-active');

      // Update links' classes
      if ($tabLinkEl && $tabLinkEl.length > 0) {
        $tabLinkEl.addClass('tab-link-active');
        // Material Highlight
        if (app.theme === 'md' && app.toolbar) {
          const $tabbarEl = $tabLinkEl.parents('.tabbar, .tabbar-labels');
          if ($tabbarEl.length > 0) {
            app.toolbar.setHighlight($tabbarEl);
          }
        }
      }
    }
    return {
      $newTabEl,
      newTabEl: $newTabEl[0],
      $oldTabEl,
      oldTabEl: $oldTabEl[0],
      onTabsChanged,
      animated,
    };
  },
};
var Tabs = {
  name: 'tabs',
  create() {
    const app = this;
    Utils.extend(app, {
      tab: {
        show: Tab.show.bind(app),
      },
    });
  },
  on: {
    'pageInit tabMounted': function onInit(pageOrTabEl) {
      const $el = $(pageOrTabEl.el || pageOrTabEl);
      const animatedTabEl = $el.find('.tabs-animated-wrap > .tabs > .tab-active')[0];
      if (!animatedTabEl) return;
      const app = this;
      app.tab.show({ tabEl: animatedTabEl, animatedInit: true, animate: false });
    },
  },
  clicks: {
    '.tab-link': function tabLinkClick($clickedEl, data = {}) {
      if (($clickedEl.attr('href') && $clickedEl.attr('href').indexOf('#') === 0) || $clickedEl.attr('data-tab')) {
        const app = this;
        app.tab.show({
          tabEl: data.tab || $clickedEl.attr('href'),
          tabLinkEl: $clickedEl,
          animate: data.animate,
        });
      }
    },
  },
};

function swipePanel(panel) {
  const app = panel.app;
  if (panel.swipeInitialized) {
    return;
  }
  Utils.extend(panel, {
    swipeable: true,
    swipeInitialized: true,
  });
  const params = panel.params;
  const { $el, $backdropEl, side, effect } = panel;
  let otherPanel;

  let isTouched;
  let isGestureStarted;
  let isMoved;
  let isScrolling;
  let isInterrupted;
  const touchesStart = {};
  let touchStartTime;
  let touchesDiff;
  let translate;
  let backdropOpacity;
  let panelWidth;
  let direction;

  let $viewEl;

  let touchMoves = 0;
  function handleTouchStart(e) {
    if (!panel.swipeable || isGestureStarted) return;
    if (!app.panel.allowOpen || (!params.swipe && !params.swipeOnlyClose) || isTouched) return;
    if ($('.modal-in:not(.toast):not(.notification), .photo-browser-in').length > 0) return;
    otherPanel = app.panel.get(side === 'left' ? 'right' : 'left') || {};
    const otherPanelOpened = otherPanel.opened && otherPanel.$el && !otherPanel.$el.hasClass('panel-in-breakpoint');
    if (!panel.opened && otherPanelOpened) {
      return;
    }
    if (!params.swipeOnlyClose) {
      if (otherPanelOpened) return;
    }
    if (e.target && e.target.nodeName.toLowerCase() === 'input' && e.target.type === 'range') return;
    if ($(e.target).closest('.range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel, .card-opened').length > 0) return;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    if (params.swipeOnlyClose && !panel.opened) {
      return;
    }
    if (params.swipeActiveArea && !panel.opened) {
      if (side === 'left') {
        if (touchesStart.x > params.swipeActiveArea) return;
      }
      if (side === 'right') {
        if (touchesStart.x < app.width - params.swipeActiveArea) return;
      }
    }
    touchMoves = 0;
    $viewEl = $(panel.getViewEl());
    isMoved = false;
    isTouched = true;
    isScrolling = undefined;
    isInterrupted = false;

    touchStartTime = Utils.now();
    direction = undefined;
  }
  function handleTouchMove(e) {
    if (!isTouched || isGestureStarted || isInterrupted) return;
    touchMoves += 1;
    if (touchMoves < 2) return;
    if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
      isTouched = false;
      return;
    }
    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === 'undefined') {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
    }
    if (isScrolling) {
      isTouched = false;
      return;
    }
    if (!direction) {
      if (pageX > touchesStart.x) {
        direction = 'to-right';
      } else {
        direction = 'to-left';
      }

      if (params.swipeActiveArea > 0 && !panel.opened) {
        if (side === 'left' && touchesStart.x > params.swipeActiveArea) {
          isTouched = false;
          return;
        }
        if (side === 'right' && touchesStart.x < app.width - params.swipeActiveArea) {
          isTouched = false;
          return;
        }
      }
      if ($el.hasClass('panel-in-breakpoint')) {
        isTouched = false;
        return;
      }

      if (
        (side === 'left'
          && (
            direction === 'to-left' && !$el.hasClass('panel-in')
          )
        )
        || (side === 'right'
          && (
            direction === 'to-right' && !$el.hasClass('panel-in')
          )
        )
      ) {
        isTouched = false;
        return;
      }
    }

    let threshold = panel.opened ? 0 : -params.swipeThreshold;
    if (side === 'right') threshold = -threshold;

    if (!isMoved) {
      if (!panel.opened) {
        panel.insertToRoot();
        $el.addClass('panel-in-swipe');
        $backdropEl.css('visibility', 'visible');
        $el.trigger('panel:swipeopen');
        panel.emit('local::swipeOpen panelSwipeOpen', panel);
      }
      panelWidth = $el[0].offsetWidth;
      if (effect === 'reveal' && $el.hasClass('panel-in-collapsed')) {
        panelWidth -= parseFloat($viewEl.css(`margin-${side}`));
      }
      $el.transition(0);
    }

    isMoved = true;

    e.preventDefault();

    touchesDiff = (pageX - touchesStart.x) + threshold;

    if (side === 'right') {
      if (effect === 'cover') {
        translate = touchesDiff + (panel.opened ? 0 : panelWidth);
        if (translate < 0) translate = 0;
        if (translate > panelWidth) {
          translate = panelWidth;
        }
      } else {
        translate = touchesDiff - (panel.opened ? panelWidth : 0);
        if (translate > 0) translate = 0;
        if (translate < -panelWidth) {
          translate = -panelWidth;
        }
      }
    } else {
      translate = touchesDiff + (panel.opened ? panelWidth : 0);
      if (translate < 0) translate = 0;
      if (translate > panelWidth) {
        translate = panelWidth;
      }
    }
    const noFollowProgress = Math.abs(translate / panelWidth);
    if (effect === 'reveal') {
      if (!params.swipeNoFollow) {
        $viewEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
        $backdropEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
      }

      $el.trigger('panel:swipe', Math.abs(translate / panelWidth));
      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
    } else {
      if (side === 'left') translate -= panelWidth;
      if (!params.swipeNoFollow) {
        $el.transform(`translate3d(${translate}px,0,0)`).transition(0);

        $backdropEl.transition(0);
        backdropOpacity = 1 - Math.abs(translate / panelWidth);
        $backdropEl.css({ opacity: backdropOpacity });
      }

      $el.trigger('panel:swipe', Math.abs(translate / panelWidth));
      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
    }

    if (params.swipeNoFollow) {
      const stateChanged = (panel.opened && noFollowProgress === 0) || (!panel.opened && noFollowProgress === 1);
      if (stateChanged) {
        isInterrupted = true;
        // eslint-disable-next-line
        handleTouchEnd(e);
      }
    }
  }
  function handleTouchEnd(e) {
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    const isGesture = e.type === 'gesturestart' || isGestureStarted;
    isTouched = false;
    isMoved = false;
    const timeDiff = (new Date()).getTime() - touchStartTime;
    let action;
    const edge = (translate === 0 || Math.abs(translate) === panelWidth) && !params.swipeNoFollow;

    const threshold = params.swipeThreshold || 0;

    if (isGesture) {
      action = 'reset';
    } else if (!panel.opened) {
      if (Math.abs(touchesDiff) < threshold) {
        action = 'reset';
      } else if (effect === 'cover') {
        if (translate === 0) {
          action = 'swap'; // open
        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
          action = 'swap'; // open
        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
          action = 'swap'; // open
        } else {
          action = 'reset'; // close
        }
      } else if (translate === 0) {
        action = 'reset';
      } else if (
        (timeDiff < 300 && Math.abs(translate) > 0)
        || (timeDiff >= 300 && (Math.abs(translate) >= panelWidth / 2))
      ) {
        action = 'swap';
      } else {
        action = 'reset';
      }
    } else if (effect === 'cover') {
      if (translate === 0) {
        action = 'reset'; // open
      } else if (timeDiff < 300 && Math.abs(translate) > 0) {
        action = 'swap'; // open
      } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
        action = 'reset'; // open
      } else {
        action = 'swap'; // close
      }
    } else if (translate === -panelWidth) {
      action = 'reset';
    } else if (
      (timeDiff < 300 && Math.abs(translate) >= 0)
      || (timeDiff >= 300 && (Math.abs(translate) <= panelWidth / 2))
    ) {
      if (side === 'left' && translate === panelWidth) action = 'reset';
      else action = 'swap';
    } else {
      action = 'reset';
    }
    if (action === 'swap') {
      if (panel.opened) {
        panel.close(!edge);
      } else {
        panel.open(!edge);
      }
    }
    let removePanelInClass = true;
    if (action === 'reset') {
      if (!panel.opened) {
        if (edge) {
          // edge position
          $el.removeClass('panel-in-swipe');
        } else {
          removePanelInClass = false;
          const target = effect === 'reveal' ? $viewEl : $el;
          $('html').addClass('with-panel-closing');
          target.transitionEnd(() => {
            if ($el.hasClass('panel-in')) return;
            $el.removeClass('panel-in-swipe');
            $('html').removeClass('with-panel-closing');
          });
        }
      }
    }
    if (effect === 'reveal') {
      Utils.nextFrame(() => {
        $viewEl.transition('');
        $viewEl.transform('');
      });
    }
    if (removePanelInClass) {
      $el.removeClass('panel-in-swipe');
    }
    $el.transition('').transform('');
    $backdropEl.transform('').transition('').css({ opacity: '', visibility: '' });
  }
  function handleGestureStart(e) {
    isGestureStarted = true;
    handleTouchEnd(e);
  }
  function handleGestureEnd() {
    isGestureStarted = false;
  }

  // Add Events
  app.on('touchstart:passive', handleTouchStart);
  app.on('touchmove:active', handleTouchMove);
  app.on('touchend:passive', handleTouchEnd);
  app.on('gesturestart', handleGestureStart);
  app.on('gestureend', handleGestureEnd);
  panel.on('panelDestroy', () => {
    app.off('touchstart:passive', handleTouchStart);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
    app.off('gesturestart', handleGestureStart);
    app.off('gestureend', handleGestureEnd);
  });
}

function resizablePanel(panel) {
  const app = panel.app;
  if (panel.resizableInitialized) return;
  Utils.extend(panel, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true,
  });
  const $htmlEl = $('html');
  const { $el, $backdropEl, side, effect } = panel;
  if (!$el) return;

  let isTouched;
  let isMoved;
  const touchesStart = {};
  let touchesDiff;
  let panelWidth;

  let $viewEl;

  let panelMinWidth;
  let panelMaxWidth;
  let visibleByBreakpoint;

  function transformCSSWidth(v) {
    if (!v) return null;
    if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
      return parseInt(v, 10) / 100 * app.width;
    }
    const newV = parseInt(v, 10);
    if (Number.isNaN(newV)) return null;
    return newV;
  }

  function isResizable() {
    return panel.resizable && $el.hasClass('panel-resizable');
  }

  function handleTouchStart(e) {
    if (!isResizable()) return;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    panelMinWidth = transformCSSWidth($el.css('min-width'));
    panelMaxWidth = transformCSSWidth($el.css('max-width'));
    visibleByBreakpoint = $el.hasClass('panel-in-breakpoint');
  }
  function handleTouchMove(e) {
    if (!isTouched) return;
    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

    if (!isMoved) {
      panelWidth = $el[0].offsetWidth;
      $el.transition(0);
      $el.addClass('panel-resizing');
      $htmlEl.css('cursor', 'col-resize');
      if (effect === 'reveal' || visibleByBreakpoint) {
        $viewEl = $(panel.getViewEl());
      }
      if (effect === 'reveal' && !visibleByBreakpoint) {
        $backdropEl.transition(0);
        $viewEl.transition(0);
      }
    }

    isMoved = true;

    e.preventDefault();

    touchesDiff = (pageX - touchesStart.x);

    let newPanelWidth = side === 'left' ? panelWidth + touchesDiff : panelWidth - touchesDiff;
    if (panelMinWidth && !Number.isNaN(panelMinWidth)) {
      newPanelWidth = Math.max(newPanelWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth)) {
      newPanelWidth = Math.min(newPanelWidth, panelMaxWidth);
    }
    newPanelWidth = Math.min(Math.max(newPanelWidth, 0), app.width);

    panel.resizableWidth = newPanelWidth;
    $el[0].style.width = `${newPanelWidth}px`;
    if (effect === 'reveal' && !visibleByBreakpoint) {
      if ($viewEl) {
        $viewEl.transform(`translate3d(${side === 'left' ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
      if ($backdropEl) {
        $backdropEl.transform(`translate3d(${side === 'left' ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
    } else if (visibleByBreakpoint && $viewEl) {
      $viewEl.css(`margin-${side}`, `${newPanelWidth}px`);
    }

    $el.trigger('panel:resize', newPanelWidth);
    panel.emit('local::resize panelResize', panel, newPanelWidth);
  }
  function handleTouchEnd() {
    $('html').css('cursor', '');
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;

    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
    $el[0].style.width = '';
    if (effect === 'reveal' && !visibleByBreakpoint) {
      $viewEl.transform('');
      $backdropEl.transform('');
    }
    $el.removeClass('panel-resizing');
    Utils.nextFrame(() => {
      $el.transition('');
      if (effect === 'reveal') {
        $backdropEl.transition('');
        if ($viewEl) $viewEl.transition('');
      }
    });
  }

  function handleResize() {
    if (!panel.opened || !panel.resizableWidth) return;
    panelMinWidth = transformCSSWidth($el.css('min-width'));
    panelMaxWidth = transformCSSWidth($el.css('max-width'));

    if (panelMinWidth && !Number.isNaN(panelMinWidth) && panel.resizableWidth < panelMinWidth) {
      panel.resizableWidth = Math.max(panel.resizableWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth) && panel.resizableWidth > panelMaxWidth) {
      panel.resizableWidth = Math.min(panel.resizableWidth, panelMaxWidth);
    }
    panel.resizableWidth = Math.min(Math.max(panel.resizableWidth, 0), app.width);

    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
  }

  if (panel.$el.find('.panel-resize-handler').length === 0) {
    panel.$el.append('<div class="panel-resize-handler"></div>');
  }
  panel.$resizeHandlerEl = panel.$el.children('.panel-resize-handler');

  $el.addClass('panel-resizable');

  // Add Events
  const passive = Support.passiveListener ? { passive: true } : false;

  panel.$el.on(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
  app.on('touchmove:active', handleTouchMove);
  app.on('touchend:passive', handleTouchEnd);
  app.on('resize', handleResize);
  panel.on('beforeOpen', handleResize);

  panel.once('panelDestroy', () => {
    $el.removeClass('panel-resizable');
    panel.$resizeHandlerEl.remove();
    panel.$el.off(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
    app.off('resize', handleResize);
    panel.off('beforeOpen', handleResize);
  });
}

class Panel extends Framework7Class {
  constructor(app, params = {}) {
    const extendedParams = Utils.extend(
      { on: {} },
      app.params.panel,
      params
    );
    super(extendedParams, [app]);

    const panel = this;

    panel.params = extendedParams;

    let $el;
    if (panel.params.el) {
      $el = $(panel.params.el).eq(0);
    } else if (panel.params.content) {
      $el = $(panel.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
    }

    if ($el.length === 0) return panel;
    if ($el[0].f7Panel) return $el[0].f7Panel;

    $el[0].f7Panel = panel;

    let { side, effect, resizable } = panel.params;
    if (typeof side === 'undefined') side = $el.hasClass('panel-left') ? 'left' : 'right';
    if (typeof effect === 'undefined') effect = $el.hasClass('panel-cover') ? 'cover' : 'reveal';
    if (typeof resizable === 'undefined') resizable = $el.hasClass('panel-resizable');

    let $backdropEl;
    if (panel.params.backdrop && panel.params.backdropEl) {
      $backdropEl = $(panel.params.backdropEl);
    } else if (panel.params.backdrop) {
      $backdropEl = app.root.children('.panel-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="panel-backdrop"></div>');
        app.root.prepend($backdropEl);
      }
    }

    Utils.extend(panel, {
      app,
      side,
      effect,
      resizable,
      $el,
      el: $el[0],
      opened: false,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
    });

    // Install Modules
    panel.useModules();

    // Init
    panel.init();

    return panel;
  }

  getViewEl() {
    const panel = this;
    const app = panel.app;
    let viewEl;
    if (app.root.children('.views').length > 0) {
      viewEl = app.root.children('.views')[0];
    } else {
      viewEl = app.root.children('.view')[0];
    }
    return viewEl;
  }

  enableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = false;
    panel.setVisibleBreakpoint();
    return panel;
  }

  disableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = true;
    panel.setVisibleBreakpoint();
    return panel;
  }

  toggleVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = !panel.visibleBreakpointDisabled;
    panel.setVisibleBreakpoint();
    return panel;
  }

  setVisibleBreakpoint(emitEvents = true) {
    const panel = this;
    const app = panel.app;
    if (!panel.visibleBreakpointResizeHandler) {
      panel.visibleBreakpointResizeHandler = function visibleBreakpointResizeHandler() {
        panel.setVisibleBreakpoint();
      };
      app.on('resize', panel.visibleBreakpointResizeHandler);
    }
    const { side, $el, params, visibleBreakpointDisabled } = panel;
    const breakpoint = params.visibleBreakpoint;
    const $viewEl = $(panel.getViewEl());
    const wasVisible = $el.hasClass('panel-in-breakpoint');

    if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null && !visibleBreakpointDisabled) {
      if (!wasVisible) {
        $('html').removeClass(`with-panel-${side}-reveal with-panel-${side}-cover with-panel`);
        $el.addClass('panel-in-breakpoint').removeClass('panel-in panel-in-collapsed');
        panel.onOpen(false);
        panel.onOpened();
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`,
        });
        app.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit('local::breakpoint panelBreakpoint', panel);
          panel.$el.trigger('panel:breakpoint');
        }
      } else {
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`,
        });
      }
    } else if (wasVisible) {
      $el.removeClass('panel-in-breakpoint panel-in');
      panel.onClose();
      panel.onClosed();
      $viewEl.css({
        [`margin-${side}`]: '',
      });
      if (emitEvents) {
        panel.emit('local::breakpoint panelBreakpoint', panel);
        panel.$el.trigger('panel:breakpoint');
      }
    }
  }

  enableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = false;
    panel.setCollapsedBreakpoint();
    return panel;
  }

  disableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = true;
    panel.setCollapsedBreakpoint();
    return panel;
  }

  toggleCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = !panel.collapsedBreakpointDisabled;
    panel.setCollapsedBreakpoint();
    return panel;
  }

  setCollapsedBreakpoint(emitEvents) {
    const panel = this;
    const app = panel.app;
    if (!panel.collapsedBreakpointResizeHandler) {
      panel.collapsedBreakpointResizeHandler = function collapsedBreakpointResizeHandler() {
        panel.setCollapsedBreakpoint();
      };
      app.on('resize', panel.collapsedBreakpointResizeHandler);
    }
    const { side, $el, params, collapsedBreakpointDisabled } = panel;
    if ($el.hasClass('panel-in-breakpoint')) return;
    const breakpoint = params.collapsedBreakpoint;
    const wasVisible = $el.hasClass('panel-in-collapsed');

    if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null && !collapsedBreakpointDisabled) {
      if (!wasVisible) {
        $('html').removeClass(`with-panel-${side}-reveal with-panel-${side}-cover with-panel`);
        $el.addClass('panel-in-collapsed').removeClass('panel-in');
        panel.collapsed = true;
        app.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit('local::collapsedBreakpoint panelCollapsedBreakpoint', panel);
          panel.$el.trigger('panel:collapsedbreakpoint');
        }
      }
    } else if (wasVisible) {
      $el.removeClass('panel-in-collapsed panel-in');
      panel.collapsed = false;
      if (emitEvents) {
        panel.emit('local::collapsedBreakpoint panelCollapsedBreakpoint', panel);
        panel.$el.trigger('panel:collapsedbreakpoint');
      }
    }
  }

  enableResizable() {
    const panel = this;
    if (panel.resizableInitialized) {
      panel.resizable = true;
      panel.$el.addClass('panel-resizable');
    } else {
      resizablePanel(panel);
    }
    return panel;
  }

  disableResizable() {
    const panel = this;
    panel.resizable = false;
    panel.$el.removeClass('panel-resizable');
    return panel;
  }

  enableSwipe() {
    const panel = this;
    if (panel.swipeInitialized) {
      panel.swipeable = true;
    } else {
      swipePanel(panel);
    }
    return panel;
  }

  disableSwipe() {
    const panel = this;
    panel.swipeable = false;
    return panel;
  }

  onOpen(modifyHtmlClasses = true) {
    const panel = this;
    const app = panel.app;

    panel.opened = true;
    app.panel.allowOpen = false;

    panel.$el.trigger('panel:beforeopen');
    panel.emit('local::beforeOpen panelBeforeOpen', panel);

    if (modifyHtmlClasses) {
      $('html').addClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }

    panel.$el.trigger('panel:open');
    panel.emit('local::open panelOpen', panel);
  }

  onOpened() {
    const panel = this;
    const app = panel.app;

    app.panel.allowOpen = true;

    panel.$el.trigger('panel:opened');
    panel.emit('local::opened panelOpened', panel);
  }

  onClose() {
    const panel = this;
    const app = panel.app;

    panel.opened = false;
    app.panel.allowOpen = false;

    panel.$el.trigger('panel:beforeclose');
    panel.emit('local::beforeClose panelBeforeClose', panel);

    $('html').addClass('with-panel-closing');
    $('html').removeClass(`with-panel with-panel-${panel.side}-${panel.effect}`);

    panel.$el.trigger('panel:close');
    panel.emit('local::close panelClose', panel);
  }

  onClosed() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    $('html').removeClass('with-panel-closing');
    panel.$el.removeClass('panel-out');
    if (panel.$backdropEl) {
      const otherPanel = app.panel.get('.panel-in');
      const shouldHideBackdrop = !otherPanel || (otherPanel && !otherPanel.$backdropEl);
      if (shouldHideBackdrop) {
        panel.$backdropEl.removeClass('panel-backdrop-in');
      }
    }
    panel.$el.trigger('panel:closed');
    panel.emit('local::closed panelClosed', panel);
  }

  toggle(animate = true) {
    const panel = this;
    const breakpoint = panel.params.visibleBreakpoint;
    const app = panel.app;
    if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null) {
      return panel.toggleVisibleBreakpoint();
    }
    if (panel.opened) panel.close(animate);
    else panel.open(animate);
    return panel;
  }

  insertToRoot() {
    const panel = this;
    const { $el, app, $backdropEl } = panel;
    const $panelParentEl = $el.parent();
    const wasInDom = $el.parents(document).length > 0;

    if (!$panelParentEl.is(app.root) || $el.prevAll('.views, .view').length) {
      const $insertBeforeEl = app.root.children('.panel, .views, .view').eq(0);
      const $insertAfterEl = app.root.children('.panel-backdrop').eq(0);

      if ($insertBeforeEl.length) {
        $el.insertBefore($insertBeforeEl);
      } else if ($insertAfterEl) {
        $el.insertBefore($insertAfterEl);
      } else {
        app.root.prepend($el);
      }

      if ($backdropEl
        && $backdropEl.length
        && (
          (
            !$backdropEl.parent().is(app.root)
            && $backdropEl.nextAll('.panel').length === 0
          )
          || (
            $backdropEl.parent().is(app.root)
            && $backdropEl.nextAll('.panel').length === 0
          )
        )
      ) {
        $backdropEl.insertBefore($el);
      }

      panel.once('panelClosed', () => {
        if (wasInDom) {
          $panelParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
  }

  open(animate = true) {
    const panel = this;
    const app = panel.app;

    if (!app.panel.allowOpen) return false;

    const { effect, $el, $backdropEl, opened } = panel;

    if (!$el || $el.hasClass('panel-in')) {
      return panel;
    }

    panel.insertToRoot();

    // Ignore if opened
    if (opened || $el.hasClass('panel-in-breakpoint') || $el.hasClass('panel-in')) return false;

    // Close if some panel is opened
    const otherOpenedPanel = app.panel.get('.panel-in');
    if (otherOpenedPanel && otherOpenedPanel !== panel) {
      otherOpenedPanel.close(animate);
    }

    $el[animate ? 'removeClass' : 'addClass']('not-animated');
    $el.addClass('panel-in');

    if ($backdropEl) {
      $backdropEl.addClass('panel-backdrop-in');
      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
    }

    if (panel.effect === 'cover') {
      /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
      panel._clientLeft = $el[0].clientLeft;
    }

    // Transitionend
    const transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

    function panelTransitionEnd() {
      transitionEndTarget.transitionEnd((e) => {
        if ($(e.target).is(transitionEndTarget)) {
          if ($el.hasClass('panel-out')) {
            panel.onClosed();
          } else {
            panel.onOpened();
          }
        } else panelTransitionEnd();
      });
    }
    if (animate) {
      if ($backdropEl) {
        $backdropEl.removeClass('not-animated');
      }
      panelTransitionEnd();
      $el
        .removeClass('panel-out not-animated')
        .addClass('panel-in');
      panel.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass('not-animated');
      }
      $el.removeClass('panel-out').addClass('panel-in not-animated');
      panel.onOpen();
      panel.onOpened();
    }

    return true;
  }

  close(animate = true) {
    const panel = this;

    const { effect, $el, $backdropEl, opened } = panel;
    if (!opened || $el.hasClass('panel-in-breakpoint') || !$el.hasClass('panel-in')) return panel;

    $el[animate ? 'removeClass' : 'addClass']('not-animated');
    if ($backdropEl) {
      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
    }

    const transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

    function transitionEnd() {
      if ($el.hasClass('panel-out')) {
        panel.onClosed();
      } else if ($el.hasClass('panel-in')) {
        panel.onOpened();
      }
      $('html').removeClass('with-panel-closing');
    }
    if (animate) {
      transitionEndTarget
        .transitionEnd(() => {
          transitionEnd();
        });
      $el
        .removeClass('panel-in')
        .addClass('panel-out');
      // Emit close
      panel.onClose();
    } else {
      $el
        .addClass('not-animated')
        .removeClass('panel-in')
        .addClass('panel-out');
      // Emit close
      panel.onClose();
      panel.onClosed();
    }

    return panel;
  }

  init() {
    const panel = this;
    // const app = panel.app;
    if (typeof panel.params.visibleBreakpoint !== 'undefined') {
      panel.setVisibleBreakpoint();
    }
    if (typeof panel.params.collapsedBreakpoint !== 'undefined') {
      panel.setCollapsedBreakpoint();
    }
    if (panel.params.swipe) {
      panel.enableSwipe();
    }
    if (panel.resizable) {
      panel.enableResizable();
    }
  }

  destroy() {
    let panel = this;
    const app = panel.app;

    if (!panel.$el) {
      // Panel already destroyed
      return;
    }

    panel.emit('local::beforeDestroy panelBeforeDestroy', panel);
    panel.$el.trigger('panel:beforedestroy');

    if (panel.visibleBreakpointResizeHandler) {
      app.off('resize', panel.visibleBreakpointResizeHandler);
    }
    if (panel.collapsedBreakpointResizeHandler) {
      app.off('resize', panel.collapsedBreakpointResizeHandler);
    }
    if (panel.$el.hasClass('panel-in-breakpoint') || panel.$el.hasClass('panel-in-collapsed')) {
      const $viewEl = $(panel.getViewEl());
      panel.$el.removeClass('panel-in-breakpoint panel-in-collapsed panel-in');
      $viewEl.css({
        [`margin-${panel.side}`]: '',
      });
      panel.emit('local::breakpoint panelBreakpoint', panel);
      panel.$el.trigger('panel:breakpoint');
    }

    panel.$el.trigger('panel:destroy');
    panel.emit('local::destroy panelDestroy', panel);
    if (panel.el) {
      panel.el.f7Panel = null;
      delete panel.el.f7Panel;
    }
    Utils.deleteProps(panel);

    panel = null;
  }
}

var Panel$1 = {
  name: 'panel',
  params: {
    panel: {
      opened: undefined, // default based on panel-in class
      side: undefined, // default based on panel class
      effect: undefined, // default based on panel class
      resizable: undefined, // default based on panel-resizable class
      backdrop: true,
      backdropEl: undefined,
      visibleBreakpoint: undefined,
      collapsedBreakpoint: undefined,
      swipe: false, // or true
      swipeNoFollow: false, // or true
      swipeOnlyClose: false,
      swipeActiveArea: 0,
      swipeThreshold: 0,
      closeByBackdropClick: true,
    },
  },
  static: {
    Panel,
  },
  instance: {
    panel: {
      allowOpen: true,
    },
  },
  create() {
    const app = this;
    Utils.extend(app.panel, {
      create(params) {
        return new Panel(app, params);
      },
      get(el = '.panel') {
        if (el instanceof Panel) return el;
        if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line
        const $el = $(el);
        if ($el.length === 0 || $el.length > 1) return undefined;
        return $el[0].f7Panel;
      },
      destroy(el = '.panel') {
        const panel = app.panel.get(el);
        if (panel && panel.destroy) return panel.destroy();
        return undefined;
      },
      open(el = '.panel', animate) {
        if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line
        let panel = app.panel.get(el);
        if (panel && panel.open) return panel.open(animate);
        if (!panel) {
          panel = app.panel.create({ el });
          return panel.open(animate);
        }
        return undefined;
      },
      close(el = '.panel-in', animate) {
        if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line
        let panel = app.panel.get(el);
        if (panel && panel.open) return panel.close(animate);
        if (!panel) {
          panel = app.panel.create({ el });
          return panel.close(animate);
        }
        return undefined;
      },
      toggle(el = '.panel', animate) {
        if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line
        let panel = app.panel.get(el);
        if (panel && panel.toggle) return panel.toggle(animate);
        if (!panel) {
          panel = app.panel.create({ el });
          return panel.toggle(animate);
        }
        return undefined;
      },
    });
  },
  on: {
    init() {
      const app = this;
      $('.panel-init').each((index, panelEl) => {
        const params = Object.assign(
          { el: panelEl },
          $(panelEl).dataset() || {}
        );
        app.panel.create(params);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.panel-init').each((index, panelEl) => {
        const params = Object.assign(
          { el: panelEl },
          $(panelEl).dataset() || {}
        );
        app.panel.create(params);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.panel-init').each((index, panelEl) => {
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy) panel.destroy();
      });
    },
  },
  vnode: {
    'panel-init': {
      insert(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const params = Object.assign(
          { el: panelEl },
          $(panelEl).dataset() || {}
        );
        app.panel.create(params);
      },
      destroy(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy) panel.destroy();
      },
    },
  },
  clicks: {
    '.panel-open': function open(clickedEl, data = {}) {
      const app = this;
      app.panel.open(data.panel, data.animate);
    },
    '.panel-close': function close(clickedEl, data = {}) {
      const app = this;
      app.panel.close(data.panel, data.animate);
    },
    '.panel-toggle': function close(clickedEl, data = {}) {
      const app = this;
      app.panel.toggle(data.panel, data.animate);
    },
    '.panel-backdrop': function close() {
      const app = this;
      const $panelEl = $('.panel-in:not(.panel-out)');
      if (!$panelEl.length) return;
      const instance = $panelEl[0] && $panelEl[0].f7Panel;
      $panelEl.trigger('panel:backdrop-click');
      if (instance) {
        instance.emit('backdropClick', instance);
      }
      app.emit('panelBackdropClick', instance || $panelEl[0]);
      if (app.params.panel.closeByBackdropClick) app.panel.close();
    },
  },
};

const CardExpandable = {
  open(cardEl = '.card-expandable', animate = true) {
    const app = this;

    const $cardEl = $(cardEl).eq(0);
    if (!$cardEl || !$cardEl.length) return;
    if ($cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) return;

    const $pageEl = $cardEl.parents('.page').eq(0);
    if (!$pageEl.length) return;

    if ($pageEl.find('.card-opened').length) {
      return;
    }

    let prevented;

    function prevent() {
      prevented = true;
    }

    $cardEl.trigger('card:beforeopen', { prevent });
    app.emit('cardBeforeOpen', $cardEl[0], prevent);

    if (prevented) return;

    const cardParams = Object.assign({ animate }, app.params.card, $cardEl.dataset());

    const $pageContentEl = $cardEl.parents('.page-content');

    let $backdropEl;
    if ($cardEl.attr('data-backdrop-el')) {
      $backdropEl = $($cardEl.attr('data-backdrop-el'));
    }
    if (!$backdropEl && cardParams.backdrop) {
      $backdropEl = $pageContentEl.find('.card-backdrop');
      if (!$backdropEl.length) {
        $backdropEl = $('<div class="card-backdrop"></div>');
        $pageContentEl.append($backdropEl);
      }
    }

    let $navbarEl;
    let $toolbarEl;
    if (cardParams.hideNavbarOnOpen) {
      $navbarEl = $pageEl.children('.navbar');
      if (!$navbarEl.length) {
        if ($pageEl[0].f7Page) $navbarEl = $pageEl[0].f7Page.$navbarEl;
      }
    }
    if (cardParams.hideToolbarOnOpen) {
      $toolbarEl = $pageEl.children('.toolbar');
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents('.view').children('.toolbar');
      }
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents('.views').children('.toolbar');
      }
    }

    const currTransform = $cardEl.css('transform');
    let hasTransform;
    if (currTransform && currTransform.match(/[2-9]/)) {
      hasTransform = true;
    }
    const $cardContentEl = $cardEl.children('.card-content');

    const $cardSizeEl = $(document.createElement('div')).addClass('card-expandable-size');
    $cardEl.append($cardSizeEl);

    let cardWidth = $cardEl[0].offsetWidth;
    let cardHeight = $cardEl[0].offsetHeight;
    let pageWidth = $pageEl[0].offsetWidth;
    let pageHeight = $pageEl[0].offsetHeight;

    let maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
    let maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;

    let statusbarHeight;
    if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
      statusbarHeight = parseInt($navbarEl.css('--f7-safe-area-top'), 10);
      if (Number.isNaN(statusbarHeight)) statusbarHeight = 0;
    }
    if (statusbarHeight) {
      maxHeight -= statusbarHeight;
    }

    let scaleX = maxWidth / cardWidth;
    let scaleY = maxHeight / cardHeight;

    let offset = $cardEl.offset();
    let pageOffset = $pageEl.offset();
    if (statusbarHeight) {
      pageOffset.top += statusbarHeight / 2;
    }
    offset.left -= pageOffset.left;

    let cardLeftOffset;
    let cardTopOffset;

    if (hasTransform) {
      const transformValues = currTransform
        .replace(/matrix\(|\)/g, '')
        .split(',')
        .map(el => el.trim());
      if (transformValues && transformValues.length > 1) {
        const scale = parseFloat(transformValues[0]);
        cardLeftOffset = offset.left - cardWidth * (1 - scale) / 2;
        cardTopOffset = offset.top - pageOffset.top - cardHeight * (1 - scale) / 2;
        if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
      } else {
        cardLeftOffset = $cardEl[0].offsetLeft;
        cardTopOffset = $cardEl[0].offsetTop - ($pageContentEl.length ? $pageContentEl[0].scrollTop : 0);
      }
    } else {
      cardLeftOffset = offset.left;
      cardTopOffset = offset.top - pageOffset.top;
      if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
    }

    cardLeftOffset -= (pageWidth - maxWidth) / 2;
    cardTopOffset -= (pageHeight - maxHeight) / 2;

    let cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
    if (app.rtl) {
      [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
    }
    let cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
    let translateX = (cardRightOffset - cardLeftOffset) / 2;
    let translateY = (cardBottomOffset - cardTopOffset) / 2;
    if (cardParams.hideNavbarOnOpen && $navbarEl && $navbarEl.length) {
      if ($navbarEl.closest('.navbar-hidden').length) {
        // Was hidden
        $cardEl[0].f7KeepNavbarOnClose = true;
      } else {
        delete $cardEl[0].f7KeepNavbarOnClose;
        app.navbar.hide($navbarEl, cardParams.animate, cardParams.hideStatusbarOnOpen);
      }
    }
    if (cardParams.hideToolbarOnOpen && $toolbarEl && $toolbarEl.length) {
      if ($toolbarEl.closest('.toolbar-hidden').length) {
        // Was hidden
        $cardEl[0].f7KeepToolbarOnClose = true;
      } else {
        delete $cardEl[0].f7KeepToolbarOnClose;
        app.toolbar.hide($toolbarEl, cardParams.animate);
      }
    }
    if ($backdropEl) {
      $backdropEl.removeClass('card-backdrop-out').addClass('card-backdrop-in');
    }
    $cardEl.removeClass('card-transitioning');
    if (cardParams.animate) {
      $cardEl.addClass('card-opening');
    }
    $cardEl.trigger('card:open');
    app.emit('cardOpen', $cardEl[0]);
    function transitionEnd() {
      $pageEl.addClass('page-with-card-opened');
      if (app.device.ios && $pageContentEl.length) {
        $pageContentEl.css('height', `${$pageContentEl[0].offsetHeight + 1}px`);
        setTimeout(() => {
          $pageContentEl.css('height', '');
        });
      }
      $cardEl.addClass('card-opened');
      $cardEl.removeClass('card-opening');
      $cardEl.trigger('card:opened');
      app.emit('cardOpened', $cardEl[0], $pageEl[0]);
    }
    $cardContentEl
      .css({
        width: `${maxWidth}px`,
        height: `${maxHeight}px`,
      })
      .transform(`translate3d(${app.rtl ? (cardLeftOffset + translateX) : (-cardLeftOffset - translateX)}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);

    $cardEl
      .transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
    if (cardParams.animate) {
      $cardEl.transitionEnd(() => {
        transitionEnd();
      });
    } else {
      transitionEnd();
    }

    function onResize() {
      $cardEl.removeClass('card-transitioning');
      cardWidth = $cardEl[0].offsetWidth;
      cardHeight = $cardEl[0].offsetHeight;
      pageWidth = $pageEl[0].offsetWidth;
      pageHeight = $pageEl[0].offsetHeight;
      maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
      maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;

      statusbarHeight = 0;
      if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
        statusbarHeight = parseInt($navbarEl.css('--f7-safe-area-top'), 10);
        if (Number.isNaN(statusbarHeight)) statusbarHeight = 0;
      }
      if (statusbarHeight) {
        maxHeight -= statusbarHeight;
      }


      scaleX = maxWidth / cardWidth;
      scaleY = maxHeight / cardHeight;

      $cardEl.transform('translate3d(0px, 0px, 0) scale(1)');
      offset = $cardEl.offset();
      pageOffset = $pageEl.offset();
      if (statusbarHeight) {
        pageOffset.top += statusbarHeight / 2;
      }
      offset.left -= pageOffset.left;
      offset.top -= pageOffset.top;

      cardLeftOffset = offset.left - (pageWidth - maxWidth) / 2;
      if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
      cardTopOffset = offset.top - (pageHeight - maxHeight) / 2;

      cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
      cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
      if (app.rtl) {
        [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
      }
      translateX = (cardRightOffset - cardLeftOffset) / 2;
      translateY = (cardBottomOffset - cardTopOffset) / 2;

      $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
      $cardContentEl
        .css({
          width: `${maxWidth}px`,
          height: `${maxHeight}px`,
        })
        .transform(`translate3d(${app.rtl ? (cardLeftOffset + translateX) : (-cardLeftOffset - translateX)}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);
    }

    let cardScrollTop;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchEndX;
    let touchEndY;
    let isScrolling;
    let progress;
    let isV;
    let isH;
    let $cardScrollableEl;
    function onTouchStart(e) {
      if (!$(e.target).closest($cardEl).length) return;
      if (!$cardEl.hasClass('card-opened')) return;
      $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);

      if ($cardScrollableEl[0]
        && $cardScrollableEl[0] !== $cardContentEl[0]
        && !$cardScrollableEl[0].contains(e.target)
      ) {
        cardScrollTop = 0;
      } else {
        cardScrollTop = $cardScrollableEl.scrollTop();
      }
      isTouched = true;
      touchStartX = e.targetTouches[0].pageX;
      touchStartY = e.targetTouches[0].pageY;
      isScrolling = undefined;
      isV = false;
      isH = false;
    }
    function onTouchMove(e) {
      if (!isTouched) return;
      touchEndX = e.targetTouches[0].pageX;
      touchEndY = e.targetTouches[0].pageY;
      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(touchEndY - touchStartY) > Math.abs(touchEndX - touchStartX));
      }
      if (!isH && !isV) {
        if (!isScrolling && e.targetTouches[0].clientX <= 50) {
          isH = true;
        } else {
          isV = true;
        }
      }

      if (!(isH || isV) || (isV && cardScrollTop !== 0)) {
        isTouched = true;
        isMoved = true;
        return;
      }
      if (!isMoved) {
        $cardEl.removeClass('card-transitioning');
      }

      isMoved = true;
      progress = isV ? Math.max((touchEndY - touchStartY) / 150, 0) : Math.max((touchEndX - touchStartX) / (cardWidth / 2), 0);
      if ((progress > 0 && isV) || isH) {
        if (isV && app.device.ios && $cardScrollableEl[0] === $cardContentEl[0]) {
          $cardScrollableEl.css('-webkit-overflow-scrolling', 'auto');
          $cardScrollableEl.scrollTop(0);
        }
        e.preventDefault();
      }

      if (progress > 1) progress **= 0.3;
      if (progress > (isV ? 1.3 : 1.1)) {
        isTouched = false;
        isMoved = false;
        app.card.close($cardEl);
      } else {
        $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX * (1 - progress * 0.2)}, ${scaleY * (1 - progress * 0.2)})`);
      }
    }
    function onTouchEnd() {
      if (!isTouched || !isMoved) return;
      isTouched = false;
      isMoved = false;
      if (app.device.ios) {
        $cardScrollableEl.css('-webkit-overflow-scrolling', '');
      }
      if (progress >= 0.8) {
        app.card.close($cardEl);
      } else {
        $cardEl
          .addClass('card-transitioning')
          .transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
      }
    }

    $cardEl[0].detachEventHandlers = function detachEventHandlers() {
      app.off('resize', onResize);
      if (Support.touch && cardParams.swipeToClose) {
        app.off('touchstart:passive', onTouchStart);
        app.off('touchmove:active', onTouchMove);
        app.off('touchend:passive', onTouchEnd);
      }
    };

    app.on('resize', onResize);
    if (Support.touch && cardParams.swipeToClose) {
      app.on('touchstart:passive', onTouchStart);
      app.on('touchmove:active', onTouchMove);
      app.on('touchend:passive', onTouchEnd);
    }
  },
  close(cardEl = '.card-expandable.card-opened', animate = true) {
    const app = this;
    const $cardEl = $(cardEl).eq(0);
    if (!$cardEl || !$cardEl.length) return;
    if (!$cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) return;

    const $cardContentEl = $cardEl.children('.card-content');
    const $pageContentEl = $cardEl.parents('.page-content');

    const $pageEl = $cardEl.parents('.page').eq(0);
    if (!$pageEl.length) return;

    const cardParams = Object.assign({ animate }, app.params.card, $cardEl.dataset());
    const $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);

    let $navbarEl;
    let $toolbarEl;

    let $backdropEl;
    if ($cardEl.attr('data-backdrop-el')) {
      $backdropEl = $($cardEl.attr('data-backdrop-el'));
    }
    if (cardParams.backdrop) {
      $backdropEl = $cardEl.parents('.page-content').find('.card-backdrop');
    }

    if (cardParams.hideNavbarOnOpen) {
      $navbarEl = $pageEl.children('.navbar');
      if (!$navbarEl.length) {
        if ($pageEl[0].f7Page) $navbarEl = $pageEl[0].f7Page.$navbarEl;
      }
      if ($navbarEl && $navbarEl.length && !$cardEl[0].f7KeepNavbarOnClose) {
        app.navbar.show($navbarEl, cardParams.animate);
      }
    }
    if (cardParams.hideToolbarOnOpen) {
      $toolbarEl = $pageEl.children('.toolbar');
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents('.view').children('.toolbar');
      }
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents('.views').children('.toolbar');
      }
      if ($toolbarEl && $toolbarEl.length && !$cardEl[0].f7KeepToolbarOnClose) {
        app.toolbar.show($toolbarEl, cardParams.animate);
      }
    }

    $pageEl.removeClass('page-with-card-opened');

    if (app.device.ios && $pageContentEl.length) {
      $pageContentEl.css('height', `${$pageContentEl[0].offsetHeight + 1}px`);
      setTimeout(() => {
        $pageContentEl.css('height', '');
      });
    }

    if ($backdropEl && $backdropEl.length) {
      $backdropEl.removeClass('card-backdrop-in').addClass('card-backdrop-out');
    }

    $cardEl.removeClass('card-opened card-transitioning');
    if (cardParams.animate) {
      $cardEl.addClass('card-closing');
    } else {
      $cardEl.addClass('card-no-transition');
    }
    $cardEl.transform('');
    $cardEl.trigger('card:close');
    app.emit('cardClose', $cardEl[0], $pageEl[0]);

    const animateWidth = $cardEl.hasClass('card-expandable-animate-width');

    function transitionEnd() {
      if (!animateWidth) {
        $cardContentEl
          .css({
            width: '',
            height: '',
          });
      }
      if ($backdropEl && $backdropEl.length) {
        $backdropEl.removeClass('card-backdrop-in card-backdrop-out');
      }
      $cardEl.removeClass('card-closing card-no-transition');
      $cardEl.trigger('card:closed');
      $cardEl.find('.card-expandable-size').remove();
      app.emit('cardClosed', $cardEl[0], $pageEl[0]);
    }
    if (animateWidth) {
      $cardContentEl
        .css({
          width: '',
          height: '',
        });
    }

    $cardContentEl
      .transform('')
      .scrollTop(0, animate ? 300 : 0);
    if ($cardScrollableEl.length && $cardScrollableEl[0] !== $cardContentEl[0]) {
      $cardScrollableEl.scrollTop(0, animate ? 300 : 0);
    }
    if (animate) {
      $cardContentEl.transitionEnd(() => {
        transitionEnd();
      });
    } else {
      transitionEnd();
    }

    if ($cardEl[0].detachEventHandlers) {
      $cardEl[0].detachEventHandlers();
      delete $cardEl[0].detachEventHandlers;
    }
  },
  toggle(cardEl = '.card-expandable', animate) {
    const app = this;
    const $cardEl = $(cardEl).eq(0);
    if (!$cardEl.length) return;
    if ($cardEl.hasClass('card-opened')) {
      app.card.close($cardEl, animate);
    } else {
      app.card.open($cardEl, animate);
    }
  },
};

var Card = {
  name: 'card',
  params: {
    card: {
      hideNavbarOnOpen: true,
      hideStatusbarOnOpen: true,
      hideToolbarOnOpen: true,
      scrollableEl: '.card-content',
      swipeToClose: true,
      closeByBackdropClick: true,
      backdrop: true,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      card: {
        open: CardExpandable.open.bind(app),
        close: CardExpandable.close.bind(app),
        toggle: CardExpandable.toggle.bind(app),
      },
    });
  },
  on: {
    pageBeforeIn(page) {
      const app = this;
      if (app.params.card.hideNavbarOnOpen && page.navbarEl && page.$el.find('.card-opened.card-expandable').length) {
        app.navbar.hide(page.navbarEl, true, app.params.card.hideStatusbarOnOpen);
      }

      if (app.params.card.hideToolbarOnOpen && page.$el.find('.card-opened.card-expandable').length) {
        let $toolbarEl = page.$el.children('.toolbar');
        if (!$toolbarEl.length) {
          $toolbarEl = page.$el.parents('.view').children('.toolbar');
        }
        if (!$toolbarEl.length) {
          $toolbarEl = page.$el.parents('.views').children('.toolbar');
        }
        if ($toolbarEl && $toolbarEl.length) {
          app.toolbar.hide($toolbarEl);
        }
      }
    },
  },
  clicks: {
    '.card-close': function closeCard($clickedEl, data) {
      const app = this;
      app.card.close(data.card, data.animate);
    },
    '.card-open': function closeCard($clickedEl, data) {
      const app = this;
      app.card.open(data.card, data.animate);
    },
    '.card-expandable': function toggleExpandableCard($clickedEl, data, e) {
      const app = this;
      if ($clickedEl.hasClass('card-opened') || $clickedEl.hasClass('card-opening') || $clickedEl.hasClass('card-closing')) return;
      if ($(e.target).closest('.card-prevent-open, .card-close').length) return;
      app.card.open($clickedEl);
    },
    '.card-backdrop-in': function onBackdropClick() {
      const app = this;
      let needToClose = false;
      if (app.params.card.closeByBackdropClick) needToClose = true;
      const $openedCardEl = $('.card-opened');
      if (!$openedCardEl.length) return;
      if ($openedCardEl.attr('data-close-by-backdrop-click') === 'true') {
        needToClose = true;
      } else if ($openedCardEl.attr('data-close-by-backdrop-click') === 'false') {
        needToClose = false;
      }
      if (needToClose) app.card.close($openedCardEl);
    },
  },
};

var Chip = {
  name: 'chip',
};

// Form Data
const FormData$1 = {
  store(form, data) {
    const app = this;
    let formId = form;

    const $formEl = $(form);
    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
      formId = $formEl.attr('id');
    }
    // Store form data in app.formsData
    app.form.data[`form-${formId}`] = data;

    // Store form data in local storage also
    win.localStorage[`f7form-${formId}`] = JSON.stringify(data);
  },
  get(form) {
    const app = this;
    let formId = form;

    const $formEl = $(form);
    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
      formId = $formEl.attr('id');
    }

    if (win.localStorage[`f7form-${formId}`]) {
      return JSON.parse(win.localStorage[`f7form-${formId}`]);
    }
    if (app.form.data[`form-${formId}`]) {
      return app.form.data[`form-${formId}`];
    }
    return undefined;
  },
  remove(form) {
    const app = this;
    let formId = form;

    const $formEl = $(form);
    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
      formId = $formEl.attr('id');
    }

    // Delete form data from app.formsData
    if (app.form.data[`form-${formId}`]) {
      app.form.data[`form-${formId}`] = '';
      delete app.form.data[`form-${formId}`];
    }

    // Delete form data from local storage also
    if (win.localStorage[`f7form-${formId}`]) {
      win.localStorage[`f7form-${formId}`] = '';
      win.localStorage.removeItem(`f7form-${formId}`);
    }
  },
};

// Form Storage
const FormStorage = {
  init(formEl) {
    const app = this;
    const $formEl = $(formEl);
    const formId = $formEl.attr('id');
    if (!formId) return;
    const initialData = app.form.getFormData(formId);
    if (initialData) {
      app.form.fillFromData($formEl, initialData);
    }
    function store() {
      const data = app.form.convertToData($formEl);
      if (!data) return;
      app.form.storeFormData(formId, data);
      $formEl.trigger('form:storedata', data);
      app.emit('formStoreData', $formEl[0], data);
    }
    $formEl.on('change submit', store);
  },
  destroy(formEl) {
    const $formEl = $(formEl);
    $formEl.off('change submit');
  },
};

// Form To/From Data
function formToData(formEl) {
  const app = this;
  const $formEl = $(formEl).eq(0);
  if ($formEl.length === 0) return undefined;

  // Form data
  const data = {};

  // Skip input types
  const skipTypes = ['submit', 'image', 'button', 'file'];
  const skipNames = [];
  $formEl.find('input, select, textarea').each((inputIndex, inputEl) => {
    const $inputEl = $(inputEl);
    if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
      return;
    }
    const name = $inputEl.attr('name');
    const type = $inputEl.attr('type');
    const tag = inputEl.nodeName.toLowerCase();
    if (skipTypes.indexOf(type) >= 0) return;
    if (skipNames.indexOf(name) >= 0 || !name) return;
    if (tag === 'select' && $inputEl.prop('multiple')) {
      skipNames.push(name);
      data[name] = [];
      $formEl.find(`select[name="${name}"] option`).each((index, el) => {
        if (el.selected) data[name].push(el.value);
      });
    } else {
      switch (type) {
        case 'checkbox':
          skipNames.push(name);
          data[name] = [];
          $formEl.find(`input[name="${name}"]`).each((index, el) => {
            if (el.checked) data[name].push(el.value);
          });
          break;
        case 'radio':
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((index, el) => {
            if (el.checked) data[name] = el.value;
          });
          break;
        default:
          data[name] = $inputEl.val();
          break;
      }
    }
  });
  $formEl.trigger('form:todata', data);
  app.emit('formToData', $formEl[0], data);

  return data;
}
function formFromData(formEl, formData) {
  const app = this;
  const $formEl = $(formEl).eq(0);
  if (!$formEl.length) return;

  let data = formData;
  const formId = $formEl.attr('id');

  if (!data && formId) {
    data = app.form.getFormData(formId);
  }

  if (!data) return;

  // Skip input types
  const skipTypes = ['submit', 'image', 'button', 'file'];
  const skipNames = [];

  $formEl.find('input, select, textarea').each((inputIndex, inputEl) => {
    const $inputEl = $(inputEl);
    if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
      return;
    }
    const name = $inputEl.attr('name');
    const type = $inputEl.attr('type');
    const tag = inputEl.nodeName.toLowerCase();
    if (typeof data[name] === 'undefined' || data[name] === null) return;
    if (skipTypes.indexOf(type) >= 0) return;
    if (skipNames.indexOf(name) >= 0 || !name) return;
    if (tag === 'select' && $inputEl.prop('multiple')) {
      skipNames.push(name);
      $formEl.find(`select[name="${name}"] option`).each((index, el) => {
        const selectEl = el;
        if (data[name].indexOf(el.value) >= 0) selectEl.selected = true;
        else selectEl.selected = false;
      });
    } else {
      switch (type) {
        case 'checkbox':
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((index, el) => {
            const checkboxEl = el;
            if (data[name].indexOf(el.value) >= 0) checkboxEl.checked = true;
            else checkboxEl.checked = false;
          });
          break;
        case 'radio':
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((index, el) => {
            const radioEl = el;
            if (data[name] === el.value) radioEl.checked = true;
            else radioEl.checked = false;
          });
          break;
        default:
          $inputEl.val(data[name]);
          break;
      }
    }
    if (tag === 'select' || tag === 'input' || tag === 'textarea') {
      $inputEl.trigger('change', 'fromdata');
    }
  });
  $formEl.trigger('form:fromdata', data);
  app.emit('formFromData', $formEl[0], data);
}

function initAjaxForm() {
  const app = this;

  function onSubmitChange(e, fromData) {
    const $formEl = $(this);
    if (e.type === 'change' && !$formEl.hasClass('form-ajax-submit-onchange')) return;
    if (e.type === 'submit') e.preventDefault();

    if (e.type === 'change' && fromData === 'fromdata') return;

    const method = ($formEl.attr('method') || 'GET').toUpperCase();
    const contentType = $formEl.prop('enctype') || $formEl.attr('enctype');

    const url = $formEl.attr('action');
    if (!url) return;

    let data;
    if (method === 'POST') {
      if (contentType === 'application/x-www-form-urlencoded') {
        data = app.form.convertToData($formEl[0]);
      } else {
        data = new win.FormData($formEl[0]);
      }
    } else {
      data = Utils.serializeObject(app.form.convertToData($formEl[0]));
    }

    app.request({
      method,
      url,
      contentType,
      data,
      beforeSend(xhr) {
        $formEl.trigger('formajax:beforesend', { data, xhr });
        app.emit('formAjaxBeforeSend', $formEl[0], data, xhr);
      },
      error(xhr) {
        $formEl.trigger('formajax:error', { data, xhr });
        app.emit('formAjaxError', $formEl[0], data, xhr);
      },
      complete(xhr) {
        $formEl.trigger('formajax:complete', { data, xhr });
        app.emit('formAjaxComplete', $formEl[0], data, xhr);
      },
      success(response, status, xhr) {
        $formEl.trigger('formajax:success', { data, xhr });
        app.emit('formAjaxSuccess', $formEl[0], data, xhr);
      },
    });
  }
  $(doc).on('submit change', 'form.form-ajax-submit, form.form-ajax-submit-onchange', onSubmitChange);
}

var Form = {
  name: 'form',
  create() {
    const app = this;
    Utils.extend(app, {
      form: {
        data: {},
        storeFormData: FormData$1.store.bind(app),
        getFormData: FormData$1.get.bind(app),
        removeFormData: FormData$1.remove.bind(app),
        convertToData: formToData.bind(app),
        fillFromData: formFromData.bind(app),
        storage: {
          init: FormStorage.init.bind(app),
          destroy: FormStorage.destroy.bind(app),
        },
      },
    });
  },
  on: {
    init() {
      const app = this;
      initAjaxForm.call(app);
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      $(tabEl).find('.form-store-data').each((index, formEl) => {
        app.form.storage.destroy(formEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.form-store-data').each((index, formEl) => {
        app.form.storage.init(formEl);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.form-store-data').each((index, formEl) => {
        app.form.storage.destroy(formEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.form-store-data').each((index, formEl) => {
        app.form.storage.init(formEl);
      });
    },
  },
};

const Input = {
  ignoreTypes: ['checkbox', 'button', 'submit', 'range', 'radio', 'image'],
  createTextareaResizableShadow() {
    const $shadowEl = $(doc.createElement('textarea'));
    $shadowEl.addClass('textarea-resizable-shadow');
    $shadowEl.prop({
      disabled: true,
      readonly: true,
    });
    Input.textareaResizableShadow = $shadowEl;
  },
  textareaResizableShadow: undefined,
  resizeTextarea(textareaEl) {
    const app = this;
    const $textareaEl = $(textareaEl);
    if (!Input.textareaResizableShadow) {
      Input.createTextareaResizableShadow();
    }
    const $shadowEl = Input.textareaResizableShadow;
    if (!$textareaEl.length) return;
    if (!$textareaEl.hasClass('resizable')) return;
    if (Input.textareaResizableShadow.parents().length === 0) {
      app.root.append($shadowEl);
    }

    const styles = win.getComputedStyle($textareaEl[0]);
    ('padding-top padding-bottom padding-left padding-right margin-left margin-right margin-top margin-bottom width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display').split(' ').forEach((style) => {
      let styleValue = styles[style];
      if (('font-size line-height letter-spacing width').split(' ').indexOf(style) >= 0) {
        styleValue = styleValue.replace(',', '.');
      }
      $shadowEl.css(style, styleValue);
    });
    const currentHeight = $textareaEl[0].clientHeight;

    $shadowEl.val('');
    const initialHeight = $shadowEl[0].scrollHeight;

    $shadowEl.val($textareaEl.val());
    $shadowEl.css('height', 0);
    const scrollHeight = $shadowEl[0].scrollHeight;

    if (currentHeight !== scrollHeight) {
      if (scrollHeight > initialHeight) {
        $textareaEl.css('height', `${scrollHeight}px`);
      } else if (scrollHeight < currentHeight) {
        $textareaEl.css('height', '');
      }
      if (scrollHeight > initialHeight || scrollHeight < currentHeight) {
        $textareaEl.trigger('textarea:resize', { initialHeight, currentHeight, scrollHeight });
        app.emit('textareaResize', { initialHeight, currentHeight, scrollHeight });
      }
    }
  },
  validate(inputEl) {
    const $inputEl = $(inputEl);
    if (!$inputEl.length) return true;
    const $itemInputEl = $inputEl.parents('.item-input');
    const $inputWrapEl = $inputEl.parents('.input');
    function unsetReadonly() {
      if ($inputEl[0].f7ValidateReadonly) {
        $inputEl[0].readOnly = false;
      }
    }
    function setReadonly() {
      if ($inputEl[0].f7ValidateReadonly) {
        $inputEl[0].readOnly = true;
      }
    }
    unsetReadonly();
    const validity = $inputEl[0].validity;
    const validationMessage = $inputEl.dataset().errorMessage || $inputEl[0].validationMessage || '';
    if (!validity) {
      setReadonly();
      return true;
    }
    if (!validity.valid) {
      let $errorEl = $inputEl.nextAll('.item-input-error-message, .input-error-message');
      if (validationMessage) {
        if ($errorEl.length === 0) {
          $errorEl = $(`<div class="${$inputWrapEl.length ? 'input-error-message' : 'item-input-error-message'}"></div>`);
          $errorEl.insertAfter($inputEl);
        }
        $errorEl.text(validationMessage);
      }
      if ($errorEl.length > 0) {
        $itemInputEl.addClass('item-input-with-error-message');
        $inputWrapEl.addClass('input-with-error-message');
      }
      $itemInputEl.addClass('item-input-invalid');
      $inputWrapEl.addClass('input-invalid');
      $inputEl.addClass('input-invalid');
      setReadonly();
      return false;
    }
    $itemInputEl.removeClass('item-input-invalid item-input-with-error-message');
    $inputWrapEl.removeClass('input-invalid input-with-error-message');
    $inputEl.removeClass('input-invalid');
    setReadonly();
    return true;
  },
  validateInputs(el) {
    const app = this;
    const validates = $(el)
      .find('input, textarea, select')
      .toArray()
      .map((inputEl) => app.input.validate(inputEl));
    return validates.indexOf(false) < 0;
  },
  focus(inputEl) {
    const $inputEl = $(inputEl);
    const type = $inputEl.attr('type');
    if (Input.ignoreTypes.indexOf(type) >= 0) return;
    $inputEl.parents('.item-input').addClass('item-input-focused');
    $inputEl.parents('.input').addClass('input-focused');
    $inputEl.addClass('input-focused');
  },
  blur(inputEl) {
    const $inputEl = $(inputEl);
    $inputEl.parents('.item-input').removeClass('item-input-focused');
    $inputEl.parents('.input').removeClass('input-focused');
    $inputEl.removeClass('input-focused');
  },
  checkEmptyState(inputEl) {
    const app = this;
    let $inputEl = $(inputEl);
    if (!$inputEl.is('input, select, textarea, .item-input [contenteditable]')) {
      $inputEl = $inputEl.find('input, select, textarea, .item-input [contenteditable]').eq(0);
    }
    if (!$inputEl.length) return;
    const isContentEditable = $inputEl[0].hasAttribute('contenteditable');
    let value;
    if (isContentEditable) {
      if ($inputEl.find('.text-editor-placeholder').length) value = '';
      else value = $inputEl.html();
    } else {
      value = $inputEl.val();
    }
    const $itemInputEl = $inputEl.parents('.item-input');
    const $inputWrapEl = $inputEl.parents('.input');
    if ((value && (typeof value === 'string' && value.trim() !== '')) || (Array.isArray(value) && value.length > 0)) {
      $itemInputEl.addClass('item-input-with-value');
      $inputWrapEl.addClass('input-with-value');
      $inputEl.addClass('input-with-value');
      $inputEl.trigger('input:notempty');
      app.emit('inputNotEmpty', $inputEl[0]);
    } else {
      $itemInputEl.removeClass('item-input-with-value');
      $inputWrapEl.removeClass('input-with-value');
      $inputEl.removeClass('input-with-value');
      $inputEl.trigger('input:empty');
      app.emit('inputEmpty', $inputEl[0]);
    }
  },
  scrollIntoView(inputEl, duration = 0, centered, force) {
    const $inputEl = $(inputEl);
    const $scrollableEl = $inputEl.parents('.page-content, .panel, .card-expandable .card-content').eq(0);
    if (!$scrollableEl.length) {
      return false;
    }
    const contentHeight = $scrollableEl[0].offsetHeight;
    const contentScrollTop = $scrollableEl[0].scrollTop;
    const contentPaddingTop = parseInt($scrollableEl.css('padding-top'), 10);
    const contentPaddingBottom = parseInt($scrollableEl.css('padding-bottom'), 10);
    const contentOffsetTop = $scrollableEl.offset().top - contentScrollTop;

    const inputOffsetTop = $inputEl.offset().top - contentOffsetTop;
    const inputHeight = $inputEl[0].offsetHeight;

    const min = (inputOffsetTop + contentScrollTop) - contentPaddingTop;
    const max = ((inputOffsetTop + contentScrollTop) - contentHeight) + contentPaddingBottom + inputHeight;
    const centeredPosition = min + ((max - min) / 2);

    if (contentScrollTop > min) {
      $scrollableEl.scrollTop(centered ? centeredPosition : min, duration);
      return true;
    }
    if (contentScrollTop < max) {
      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
      return true;
    }
    if (force) {
      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
    }
    return false;
  },
  init() {
    const app = this;
    Input.createTextareaResizableShadow();
    function onFocus() {
      const inputEl = this;
      if (app.params.input.scrollIntoViewOnFocus) {
        if (Device.android) {
          $(win).once('resize', () => {
            if (doc && doc.activeElement === inputEl) {
              app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
            }
          });
        } else {
          app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
        }
      }
      app.input.focus(inputEl);
    }
    function onBlur() {
      const $inputEl = $(this);
      const tag = $inputEl[0].nodeName.toLowerCase();
      app.input.blur($inputEl);
      if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null || $inputEl.attr('data-validate-on-blur') !== null) {
        app.input.validate($inputEl);
      }
      // Resize textarea
      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
        if (Input.textareaResizableShadow) Input.textareaResizableShadow.remove();
      }
    }
    function onChange() {
      const $inputEl = $(this);
      const type = $inputEl.attr('type');
      const tag = $inputEl[0].nodeName.toLowerCase();
      const isContentEditable = $inputEl[0].hasAttribute('contenteditable');
      if (Input.ignoreTypes.indexOf(type) >= 0) return;

      // Check Empty State
      app.input.checkEmptyState($inputEl);
      if (isContentEditable) return;

      // Check validation
      if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
        app.input.validate($inputEl);
      }

      // Resize textarea
      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
        app.input.resizeTextarea($inputEl);
      }
    }
    function onInvalid(e) {
      const $inputEl = $(this);
      if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
        e.preventDefault();
        app.input.validate($inputEl);
      }
    }
    function clearInput() {
      const $clicked = $(this);
      const $inputEl = $clicked.siblings('input, textarea').eq(0);
      const previousValue = $inputEl.val();
      $inputEl
        .val('')
        .trigger('input change')
        .focus()
        .trigger('input:clear', previousValue);
      app.emit('inputClear', previousValue);
    }
    function preventDefault(e) {
      e.preventDefault();
    }
    $(doc).on('click', '.input-clear-button', clearInput);
    $(doc).on('mousedown', '.input-clear-button', preventDefault);
    $(doc).on('change input', 'input, textarea, select, .item-input [contenteditable]', onChange, true);
    $(doc).on('focus', 'input, textarea, select, .item-input [contenteditable]', onFocus, true);
    $(doc).on('blur', 'input, textarea, select, .item-input [contenteditable]', onBlur, true);
    $(doc).on('invalid', 'input, textarea, select', onInvalid, true);
  },
};

var Input$1 = {
  name: 'input',
  params: {
    input: {
      scrollIntoViewOnFocus: Device.android,
      scrollIntoViewCentered: false,
      scrollIntoViewDuration: 0,
      scrollIntoViewAlways: false,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      input: {
        scrollIntoView: Input.scrollIntoView.bind(app),
        focus: Input.focus.bind(app),
        blur: Input.blur.bind(app),
        validate: Input.validate.bind(app),
        validateInputs: Input.validateInputs.bind(app),
        checkEmptyState: Input.checkEmptyState.bind(app),
        resizeTextarea: Input.resizeTextarea.bind(app),
        init: Input.init.bind(app),
      },
    });
  },
  on: {
    init() {
      const app = this;
      app.input.init();
    },
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = $(tabEl);
      $tabEl.find('.item-input, .input').each((itemInputIndex, itemInputEl) => {
        const $itemInputEl = $(itemInputEl);
        $itemInputEl.find('input, select, textarea, [contenteditable]').each((inputIndex, inputEl) => {
          const $inputEl = $(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $tabEl.find('textarea.resizable').each((textareaIndex, textareaEl) => {
        app.input.resizeTextarea(textareaEl);
      });
    },
    pageInit(page) {
      const app = this;
      const $pageEl = page.$el;
      $pageEl.find('.item-input, .input').each((itemInputIndex, itemInputEl) => {
        const $itemInputEl = $(itemInputEl);
        $itemInputEl.find('input, select, textarea, [contenteditable]').each((inputIndex, inputEl) => {
          const $inputEl = $(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $pageEl.find('textarea.resizable').each((textareaIndex, textareaEl) => {
        app.input.resizeTextarea(textareaEl);
      });
    },
    'panelBreakpoint panelCollapsedBreakpoint panelResize panelOpen panelSwipeOpen resize viewMasterDetailBreakpoint': function onPanelOpen(instance) {
      const app = this;
      if (instance && instance.$el) {
        instance.$el.find('textarea.resizable').each((textareaIndex, textareaEl) => {
          app.input.resizeTextarea(textareaEl);
        });
      } else {
        $('textarea.resizable').each((textareaIndex, textareaEl) => {
          app.input.resizeTextarea(textareaEl);
        });
      }
    },
  },
};

var Checkbox = {
  name: 'checkbox',
};

var Radio = {
  name: 'radio',
};

class Toggle extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const toggle = this;

    const defaults = {};

    // Extend defaults with modules params
    toggle.useModulesParams(defaults);

    toggle.params = Utils.extend(defaults, params);

    const el = toggle.params.el;
    if (!el) return toggle;

    const $el = $(el);
    if ($el.length === 0) return toggle;

    if ($el[0].f7Toggle) return $el[0].f7Toggle;

    const $inputEl = $el.children('input[type="checkbox"]');

    Utils.extend(toggle, {
      app,
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl[0],
      disabled: $el.hasClass('disabled') || $inputEl.hasClass('disabled') || $inputEl.attr('disabled') || $inputEl[0].disabled,
    });

    Object.defineProperty(toggle, 'checked', {
      enumerable: true,
      configurable: true,
      set(checked) {
        if (!toggle || typeof toggle.$inputEl === 'undefined') return;
        if (toggle.checked === checked) return;
        $inputEl[0].checked = checked;
        toggle.$inputEl.trigger('change');
      },
      get() {
        return $inputEl[0].checked;
      },
    });

    $el[0].f7Toggle = toggle;

    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let toggleWidth;
    let touchStartTime;
    let touchStartChecked;
    function handleTouchStart(e) {
      if (isTouched || toggle.disabled) return;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchesDiff = 0;

      isTouched = true;
      isScrolling = undefined;
      touchStartTime = Utils.now();
      touchStartChecked = toggle.checked;

      toggleWidth = $el[0].offsetWidth;
      Utils.nextTick(() => {
        if (isTouched) {
          $el.addClass('toggle-active-state');
        }
      });
    }
    function handleTouchMove(e) {
      if (!isTouched || toggle.disabled) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      const inverter = app.rtl ? -1 : 1;

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();

      touchesDiff = pageX - touchesStart.x;


      let changed;
      if (touchesDiff * inverter < 0 && Math.abs(touchesDiff) > toggleWidth / 3 && touchStartChecked) {
        changed = true;
      }
      if (touchesDiff * inverter > 0 && Math.abs(touchesDiff) > toggleWidth / 3 && !touchStartChecked) {
        changed = true;
      }
      if (changed) {
        touchesStart.x = pageX;
        toggle.checked = !touchStartChecked;
        touchStartChecked = !touchStartChecked;
      }
    }
    function handleTouchEnd() {
      if (!isTouched || toggle.disabled) {
        if (isScrolling) $el.removeClass('toggle-active-state');
        isTouched = false;
        return;
      }
      const inverter = app.rtl ? -1 : 1;
      isTouched = false;

      $el.removeClass('toggle-active-state');

      let changed;
      if ((Utils.now() - touchStartTime) < 300) {
        if (touchesDiff * inverter < 0 && touchStartChecked) {
          changed = true;
        }
        if (touchesDiff * inverter > 0 && !touchStartChecked) {
          changed = true;
        }
        if (changed) {
          toggle.checked = !touchStartChecked;
        }
      }
    }
    function handleInputChange() {
      toggle.$el.trigger('toggle:change');
      toggle.emit('local::change toggleChange', toggle);
    }
    toggle.attachEvents = function attachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      toggle.$inputEl.on('change', handleInputChange);
    };
    toggle.detachEvents = function detachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off('touchmove', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      toggle.$inputEl.off('change', handleInputChange);
    };

    // Install Modules
    toggle.useModules();

    // Init
    toggle.init();
  }

  toggle() {
    const toggle = this;
    toggle.checked = !toggle.checked;
  }

  init() {
    const toggle = this;
    toggle.attachEvents();
  }

  destroy() {
    let toggle = this;
    toggle.$el.trigger('toggle:beforedestroy');
    toggle.emit('local::beforeDestroy toggleBeforeDestroy', toggle);
    delete toggle.$el[0].f7Toggle;
    toggle.detachEvents();
    Utils.deleteProps(toggle);
    toggle = null;
  }
}

var Toggle$1 = {
  name: 'toggle',
  create() {
    const app = this;
    app.toggle = ConstructorMethods({
      defaultSelector: '.toggle',
      constructor: Toggle,
      app,
      domProp: 'f7Toggle',
    });
  },
  static: {
    Toggle,
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.toggle-init').each((index, toggleEl) => app.toggle.create({ el: toggleEl }));
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find('.toggle-init').each((index, toggleEl) => {
        if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.toggle-init').each((index, toggleEl) => app.toggle.create({ el: toggleEl }));
    },
    pageBeforeRemove(page) {
      page.$el.find('.toggle-init').each((index, toggleEl) => {
        if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
      });
    },
  },
  vnode: {
    'toggle-init': {
      insert(vnode) {
        const app = this;
        const toggleEl = vnode.elm;
        app.toggle.create({ el: toggleEl });
      },
      destroy(vnode) {
        const toggleEl = vnode.elm;
        if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
      },
    },
  },
};

class Range extends Framework7Class {
  constructor(app, params) {
    super(params, [app]);

    const range = this;

    const defaults = {
      el: null,
      inputEl: null,
      dual: false,
      step: 1,
      label: false,
      min: 0,
      max: 100,
      value: 0,
      draggableBar: true,
      vertical: false,
      verticalReversed: false,
      formatLabel: null,
      scale: false,
      scaleSteps: 5,
      scaleSubSteps: 0,
      formatScaleLabel: null,
      limitKnobPosition: app.theme === 'ios',
    };

    // Extend defaults with modules params
    range.useModulesParams(defaults);

    range.params = Utils.extend(defaults, params);

    const el = range.params.el;
    if (!el) return range;

    const $el = $(el);
    if ($el.length === 0) return range;

    if ($el[0].f7Range) return $el[0].f7Range;

    const dataset = $el.dataset();

    ('step min max value scaleSteps scaleSubSteps').split(' ').forEach((paramName) => {
      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
        range.params[paramName] = parseFloat(dataset[paramName]);
      }
    });
    ('dual label vertical verticalReversed scale').split(' ').forEach((paramName) => {
      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
        range.params[paramName] = dataset[paramName];
      }
    });

    if (!range.params.value) {
      if (typeof dataset.value !== 'undefined') range.params.value = dataset.value;
      if (typeof dataset.valueLeft !== 'undefined' && typeof dataset.valueRight !== 'undefined') {
        range.params.value = [parseFloat(dataset.valueLeft), parseFloat(dataset.valueRight)];
      }
    }

    let $inputEl;
    if (!range.params.dual) {
      if (range.params.inputEl) {
        $inputEl = $(range.params.inputEl);
      } else if ($el.find('input[type="range"]').length) {
        $inputEl = $el.find('input[type="range"]').eq(0);
      }
    }

    const {
      dual, step, label, min, max, value, vertical, verticalReversed, scale, scaleSteps, scaleSubSteps, limitKnobPosition,
    } = range.params;

    Utils.extend(range, {
      app,
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : undefined,
      dual,
      step,
      label,
      min,
      max,
      value,
      previousValue: value,
      vertical,
      verticalReversed,
      scale,
      scaleSteps,
      scaleSubSteps,
      limitKnobPosition,
    });

    if ($inputEl) {
      ('step min max').split(' ').forEach((paramName) => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          range.params[paramName] = parseFloat($inputEl.attr(paramName));
          range[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });
      if (typeof $inputEl.val() !== 'undefined') {
        range.params.value = parseFloat($inputEl.val());
        range.value = parseFloat($inputEl.val());
      }
    }

    // Dual
    if (range.dual) {
      $el.addClass('range-slider-dual');
    }
    if (range.label) {
      $el.addClass('range-slider-label');
    }

    // Vertical
    if (range.vertical) {
      $el.addClass('range-slider-vertical');
      if (range.verticalReversed) {
        $el.addClass('range-slider-vertical-reversed');
      }
    } else {
      $el.addClass('range-slider-horizontal');
    }

    // Check for layout
    const $barEl = $('<div class="range-bar"></div>');
    const $barActiveEl = $('<div class="range-bar-active"></div>');
    $barEl.append($barActiveEl);

    // Create Knobs
    const knobHTML = `
      <div class="range-knob-wrap">
        <div class="range-knob"></div>
        ${range.label ? '<div class="range-knob-label"></div>' : ''}
      </div>
    `;
    const knobs = [$(knobHTML)];

    if (range.dual) {
      knobs.push($(knobHTML));
    }

    $el.append($barEl);
    knobs.forEach(($knobEl) => {
      $el.append($knobEl);
    });

    // Labels
    const labels = [];
    if (range.label) {
      labels.push(knobs[0].find('.range-knob-label'));
      if (range.dual) {
        labels.push(knobs[1].find('.range-knob-label'));
      }
    }

    // Scale
    let $scaleEl;
    if (range.scale && range.scaleSteps >= 1) {
      $scaleEl = $(`
        <div class="range-scale">
          ${range.renderScale()}
        </div>
      `);
      $el.append($scaleEl);
    }

    Utils.extend(range, {
      knobs,
      labels,
      $barEl,
      $barActiveEl,
      $scaleEl,
    });

    $el[0].f7Range = range;

    // Touch Events
    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let rangeOffset;
    let rangeOffsetLeft;
    let rangeOffsetTop;
    let $touchedKnobEl;
    let dualValueIndex;
    let valueChangedByTouch;
    let targetTouchIdentifier;
    function onTouchChange() {
      valueChangedByTouch = true;
    }
    function handleTouchStart(e) {
      if (isTouched) return;
      if (!range.params.draggableBar) {
        if ($(e.target).closest('.range-knob').length === 0) {
          return;
        }
      }
      valueChangedByTouch = false;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      if (e.type === 'touchstart') {
        targetTouchIdentifier = e.targetTouches[0].identifier;
      }

      isTouched = true;
      isScrolling = undefined;
      rangeOffset = $el.offset();
      rangeOffsetLeft = rangeOffset.left;
      rangeOffsetTop = rangeOffset.top;

      let progress;
      if (range.vertical) {
        progress = (touchesStart.y - rangeOffsetTop) / range.rangeHeight;
        if (!range.verticalReversed) progress = 1 - progress;
      } else if (range.app.rtl) {
        progress = ((rangeOffsetLeft + range.rangeWidth) - touchesStart.x) / range.rangeWidth;
      } else {
        progress = (touchesStart.x - rangeOffsetLeft) / range.rangeWidth;
      }

      let newValue = (progress * (range.max - range.min)) + range.min;
      if (range.dual) {
        if (Math.abs(range.value[0] - newValue) < Math.abs(range.value[1] - newValue)) {
          dualValueIndex = 0;
          $touchedKnobEl = range.knobs[0];
          newValue = [newValue, range.value[1]];
        } else {
          dualValueIndex = 1;
          $touchedKnobEl = range.knobs[1];
          newValue = [range.value[0], newValue];
        }
      } else {
        $touchedKnobEl = range.knobs[0];
        newValue = (progress * (range.max - range.min)) + range.min;
      }
      Utils.nextTick(() => {
        if (isTouched) $touchedKnobEl.addClass('range-knob-active-state');
      }, 70);
      range.on('change', onTouchChange);
      range.setValue(newValue, true);
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      let pageX;
      let pageY;
      if (e.type === 'touchmove') {
        for (let i = 0; i < e.targetTouches.length; i += 1) {
          if (e.targetTouches[i].identifier === targetTouchIdentifier) {
            pageX = e.targetTouches[i].pageX;
            pageY = e.targetTouches[i].pageY;
          }
        }
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      }
      if (typeof pageX === 'undefined' && typeof pageY === 'undefined') return;

      if (typeof isScrolling === 'undefined' && !range.vertical) {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();

      let progress;
      if (range.vertical) {
        progress = (pageY - rangeOffsetTop) / range.rangeHeight;
        if (!range.verticalReversed) progress = 1 - progress;
      } else if (range.app.rtl) {
        progress = ((rangeOffsetLeft + range.rangeWidth) - pageX) / range.rangeWidth;
      } else {
        progress = (pageX - rangeOffsetLeft) / range.rangeWidth;
      }

      let newValue = (progress * (range.max - range.min)) + range.min;
      if (range.dual) {
        let leftValue;
        let rightValue;
        if (dualValueIndex === 0) {
          leftValue = newValue;
          rightValue = range.value[1];
          if (leftValue > rightValue) {
            rightValue = leftValue;
          }
        } else {
          leftValue = range.value[0];
          rightValue = newValue;
          if (rightValue < leftValue) {
            leftValue = rightValue;
          }
        }
        newValue = [leftValue, rightValue];
      }
      range.setValue(newValue, true);
    }
    function handleTouchEnd(e) {
      if (e.type === 'touchend') {
        let touchEnded;
        for (let i = 0; i < e.changedTouches.length; i += 1) {
          if (e.changedTouches[i].identifier === targetTouchIdentifier) touchEnded = true;
        }
        if (!touchEnded) return;
      }
      if (!isTouched) {
        if (isScrolling) $touchedKnobEl.removeClass('range-knob-active-state');
        isTouched = false;
        return;
      }
      range.off('change', onTouchChange);
      isTouched = false;
      $touchedKnobEl.removeClass('range-knob-active-state');
      if (valueChangedByTouch && range.$inputEl && !range.dual) {
        range.$inputEl.trigger('change');
      }
      valueChangedByTouch = false;
      if (typeof range.previousValue !== 'undefined') {
        if (
          (
            range.dual
            && (
              range.previousValue[0] !== range.value[0]
              || range.previousValue[1] !== range.value[1]
            )
          )
          || (
            !range.dual
            && range.previousValue !== range.value
          )
        ) {
          range.$el.trigger('range:changed', range.value);
          range.emit('local::changed rangeChanged', range, range.value);
        }
      }
    }

    function handleResize() {
      range.calcSize();
      range.layout();
    }
    let parentModals;
    let parentPanel;
    let parentPage;
    range.attachEvents = function attachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      range.$el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('tabShow', handleResize);
      app.on('resize', handleResize);
      parentModals = range.$el.parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast');
      parentModals.on('modal:open', handleResize);
      parentPanel = range.$el.parents('.panel');
      parentPanel.on('panel:open panel:resize', handleResize);
      parentPage = range.$el.parents('.page').eq(0);
      parentPage.on('page:reinit', handleResize);
    };
    range.detachEvents = function detachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      range.$el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off('touchmove', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('tabShow', handleResize);
      app.off('resize', handleResize);
      if (parentModals) {
        parentModals.off('modal:open', handleResize);
      }
      if (parentPanel) {
        parentPanel.off('panel:open panel:resize', handleResize);
      }
      if (parentPage) {
        parentPage.off('page:reinit', handleResize);
      }
      parentModals = null;
      parentPanel = null;
      parentPage = null;
    };

    // Install Modules
    range.useModules();

    // Init
    range.init();

    return range;
  }

  calcSize() {
    const range = this;
    if (range.vertical) {
      const height = range.$el.outerHeight();
      if (height === 0) return;
      range.rangeHeight = height;
      range.knobHeight = range.knobs[0].outerHeight();
    } else {
      const width = range.$el.outerWidth();
      if (width === 0) return;
      range.rangeWidth = width;
      range.knobWidth = range.knobs[0].outerWidth();
    }
  }

  layout() {
    const range = this;
    const {
      app,
      knobWidth,
      knobHeight,
      rangeWidth,
      rangeHeight,
      min,
      max,
      knobs,
      $barActiveEl,
      value,
      label,
      labels,
      vertical,
      verticalReversed,
      limitKnobPosition,
    } = range;
    const knobSize = vertical ? knobHeight : knobWidth;
    const rangeSize = vertical ? rangeHeight : rangeWidth;
    // eslint-disable-next-line
    const positionProperty = vertical
      ? (verticalReversed ? 'top' : 'bottom')
      : (app.rtl ? 'right' : 'left');
    if (range.dual) {
      const progress = [((value[0] - min) / (max - min)), ((value[1] - min) / (max - min))];
      $barActiveEl.css({
        [positionProperty]: `${progress[0] * 100}%`,
        [vertical ? 'height' : 'width']: `${(progress[1] - progress[0]) * 100}%`,
      });
      knobs.forEach(($knobEl, knobIndex) => {
        let startPos = rangeSize * progress[knobIndex];
        if (limitKnobPosition) {
          const realStartPos = (rangeSize * progress[knobIndex]) - (knobSize / 2);
          if (realStartPos < 0) startPos = knobSize / 2;
          if ((realStartPos + knobSize) > rangeSize) startPos = rangeSize - (knobSize / 2);
        }
        $knobEl.css(positionProperty, `${startPos}px`);
        if (label) labels[knobIndex].text(range.formatLabel(value[knobIndex], labels[knobIndex][0]));
      });
    } else {
      const progress = ((value - min) / (max - min));
      $barActiveEl.css(vertical ? 'height' : 'width', `${progress * 100}%`);

      let startPos = rangeSize * progress;
      if (limitKnobPosition) {
        const realStartPos = (rangeSize * progress) - (knobSize / 2);
        if (realStartPos < 0) startPos = knobSize / 2;
        if ((realStartPos + knobSize) > rangeSize) startPos = rangeSize - (knobSize / 2);
      }
      knobs[0].css(positionProperty, `${startPos}px`);
      if (label) labels[0].text(range.formatLabel(value, labels[0][0]));
    }
    if ((range.dual && value.indexOf(min) >= 0) || (!range.dual && value === min)) {
      range.$el.addClass('range-slider-min');
    } else {
      range.$el.removeClass('range-slider-min');
    }
    if ((range.dual && value.indexOf(max) >= 0) || (!range.dual && value === max)) {
      range.$el.addClass('range-slider-max');
    } else {
      range.$el.removeClass('range-slider-max');
    }
  }

  setValue(newValue, byTouchMove) {
    const range = this;
    const { step, min, max } = range;
    let valueChanged;
    let oldValue;
    if (range.dual) {
      oldValue = [range.value[0], range.value[1]];
      let newValues = newValue;
      if (!Array.isArray(newValues)) newValues = [newValue, newValue];
      if (newValue[0] > newValue[1]) {
        newValues = [newValues[0], newValues[0]];
      }
      newValues = newValues.map(value => Math.max(Math.min(Math.round(value / step) * step, max), min));
      if (newValues[0] === range.value[0] && newValues[1] === range.value[1]) {
        return range;
      }
      newValues.forEach((value, valueIndex) => {
        range.value[valueIndex] = value;
      });
      valueChanged = oldValue[0] !== newValues[0] || oldValue[1] !== newValues[1];
      range.layout();
    } else {
      oldValue = range.value;
      const value = Math.max(Math.min(Math.round(newValue / step) * step, max), min);
      range.value = value;
      range.layout();
      valueChanged = oldValue !== value;
    }

    if (valueChanged) {
      range.previousValue = oldValue;
    }
    // Events
    if (!valueChanged) return range;
    range.$el.trigger('range:change', range.value);
    if (range.$inputEl && !range.dual) {
      range.$inputEl.val(range.value);
      if (!byTouchMove) {
        range.$inputEl.trigger('input change');
      } else {
        range.$inputEl.trigger('input');
      }
    }
    if (!byTouchMove) {
      range.$el.trigger('range:changed', range.value);
      range.emit('local::changed rangeChanged', range, range.value);
    }
    range.emit('local::change rangeChange', range, range.value);
    return range;
  }

  getValue() {
    return this.value;
  }

  formatLabel(value, labelEl) {
    const range = this;
    if (range.params.formatLabel) return range.params.formatLabel.call(range, value, labelEl);
    return value;
  }

  formatScaleLabel(value) {
    const range = this;
    if (range.params.formatScaleLabel) return range.params.formatScaleLabel.call(range, value);
    return value;
  }

  renderScale() {
    const range = this;
    const { app, verticalReversed, vertical } = range;

    // eslint-disable-next-line
    const positionProperty = vertical
      ? (verticalReversed ? 'top' : 'bottom')
      : (app.rtl ? 'right' : 'left');

    let html = '';
    Array
      .from({ length: range.scaleSteps + 1 })
      .forEach((scaleEl, index) => {
        const scaleStepValue = (range.max - range.min) / range.scaleSteps;
        const scaleValue = range.min + scaleStepValue * index;
        const progress = ((scaleValue - range.min) / (range.max - range.min));
        html += `<div class="range-scale-step" style="${positionProperty}: ${progress * 100}%">${range.formatScaleLabel(scaleValue)}</div>`;

        if (range.scaleSubSteps && range.scaleSubSteps > 1 && index < range.scaleSteps) {
          Array
            .from({ length: range.scaleSubSteps - 1 })
            .forEach((subStepEl, subIndex) => {
              const subStep = scaleStepValue / range.scaleSubSteps;
              const scaleSubValue = scaleValue + subStep * (subIndex + 1);
              const subProgress = ((scaleSubValue - range.min) / (range.max - range.min));
              html += `<div class="range-scale-step range-scale-substep" style="${positionProperty}: ${subProgress * 100}%"></div>`;
            });
        }
      });

    return html;
  }

  updateScale() {
    const range = this;
    if (!range.scale || range.scaleSteps < 1) {
      if (range.$scaleEl) range.$scaleEl.remove();
      delete range.$scaleEl;
      return;
    }
    if (!range.$scaleEl) {
      range.$scaleEl = $('<div class="range-scale"></div>');
      range.$el.append(range.$scaleEl);
    }

    range.$scaleEl.html(range.renderScale());
  }

  init() {
    const range = this;
    range.calcSize();
    range.layout();
    range.attachEvents();
    return range;
  }

  destroy() {
    let range = this;
    range.$el.trigger('range:beforedestroy');
    range.emit('local::beforeDestroy rangeBeforeDestroy', range);
    delete range.$el[0].f7Range;
    range.detachEvents();
    Utils.deleteProps(range);
    range = null;
  }
}

var Range$1 = {
  name: 'range',
  create() {
    const app = this;
    app.range = Utils.extend(
      ConstructorMethods({
        defaultSelector: '.range-slider',
        constructor: Range,
        app,
        domProp: 'f7Range',
      }),
      {
        getValue(el = '.range-slider') {
          const range = app.range.get(el);
          if (range) return range.getValue();
          return undefined;
        },
        setValue(el = '.range-slider', value) {
          const range = app.range.get(el);
          if (range) return range.setValue(value);
          return undefined;
        },
      }
    );
  },
  static: {
    Range,
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.range-slider-init').each((index, rangeEl) => new Range(app, {
        el: rangeEl,
      }));
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find('.range-slider-init').each((index, rangeEl) => {
        if (rangeEl.f7Range) rangeEl.f7Range.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.range-slider-init').each((index, rangeEl) => new Range(app, {
        el: rangeEl,
      }));
    },
    pageBeforeRemove(page) {
      page.$el.find('.range-slider-init').each((index, rangeEl) => {
        if (rangeEl.f7Range) rangeEl.f7Range.destroy();
      });
    },
  },
  vnode: {
    'range-slider-init': {
      insert(vnode) {
        const rangeEl = vnode.elm;
        const app = this;
        app.range.create({ el: rangeEl });
      },
      destroy(vnode) {
        const rangeEl = vnode.elm;
        if (rangeEl.f7Range) rangeEl.f7Range.destroy();
      },
    },
  },
};

class Stepper extends Framework7Class {
  constructor(app, params) {
    super(params, [app]);
    const stepper = this;

    const defaults = {
      el: null,
      inputEl: null,
      valueEl: null,
      value: 0,
      formatValue: null,
      step: 1,
      min: 0,
      max: 100,
      watchInput: true,
      autorepeat: false,
      autorepeatDynamic: false,
      wraps: false,
      manualInputMode: false,
      decimalPoint: 4,
      buttonsEndInputMode: true,
    };

    // Extend defaults with modules params
    stepper.useModulesParams(defaults);

    stepper.params = Utils.extend(defaults, params);
    if (stepper.params.value < stepper.params.min) {
      stepper.params.value = stepper.params.min;
    }
    if (stepper.params.value > stepper.params.max) {
      stepper.params.value = stepper.params.max;
    }

    const el = stepper.params.el;
    if (!el) return stepper;

    const $el = $(el);
    if ($el.length === 0) return stepper;

    if ($el[0].f7Stepper) return $el[0].f7Stepper;

    let $inputEl;
    if (stepper.params.inputEl) {
      $inputEl = $(stepper.params.inputEl);
    } else if ($el.find('.stepper-input-wrap').find('input, textarea').length) {
      $inputEl = $el.find('.stepper-input-wrap').find('input, textarea').eq(0);
    }

    if ($inputEl && $inputEl.length) {
      ('step min max').split(' ').forEach((paramName) => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          stepper.params[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });

      const decimalPoint = parseInt(stepper.params.decimalPoint, 10);
      if (Number.isNaN(decimalPoint)) {
        stepper.params.decimalPoint = 0;
      } else {
        stepper.params.decimalPoint = decimalPoint;
      }

      const inputValue = parseFloat($inputEl.val());
      if (typeof params.value === 'undefined' && !Number.isNaN(inputValue) && (inputValue || inputValue === 0)) {
        stepper.params.value = inputValue;
      }
    }

    let $valueEl;
    if (stepper.params.valueEl) {
      $valueEl = $(stepper.params.valueEl);
    } else if ($el.find('.stepper-value').length) {
      $valueEl = $el.find('.stepper-value').eq(0);
    }

    const $buttonPlusEl = $el.find('.stepper-button-plus');
    const $buttonMinusEl = $el.find('.stepper-button-minus');

    const { step, min, max, value, decimalPoint } = stepper.params;

    Utils.extend(stepper, {
      app,
      $el,
      el: $el[0],
      $buttonPlusEl,
      buttonPlusEl: $buttonPlusEl[0],
      $buttonMinusEl,
      buttonMinusEl: $buttonMinusEl[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : undefined,
      $valueEl,
      valueEl: $valueEl ? $valueEl[0] : undefined,
      step,
      min,
      max,
      value,
      decimalPoint,
      typeModeChanged: false,
    });

    $el[0].f7Stepper = stepper;

    // Handle Events
    const touchesStart = {};
    let isTouched;
    let isScrolling;
    let preventButtonClick;
    let intervalId;
    let timeoutId;
    let autorepeatAction = null;
    let autorepeatInAction = false;
    let manualInput = false;

    function dynamicRepeat(current, progressions, startsIn, progressionStep, repeatEvery, action) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        if (current === 1) {
          preventButtonClick = true;
          autorepeatInAction = true;
        }
        clearInterval(intervalId);
        action();
        intervalId = setInterval(() => {
          action();
        }, repeatEvery);
        if (current < progressions) {
          dynamicRepeat(current + 1, progressions, startsIn, progressionStep, repeatEvery / 2, action);
        }
      }, current === 1 ? startsIn : progressionStep);
    }

    function onTouchStart(e) {
      if (isTouched) return;
      if (manualInput) { return; }
      if ($(e.target).closest($buttonPlusEl).length) {
        autorepeatAction = 'increment';
      } else if ($(e.target).closest($buttonMinusEl).length) {
        autorepeatAction = 'decrement';
      }
      if (!autorepeatAction) return;

      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isScrolling = undefined;

      const progressions = stepper.params.autorepeatDynamic ? 4 : 1;
      dynamicRepeat(1, progressions, 500, 1000, 300, () => {
        stepper[autorepeatAction]();
      });
    }
    function onTouchMove(e) {
      if (!isTouched) return;
      if (manualInput) { return; }
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (typeof isScrolling === 'undefined' && !autorepeatInAction) {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      const distance = (((pageX - touchesStart.x) ** 2) + ((pageY - touchesStart.y) ** 2)) ** 0.5;

      if (isScrolling || distance > 20) {
        isTouched = false;
        clearTimeout(timeoutId);
        clearInterval(intervalId);
      }
    }
    function onTouchEnd() {
      clearTimeout(timeoutId);
      clearInterval(intervalId);
      autorepeatAction = null;
      autorepeatInAction = false;
      isTouched = false;
    }

    function onMinusClick() {
      if (manualInput) {
        if (stepper.params.buttonsEndInputMode) {
          manualInput = false;
          stepper.endTypeMode(true);
        }
        return;
      }
      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }
      stepper.decrement(true);
    }
    function onPlusClick() {
      if (manualInput) {
        if (stepper.params.buttonsEndInputMode) {
          manualInput = false;
          stepper.endTypeMode(true);
        }
        return;
      }
      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }
      stepper.increment(true);
    }
    function onInputClick(e) {
      if (!e.target.readOnly && stepper.params.manualInputMode) {
        manualInput = true;
        if (typeof e.target.selectionStart === 'number') {
          e.target.selectionStart = e.target.value.length;
          e.target.selectionEnd = e.target.value.length;
        }
      }
    }
    function onInputKey(e) {
      if (e.keyCode === 13 || e.which === 13) {
        e.preventDefault();
        manualInput = false;
        stepper.endTypeMode();
      }
    }
    function onInputBlur() {
      manualInput = false;
      stepper.endTypeMode(true);
    }
    function onInput(e) {
      if (manualInput) {
        stepper.typeValue(e.target.value);
        return;
      }
      if (e.detail && e.detail.sentByF7Stepper) return;
      stepper.setValue(e.target.value, true);
    }
    stepper.attachEvents = function attachEvents() {
      $buttonMinusEl.on('click', onMinusClick);
      $buttonPlusEl.on('click', onPlusClick);
      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.on('input', onInput);
        $inputEl.on('click', onInputClick);
        $inputEl.on('blur', onInputBlur);
        $inputEl.on('keyup', onInputKey);
      }
      if (stepper.params.autorepeat) {
        app.on('touchstart:passive', onTouchStart);
        app.on('touchmove:active', onTouchMove);
        app.on('touchend:passive', onTouchEnd);
      }
    };
    stepper.detachEvents = function detachEvents() {
      $buttonMinusEl.off('click', onMinusClick);
      $buttonPlusEl.off('click', onPlusClick);
      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.off('input', onInput);
        $inputEl.off('click', onInputClick);
        $inputEl.off('blur', onInputBlur);
        $inputEl.off('keyup', onInputKey);
      }
    };

    // Install Modules
    stepper.useModules();

    // Init
    stepper.init();

    return stepper;
  }

  minus() {
    return this.decrement();
  }

  plus() {
    return this.increment();
  }

  decrement() {
    const stepper = this;
    return stepper.setValue(stepper.value - stepper.step, false, true);
  }

  increment() {
    const stepper = this;
    return stepper.setValue(stepper.value + stepper.step, false, true);
  }

  setValue(newValue, forceUpdate, withWraps) {
    const stepper = this;
    const { step, min, max } = stepper;

    const oldValue = stepper.value;

    let value = Math.round(newValue / step) * step;
    if (stepper.params.wraps && withWraps) {
      if (value > max) value = min;
      if (value < min) value = max;
    } else {
      value = Math.max(Math.min(value, max), min);
    }

    if (Number.isNaN(value)) {
      value = oldValue;
    }
    stepper.value = value;

    const valueChanged = oldValue !== value;

    // Events
    if (!valueChanged && !forceUpdate) return stepper;

    stepper.$el.trigger('stepper:change', stepper.value);
    const formattedValue = stepper.formatValue(stepper.value);
    if (stepper.$inputEl && stepper.$inputEl.length) {
      stepper.$inputEl.val(formattedValue);
      stepper.$inputEl.trigger('input change', { sentByF7Stepper: true });
    }
    if (stepper.$valueEl && stepper.$valueEl.length) {
      stepper.$valueEl.html(formattedValue);
    }
    stepper.emit('local::change stepperChange', stepper, stepper.value);
    return stepper;
  }

  endTypeMode(noBlur) {
    const stepper = this;
    const { min, max } = stepper;
    let value = parseFloat(stepper.value);

    if (Number.isNaN(value)) value = 0;

    value = Math.max(Math.min(value, max), min);

    stepper.value = value;
    if (!stepper.typeModeChanged) {
      if (stepper.$inputEl && stepper.$inputEl.length && !noBlur) {
        stepper.$inputEl.blur();
      }
      return stepper;
    }
    stepper.typeModeChanged = false;

    stepper.$el.trigger('stepper:change', stepper.value);
    const formattedValue = stepper.formatValue(stepper.value);
    if (stepper.$inputEl && stepper.$inputEl.length) {
      stepper.$inputEl.val(formattedValue);
      stepper.$inputEl.trigger('input change', { sentByF7Stepper: true });
      if (!noBlur) stepper.$inputEl.blur();
    }
    if (stepper.$valueEl && stepper.$valueEl.length) {
      stepper.$valueEl.html(formattedValue);
    }
    stepper.emit('local::change stepperChange', stepper, stepper.value);
    return stepper;
  }

  typeValue(value) {
    const stepper = this;
    stepper.typeModeChanged = true;
    let inputTxt = String(value);
    if (inputTxt.lastIndexOf('.') + 1 === inputTxt.length || inputTxt.lastIndexOf(',') + 1 === inputTxt.length) {
      if (inputTxt.lastIndexOf('.') !== inputTxt.indexOf('.') || inputTxt.lastIndexOf(',') !== inputTxt.indexOf(',')) {
        inputTxt = inputTxt.slice(0, -1);
        stepper.value = inputTxt;
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
    } else {
      let newValue = parseFloat(inputTxt.replace(',', '.'));
      if (newValue === 0) {
        stepper.value = inputTxt.replace(',', '.');
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
      if (Number.isNaN(newValue)) {
        stepper.value = 0;
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
      const powVal = 10 ** stepper.params.decimalPoint;
      newValue = (Math.round((newValue) * powVal)).toFixed(stepper.params.decimalPoint + 1) / powVal;
      stepper.value = parseFloat(String(newValue).replace(',', '.'));
      stepper.$inputEl.val(stepper.value);
      return stepper;
    }
    stepper.value = inputTxt;
    stepper.$inputEl.val(inputTxt);
    return stepper;
  }

  getValue() {
    return this.value;
  }

  formatValue(value) {
    const stepper = this;
    if (!stepper.params.formatValue) return value;
    return stepper.params.formatValue.call(stepper, value);
  }

  init() {
    const stepper = this;
    stepper.attachEvents();
    if (stepper.$valueEl && stepper.$valueEl.length) {
      const formattedValue = stepper.formatValue(stepper.value);
      stepper.$valueEl.html(formattedValue);
    }
    return stepper;
  }

  destroy() {
    let stepper = this;
    stepper.$el.trigger('stepper:beforedestroy');
    stepper.emit('local::beforeDestroy stepperBeforeDestroy', stepper);
    delete stepper.$el[0].f7Stepper;
    stepper.detachEvents();
    Utils.deleteProps(stepper);
    stepper = null;
  }
}

var Stepper$1 = {
  name: 'stepper',
  create() {
    const app = this;
    app.stepper = Utils.extend(
      ConstructorMethods({
        defaultSelector: '.stepper',
        constructor: Stepper,
        app,
        domProp: 'f7Stepper',
      }),
      {
        getValue(el = '.stepper') {
          const stepper = app.stepper.get(el);
          if (stepper) return stepper.getValue();
          return undefined;
        },
        setValue(el = '.stepper', value) {
          const stepper = app.stepper.get(el);
          if (stepper) return stepper.setValue(value);
          return undefined;
        },
      }
    );
  },
  static: {
    Stepper,
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.stepper-init').each((index, stepperEl) => {
        const dataset = $(stepperEl).dataset();
        app.stepper.create(Utils.extend({ el: stepperEl }, dataset || {}));
      });
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find('.stepper-init').each((index, stepperEl) => {
        if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.stepper-init').each((index, stepperEl) => {
        const dataset = $(stepperEl).dataset();
        app.stepper.create(Utils.extend({ el: stepperEl }, dataset || {}));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find('.stepper-init').each((index, stepperEl) => {
        if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
      });
    },
  },
  vnode: {
    'stepper-init': {
      insert(vnode) {
        const app = this;
        const stepperEl = vnode.elm;
        const dataset = $(stepperEl).dataset();
        app.stepper.create(Utils.extend({ el: stepperEl }, dataset || {}));
      },
      destroy(vnode) {
        const stepperEl = vnode.elm;
        if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
      },
    },
  },
};

class SmartSelect extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const ss = this;

    const defaults = Utils.extend({
      on: {},
    }, app.params.smartSelect);

    if (typeof defaults.searchbarDisableButton === 'undefined') {
      defaults.searchbarDisableButton = app.theme !== 'aurora';
    }

    // Extend defaults with modules params
    ss.useModulesParams(defaults);

    ss.params = Utils.extend({}, defaults, params);

    ss.app = app;

    const $el = $(ss.params.el).eq(0);
    if ($el.length === 0) return ss;

    if ($el[0].f7SmartSelect) return $el[0].f7SmartSelect;

    const $selectEl = $el.find('select').eq(0);
    if ($selectEl.length === 0) return ss;

    let $valueEl;
    if (ss.params.setValueText) {
      $valueEl = $(ss.params.valueEl);
      if ($valueEl.length === 0) {
        $valueEl = $el.find('.item-after');
      }
      if ($valueEl.length === 0) {
        $valueEl = $('<div class="item-after"></div>');
        $valueEl.insertAfter($el.find('.item-title'));
      }
    }

    // Url
    let url = params.url;
    if (!url) {
      if ($el.attr('href') && $el.attr('href') !== '#') url = $el.attr('href');
      else if ($selectEl.attr('name')) url = `${$selectEl.attr('name').toLowerCase()}-select/`;
    }
    if (!url) url = ss.params.url;

    const multiple = $selectEl[0].multiple;
    const inputType = multiple ? 'checkbox' : 'radio';
    const id = Utils.id();

    Utils.extend(ss, {
      $el,
      el: $el[0],
      $selectEl,
      selectEl: $selectEl[0],
      $valueEl,
      valueEl: $valueEl && $valueEl[0],
      url,
      multiple,
      inputType,
      id,
      inputName: `${inputType}-${id}`,
      selectName: $selectEl.attr('name'),
      maxLength: $selectEl.attr('maxlength') || params.maxLength,
    });

    $el[0].f7SmartSelect = ss;

    // Events
    function onClick() {
      ss.open();
    }
    function onChange() {
      const value = ss.$selectEl.val();
      ss.$el.trigger('smartselect:change', value);
      ss.emit('local::change smartSelectChange', ss, value);
      if (ss.vl) {
        ss.vl.clearCache();
      }
      ss.setValueText();
    }
    ss.attachEvents = function attachEvents() {
      $el.on('click', onClick);
      $el.on('change', 'select', onChange);
    };
    ss.detachEvents = function detachEvents() {
      $el.off('click', onClick);
      $el.off('change', 'select', onChange);
    };

    function handleInputChange() {
      let optionEl;
      let text;
      const inputEl = this;
      const value = inputEl.value;
      let optionText = [];
      let displayAs;
      if (inputEl.type === 'checkbox') {
        for (let i = 0; i < ss.selectEl.options.length; i += 1) {
          optionEl = ss.selectEl.options[i];
          if (optionEl.value === value) {
            optionEl.selected = inputEl.checked;
          }
          if (optionEl.selected) {
            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-value-as');
            text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
            optionText.push(text.trim());
          }
        }
        if (ss.maxLength) {
          ss.checkMaxLength();
        }
      } else {
        optionEl = ss.$selectEl.find(`option[value="${value}"]`)[0];
        if (!optionEl) {
          optionEl = ss.$selectEl.find('option').filter((index, optEl) => optEl.value === value)[0];
        }
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-as');
        text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
        optionText = [text];
        ss.selectEl.value = value;
      }

      ss.$selectEl.trigger('change');
      if (ss.params.setValueText) {
        ss.$valueEl.text(ss.formatValueText(optionText));
      }
      if (ss.params.closeOnSelect && ss.inputType === 'radio') {
        ss.close();
      }
    }

    ss.attachInputsEvents = function attachInputsEvents() {
      ss.$containerEl.on('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };
    ss.detachInputsEvents = function detachInputsEvents() {
      ss.$containerEl.off('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };

    // Install Modules
    ss.useModules();

    // Init
    ss.init();

    return ss;
  }

  setValue(value) {
    const ss = this;
    let newValue = value;
    let optionText = [];
    let optionEl;
    let displayAs;
    let text;
    if (ss.multiple) {
      if (!Array.isArray(newValue)) newValue = [newValue];
      for (let i = 0; i < ss.selectEl.options.length; i += 1) {
        optionEl = ss.selectEl.options[i];
        if (newValue.indexOf(optionEl.value) >= 0) {
          optionEl.selected = true;
        } else {
          optionEl.selected = false;
        }
        if (optionEl.selected) {
          displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-value-as');
          text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
          optionText.push(text.trim());
        }
      }
    } else {
      optionEl = ss.$selectEl.find(`option[value="${newValue}"]`)[0];
      if (optionEl) {
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-as');
        text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
        optionText = [text];
      }
      ss.selectEl.value = newValue;
    }
    if (ss.params.setValueText) {
      ss.$valueEl.text(ss.formatValueText(optionText));
    }
    ss.$selectEl.trigger('change');
    return ss;
  }

  unsetValue() {
    const ss = this;
    if (ss.params.setValueText) {
      ss.$valueEl.text(ss.formatValueText([]));
    }
    ss.$selectEl.find('option').each((optionIndex, optionEl) => {
      optionEl.selected = false;
      optionEl.checked = false;
    });
    ss.$selectEl[0].value = null;

    if (ss.$containerEl) {
      ss.$containerEl.find(`input[name="${ss.inputName}"][type="checkbox"], input[name="${ss.inputName}"][type="radio"]`).prop('checked', false);
    }
    ss.$selectEl.trigger('change');
  }

  getValue() {
    const ss = this;
    return ss.$selectEl.val();
  }

  get view() {
    const { params, $el } = this;
    let view;
    if (params.view) {
      view = params.view;
    }
    if (!view) {
      view = $el.parents('.view').length && $el.parents('.view')[0].f7View;
    }
    if (!view && params.openIn === 'page') {
      throw Error('Smart Select requires initialized View');
    }
    return view;
  }

  checkMaxLength() {
    const ss = this;
    const $containerEl = ss.$containerEl;
    if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
      $containerEl.find('input[type="checkbox"]').each((index, inputEl) => {
        if (!inputEl.checked) {
          $(inputEl).parents('li').addClass('disabled');
        } else {
          $(inputEl).parents('li').removeClass('disabled');
        }
      });
    } else {
      $containerEl.find('.disabled').removeClass('disabled');
    }
  }

  formatValueText(values) {
    const ss = this;
    let textValue;
    if (ss.params.formatValueText) {
      textValue = ss.params.formatValueText.call(ss, values, ss);
    } else {
      textValue = values.join(', ');
    }
    return textValue;
  }

  setValueText(value) {
    const ss = this;
    let valueArray = [];
    if (typeof value !== 'undefined') {
      if (Array.isArray(value)) {
        valueArray = value;
      } else {
        valueArray = [value];
      }
    } else {
      ss.$selectEl.find('option').each((optionIndex, optionEl) => {
        const $optionEl = $(optionEl);
        if (optionEl.selected) {
          const displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data('display-value-as');
          if (displayAs && typeof displayAs !== 'undefined') {
            valueArray.push(displayAs);
          } else {
            valueArray.push(optionEl.textContent.trim());
          }
        }
      });
    }
    if (ss.params.setValueText) {
      ss.$valueEl.text(ss.formatValueText(valueArray));
    }
  }

  getItemsData() {
    const ss = this;
    const theme = ss.app.theme;
    const items = [];
    let previousGroupEl;
    ss.$selectEl.find('option').each((index, optionEl) => {
      const $optionEl = $(optionEl);
      const optionData = $optionEl.dataset();
      const optionImage = optionData.optionImage || ss.params.optionImage;
      const optionIcon = optionData.optionIcon || ss.params.optionIcon;
      const optionIconIos = theme === 'ios' && (optionData.optionIconIos || ss.params.optionIconIos);
      const optionIconMd = theme === 'md' && (optionData.optionIconMd || ss.params.optionIconMd);
      const optionIconAurora = theme === 'aurora' && (optionData.optionIconAurora || ss.params.optionIconAurora);
      const optionHasMedia = optionImage || optionIcon || optionIconIos || optionIconMd || optionIconAurora;
      const optionColor = optionData.optionColor;

      let optionClassName = optionData.optionClass || '';
      if ($optionEl[0].disabled) optionClassName += ' disabled';

      const optionGroupEl = $optionEl.parent('optgroup')[0];
      const optionGroupLabel = optionGroupEl && optionGroupEl.label;
      let optionIsLabel = false;
      if (optionGroupEl && optionGroupEl !== previousGroupEl) {
        optionIsLabel = true;
        previousGroupEl = optionGroupEl;
        items.push({
          groupLabel: optionGroupLabel,
          isLabel: optionIsLabel,
        });
      }
      items.push({
        value: $optionEl[0].value,
        text: $optionEl[0].textContent.trim(),
        selected: $optionEl[0].selected,
        groupEl: optionGroupEl,
        groupLabel: optionGroupLabel,
        image: optionImage,
        icon: optionIcon,
        iconIos: optionIconIos,
        iconMd: optionIconMd,
        iconAurora: optionIconAurora,
        color: optionColor,
        className: optionClassName,
        disabled: $optionEl[0].disabled,
        id: ss.id,
        hasMedia: optionHasMedia,
        checkbox: ss.inputType === 'checkbox',
        radio: ss.inputType === 'radio',
        inputName: ss.inputName,
        inputType: ss.inputType,
      });
    });
    ss.items = items;
    return items;
  }

  renderSearchbar() {
    const ss = this;
    if (ss.params.renderSearchbar) return ss.params.renderSearchbar.call(ss);
    const searchbarHTML = `
      <form class="searchbar">
        <div class="searchbar-inner">
          <div class="searchbar-input-wrap">
            <input type="search" placeholder="${ss.params.searchbarPlaceholder}"/>
            <i class="searchbar-icon"></i>
            <span class="input-clear-button"></span>
          </div>
          ${ss.params.searchbarDisableButton ? `
          <span class="searchbar-disable-button">${ss.params.searchbarDisableText}</span>
          ` : ''}
        </div>
      </form>
    `;
    return searchbarHTML;
  }

  renderItem(item, index) {
    const ss = this;
    if (ss.params.renderItem) return ss.params.renderItem.call(ss, item, index);

    function getIconContent(iconValue = '') {
      if (iconValue.indexOf(':') >= 0) {
        return iconValue.split(':')[1];
      }
      return '';
    }
    function getIconClass(iconValue = '') {
      if (iconValue.indexOf(':') >= 0) {
        let className = iconValue.split(':')[0];
        if (className === 'f7') className = 'f7-icons';
        if (className === 'material') className = 'material-icons';
        return className;
      }
      return iconValue;
    }

    let itemHtml;
    if (item.isLabel) {
      itemHtml = `<li class="item-divider">${item.groupLabel}</li>`;
    } else {
      let selected = item.selected;
      let disabled;
      if (ss.params.virtualList) {
        const ssValue = ss.getValue();
        selected = ss.multiple ? ssValue.indexOf(item.value) >= 0 : ssValue === item.value;
        if (ss.multiple) {
          disabled = ss.multiple && !selected && ssValue.length === parseInt(ss.maxLength, 10);
        }
      }

      const { icon, iconIos, iconMd, iconAurora } = item;
      const hasIcon = icon || iconIos || iconMd || iconAurora;
      const iconContent = getIconContent(icon || iconIos || iconMd || iconAurora || '');
      const iconClass = getIconClass(icon || iconIos || iconMd || iconAurora || '');

      itemHtml = `
        <li class="${item.className || ''}${disabled ? ' disabled' : ''}">
          <label class="item-${item.inputType} item-content">
            <input type="${item.inputType}" name="${item.inputName}" value="${item.value}" ${selected ? 'checked' : ''}/>
            <i class="icon icon-${item.inputType}"></i>
            ${item.hasMedia ? `
              <div class="item-media">
                ${hasIcon ? `<i class="icon ${iconClass}">${iconContent}</i>` : ''}
                ${item.image ? `<img src="${item.image}">` : ''}
              </div>
            ` : ''}
            <div class="item-inner">
              <div class="item-title${item.color ? ` text-color-${item.color}` : ''}">${item.text}</div>
            </div>
          </label>
        </li>
      `;
    }
    return itemHtml;
  }

  renderItems() {
    const ss = this;
    if (ss.params.renderItems) return ss.params.renderItems.call(ss, ss.items);
    const itemsHtml = `
      ${ss.items.map((item, index) => `${ss.renderItem(item, index)}`).join('')}
    `;
    return itemsHtml;
  }

  renderPage() {
    const ss = this;
    if (ss.params.renderPage) return ss.params.renderPage.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === 'undefined') {
      const $itemTitleEl = ss.$el.find('.item-title');
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
    }
    const cssClass = ss.params.cssClass;
    const pageHtml = `
      <div class="page smart-select-page ${cssClass}" data-name="smart-select-page" data-select-name="${ss.selectName}">
        <div class="navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ''}">
          <div class="navbar-bg"></div>
          <div class="navbar-inner sliding ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ''}">
            <div class="left">
              <a class="link back">
                <i class="icon icon-back"></i>
                <span class="if-not-md">${ss.params.pageBackLinkText}</span>
              </a>
            </div>
            ${pageTitle ? `<div class="title">${pageTitle}</div>` : ''}
            ${ss.params.searchbar ? `<div class="subnavbar">${ss.renderSearchbar()}</div>` : ''}
          </div>
        </div>
        ${ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : ''}
        <div class="page-content">
          <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}">
            <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
          </div>
        </div>
      </div>
    `;
    return pageHtml;
  }

  renderPopup() {
    const ss = this;
    if (ss.params.renderPopup) return ss.params.renderPopup.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === 'undefined') {
      const $itemTitleEl = ss.$el.find('.item-title');
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
    }
    const cssClass = ss.params.cssClass || '';
    const popupHtml = `
      <div class="popup smart-select-popup ${cssClass} ${ss.params.popupTabletFullscreen ? 'popup-tablet-fullscreen' : ''}" data-select-name="${ss.selectName}">
        <div class="view">
          <div class="page smart-select-page ${ss.params.searchbar ? 'page-with-subnavbar' : ''}" data-name="smart-select-page">
            <div class="navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ''}">
              <div class="navbar-bg"></div>
              <div class="navbar-inner sliding">
                ${pageTitle ? `<div class="title">${pageTitle}</div>` : ''}
                <div class="right">
                  <a class="link popup-close" data-popup=".smart-select-popup[data-select-name='${ss.selectName}']">${ss.params.popupCloseLinkText}</span></a>
                </div>
                ${ss.params.searchbar ? `<div class="subnavbar">${ss.renderSearchbar()}</div>` : ''}
              </div>
            </div>
            ${ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : ''}
            <div class="page-content">
              <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}">
                <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
    return popupHtml;
  }

  renderSheet() {
    const ss = this;
    if (ss.params.renderSheet) return ss.params.renderSheet.call(ss, ss.items);
    const cssClass = ss.params.cssClass;
    const sheetHtml = `
      <div class="sheet-modal smart-select-sheet ${cssClass}" data-select-name="${ss.selectName}">
        <div class="toolbar toolbar-top ${ss.params.toolbarColorTheme ? `color-${ss.params.toolbarColorTheme}` : ''}">
          <div class="toolbar-inner">
            <div class="left"></div>
            <div class="right">
              <a class="link sheet-close">${ss.params.sheetCloseLinkText}</a>
            </div>
          </div>
        </div>
        <div class="sheet-modal-inner">
          <div class="page-content">
            <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}">
              <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
            </div>
          </div>
        </div>
      </div>
    `;
    return sheetHtml;
  }

  renderPopover() {
    const ss = this;
    if (ss.params.renderPopover) return ss.params.renderPopover.call(ss, ss.items);
    const cssClass = ss.params.cssClass;
    const popoverHtml = `
      <div class="popover smart-select-popover ${cssClass}" data-select-name="${ss.selectName}">
        <div class="popover-inner">
          <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}">
            <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
          </div>
        </div>
      </div>
    `;
    return popoverHtml;
  }

  scrollToSelectedItem() {
    const ss = this;
    const { params, $containerEl } = ss;
    if (!ss.opened) return ss;
    if (params.virtualList) {
      let selectedIndex;
      ss.vl.items.forEach((item, index) => {
        if (typeof selectedIndex === 'undefined' && item.selected) {
          selectedIndex = index;
        }
      });
      if (typeof selectedIndex !== 'undefined') {
        ss.vl.scrollToItem(selectedIndex);
      }
    } else {
      const $selectedItemEl = $containerEl.find('input:checked').parents('li');
      if (!$selectedItemEl.length) return ss;
      const $pageContentEl = $containerEl.find('.page-content');
      $pageContentEl.scrollTop($selectedItemEl.offset().top - $pageContentEl.offset().top - parseInt($pageContentEl.css('padding-top'), 10));
    }
    return ss;
  }

  onOpen(type, containerEl) {
    const ss = this;
    const app = ss.app;
    const $containerEl = $(containerEl);
    ss.$containerEl = $containerEl;
    ss.openedIn = type;
    ss.opened = true;

    // Init VL
    if (ss.params.virtualList) {
      ss.vl = app.virtualList.create({
        el: $containerEl.find('.virtual-list'),
        items: ss.items,
        renderItem: ss.renderItem.bind(ss),
        height: ss.params.virtualListHeight,
        searchByItem(query, item) {
          if (item.text && item.text.toLowerCase().indexOf(query.trim().toLowerCase()) >= 0) return true;
          return false;
        },
      });
    }
    if (ss.params.scrollToSelectedItem) {
      ss.scrollToSelectedItem();
    }

    // Init SB
    if (ss.params.searchbar) {
      let $searchbarEl = $containerEl.find('.searchbar');
      if (type === 'page' && app.theme === 'ios') {
        $searchbarEl = $(app.navbar.getElByPage($containerEl)).find('.searchbar');
      }

      if (ss.params.appendSearchbarNotFound && (type === 'page' || type === 'popup')) {
        let $notFoundEl = null;

        if (typeof ss.params.appendSearchbarNotFound === 'string') {
          $notFoundEl = $(`<div class="block searchbar-not-found">${ss.params.appendSearchbarNotFound}</div>`);
        } else if (typeof ss.params.appendSearchbarNotFound === 'boolean') {
          $notFoundEl = $('<div class="block searchbar-not-found">Nothing found</div>');
        } else {
          $notFoundEl = ss.params.appendSearchbarNotFound;
        }

        if ($notFoundEl) {
          $containerEl.find('.page-content').append($notFoundEl[0]);
        }
      }

      const searchbarParams = Utils.extend({
        el: $searchbarEl,
        backdropEl: $containerEl.find('.searchbar-backdrop'),
        searchContainer: `.smart-select-list-${ss.id}`,
        searchIn: '.item-title',
      }, typeof ss.params.searchbar === 'object' ? ss.params.searchbar : {});

      ss.searchbar = app.searchbar.create(searchbarParams);
    }

    // Check for max length
    if (ss.maxLength) {
      ss.checkMaxLength();
    }

    // Close on select
    if (ss.params.closeOnSelect) {
      ss.$containerEl.find(`input[type="radio"][name="${ss.inputName}"]:checked`).parents('label').once('click', () => {
        ss.close();
      });
    }

    // Attach input events
    ss.attachInputsEvents();

    ss.$el.trigger('smartselect:open');
    ss.emit('local::open smartSelectOpen', ss);
  }

  onOpened() {
    const ss = this;

    ss.$el.trigger('smartselect:opened');
    ss.emit('local::opened smartSelectOpened', ss);
  }

  onClose() {
    const ss = this;
    if (ss.destroyed) return;

    // Destroy VL
    if (ss.vl && ss.vl.destroy) {
      ss.vl.destroy();
      ss.vl = null;
      delete ss.vl;
    }

    // Destroy SB
    if (ss.searchbar && ss.searchbar.destroy) {
      ss.searchbar.destroy();
      ss.searchbar = null;
      delete ss.searchbar;
    }
    // Detach events
    ss.detachInputsEvents();

    ss.$el.trigger('smartselect:close');
    ss.emit('local::close smartSelectClose', ss);
  }

  onClosed() {
    const ss = this;
    if (ss.destroyed) return;
    ss.opened = false;
    ss.$containerEl = null;
    delete ss.$containerEl;

    ss.$el.trigger('smartselect:closed');
    ss.emit('local::closed smartSelectClosed', ss);
  }

  openPage() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const pageHtml = ss.renderPage(ss.items);

    ss.view.router.navigate({
      url: ss.url,
      route: {
        content: pageHtml,
        path: ss.url,
        on: {
          pageBeforeIn(e, page) {
            ss.onOpen('page', page.el);
          },
          pageAfterIn(e, page) {
            ss.onOpened('page', page.el);
          },
          pageBeforeOut(e, page) {
            ss.onClose('page', page.el);
          },
          pageAfterOut(e, page) {
            ss.onClosed('page', page.el);
          },
        },
      },
    });
    return ss;
  }

  openPopup() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const popupHtml = ss.renderPopup(ss.items);

    const popupParams = {
      content: popupHtml,
      push: ss.params.popupPush,
      swipeToClose: ss.params.popupSwipeToClose,
      on: {
        popupOpen(popup) {
          ss.onOpen('popup', popup.el);
        },
        popupOpened(popup) {
          ss.onOpened('popup', popup.el);
        },
        popupClose(popup) {
          ss.onClose('popup', popup.el);
        },
        popupClosed(popup) {
          ss.onClosed('popup', popup.el);
        },
      },
    };

    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popup: popupParams,
        },
      });
    } else {
      ss.modal = ss.app.popup.create(popupParams).open();
    }
    return ss;
  }

  openSheet() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const sheetHtml = ss.renderSheet(ss.items);

    const sheetParams = {
      content: sheetHtml,
      backdrop: false,
      scrollToEl: ss.$el,
      closeByOutsideClick: true,
      push: ss.params.sheetPush,
      swipeToClose: ss.params.sheetSwipeToClose,
      on: {
        sheetOpen(sheet) {
          ss.onOpen('sheet', sheet.el);
        },
        sheetOpened(sheet) {
          ss.onOpened('sheet', sheet.el);
        },
        sheetClose(sheet) {
          ss.onClose('sheet', sheet.el);
        },
        sheetClosed(sheet) {
          ss.onClosed('sheet', sheet.el);
        },
      },
    };

    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          sheet: sheetParams,
        },
      });
    } else {
      ss.modal = ss.app.sheet.create(sheetParams).open();
    }
    return ss;
  }

  openPopover() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const popoverHtml = ss.renderPopover(ss.items);
    const popoverParams = {
      content: popoverHtml,
      targetEl: ss.$el,
      on: {
        popoverOpen(popover) {
          ss.onOpen('popover', popover.el);
        },
        popoverOpened(popover) {
          ss.onOpened('popover', popover.el);
        },
        popoverClose(popover) {
          ss.onClose('popover', popover.el);
        },
        popoverClosed(popover) {
          ss.onClosed('popover', popover.el);
        },
      },
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popover: popoverParams,
        },
      });
    } else {
      ss.modal = ss.app.popover.create(popoverParams).open();
    }
    return ss;
  }

  open(type) {
    const ss = this;
    if (ss.opened) return ss;
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    if (ss.$el) {
      ss.$el.trigger('smartselect:beforeopen', { prevent });
    }
    ss.emit('local::beforeOpen smartSelectBeforeOpen', ss, prevent);
    if (prevented) return ss;
    const openIn = type || ss.params.openIn;
    ss[`open${openIn.split('').map((el, index) => {
      if (index === 0) return el.toUpperCase();
      return el;
    }).join('')}`]();
    return ss;
  }

  close() {
    const ss = this;
    if (!ss.opened) return ss;
    if ((ss.params.routableModals && ss.view) || ss.openedIn === 'page') {
      ss.view.router.back();
    } else {
      ss.modal.once('modalClosed', () => {
        Utils.nextTick(() => {
          if (ss.destroyed) return;
          ss.modal.destroy();
          delete ss.modal;
        });
      });
      ss.modal.close();
    }
    return ss;
  }

  init() {
    const ss = this;
    ss.attachEvents();
    ss.setValueText();
  }

  destroy() {
    const ss = this;
    ss.emit('local::beforeDestroy smartSelectBeforeDestroy', ss);
    ss.$el.trigger('smartselect:beforedestroy');
    ss.detachEvents();
    delete ss.$el[0].f7SmartSelect;
    Utils.deleteProps(ss);
    ss.destroyed = true;
  }
}

var SmartSelect$1 = {
  name: 'smartSelect',
  params: {
    smartSelect: {
      el: undefined,
      valueEl: undefined,
      setValueText: true,
      formatValueText: null,
      openIn: 'page', // or 'popup' or 'sheet' or 'popover'
      popupPush: false,
      popupSwipeToClose: undefined, // defaults to app
      sheetPush: false,
      sheetSwipeToClose: undefined, // defaults to app
      pageTitle: undefined,
      pageBackLinkText: 'Back',
      popupCloseLinkText: 'Close',
      popupTabletFullscreen: false,
      sheetCloseLinkText: 'Done',
      searchbar: false,
      searchbarPlaceholder: 'Search',
      searchbarDisableText: 'Cancel',
      searchbarDisableButton: undefined,
      closeOnSelect: false,
      virtualList: false,
      virtualListHeight: undefined,
      scrollToSelectedItem: false,
      formColorTheme: undefined,
      navbarColorTheme: undefined,
      routableModals: true,
      url: 'select/',
      cssClass: '',
      /*
        Custom render functions
      */
      renderPage: undefined,
      renderPopup: undefined,
      renderSheet: undefined,
      renderPopover: undefined,
      renderItems: undefined,
      renderItem: undefined,
      renderSearchbar: undefined,
    },
  },
  static: {
    SmartSelect,
  },
  create() {
    const app = this;
    app.smartSelect = Utils.extend(
      ConstructorMethods({
        defaultSelector: '.smart-select',
        constructor: SmartSelect,
        app,
        domProp: 'f7SmartSelect',
      }),
      {
        open(smartSelectEl) {
          const ss = app.smartSelect.get(smartSelectEl);
          if (ss && ss.open) return ss.open();
          return undefined;
        },
        close(smartSelectEl) {
          const ss = app.smartSelect.get(smartSelectEl);
          if (ss && ss.close) return ss.close();
          return undefined;
        },
      }
    );
  },

  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.smart-select-init').each((index, smartSelectEl) => {
        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $(smartSelectEl).dataset()));
      });
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find('.smart-select-init').each((index, smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.smart-select-init').each((index, smartSelectEl) => {
        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $(smartSelectEl).dataset()));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find('.smart-select-init').each((index, smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    },
  },
  clicks: {
    '.smart-select': function open($clickedEl, data) {
      const app = this;
      if (!$clickedEl[0].f7SmartSelect) {
        const ss = app.smartSelect.create(Utils.extend({ el: $clickedEl }, data));
        ss.open();
      }
    },
  },
  vnode: {
    'smart-select-init': {
      insert(vnode) {
        const app = this;
        const smartSelectEl = vnode.elm;
        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $(smartSelectEl).dataset()));
      },
      destroy(vnode) {
        const smartSelectEl = vnode.elm;
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      },
    },
  },
};

function getElMinSize(dimension, $el) {
  let minSize = $el.css(`min-${dimension}`);
  if (minSize === 'auto' || minSize === 'none') {
    minSize = 0;
  } else if (minSize.indexOf('px') >= 0) {
    minSize = parseFloat(minSize);
  } else if (minSize.indexOf('%') >= 0) {
    minSize = $el.parent()[0][dimension === 'height' ? 'offsetHeight' : 'offsetWidth'] * parseFloat(minSize) / 100;
  }
  return minSize;
}
function getElMaxSize(dimension, $el) {
  let maxSize = $el.css(`max-${dimension}`);
  if (maxSize === 'auto' || maxSize === 'none') {
    maxSize = null;
  } else if (maxSize.indexOf('px') >= 0) {
    maxSize = parseFloat(maxSize);
  } else if (maxSize.indexOf('%') >= 0) {
    maxSize = $el.parent()[0][dimension === 'height' ? 'offsetHeight' : 'offsetWidth'] * parseFloat(maxSize) / 100;
  }
  return maxSize;
}

const Grid = {
  init() {
    const app = this;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let $resizeHandlerEl;
    let $prevResizableEl;
    let $nextResizableEl;
    let prevElSize;
    let prevElMinSize;
    let prevElMaxSize;
    let nextElSize;
    let nextElMinSize;
    let nextElMaxSize;
    let parentSize;
    let itemsInFlow;
    let gapSize;
    let isScrolling;

    function handleTouchStart(e) {
      if (isTouched || isMoved) return;
      $resizeHandlerEl = $(e.target).closest('.resize-handler');
      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      $prevResizableEl = undefined;
      $nextResizableEl = undefined;
      isScrolling = undefined;
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      const isRow = $resizeHandlerEl.parent('.row').length === 1;
      const sizeProp = isRow ? 'height' : 'width';
      const getSizeProp = isRow ? 'offsetHeight' : 'offsetWidth';
      if (!isMoved) {
        $prevResizableEl = $resizeHandlerEl.parent(isRow ? '.row' : '.col');
        if ($prevResizableEl.length && (!$prevResizableEl.hasClass('resizable') || $prevResizableEl.hasClass('resizable-fixed'))) {
          $prevResizableEl = $prevResizableEl.prevAll('.resizable:not(.resizable-fixed)').eq(0);
        }
        $nextResizableEl = $prevResizableEl.next(isRow ? '.row' : '.col');
        if ($nextResizableEl.length && (!$nextResizableEl.hasClass('resizable') || $nextResizableEl.hasClass('resizable-fixed'))) {
          $nextResizableEl = $nextResizableEl.nextAll('.resizable:not(.resizable-fixed)').eq(0);
        }

        if ($prevResizableEl.length) {
          prevElSize = $prevResizableEl[0][getSizeProp];
          prevElMinSize = getElMinSize(sizeProp, $prevResizableEl);
          prevElMaxSize = getElMaxSize(sizeProp, $prevResizableEl);
          parentSize = $prevResizableEl.parent()[0][getSizeProp];
          itemsInFlow = $prevResizableEl.parent().children(isRow ? '.row' : '[class*="col-"], .col').length;
          gapSize = parseFloat($prevResizableEl.css(isRow ? '--f7-grid-row-gap' : '--f7-grid-gap'));
        }
        if ($nextResizableEl.length) {
          nextElSize = $nextResizableEl[0][getSizeProp];
          nextElMinSize = getElMinSize(sizeProp, $nextResizableEl);
          nextElMaxSize = getElMaxSize(sizeProp, $nextResizableEl);
          if (!$prevResizableEl.length) {
            parentSize = $nextResizableEl.parent()[0][getSizeProp];
            itemsInFlow = $nextResizableEl.parent().children(isRow ? '.row' : '[class*="col-"], .col').length;
            gapSize = parseFloat($nextResizableEl.css(isRow ? '--f7-grid-row-gap' : '--f7-grid-gap'));
          }
        }
      }

      isMoved = true;
      const touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === 'undefined' && !isRow) {
        isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }

      const isAbsolute = $prevResizableEl.hasClass('resizable-absolute') || $nextResizableEl.hasClass('resizable-absolute');
      const resizeNextEl = !isRow || (isRow && !isAbsolute);

      if ((resizeNextEl && !$nextResizableEl.length) || !$prevResizableEl.length) {
        isTouched = false;
        isMoved = false;
        return;
      }

      e.preventDefault();

      let diff = isRow
        ? touchCurrentY - touchStartY
        : touchCurrentX - touchStartX;

      let prevElNewSize;
      let nextElNewSize;
      if ($prevResizableEl.length) {
        prevElNewSize = prevElSize + diff;
        if (prevElNewSize < prevElMinSize) {
          prevElNewSize = prevElMinSize;
          diff = prevElNewSize - prevElSize;
        }
        if (prevElMaxSize && prevElNewSize > prevElMaxSize) {
          prevElNewSize = prevElMaxSize;
          diff = prevElNewSize - prevElSize;
        }
      }
      if ($nextResizableEl.length && resizeNextEl) {
        nextElNewSize = nextElSize - diff;
        if (nextElNewSize < nextElMinSize) {
          nextElNewSize = nextElMinSize;
          diff = nextElSize - nextElNewSize;
          prevElNewSize = prevElSize + diff;
        }
        if (nextElMaxSize && nextElNewSize > nextElMaxSize) {
          nextElNewSize = nextElMaxSize;
          diff = nextElSize - nextElNewSize;
          prevElNewSize = prevElSize + diff;
        }
      }

      if (isAbsolute) {
        $prevResizableEl[0].style[sizeProp] = `${prevElNewSize}px`;
        if (resizeNextEl) {
          $nextResizableEl[0].style[sizeProp] = `${nextElNewSize}px`;
        }
        $prevResizableEl.trigger('grid:resize');
        $nextResizableEl.trigger('grid:resize');
        app.emit('gridResize', $prevResizableEl[0]);
        app.emit('gridResize', $nextResizableEl[0]);
        return;
      }

      const gapAddSize = (itemsInFlow - 1) * gapSize / itemsInFlow;
      const gapAddSizeCSS = isRow
        ? `${itemsInFlow - 1} * var(--f7-grid-row-gap) / ${itemsInFlow}`
        : '(var(--f7-cols-per-row) - 1) * var(--f7-grid-gap) / var(--f7-cols-per-row)';
      const prevElNewSizeNormalized = prevElNewSize + gapAddSize;
      const nextElNewSizeNormalized = nextElNewSize + gapAddSize;
      $prevResizableEl[0].style[sizeProp] = `calc(${prevElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
      $nextResizableEl[0].style[sizeProp] = `calc(${nextElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
      $prevResizableEl.trigger('grid:resize');
      $nextResizableEl.trigger('grid:resize');
      app.emit('gridResize', $prevResizableEl[0]);
      app.emit('gridResize', $nextResizableEl[0]);
    }

    function handleTouchEnd() {
      if (!isTouched) return;
      if (!isMoved) {
        isTouched = false;
      }
      isTouched = false;
      isMoved = false;
    }

    $(document).on(app.touchEvents.start, '.col > .resize-handler, .row > .resize-handler', handleTouchStart);
    app.on('touchmove', handleTouchMove);
    app.on('touchend', handleTouchEnd);
  },
};

var Grid$1 = {
  name: 'grid',
  create() {
    const app = this;
    Utils.extend(app, {
      grid: {
        init: Grid.init.bind(app),
      },
    });
  },
  on: {
    init() {
      const app = this;
      app.grid.init();
    },
  },
};

class Calendar extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const calendar = this;

    calendar.params = Utils.extend({}, app.params.calendar, params);

    let $containerEl;
    if (calendar.params.containerEl) {
      $containerEl = $(calendar.params.containerEl);
      if ($containerEl.length === 0) return calendar;
    }

    let $inputEl;
    if (calendar.params.inputEl) {
      $inputEl = $(calendar.params.inputEl);
    }

    const isHorizontal = calendar.params.direction === 'horizontal';

    let inverter = 1;
    if (isHorizontal) {
      inverter = app.rtl ? -1 : 1;
    }

    Utils.extend(calendar, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      initialized: false,
      opened: false,
      url: calendar.params.url,
      isHorizontal,
      inverter,
      animating: false,
      hasTimePicker: calendar.params.timePicker && !calendar.params.rangePicker && !calendar.params.multiple,
    });
    calendar.dayFormatter = new Intl.DateTimeFormat(calendar.params.locale, { day: 'numeric' });
    calendar.monthFormatter = new Intl.DateTimeFormat(calendar.params.locale, { month: 'long' });
    calendar.yearFormatter = new Intl.DateTimeFormat(calendar.params.locale, { year: 'numeric' });
    calendar.timeSelectorFormatter = new Intl.DateTimeFormat(calendar.params.locale, calendar.params.timePickerFormat);

    // Auto names
    let { monthNames, monthNamesShort, dayNames, dayNamesShort } = calendar.params;
    const { monthNamesIntl, monthNamesShortIntl, dayNamesIntl, dayNamesShortIntl } = calendar.getIntlNames();
    if (monthNames === 'auto') monthNames = monthNamesIntl;
    if (monthNamesShort === 'auto') monthNamesShort = monthNamesShortIntl;
    if (dayNames === 'auto') dayNames = dayNamesIntl;
    if (dayNamesShort === 'auto') dayNamesShort = dayNamesShortIntl;

    Utils.extend(calendar, {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort,
    });

    function onInputClick() {
      calendar.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onInputClear() {
      calendar.setValue([]);
      if (calendar.opened) {
        calendar.update();
      }
    }
    function onHtmlClick(e) {
      const $targetEl = $(e.target);
      if (calendar.destroyed || !calendar.params) return;
      if (calendar.isPopover()) return;
      if (!calendar.opened || calendar.closing) return;
      if ($targetEl.closest('[class*="backdrop"]').length) return;
      if ($inputEl && $inputEl.length > 0) {
        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal, .calendar-modal').length === 0) {
          calendar.close();
        }
      } else if ($(e.target).closest('.sheet-modal, .calendar-modal').length === 0) {
        calendar.close();
      }
    }

    // Events
    Utils.extend(calendar, {
      attachInputEvents() {
        calendar.$inputEl.on('click', onInputClick);
        calendar.$inputEl.on('input:clear', onInputClear);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.on('focus mousedown', onInputFocus);
          if (calendar.$inputEl[0]) {
            calendar.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        calendar.$inputEl.off('click', onInputClick);
        calendar.$inputEl.off('input:clear', onInputClear);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.off('focus mousedown', onInputFocus);
          if (calendar.$inputEl[0]) {
            delete calendar.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachHtmlEvents() {
        app.on('click', onHtmlClick);
      },
      detachHtmlEvents() {
        app.off('click', onHtmlClick);
      },
    });
    calendar.attachCalendarEvents = function attachCalendarEvents() {
      let allowItemClick = true;
      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchCurrentX;
      let touchCurrentY;
      let touchStartTime;
      let touchEndTime;
      let currentTranslate;
      let wrapperWidth;
      let wrapperHeight;
      let percentage;
      let touchesDiff;
      let isScrolling;

      const { $el, $wrapperEl } = calendar;

      function handleTouchStart(e) {
        if (isMoved || isTouched) return;
        isTouched = true;
        touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentX = touchStartX;
        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        touchStartTime = (new Date()).getTime();
        percentage = 0;
        allowItemClick = true;
        isScrolling = undefined;
        currentTranslate = calendar.monthsTranslate;
      }
      function handleTouchMove(e) {
        if (!isTouched) return;
        const { isHorizontal: isH } = calendar;

        touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
        }
        if (isH && isScrolling) {
          isTouched = false;
          return;
        }
        e.preventDefault();
        if (calendar.animating) {
          isTouched = false;
          return;
        }
        allowItemClick = false;
        if (!isMoved) {
          // First move
          isMoved = true;
          wrapperWidth = $wrapperEl[0].offsetWidth;
          wrapperHeight = $wrapperEl[0].offsetHeight;
          $wrapperEl.transition(0);
        }

        touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
        percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
        currentTranslate = ((calendar.monthsTranslate * calendar.inverter) + percentage) * 100;

        // Transform wrapper
        $wrapperEl.transform(`translate3d(${isH ? currentTranslate : 0}%, ${isH ? 0 : currentTranslate}%, 0)`);
      }
      function handleTouchEnd() {
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }
        isTouched = false;
        isMoved = false;

        touchEndTime = new Date().getTime();
        if (touchEndTime - touchStartTime < 300) {
          if (Math.abs(touchesDiff) < 10) {
            calendar.resetMonth();
          } else if (touchesDiff >= 10) {
            if (app.rtl) calendar.nextMonth();
            else calendar.prevMonth();
          } else if (app.rtl) calendar.prevMonth();
          else calendar.nextMonth();
        } else if (percentage <= -0.5) {
          if (app.rtl) calendar.prevMonth();
          else calendar.nextMonth();
        } else if (percentage >= 0.5) {
          if (app.rtl) calendar.nextMonth();
          else calendar.prevMonth();
        } else {
          calendar.resetMonth();
        }

        // Allow click
        setTimeout(() => {
          allowItemClick = true;
        }, 100);
      }

      function handleDayClick(e) {
        if (!allowItemClick) return;
        let $dayEl = $(e.target).parents('.calendar-day');
        if ($dayEl.length === 0 && $(e.target).hasClass('calendar-day')) {
          $dayEl = $(e.target);
        }
        if ($dayEl.length === 0) return;
        if ($dayEl.hasClass('calendar-day-disabled')) return;
        if (!calendar.params.rangePicker) {
          if ($dayEl.hasClass('calendar-day-next')) calendar.nextMonth();
          if ($dayEl.hasClass('calendar-day-prev')) calendar.prevMonth();
        }
        const dateYear = parseInt($dayEl.attr('data-year'), 10);
        const dateMonth = parseInt($dayEl.attr('data-month'), 10);
        const dateDay = parseInt($dayEl.attr('data-day'), 10);
        calendar.emit(
          'local::dayClick calendarDayClick',
          calendar,
          $dayEl[0],
          dateYear,
          dateMonth,
          dateDay
        );
        if (!$dayEl.hasClass('calendar-day-selected') || calendar.params.multiple || calendar.params.rangePicker) {
          const valueToAdd = new Date(dateYear, dateMonth, dateDay, 0, 0, 0);
          if (calendar.hasTimePicker) {
            if (calendar.value && calendar.value[0]) {
              valueToAdd.setHours(calendar.value[0].getHours(), calendar.value[0].getMinutes());
            } else {
              valueToAdd.setHours(new Date().getHours(), new Date().getMinutes());
            }
          }
          calendar.addValue(valueToAdd);
        }
        if (calendar.params.closeOnSelect) {
          if (
            (calendar.params.rangePicker && calendar.value.length === 2)
            || !calendar.params.rangePicker
          ) {
            calendar.close();
          }
        }
      }

      function onNextMonthClick() {
        calendar.nextMonth();
      }

      function onPrevMonthClick() {
        calendar.prevMonth();
      }

      function onNextYearClick() {
        calendar.nextYear();
      }

      function onPrevYearClick() {
        calendar.prevYear();
      }

      function onMonthSelectorClick() {
        $el.append(calendar.renderMonthPicker());
      }
      function onMonthSelectorItemClick() {
        const $clickedEl = $(this);
        if ($clickedEl.hasClass('calendar-month-picker-item-current')) {
          $el.find('.calendar-month-picker').remove();
          return;
        }
        $el.find('.calendar-month-picker-item-current').add($clickedEl).toggleClass('calendar-month-picker-item-current');
        const index = $clickedEl.index();
        const localeMonthIndex = parseInt(calendar.$el.find('.calendar-month-current').attr('data-locale-month'), 10);
        const monthIndex = calendar.currentMonth;
        const diff = localeMonthIndex - monthIndex;
        const diffIndex = index - diff;
        calendar.setYearMonth(calendar.currentYear, diffIndex, 0);
        setTimeout(() => {
          $el.find('.calendar-month-picker').remove();
        }, 200);
      }

      function onYearSelectorClick() {
        $el.append(calendar.renderYearPicker());
        const $currentEl = $el.find('.calendar-year-picker-item-current');
        const $yearPickerEl = $el.find('.calendar-year-picker');
        if (!$currentEl || !$currentEl.length) return;
        $yearPickerEl.scrollTop(
          $currentEl[0].offsetTop
          - $yearPickerEl[0].offsetHeight / 2
          + $currentEl[0].offsetHeight / 2
        );
      }

      function onYearSelectorItemClick() {
        const $clickedEl = $(this);
        if ($clickedEl.hasClass('calendar-year-picker-item-current')) {
          $el.find('.calendar-year-picker').remove();
          return;
        }
        $el.find('.calendar-year-picker-item-current').add($clickedEl).toggleClass('calendar-year-picker-item-current');
        const year = parseInt($clickedEl.attr('data-year'), 10);
        calendar.setYearMonth(year, undefined, 0);
        setTimeout(() => {
          $el.find('.calendar-year-picker').remove();
        }, 200);
      }

      function onTimeSelectorClick() {
        calendar.openTimePicker();
      }
      function onTimePickerCloseClick() {
        calendar.closeTimePicker();
      }

      const passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;
      // Selectors clicks
      $el.find('.calendar-prev-month-button').on('click', onPrevMonthClick);
      $el.find('.calendar-next-month-button').on('click', onNextMonthClick);
      $el.find('.calendar-prev-year-button').on('click', onPrevYearClick);
      $el.find('.calendar-next-year-button').on('click', onNextYearClick);
      if (calendar.params.monthPicker) {
        $el.find('.current-month-value').on('click', onMonthSelectorClick);
        $el.on('click', '.calendar-month-picker-item', onMonthSelectorItemClick);
      }
      if (calendar.params.yearPicker) {
        $el.find('.current-year-value').on('click', onYearSelectorClick);
        $el.on('click', '.calendar-year-picker-item', onYearSelectorItemClick);
      }
      if (calendar.hasTimePicker) {
        $el.find('.calendar-time-selector a').on('click', onTimeSelectorClick);
        $el.on('click', '.calendar-time-picker-close', onTimePickerCloseClick);
      }
      // Day clicks
      $wrapperEl.on('click', handleDayClick);
      // Touch events
      if (calendar.params.touchMove) {
        $wrapperEl.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      }

      calendar.detachCalendarEvents = function detachCalendarEvents() {
        $el.find('.calendar-prev-month-button').off('click', onPrevMonthClick);
        $el.find('.calendar-next-month-button').off('click', onNextMonthClick);
        $el.find('.calendar-prev-year-button').off('click', onPrevYearClick);
        $el.find('.calendar-next-year-button').off('click', onNextYearClick);
        if (calendar.params.monthPicker) {
          $el.find('.current-month-value').off('click', onMonthSelectorClick);
          $el.off('click', '.calendar-month-picker-item', onMonthSelectorItemClick);
        }
        if (calendar.params.yearPicker) {
          $el.find('.current-year-value').off('click', onYearSelectorClick);
          $el.off('click', '.calendar-year-picker-item', onYearSelectorItemClick);
        }
        if (calendar.hasTimePicker) {
          $el.find('.calendar-time-selector a').off('click', onTimeSelectorClick);
          $el.off('click', '.calendar-time-picker-close', onTimePickerCloseClick);
        }
        $wrapperEl.off('click', handleDayClick);
        if (calendar.params.touchMove) {
          $wrapperEl.off(app.touchEvents.start, handleTouchStart, passiveListener);
          app.off('touchmove:active', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
        }
      };
    };

    calendar.init();

    return calendar;
  }

  get view() {
    const { $inputEl, app, params } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
    }
    if (!view) view = app.views.main;
    return view;
  }

  getIntlNames() {
    const calendar = this;
    const locale = calendar.params.locale;

    const monthNamesIntl = [];
    const monthNamesShortIntl = [];
    const dayNamesIntl = [];
    const dayNamesShortIntl = [];
    const formatterMonthNames = new Intl.DateTimeFormat(locale, { month: 'long' });
    const formatterMonthNamesShort = new Intl.DateTimeFormat(locale, { month: 'short' });
    const formatterDayNames = new Intl.DateTimeFormat(locale, { weekday: 'long' });
    const formatterDayNamesShort = new Intl.DateTimeFormat(locale, { weekday: 'short' });
    let year;
    let yearStarted;
    let yearEnded;
    for (let i = 0; i < 24; i += 1) {
      const date = new Date().setMonth(i, 1);
      const currentYear = calendar.yearFormatter.format(date);

      if (year && currentYear !== year) {
        if (yearStarted) yearEnded = true;
        yearStarted = true;
        year = currentYear;
      }
      if (!year) {
        year = currentYear;
      }
      if (yearStarted && year === currentYear && !yearEnded) {
        monthNamesIntl.push(formatterMonthNames.format(date));
        monthNamesShortIntl.push(formatterMonthNamesShort.format(date));
      }
    }
    const weekDay = new Date().getDay();
    for (let i = 0; i < 7; i += 1) {
      const date = new Date().getTime() + (i - weekDay) * 24 * 60 * 60 * 1000;
      dayNamesIntl.push(formatterDayNames.format(date));
      dayNamesShortIntl.push(formatterDayNamesShort.format(date));
    }

    return {
      monthNamesIntl,
      monthNamesShortIntl,
      dayNamesIntl,
      dayNamesShortIntl,
    };
  }

  normalizeDate(date) {
    const calendar = this;
    const d = new Date(date);
    if (calendar.hasTimePicker) {
      return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
    }
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }

  normalizeValues(values) {
    const calendar = this;
    let newValues = [];
    if (values && Array.isArray(values)) {
      newValues = values.map(val => calendar.normalizeDate(val));
    }
    return newValues;
  }

  initInput() {
    const calendar = this;
    if (!calendar.$inputEl) return;
    if (calendar.params.inputReadOnly) calendar.$inputEl.prop('readOnly', true);
  }

  isPopover() {
    const calendar = this;
    const { app, modal, params } = calendar;
    if (params.openIn === 'sheet') return false;
    if (modal && modal.type !== 'popover') return false;

    if (!calendar.inline && calendar.inputEl) {
      if (params.openIn === 'popover') return true;
      if (app.device.ios) {
        return !!app.device.ipad;
      }
      if (app.width >= 768) {
        return true;
      }
      if (app.device.desktop && app.theme === 'aurora') {
        return true;
      }
    }
    return false;
  }

  formatDate(d) {
    const calendar = this;
    const date = new Date(d);
    const year = date.getFullYear();
    const month = date.getMonth();
    const month1 = month + 1;
    const day = date.getDate();
    const weekDay = date.getDay();
    const { monthNames, monthNamesShort, dayNames, dayNamesShort } = calendar;
    const { dateFormat, locale } = calendar.params;

    function twoDigits(number) {
      return (number < 10) ? `0${number}` : number;
    }
    if (typeof dateFormat === 'string') {
      const tokens = {
        yyyy: year,
        yy: String(year).substring(2),
        mm: twoDigits(month1),
        m: month1,
        MM: monthNames[month],
        M: monthNamesShort[month],
        dd: twoDigits(day),
        d: day,
        DD: dayNames[weekDay],
        D: dayNamesShort[weekDay],
      };
      if (calendar.params.timePicker) {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        let hours12 = hours;
        if (hours > 12) hours12 = hours - 12;
        if (hours === 0) hours12 = 12;
        const a = hours >= 12 && hours !== 0 ? 'pm' : 'am';

        Object.assign(tokens, {
          HH: twoDigits(hours),
          H: hours,
          hh: twoDigits(hours12),
          h: hours12,
          ss: twoDigits(seconds),
          s: seconds,
          ':mm': twoDigits(minutes),
          ':m': minutes,
          a,
          A: a.toUpperCase(),
        });
      }
      const regexp = new RegExp(
        Object.keys(tokens).map(t => `(${t})`).join('|'),
        'g',
      );
      return dateFormat.replace(regexp, (token) => {
        if (token in tokens) return tokens[token];
        return token;
      });
    }
    if (typeof dateFormat === 'function') {
      return dateFormat(date);
    }
    // Intl Object
    const formatter = new Intl.DateTimeFormat(locale, dateFormat);
    return formatter.format(date);
  }

  formatValue() {
    const calendar = this;
    const { value } = calendar;
    if (calendar.params.formatValue) {
      return calendar.params.formatValue.call(calendar, value);
    }
    return value
      .map(v => calendar.formatDate(v))
      .join(calendar.params.rangePicker ? ' - ' : ', ');
  }

  addValue(newValue) {
    const calendar = this;
    const { multiple, rangePicker, rangePickerMinDays, rangePickerMaxDays } = calendar.params;
    if (multiple) {
      if (!calendar.value) calendar.value = [];
      let inValuesIndex;
      for (let i = 0; i < calendar.value.length; i += 1) {
        if (new Date(newValue).getTime() === new Date(calendar.value[i]).getTime()) {
          inValuesIndex = i;
        }
      }
      if (typeof inValuesIndex === 'undefined') {
        calendar.value.push(newValue);
      } else {
        calendar.value.splice(inValuesIndex, 1);
      }
      calendar.updateValue();
    } else if (rangePicker) {
      if (!calendar.value) calendar.value = [];
      if (calendar.value.length === 2 || calendar.value.length === 0) {
        calendar.value = [];
      }

      if ((calendar.value.length === 0
        || ((Math.abs(calendar.value[0].getTime() - newValue.getTime()) >= (rangePickerMinDays - 1) * 60 * 60 * 24 * 1000) && (rangePickerMaxDays === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) <= (rangePickerMaxDays - 1) * 60 * 60 * 24 * 1000)))) calendar.value.push(newValue);
      else calendar.value = [];

      calendar.value.sort((a, b) => a - b);
      calendar.updateValue();
    } else {
      calendar.value = [newValue];
      calendar.updateValue();
    }
  }

  setValue(values) {
    const calendar = this;
    const currentValue = calendar.value;
    if (Array.isArray(currentValue) && Array.isArray(values) && currentValue.length === values.length) {
      let equal = true;
      currentValue.forEach((v, index) => {
        if (v !== values[index]) equal = false;
      });
      if (equal) return;
    }
    calendar.value = values;
    calendar.updateValue();
  }

  getValue() {
    const calendar = this;
    return calendar.value;
  }

  updateValue(onlyHeader) {
    const calendar = this;
    const {
      $el,
      $wrapperEl,
      $inputEl,
      value,
      params,
    } = calendar;
    let i;
    if ($el && $el.length > 0) {
      $wrapperEl.find('.calendar-day-selected').removeClass('calendar-day-selected');
      let valueDate;
      if (params.rangePicker && value.length === 2) {
        for (i = new Date(value[0]).getTime(); i <= new Date(value[1]).getTime(); i += 24 * 60 * 60 * 1000) {
          valueDate = new Date(i);
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass('calendar-day-selected');
        }
      } else {
        for (i = 0; i < calendar.value.length; i += 1) {
          valueDate = new Date(value[i]);
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass('calendar-day-selected');
        }
      }
    }
    if (!onlyHeader) {
      calendar.emit('local::change calendarChange', calendar, value);
    }

    if ($el && $el.length > 0 && calendar.hasTimePicker) {
      $el.find('.calendar-time-selector a').text(value && value.length ? calendar.timeSelectorFormatter.format(value[0]) : calendar.params.timePickerPlaceholder);
    }

    if (($inputEl && $inputEl.length) || params.header) {
      const inputValue = calendar.formatValue(value);
      if (params.header && $el && $el.length) {
        $el.find('.calendar-selected-date').text(inputValue);
      }
      if ($inputEl && $inputEl.length && !onlyHeader) {
        $inputEl.val(inputValue);
        $inputEl.trigger('change');
      }
    }
  }

  updateCurrentMonthYear(dir) {
    const calendar = this;
    const { $months, $el, monthNames } = calendar;
    let currentLocaleMonth;
    let currentLocaleYear;
    if (typeof dir === 'undefined') {
      calendar.currentMonth = parseInt($months.eq(1).attr('data-month'), 10);
      calendar.currentYear = parseInt($months.eq(1).attr('data-year'), 10);
      currentLocaleMonth = $months.eq(1).attr('data-locale-month');
      currentLocaleYear = $months.eq(1).attr('data-locale-year');
    } else {
      calendar.currentMonth = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-month'), 10);
      calendar.currentYear = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-year'), 10);
      currentLocaleMonth = $months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-locale-month');
      currentLocaleYear = $months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-locale-year');
    }
    $el.find('.current-month-value').text(monthNames[currentLocaleMonth]);
    $el.find('.current-year-value').text(currentLocaleYear);
  }

  update() {
    const calendar = this;
    const { currentYear, currentMonth, $wrapperEl } = calendar;
    const currentDate = new Date(currentYear, currentMonth);
    const prevMonthHtml = calendar.renderMonth(currentDate, 'prev');
    const currentMonthHtml = calendar.renderMonth(currentDate);
    const nextMonthHtml = calendar.renderMonth(currentDate, 'next');

    $wrapperEl
      .transition(0)
      .html(`${prevMonthHtml}${currentMonthHtml}${nextMonthHtml}`)
      .transform('translate3d(0,0,0)');
    calendar.$months = $wrapperEl.find('.calendar-month');
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();
    calendar.$months.each((index, monthEl) => {
      calendar.emit(
        'local::monthAdd calendarMonthAdd',
        monthEl
      );
    });
  }

  onMonthChangeStart(dir) {
    const calendar = this;
    const { $months, currentYear, currentMonth } = calendar;
    calendar.updateCurrentMonthYear(dir);
    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
    const currentIndex = dir === 'next' ? $months.length - 1 : 0;

    $months.eq(currentIndex).addClass('calendar-month-current');
    $months.eq(dir === 'next' ? currentIndex - 1 : currentIndex + 1).addClass(dir === 'next' ? 'calendar-month-prev' : 'calendar-month-next');

    calendar.emit(
      'local::monthYearChangeStart calendarMonthYearChangeStart',
      calendar,
      currentYear,
      currentMonth
    );
  }

  onMonthChangeEnd(dir, rebuildBoth) {
    const calendar = this;
    const { currentYear, currentMonth, $wrapperEl, monthsTranslate } = calendar;
    calendar.animating = false;
    let nextMonthHtml;
    let prevMonthHtml;
    let currentMonthHtml;
    $wrapperEl
      .find('.calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)')
      .remove();

    if (typeof dir === 'undefined') {
      dir = 'next'; // eslint-disable-line
      rebuildBoth = true; // eslint-disable-line
    }
    if (!rebuildBoth) {
      currentMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), dir);
    } else {
      $wrapperEl.find('.calendar-month-next, .calendar-month-prev').remove();
      prevMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'prev');
      nextMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'next');
    }
    if (dir === 'next' || rebuildBoth) {
      $wrapperEl.append(currentMonthHtml || nextMonthHtml);
    }
    if (dir === 'prev' || rebuildBoth) {
      $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
    }
    const $months = $wrapperEl.find('.calendar-month');
    calendar.$months = $months;
    calendar.setMonthsTranslate(monthsTranslate);
    calendar.emit(
      'local::monthAdd calendarMonthAdd',
      calendar,
      dir === 'next' ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]
    );
    calendar.emit(
      'local::monthYearChangeEnd calendarMonthYearChangeEnd',
      calendar,
      currentYear,
      currentMonth
    );
  }

  setMonthsTranslate(translate) {
    const calendar = this;
    const { $months, isHorizontal: isH, inverter } = calendar;
    // eslint-disable-next-line
    translate = translate || calendar.monthsTranslate || 0;
    if (typeof calendar.monthsTranslate === 'undefined') {
      calendar.monthsTranslate = translate;
    }
    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
    const prevMonthTranslate = -(translate + 1) * 100 * inverter;
    const currentMonthTranslate = -translate * 100 * inverter;
    const nextMonthTranslate = -(translate - 1) * 100 * inverter;
    $months.eq(0)
      .transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`)
      .addClass('calendar-month-prev');
    $months.eq(1)
      .transform(`translate3d(${isH ? currentMonthTranslate : 0}%, ${isH ? 0 : currentMonthTranslate}%, 0)`)
      .addClass('calendar-month-current');
    $months.eq(2)
      .transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`)
      .addClass('calendar-month-next');
  }

  nextMonth(transition) {
    const calendar = this;
    const { params, $wrapperEl, inverter, isHorizontal: isH } = calendar;
    if (typeof transition === 'undefined' || typeof transition === 'object') {
      transition = ''; // eslint-disable-line
      if (!params.animate) transition = 0; // eslint-disable-line
    }
    const nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-month'), 10);
    const nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-year'), 10);
    const nextDate = new Date(nextYear, nextMonth);
    const nextDateTime = nextDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.maxDate) {
      if (nextDateTime > new Date(params.maxDate).getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate -= 1;
    if (nextMonth === calendar.currentMonth) {
      const nextMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
      const nextMonthHtml = $(calendar.renderMonth(nextDateTime, 'next'))
        .transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`)
        .addClass('calendar-month-next');
      $wrapperEl.append(nextMonthHtml[0]);
      calendar.$months = $wrapperEl.find('.calendar-month');
      calendar.emit(
        'local::monthAdd calendarMonthAdd',
        calendar.$months.eq(calendar.$months.length - 1)[0]
      );
    }
    calendar.animating = true;
    calendar.onMonthChangeStart('next');
    const translate = (calendar.monthsTranslate * 100) * inverter;

    $wrapperEl.transition(transition).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd('next');
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd('next');
    }
  }

  prevMonth(transition) {
    const calendar = this;
    const { params, $wrapperEl, inverter, isHorizontal: isH } = calendar;
    if (typeof transition === 'undefined' || typeof transition === 'object') {
      transition = ''; // eslint-disable-line
      if (!params.animate) transition = 0; // eslint-disable-line
    }
    const prevMonth = parseInt(calendar.$months.eq(0).attr('data-month'), 10);
    const prevYear = parseInt(calendar.$months.eq(0).attr('data-year'), 10);
    const prevDate = new Date(prevYear, prevMonth + 1, -1);
    const prevDateTime = prevDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
      if (prevDateTime < minDate.getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate += 1;
    if (prevMonth === calendar.currentMonth) {
      const prevMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
      const prevMonthHtml = $(calendar.renderMonth(prevDateTime, 'prev'))
        .transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`)
        .addClass('calendar-month-prev');
      $wrapperEl.prepend(prevMonthHtml[0]);
      calendar.$months = $wrapperEl.find('.calendar-month');
      calendar.emit(
        'local::monthAdd calendarMonthAdd',
        calendar.$months.eq(0)[0]
      );
    }
    calendar.animating = true;
    calendar.onMonthChangeStart('prev');
    const translate = (calendar.monthsTranslate * 100) * inverter;
    $wrapperEl
      .transition(transition)
      .transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd('prev');
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd('prev');
    }
  }

  resetMonth(transition = '') {
    const calendar = this;
    const { $wrapperEl, inverter, isHorizontal: isH, monthsTranslate } = calendar;
    const translate = (monthsTranslate * 100) * inverter;
    $wrapperEl
      .transition(transition)
      .transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
  }
  // eslint-disable-next-line
  setYearMonth(year, month, transition) {
    const calendar = this;
    const { params, isHorizontal: isH, $wrapperEl, inverter } = calendar;
    // eslint-disable-next-line
    if (typeof year === 'undefined') year = calendar.currentYear;
    // eslint-disable-next-line
    if (typeof month === 'undefined') month = calendar.currentMonth;
    if (typeof transition === 'undefined' || typeof transition === 'object') {
      // eslint-disable-next-line
      transition = '';
      // eslint-disable-next-line
      if (!params.animate) transition = 0;
    }
    let targetDate;
    if (year < calendar.currentYear) {
      targetDate = new Date(year, month + 1, -1).getTime();
    } else {
      targetDate = new Date(year, month).getTime();
    }
    if (params.maxDate && targetDate > new Date(params.maxDate).getTime()) {
      return false;
    }
    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
      if (targetDate < minDate.getTime()) {
        return false;
      }
    }
    const currentDate = new Date(calendar.currentYear, calendar.currentMonth).getTime();
    const dir = targetDate > currentDate ? 'next' : 'prev';
    const newMonthHTML = calendar.renderMonth(new Date(year, month));
    calendar.monthsTranslate = calendar.monthsTranslate || 0;
    const prevTranslate = calendar.monthsTranslate;
    let monthTranslate;
    const transitionEndCallback = !calendar.animating && transition !== 0;
    if (targetDate > currentDate) {
      // To next
      calendar.monthsTranslate -= 1;
      if (!calendar.animating) calendar.$months.eq(calendar.$months.length - 1).remove();
      $wrapperEl.append(newMonthHTML);
      calendar.$months = $wrapperEl.find('.calendar-month');
      monthTranslate = -(prevTranslate - 1) * 100 * inverter;
      calendar.$months
        .eq(calendar.$months.length - 1)
        .transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`)
        .addClass('calendar-month-next');
    } else {
      // To prev
      calendar.monthsTranslate += 1;
      if (!calendar.animating) calendar.$months.eq(0).remove();
      $wrapperEl.prepend(newMonthHTML);
      calendar.$months = $wrapperEl.find('.calendar-month');
      monthTranslate = -(prevTranslate + 1) * 100 * inverter;
      calendar.$months
        .eq(0)
        .transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`)
        .addClass('calendar-month-prev');
    }
    calendar.emit(
      'local::monthAdd calendarMonthAdd',
      dir === 'next'
        ? calendar.$months.eq(calendar.$months.length - 1)[0]
        : calendar.$months.eq(0)[0]
    );

    calendar.animating = true;
    calendar.onMonthChangeStart(dir);
    const wrapperTranslate = (calendar.monthsTranslate * 100) * inverter;
    $wrapperEl
      .transition(transition)
      .transform(`translate3d(${isH ? wrapperTranslate : 0}%, ${isH ? 0 : wrapperTranslate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd(dir, true);
      });
    }
    if (!params.animate || transition === 0) {
      calendar.onMonthChangeEnd(dir, true);
    }
  }

  nextYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear + 1);
  }

  prevYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear - 1);
  }
  // eslint-disable-next-line
  dateInRange(dayDate, range) {
    let match = false;
    let i;
    if (!range) return false;
    if (Array.isArray(range)) {
      for (i = 0; i < range.length; i += 1) {
        if (range[i].from || range[i].to) {
          if (range[i].from && range[i].to) {
            if ((dayDate <= new Date(range[i].to).getTime()) && (dayDate >= new Date(range[i].from).getTime())) {
              match = true;
            }
          } else if (range[i].from) {
            if (dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime()) {
              match = true;
            }
          }
        } else if (range[i].date) {
          if (dayDate === new Date(range[i].date).getTime()) {
            match = true;
          }
        } else if (dayDate === new Date(range[i]).getTime()) {
          match = true;
        }
      }
    } else if (range.from || range.to) {
      if (range.from && range.to) {
        if ((dayDate <= new Date(range.to).getTime()) && (dayDate >= new Date(range.from).getTime())) {
          match = true;
        }
      } else if (range.from) {
        if (dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.to) {
        if (dayDate <= new Date(range.to).getTime()) {
          match = true;
        }
      }
    } else if (range.date) {
      match = dayDate === new Date(range.date).getTime();
    } else if (typeof range === 'function') {
      match = range(new Date(dayDate));
    }
    return match;
  }
  // eslint-disable-next-line
  daysInMonth(date) {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
  }

  renderMonths(date) {
    const calendar = this;
    if (calendar.params.renderMonths) {
      return calendar.params.renderMonths.call(calendar, date);
    }
    return `
    <div class="calendar-months-wrapper">
    ${calendar.renderMonth(date, 'prev')}
    ${calendar.renderMonth(date)}
    ${calendar.renderMonth(date, 'next')}
    </div>
  `.trim();
  }

  renderMonth(d, offset) {
    const calendar = this;
    const { params, value } = calendar;
    if (params.renderMonth) {
      return params.renderMonth.call(calendar, d, offset);
    }
    let date = new Date(d);
    let year = date.getFullYear();
    let month = date.getMonth();
    let localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter.format(date));
    if (localeMonth < 0) localeMonth = month;
    let localeYear = calendar.yearFormatter.format(date);

    if (offset === 'next') {
      if (month === 11) date = new Date(year + 1, 0);
      else date = new Date(year, month + 1, 1);
    }
    if (offset === 'prev') {
      if (month === 0) date = new Date(year - 1, 11);
      else date = new Date(year, month - 1, 1);
    }
    if (offset === 'next' || offset === 'prev') {
      month = date.getMonth();
      year = date.getFullYear();
      localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter.format(date));
      if (localeMonth < 0) localeMonth = month;
      localeYear = calendar.yearFormatter.format(date);
    }

    const currentValues = [];
    const today = new Date().setHours(0, 0, 0, 0);
    const minDate = params.minDate ? new Date(params.minDate).getTime() : null;
    const maxDate = params.maxDate ? new Date(params.maxDate).getTime() : null;
    const rows = 6;
    const cols = 7;
    const daysInPrevMonth = calendar.daysInMonth(new Date(date.getFullYear(), date.getMonth()).getTime() - (10 * 24 * 60 * 60 * 1000));
    const daysInMonth = calendar.daysInMonth(date);
    const minDayNumber = params.firstDay === 6 ? 0 : 1;

    let monthHtml = '';
    let dayIndex = 0 + (params.firstDay - 1);
    let disabled;
    let hasEvents;
    let firstDayOfMonthIndex = new Date(date.getFullYear(), date.getMonth()).getDay();
    if (firstDayOfMonthIndex === 0) firstDayOfMonthIndex = 7;

    if (value && value.length) {
      for (let i = 0; i < value.length; i += 1) {
        currentValues.push(new Date(value[i]).setHours(0, 0, 0, 0));
      }
    }

    for (let row = 1; row <= rows; row += 1) {
      let rowHtml = '';
      for (let col = 1; col <= cols; col += 1) {
        dayIndex += 1;
        let dayDate;
        let dayNumber = dayIndex - firstDayOfMonthIndex;
        let addClass = '';
        if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
          dayIndex -= 7;
          dayNumber = dayIndex - firstDayOfMonthIndex;
        }

        const weekDayIndex = ((col - 1) + params.firstDay > 6)
          ? ((col - 1 - 7) + params.firstDay)
          : ((col - 1) + params.firstDay);

        if (dayNumber < 0) {
          dayNumber = daysInPrevMonth + dayNumber + 1;
          addClass += ' calendar-day-prev';
          dayDate = new Date(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
        } else {
          dayNumber += 1;
          if (dayNumber > daysInMonth) {
            dayNumber -= daysInMonth;
            addClass += ' calendar-day-next';
            dayDate = new Date(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
          } else {
            dayDate = new Date(year, month, dayNumber).getTime();
          }
        }
        // Today
        if (dayDate === today) addClass += ' calendar-day-today';

        // Selected
        if (params.rangePicker && currentValues.length === 2) {
          if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) addClass += ' calendar-day-selected';
        } else if (currentValues.indexOf(dayDate) >= 0) addClass += ' calendar-day-selected';
        // Weekend
        if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
          addClass += ' calendar-day-weekend';
        }
        // Events
        let eventsHtml = '';
        hasEvents = false;
        if (params.events) {
          if (calendar.dateInRange(dayDate, params.events)) {
            hasEvents = true;
          }
        }
        if (hasEvents) {
          addClass += ' calendar-day-has-events';
          eventsHtml = `
            <span class="calendar-day-events">
              <span class="calendar-day-event"></span>
            </span>
          `;
          if (Array.isArray(params.events)) {
            const eventDots = [];
            params.events.forEach((ev) => {
              const color = ev.color || '';
              if (eventDots.indexOf(color) < 0 && calendar.dateInRange(dayDate, ev)) {
                eventDots.push(color);
              }
            });
            eventsHtml = `
              <span class="calendar-day-events">
                ${eventDots.map(color => `
                  <span class="calendar-day-event" style="${color ? `background-color: ${color}` : ''}"></span>
                `.trim()).join('')}
              </span>
            `;
          }
        }
        // Custom Ranges
        if (params.rangesClasses) {
          for (let k = 0; k < params.rangesClasses.length; k += 1) {
            if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
              addClass += ` ${params.rangesClasses[k].cssClass}`;
            }
          }
        }
        // Disabled
        disabled = false;
        if ((minDate && dayDate < minDate) || (maxDate && dayDate > maxDate)) {
          disabled = true;
        }
        if (params.disabled) {
          if (calendar.dateInRange(dayDate, params.disabled)) {
            disabled = true;
          }
        }
        if (disabled) {
          addClass += ' calendar-day-disabled';
        }

        dayDate = new Date(dayDate);
        const dayYear = dayDate.getFullYear();
        const dayMonth = dayDate.getMonth();
        const dayNumberDisplay = calendar.dayFormatter.format(dayDate);
        rowHtml += `
          <div data-year="${dayYear}" data-month="${dayMonth}" data-day="${dayNumber}" class="calendar-day${addClass}" data-date="${dayYear}-${dayMonth}-${dayNumber}">
            <span class="calendar-day-number">${dayNumberDisplay}${eventsHtml}</span>
          </div>`.trim();
      }
      monthHtml += `<div class="calendar-row">${rowHtml}</div>`;
    }
    monthHtml = `<div class="calendar-month" data-year="${year}" data-month="${month}" data-locale-year="${localeYear}" data-locale-month="${localeMonth}">${monthHtml}</div>`;
    return monthHtml;
  }

  renderWeekHeader() {
    const calendar = this;
    if (calendar.params.renderWeekHeader) {
      return calendar.params.renderWeekHeader.call(calendar);
    }
    const { params } = calendar;
    let weekDaysHtml = '';
    for (let i = 0; i < 7; i += 1) {
      const dayIndex = (i + params.firstDay > 6)
        ? ((i - 7) + params.firstDay)
        : (i + params.firstDay);
      const dayName = calendar.dayNamesShort[dayIndex];
      weekDaysHtml += `<div class="calendar-week-day">${dayName}</div>`;
    }
    return `
    <div class="calendar-week-header">
      ${weekDaysHtml}
    </div>
  `.trim();
  }

  renderMonthSelector() {
    const calendar = this;
    if (calendar.params.renderMonthSelector) {
      return calendar.params.renderMonthSelector.call(calendar);
    }

    return `
    <div class="calendar-month-selector">
      <a class="link icon-only calendar-prev-month-button">
        <i class="icon icon-prev"></i>
      </a>
      ${calendar.params.monthPicker ? `
        <a class="current-month-value link"></a>
      ` : `
        <span class="current-month-value"></span>
      `}
      <a class="link icon-only calendar-next-month-button">
        <i class="icon icon-next"></i>
      </a>
    </div>
  `.trim();
  }

  renderMonthPicker() {
    const calendar = this;
    const localeMonth = parseInt(calendar.$el.find('.calendar-month-current').attr('data-locale-month'), 10);
    return `
      <div class="calendar-month-picker">
        ${calendar.monthNames.map((m, index) => `
          <div class="calendar-month-picker-item ${localeMonth === index ? 'calendar-month-picker-item-current' : ''}">
            <span>${m}</span>
          </div>
        `).join('')}
      </div>
    `;
  }

  renderYearSelector() {
    const calendar = this;
    if (calendar.params.renderYearSelector) {
      return calendar.params.renderYearSelector.call(calendar);
    }
    return `
    <div class="calendar-year-selector">
      <a class="link icon-only calendar-prev-year-button">
        <i class="icon icon-prev"></i>
      </a>
      ${calendar.params.yearPicker ? `
        <a class="current-year-value link"></a>
      ` : `
        <span class="current-year-value"></span>
      `}
      <a class="link icon-only calendar-next-year-button">
        <i class="icon icon-next"></i>
      </a>
    </div>
  `.trim();
  }

  renderYearPicker() {
    const calendar = this;
    const currentYear = calendar.currentYear;
    let yearMin = calendar.params.yearPickerMin || new Date().getFullYear() - 100;
    if (calendar.params.minDate) {
      yearMin = Math.max(yearMin, new Date(calendar.params.minDate).getFullYear());
    }
    let yearMax = calendar.params.yearPickerMax || new Date().getFullYear() + 100;
    if (calendar.params.maxDate) {
      yearMax = Math.min(yearMax, new Date(calendar.params.maxDate).getFullYear());
    }
    const years = [];
    for (let i = yearMin; i <= yearMax; i += 1) {
      years.push(i);
    }
    return `
      <div class="calendar-year-picker">
        ${years.map(year => `
          <div data-year="${year}" class="calendar-year-picker-item ${year === currentYear ? 'calendar-year-picker-item-current' : ''}">
            <span>${calendar.yearFormatter.format(new Date().setFullYear(year))}</span>
          </div>
        `).join('')}
      </div>
    `;
  }

  // eslint-disable-next-line
  renderTimeSelector() {
    const calendar = this;
    const value = calendar.value && calendar.value[0];
    let timeString;
    if (value) timeString = calendar.timeSelectorFormatter.format(value);
    return `
      <div class="calendar-time-selector"><a class="link">${timeString || calendar.params.timePickerPlaceholder}</a></div>
    `;
  }

  renderHeader() {
    const calendar = this;
    if (calendar.params.renderHeader) {
      return calendar.params.renderHeader.call(calendar);
    }
    return `
    <div class="calendar-header">
      <div class="calendar-selected-date">${calendar.params.headerPlaceholder}</div>
    </div>
  `.trim();
  }

  renderFooter() {
    const calendar = this;
    const app = calendar.app;
    if (calendar.params.renderFooter) {
      return calendar.params.renderFooter.call(calendar);
    }
    return `
    <div class="calendar-footer">
      <a class="${app.theme === 'md' ? 'button' : 'link'} calendar-close sheet-close popover-close">${calendar.params.toolbarCloseText}</a>
    </div>
  `.trim();
  }

  renderToolbar() {
    const calendar = this;
    if (calendar.params.renderToolbar) {
      return calendar.params.renderToolbar.call(calendar, calendar);
    }
    return `
    <div class="toolbar toolbar-top no-shadow">
      <div class="toolbar-inner">
        ${calendar.params.monthSelector ? calendar.renderMonthSelector() : ''}
        ${calendar.params.yearSelector ? calendar.renderYearSelector() : ''}
      </div>
    </div>
  `.trim();
  }
  // eslint-disable-next-line
  renderInline() {
    const calendar = this;
    const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
    const { value, hasTimePicker } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    const inlineHtml = `
    <div class="calendar calendar-inline ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
      ${header ? calendar.renderHeader() : ''}
      ${toolbar ? calendar.renderToolbar() : ''}
      ${weekHeader ? calendar.renderWeekHeader() : ''}
      <div class="calendar-months">
        ${calendar.renderMonths(date)}
      </div>
      ${hasTimePicker ? calendar.renderTimeSelector() : ''}
      ${footer ? calendar.renderFooter() : ''}
    </div>
  `.trim();

    return inlineHtml;
  }

  renderCustomModal() {
    const calendar = this;
    const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
    const { value, hasTimePicker } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    const sheetHtml = `
    <div class="calendar calendar-modal ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
      ${header ? calendar.renderHeader() : ''}
      ${toolbar ? calendar.renderToolbar() : ''}
      ${weekHeader ? calendar.renderWeekHeader() : ''}
      <div class="calendar-months">
        ${calendar.renderMonths(date)}
      </div>
      ${hasTimePicker ? calendar.renderTimeSelector() : ''}
      ${footer ? calendar.renderFooter() : ''}
    </div>
  `.trim();

    return sheetHtml;
  }

  renderSheet() {
    const calendar = this;
    const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
    const { value, hasTimePicker } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    const sheetHtml = `
    <div class="sheet-modal calendar calendar-sheet ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
      ${header ? calendar.renderHeader() : ''}
      ${toolbar ? calendar.renderToolbar() : ''}
      ${weekHeader ? calendar.renderWeekHeader() : ''}
      <div class="sheet-modal-inner calendar-months">
        ${calendar.renderMonths(date)}
      </div>
      ${hasTimePicker ? calendar.renderTimeSelector() : ''}
      ${footer ? calendar.renderFooter() : ''}
    </div>
  `.trim();

    return sheetHtml;
  }

  renderPopover() {
    const calendar = this;
    const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
    const { value, hasTimePicker } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    const popoverHtml = `
    <div class="popover calendar-popover">
      <div class="popover-inner">
        <div class="calendar ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
        ${header ? calendar.renderHeader() : ''}
        ${toolbar ? calendar.renderToolbar() : ''}
        ${weekHeader ? calendar.renderWeekHeader() : ''}
        <div class="calendar-months">
          ${calendar.renderMonths(date)}
        </div>
        ${hasTimePicker ? calendar.renderTimeSelector() : ''}
        ${footer ? calendar.renderFooter() : ''}
        </div>
      </div>
    </div>
  `.trim();

    return popoverHtml;
  }

  render() {
    const calendar = this;
    const { params } = calendar;
    if (params.render) return params.render.call(calendar);
    if (!calendar.inline) {
      let modalType = params.openIn;
      if (modalType === 'auto') modalType = calendar.isPopover() ? 'popover' : 'sheet';

      if (modalType === 'popover') return calendar.renderPopover();
      if (modalType === 'sheet') return calendar.renderSheet();
      return calendar.renderCustomModal();
    }
    return calendar.renderInline();
  }

  openTimePicker() {
    const calendar = this;
    const { $el, app } = calendar;
    if (!$el || !$el.length) return;
    $el.append('<div class="calendar-time-picker"></div>');
    const hoursArr = [];
    const minutesArr = [];
    for (let i = 0; i <= 23; i += 1) { hoursArr.push(i); }
    for (let i = 0; i <= 59; i += 1) { minutesArr.push(i); }
    let value;
    if (calendar.value && calendar.value.length) {
      value = [calendar.value[0].getHours(), calendar.value[0].getMinutes()];
    } else {
      value = [new Date().getHours(), new Date().getMinutes()];
    }
    calendar.timePickerInstance = app.picker.create({
      containerEl: $el.find('.calendar-time-picker'),
      value,
      toolbar: true,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [
        {
          values: hoursArr,
        },
        {
          divider: true,
          content: ':',
        },
        {
          values: minutesArr,
          displayValues: minutesArr.map(m => (m < 10 ? `0${m}` : m)),
        },
      ],
    });
    calendar.timePickerInstance.$el.find('.toolbar a').removeClass('sheet-close popover-close').addClass('calendar-time-picker-close');
  }

  closeTimePicker() {
    const calendar = this;
    if (calendar.timePickerInstance) {
      const [hours, minutes] = calendar.timePickerInstance.value.map(v => parseInt(v, 10));
      let value = calendar.value && calendar.value.length && calendar.value[0];
      if (!value) {
        value = new Date();
        value.setHours(hours, minutes, 0, 0);
      } else {
        value = new Date(value);
        value.setHours(hours, minutes);
      }
      calendar.setValue([value]);
      calendar.timePickerInstance.close();
      calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }
    if (calendar.$el && calendar.$el.length) {
      calendar.$el.find('.calendar-time-picker').remove();
    }
  }

  onOpen() {
    const calendar = this;
    const { initialized, $el, app, $inputEl, inline, value, params } = calendar;
    calendar.closing = false;
    calendar.opened = true;
    calendar.opening = true;

    // Init main events
    calendar.attachCalendarEvents();

    const updateValue = !value && params.value;

    // Set value
    if (!initialized) {
      if (value) calendar.setValue(value, 0);
      else if (params.value) {
        calendar.setValue(calendar.normalizeValues(params.value), 0);
      }
    } else if (value) {
      calendar.setValue(value, 0);
    }

    // Update current month and year
    calendar.updateCurrentMonthYear();

    // Set initial translate
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();

    // Update input value
    if (updateValue) calendar.updateValue();
    else if (params.header && value) {
      calendar.updateValue(true);
    }

    // Extra focus
    if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
      $inputEl.trigger('focus');
    }

    calendar.initialized = true;

    calendar.$months.each((index, monthEl) => {
      calendar.emit('local::monthAdd calendarMonthAdd', monthEl);
    });

    // Trigger events
    if ($el) {
      $el.trigger('calendar:open');
    }
    if ($inputEl) {
      $inputEl.trigger('calendar:open');
    }
    calendar.emit('local::open calendarOpen', calendar);
  }

  onOpened() {
    const calendar = this;
    calendar.opening = false;
    if (calendar.$el) {
      calendar.$el.trigger('calendar:opened');
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger('calendar:opened');
    }
    calendar.emit('local::opened calendarOpened', calendar);
  }

  onClose() {
    const calendar = this;
    const app = calendar.app;
    calendar.opening = false;
    calendar.closing = true;

    if (calendar.$inputEl) {
      if (app.theme === 'md') {
        calendar.$inputEl.trigger('blur');
      } else {
        const validate = calendar.$inputEl.attr('validate');
        const required = calendar.$inputEl.attr('required');
        if (validate && required) {
          app.input.validate(calendar.$inputEl);
        }
      }
    }
    if (calendar.detachCalendarEvents) {
      calendar.detachCalendarEvents();
    }

    if (calendar.$el) {
      calendar.$el.trigger('calendar:close');
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger('calendar:close');
    }
    calendar.emit('local::close calendarClose', calendar);
  }

  onClosed() {
    const calendar = this;
    calendar.opened = false;
    calendar.closing = false;

    if (!calendar.inline) {
      Utils.nextTick(() => {
        if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
          if (!calendar.params.routableModals) {
            calendar.modal.destroy();
          }
        }
        delete calendar.modal;
      });
    }
    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }
    if (calendar.$el) {
      calendar.$el.trigger('calendar:closed');
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger('calendar:closed');
    }
    calendar.emit('local::closed calendarClosed', calendar);
  }

  open() {
    const calendar = this;
    const { app, opened, inline, $inputEl, params } = calendar;
    if (opened) return;

    if (inline) {
      calendar.$el = $(calendar.render());
      calendar.$el[0].f7Calendar = calendar;
      calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
      calendar.$months = calendar.$wrapperEl.find('.calendar-month');
      calendar.$containerEl.append(calendar.$el);
      calendar.onOpen();
      calendar.onOpened();
      return;
    }
    let modalType = params.openIn;
    if (modalType === 'auto') {
      modalType = calendar.isPopover() ? 'popover' : 'sheet';
    }
    const modalContent = calendar.render();

    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: params.scrollToInput ? $inputEl : undefined,
      content: modalContent,
      backdrop: params.backdrop === true || (modalType === 'popover' && app.params.popover.backdrop !== false && params.backdrop !== false),
      closeByBackdropClick: params.closeByBackdropClick,
      on: {
        open() {
          const modal = this;
          calendar.modal = modal;
          calendar.$el = modalType === 'popover' ? modal.$el.find('.calendar') : modal.$el;
          calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
          calendar.$months = calendar.$wrapperEl.find('.calendar-month');
          calendar.$el[0].f7Calendar = calendar;
          if (modalType === 'customModal') {
            $(calendar.$el).find('.calendar-close').once('click', () => {
              calendar.close();
            });
          }
          calendar.onOpen();
        },
        opened() { calendar.onOpened(); },
        close() { calendar.onClose(); },
        closed() { calendar.onClosed(); },
      },
    };
    if (modalType === 'sheet') {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }
    if (params.routableModals && calendar.view) {
      calendar.view.router.navigate({
        url: calendar.url,
        route: {
          path: calendar.url,
          [modalType]: modalParams,
        },
      });
    } else {
      calendar.modal = app[modalType].create(modalParams);
      calendar.modal.open();
    }
  }

  close() {
    const calendar = this;
    const { opened, inline } = calendar;
    if (!opened) return;
    if (inline) {
      calendar.onClose();
      calendar.onClosed();
      return;
    }
    if (calendar.params.routableModals && calendar.view) {
      calendar.view.router.back();
    } else {
      calendar.modal.close();
    }
  }

  init() {
    const calendar = this;

    calendar.initInput();

    if (calendar.inline) {
      calendar.open();
      calendar.emit('local::init calendarInit', calendar);
      return;
    }

    if (!calendar.initialized && calendar.params.value) {
      calendar.setValue(calendar.normalizeValues(calendar.params.value));
    }

    // Attach input Events
    if (calendar.$inputEl) {
      calendar.attachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.attachHtmlEvents();
    }
    calendar.emit('local::init calendarInit', calendar);
  }

  destroy() {
    const calendar = this;
    if (calendar.destroyed) return;
    const { $el } = calendar;
    calendar.emit('local::beforeDestroy calendarBeforeDestroy', calendar);
    if ($el) $el.trigger('calendar:beforedestroy');

    calendar.close();

    // Detach Events
    if (calendar.$inputEl) {
      calendar.detachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.detachHtmlEvents();
    }

    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }

    if ($el && $el.length) delete calendar.$el[0].f7Calendar;
    Utils.deleteProps(calendar);
    calendar.destroyed = true;
  }
}

var Calendar$1 = {
  name: 'calendar',
  static: {
    Calendar,
  },
  create() {
    const app = this;
    app.calendar = ConstructorMethods({
      defaultSelector: '.calendar',
      constructor: Calendar,
      app,
      domProp: 'f7Calendar',
    });
    app.calendar.close = function close(el = '.calendar') {
      const $el = $(el);
      if ($el.length === 0) return;
      const calendar = $el[0].f7Calendar;
      if (!calendar || (calendar && !calendar.opened)) return;
      calendar.close();
    };
  },
  params: {
    calendar: {
      // Calendar settings
      dateFormat: undefined,
      monthNames: 'auto',
      monthNamesShort: 'auto',
      dayNames: 'auto',
      dayNamesShort: 'auto',
      locale: undefined,
      firstDay: 1, // First day of the week, Monday
      weekendDays: [0, 6], // Sunday and Saturday
      multiple: false,
      rangePicker: false,
      rangePickerMinDays: 1, // when calendar is used as rangePicker
      rangePickerMaxDays: 0, // when calendar is used as rangePicker, 0 means unlimited
      direction: 'horizontal', // or 'vertical'
      minDate: null,
      maxDate: null,
      disabled: null, // dates range of disabled days
      events: null, // dates range of days with events
      rangesClasses: null, // array with custom classes date ranges
      touchMove: true,
      animate: true,
      closeOnSelect: false,
      monthSelector: true,
      monthPicker: true,
      yearSelector: true,
      yearPicker: true,
      yearPickerMin: undefined,
      yearPickerMax: undefined,
      timePicker: false,
      timePickerFormat: { hour: 'numeric', minute: 'numeric' },
      timePickerPlaceholder: 'Select time',
      weekHeader: true,
      value: null,
      // Common opener settings
      containerEl: null,
      openIn: 'auto', // or 'popover' or 'sheet' or 'customModal'
      sheetPush: false,
      sheetSwipeToClose: undefined,
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      header: false,
      headerPlaceholder: 'Select date',
      toolbar: true,
      toolbarCloseText: 'Done',
      footer: false,
      cssClass: null,
      routableModals: true,
      view: null,
      url: 'date/',
      backdrop: null,
      closeByBackdropClick: true,
      // Render functions
      renderWeekHeader: null,
      renderMonths: null,
      renderMonth: null,
      renderMonthSelector: null,
      renderYearSelector: null,
      renderHeader: null,
      renderFooter: null,
      renderToolbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      render: null,
    },
  },
};

function pickerColumn (colEl, updateItems) {
  const picker = this;
  const app = picker.app;
  const $colEl = $(colEl);
  const colIndex = $colEl.index();
  const col = picker.cols[colIndex];
  if (col.divider) return;

  col.$el = $colEl;
  col.el = $colEl[0];
  col.$itemsEl = col.$el.find('.picker-items');
  col.items = col.$itemsEl.find('.picker-item');

  let itemHeight;
  let itemsHeight;
  let minTranslate;
  let maxTranslate;
  let animationFrameId;

  function updateDuringScroll() {
    animationFrameId = Utils.requestAnimationFrame(() => {
      col.updateItems(undefined, undefined, 0);
      updateDuringScroll();
    });
  }

  col.replaceValues = function replaceColValues(values, displayValues) {
    col.detachEvents();
    col.values = values;
    col.displayValues = displayValues;
    col.$itemsEl.html(picker.renderColumn(col, true));
    col.items = col.$itemsEl.find('.picker-item');
    col.calcSize();
    col.setValue(col.values[0], 0, true);
    col.attachEvents();
  };
  col.calcSize = function calcColSize() {
    if (picker.params.rotateEffect) {
      col.$el.removeClass('picker-column-absolute');
      if (!col.width) col.$el.css({ width: '' });
    }
    let colWidth = 0;
    const colHeight = col.$el[0].offsetHeight;
    itemHeight = col.items[0].offsetHeight;
    itemsHeight = itemHeight * col.items.length;
    minTranslate = ((colHeight / 2) - itemsHeight) + (itemHeight / 2);
    maxTranslate = (colHeight / 2) - (itemHeight / 2);
    if (col.width) {
      colWidth = col.width;
      if (parseInt(colWidth, 10) === colWidth) colWidth += 'px';
      col.$el.css({ width: colWidth });
    }
    if (picker.params.rotateEffect) {
      if (!col.width) {
        col.items.each((index, itemEl) => {
          const item = $(itemEl).children('span');
          colWidth = Math.max(colWidth, item[0].offsetWidth);
        });
        col.$el.css({ width: `${colWidth + 2}px` });
      }
      col.$el.addClass('picker-column-absolute');
    }
  };

  col.setValue = function setColValue(newValue, transition = '', valueCallbacks) {
    const newActiveIndex = col.$itemsEl.find(`.picker-item[data-picker-value="${newValue}"]`).index();
    if (typeof newActiveIndex === 'undefined' || newActiveIndex === -1) {
      return;
    }
    const newTranslate = (-newActiveIndex * itemHeight) + maxTranslate;
    // Update wrapper
    col.$itemsEl.transition(transition);
    col.$itemsEl.transform(`translate3d(0,${newTranslate}px,0)`);

    // Watch items
    if (picker.params.updateValuesOnMomentum && col.activeIndex && col.activeIndex !== newActiveIndex) {
      Utils.cancelAnimationFrame(animationFrameId);
      col.$itemsEl.transitionEnd(() => {
        Utils.cancelAnimationFrame(animationFrameId);
      });
      updateDuringScroll();
    }

    // Update items
    col.updateItems(newActiveIndex, newTranslate, transition, valueCallbacks);
  };

  col.updateItems = function updateColItems(activeIndex, translate, transition, valueCallbacks) {
    if (typeof translate === 'undefined') {
      // eslint-disable-next-line
      translate = Utils.getTranslate(col.$itemsEl[0], 'y');
    }
    // eslint-disable-next-line
    if (typeof activeIndex === 'undefined') activeIndex = -Math.round((translate - maxTranslate) / itemHeight);
    // eslint-disable-next-line
    if (activeIndex < 0) activeIndex = 0;
    // eslint-disable-next-line
    if (activeIndex >= col.items.length) activeIndex = col.items.length - 1;
    const previousActiveIndex = col.activeIndex;
    col.activeIndex = activeIndex;
    col.$itemsEl.find('.picker-item-selected').removeClass('picker-item-selected');

    col.items.transition(transition);

    const selectedItem = col.items.eq(activeIndex).addClass('picker-item-selected').transform('');

    // Set 3D rotate effect
    if (picker.params.rotateEffect) {
      col.items.each((index, itemEl) => {
        const $itemEl = $(itemEl);
        const itemOffsetTop = $itemEl.index() * itemHeight;
        const translateOffset = maxTranslate - translate;
        const itemOffset = itemOffsetTop - translateOffset;
        const percentage = itemOffset / itemHeight;
        const itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;

        let angle = (-18 * percentage);
        if (angle > 180) angle = 180;
        if (angle < -180) angle = -180;
        if (Math.abs(percentage) > itemsFit) {
          $itemEl.addClass('picker-item-far');
        } else {
          $itemEl.removeClass('picker-item-far');
        }
        $itemEl.transform(`translate3d(0, ${-translate + maxTranslate}px, ${picker.needsOriginFix ? -110 : 0}px) rotateX(${angle}deg)`);
      });
    }

    if (valueCallbacks || typeof valueCallbacks === 'undefined') {
      // Update values
      col.value = selectedItem.attr('data-picker-value');
      col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value;
      // On change callback
      if (previousActiveIndex !== activeIndex) {
        if (col.onChange) {
          col.onChange(picker, col.value, col.displayValue);
        }
        picker.updateValue();
      }
    }
  };

  let allowItemClick = true;
  let isTouched;
  let isMoved;
  let touchStartY;
  let touchCurrentY;
  let touchStartTime;
  let touchEndTime;
  let startTranslate;
  let returnTo;
  let currentTranslate;
  let prevTranslate;
  let velocityTranslate;
  function handleTouchStart(e) {
    if (isMoved || isTouched) return;
    e.preventDefault();
    isTouched = true;
    touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    touchCurrentY = touchStartY;
    touchStartTime = (new Date()).getTime();

    allowItemClick = true;
    startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
    currentTranslate = startTranslate;
  }
  function handleTouchMove(e) {
    if (!isTouched) return;
    e.preventDefault();
    allowItemClick = false;
    touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    if (!isMoved) {
      // First move
      Utils.cancelAnimationFrame(animationFrameId);
      isMoved = true;
      startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
      currentTranslate = startTranslate;
      col.$itemsEl.transition(0);
    }

    const diff = touchCurrentY - touchStartY;
    currentTranslate = startTranslate + diff;
    returnTo = undefined;

    // Normalize translate
    if (currentTranslate < minTranslate) {
      currentTranslate = minTranslate - ((minTranslate - currentTranslate) ** 0.8);
      returnTo = 'min';
    }
    if (currentTranslate > maxTranslate) {
      currentTranslate = maxTranslate + ((currentTranslate - maxTranslate) ** 0.8);
      returnTo = 'max';
    }
    // Transform wrapper
    col.$itemsEl.transform(`translate3d(0,${currentTranslate}px,0)`);

    // Update items
    col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnTouchmove);

    // Calc velocity
    velocityTranslate = currentTranslate - prevTranslate || currentTranslate;
    prevTranslate = currentTranslate;
  }
  function handleTouchEnd() {
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    col.$itemsEl.transition('');
    if (returnTo) {
      if (returnTo === 'min') {
        col.$itemsEl.transform(`translate3d(0,${minTranslate}px,0)`);
      } else {
        col.$itemsEl.transform(`translate3d(0,${maxTranslate}px,0)`);
      }
    }
    touchEndTime = new Date().getTime();
    let newTranslate;
    if (touchEndTime - touchStartTime > 300) {
      newTranslate = currentTranslate;
    } else {
      newTranslate = currentTranslate + (velocityTranslate * picker.params.momentumRatio);
    }

    newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate);

    // Active Index
    const activeIndex = Math.round(Math.abs(((newTranslate - maxTranslate) / itemHeight)));

    // Normalize translate
    if (!picker.params.freeMode) newTranslate = (-activeIndex * itemHeight) + maxTranslate;

    // Transform wrapper
    col.$itemsEl.transform(`translate3d(0,${parseInt(newTranslate, 10)}px,0)`);

    // Update items
    col.updateItems(activeIndex, newTranslate, '', true);

    // Watch items
    if (picker.params.updateValuesOnMomentum) {
      updateDuringScroll();
      col.$itemsEl.transitionEnd(() => {
        Utils.cancelAnimationFrame(animationFrameId);
      });
    }

    // Allow click
    setTimeout(() => {
      allowItemClick = true;
    }, 100);
  }

  let mousewheelTimeout;
  function handleMouseWheel(e) {
    const { deltaX, deltaY } = e;
    if (Math.abs(deltaX) > Math.abs(deltaY)) return;
    clearTimeout(mousewheelTimeout);

    e.preventDefault();

    Utils.cancelAnimationFrame(animationFrameId);
    startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
    col.$itemsEl.transition(0);

    currentTranslate = startTranslate - deltaY;
    returnTo = undefined;

    // Normalize translate
    if (currentTranslate < minTranslate) {
      currentTranslate = minTranslate;
      returnTo = 'min';
    }
    if (currentTranslate > maxTranslate) {
      currentTranslate = maxTranslate;
      returnTo = 'max';
    }
    // Transform wrapper
    col.$itemsEl.transform(`translate3d(0,${currentTranslate}px,0)`);

    // Update items
    col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnMousewheel);

    // On end
    mousewheelTimeout = setTimeout(() => {
      col.$itemsEl.transition('');
      if (returnTo) {
        if (returnTo === 'min') {
          col.$itemsEl.transform(`translate3d(0,${minTranslate}px,0)`);
        } else {
          col.$itemsEl.transform(`translate3d(0,${maxTranslate}px,0)`);
        }
      }
      touchEndTime = new Date().getTime();
      let newTranslate = currentTranslate;
      newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate);

      // Active Index
      const activeIndex = Math.round(Math.abs(((newTranslate - maxTranslate) / itemHeight)));

      // Normalize translate
      if (!picker.params.freeMode) newTranslate = (-activeIndex * itemHeight) + maxTranslate;

      // Transform wrapper
      col.$itemsEl.transform(`translate3d(0,${parseInt(newTranslate, 10)}px,0)`);

      // Update items
      col.updateItems(activeIndex, newTranslate, '', true);
    }, 200);
  }

  function handleClick() {
    if (!allowItemClick) return;
    Utils.cancelAnimationFrame(animationFrameId);
    const value = $(this).attr('data-picker-value');
    col.setValue(value);
  }

  const activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;
  col.attachEvents = function attachColEvents() {
    col.$el.on(app.touchEvents.start, handleTouchStart, activeListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    if (picker.params.mousewheel) {
      col.$el.on('wheel', handleMouseWheel);
    }
    col.items.on('click', handleClick);
  };
  col.detachEvents = function detachColEvents() {
    col.$el.off(app.touchEvents.start, handleTouchStart, activeListener);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
    if (picker.params.mousewheel) {
      col.$el.off('wheel', handleMouseWheel);
    }
    col.items.off('click', handleClick);
  };

  col.init = function initCol() {
    col.calcSize();
    col.$itemsEl.transform(`translate3d(0,${maxTranslate}px,0)`).transition(0);
    if (colIndex === 0) col.$el.addClass('picker-column-first');
    if (colIndex === picker.cols.length - 1) col.$el.addClass('picker-column-last');
    // Update items on init
    if (updateItems) col.updateItems(0, maxTranslate, 0);

    col.attachEvents();
  };

  col.destroy = function destroyCol() {
    col.detachEvents();
  };

  col.init();
}

class Picker extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const picker = this;
    picker.params = Utils.extend({}, app.params.picker, params);

    let $containerEl;
    if (picker.params.containerEl) {
      $containerEl = $(picker.params.containerEl);
      if ($containerEl.length === 0) return picker;
    }

    let $inputEl;
    if (picker.params.inputEl) {
      $inputEl = $(picker.params.inputEl);
    }


    let $scrollToEl = picker.params.scrollToInput ? $inputEl : undefined;
    if (picker.params.scrollToEl) {
      const scrollToEl = $(picker.params.scrollToEl);
      if (scrollToEl.length > 0) {
        $scrollToEl = scrollToEl;
      }
    }

    Utils.extend(picker, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      needsOriginFix: app.device.ios || ((win.navigator.userAgent.toLowerCase().indexOf('safari') >= 0 && win.navigator.userAgent.toLowerCase().indexOf('chrome') < 0) && !app.device.android),
      cols: [],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      $scrollToEl,
      initialized: false,
      opened: false,
      url: picker.params.url,
    });

    function onResize() {
      picker.resizeCols();
    }
    function onInputClick() {
      picker.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onHtmlClick(e) {
      if (picker.destroyed || !picker.params) return;
      const $targetEl = $(e.target);
      if (picker.isPopover()) return;
      if (!picker.opened || picker.closing) return;
      if ($targetEl.closest('[class*="backdrop"]').length) return;
      if ($inputEl && $inputEl.length > 0) {
        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal').length === 0) {
          picker.close();
        }
      } else if ($(e.target).closest('.sheet-modal').length === 0) {
        picker.close();
      }
    }

    // Events
    Utils.extend(picker, {
      attachResizeEvent() {
        app.on('resize', onResize);
      },
      detachResizeEvent() {
        app.off('resize', onResize);
      },
      attachInputEvents() {
        picker.$inputEl.on('click', onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.on('focus mousedown', onInputFocus);
          if (picker.$inputEl[0]) {
            picker.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        picker.$inputEl.off('click', onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.off('focus mousedown', onInputFocus);
          if (picker.$inputEl[0]) {
            delete picker.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachHtmlEvents() {
        app.on('click', onHtmlClick);
      },
      detachHtmlEvents() {
        app.off('click', onHtmlClick);
      },
    });

    picker.init();

    return picker;
  }

  get view() {
    const { app, params, $inputEl } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
    }
    if (!view) view = app.views.main;
    return view;
  }

  initInput() {
    const picker = this;
    if (!picker.$inputEl) return;
    if (picker.params.inputReadOnly) picker.$inputEl.prop('readOnly', true);
  }

  resizeCols() {
    const picker = this;
    if (!picker.opened) return;
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (!picker.cols[i].divider) {
        picker.cols[i].calcSize();
        picker.cols[i].setValue(picker.cols[i].value, 0, false);
      }
    }
  }

  isPopover() {
    const picker = this;
    const { app, modal, params } = picker;
    if (params.openIn === 'sheet') return false;
    if (modal && modal.type !== 'popover') return false;

    if (!picker.inline && picker.inputEl) {
      if (params.openIn === 'popover') return true;
      if (app.device.ios) {
        return !!app.device.ipad;
      }
      if (app.width >= 768) {
        return true;
      }
      if (app.device.desktop && app.theme === 'aurora') {
        return true;
      }
    }
    return false;
  }

  formatValue() {
    const picker = this;
    const { value, displayValue } = picker;
    if (picker.params.formatValue) {
      return picker.params.formatValue.call(picker, value, displayValue);
    }
    return value.join(' ');
  }

  setValue(values, transition) {
    const picker = this;
    let valueIndex = 0;
    if (picker.cols.length === 0) {
      picker.value = values;
      picker.updateValue(values);
      return;
    }
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (picker.cols[i] && !picker.cols[i].divider) {
        picker.cols[i].setValue(values[valueIndex], transition);
        valueIndex += 1;
      }
    }
  }

  getValue() {
    const picker = this;
    return picker.value;
  }

  updateValue(forceValues) {
    const picker = this;
    const newValue = forceValues || [];
    const newDisplayValue = [];
    let column;
    if (picker.cols.length === 0) {
      const noDividerColumns = picker.params.cols.filter(c => !c.divider);
      for (let i = 0; i < noDividerColumns.length; i += 1) {
        column = noDividerColumns[i];
        if (column.displayValues !== undefined && column.values !== undefined && column.values.indexOf(newValue[i]) !== -1) {
          newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
        } else {
          newDisplayValue.push(newValue[i]);
        }
      }
    } else {
      for (let i = 0; i < picker.cols.length; i += 1) {
        if (!picker.cols[i].divider) {
          newValue.push(picker.cols[i].value);
          newDisplayValue.push(picker.cols[i].displayValue);
        }
      }
    }

    if (newValue.indexOf(undefined) >= 0) {
      return;
    }
    picker.value = newValue;
    picker.displayValue = newDisplayValue;
    picker.emit('local::change pickerChange', picker, picker.value, picker.displayValue);
    if (picker.inputEl) {
      picker.$inputEl.val(picker.formatValue());
      picker.$inputEl.trigger('change');
    }
  }

  initColumn(colEl, updateItems) {
    const picker = this;
    pickerColumn.call(picker, colEl, updateItems);
  }
  // eslint-disable-next-line
  destroyColumn(colEl) {
    const picker = this;
    const $colEl = $(colEl);
    const index = $colEl.index();
    if (picker.cols[index] && picker.cols[index].destroy) {
      picker.cols[index].destroy();
    }
  }

  renderToolbar() {
    const picker = this;
    if (picker.params.renderToolbar) return picker.params.renderToolbar.call(picker, picker);
    return `
      <div class="toolbar toolbar-top no-shadow">
        <div class="toolbar-inner">
          <div class="left"></div>
          <div class="right">
            <a class="link sheet-close popover-close">${picker.params.toolbarCloseText}</a>
          </div>
        </div>
      </div>
    `.trim();
  }
  // eslint-disable-next-line
  renderColumn(col, onlyItems) {
    const colClasses = `picker-column ${col.textAlign ? `picker-column-${col.textAlign}` : ''} ${col.cssClass || ''}`;
    let columnHtml;
    let columnItemsHtml;

    if (col.divider) {
      columnHtml = `
        <div class="${colClasses} picker-column-divider">${col.content}</div>
      `;
    } else {
      columnItemsHtml = col.values.map((value, index) => `
        <div class="picker-item" data-picker-value="${value}">
          <span>${col.displayValues ? col.displayValues[index] : value}</span>
        </div>
      `).join('');
      columnHtml = `
        <div class="${colClasses}">
          <div class="picker-items">${columnItemsHtml}</div>
        </div>
      `;
    }

    return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
  }

  renderInline() {
    const picker = this;
    const { rotateEffect, cssClass, toolbar } = picker.params;
    const inlineHtml = `
      <div class="picker picker-inline ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}">
        ${toolbar ? picker.renderToolbar() : ''}
        <div class="picker-columns">
          ${picker.cols.map(col => picker.renderColumn(col)).join('')}
          <div class="picker-center-highlight"></div>
        </div>
      </div>
    `.trim();

    return inlineHtml;
  }

  renderSheet() {
    const picker = this;
    const { rotateEffect, cssClass, toolbar } = picker.params;
    const sheetHtml = `
      <div class="sheet-modal picker picker-sheet ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}">
        ${toolbar ? picker.renderToolbar() : ''}
        <div class="sheet-modal-inner picker-columns">
          ${picker.cols.map(col => picker.renderColumn(col)).join('')}
          <div class="picker-center-highlight"></div>
        </div>
      </div>
    `.trim();

    return sheetHtml;
  }

  renderPopover() {
    const picker = this;
    const { rotateEffect, cssClass, toolbar } = picker.params;
    const popoverHtml = `
      <div class="popover picker-popover">
        <div class="popover-inner">
          <div class="picker ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}">
            ${toolbar ? picker.renderToolbar() : ''}
            <div class="picker-columns">
              ${picker.cols.map(col => picker.renderColumn(col)).join('')}
              <div class="picker-center-highlight"></div>
            </div>
          </div>
        </div>
      </div>
    `.trim();

    return popoverHtml;
  }

  render() {
    const picker = this;
    if (picker.params.render) return picker.params.render.call(picker);
    if (!picker.inline) {
      if (picker.isPopover()) return picker.renderPopover();
      return picker.renderSheet();
    }
    return picker.renderInline();
  }

  onOpen() {
    const picker = this;
    const { initialized, $el, app, $inputEl, inline, value, params } = picker;
    picker.opened = true;
    picker.closing = false;
    picker.opening = true;

    // Init main events
    picker.attachResizeEvent();

    // Init cols
    $el.find('.picker-column').each((index, colEl) => {
      let updateItems = true;
      if (
        (!initialized && params.value)
        || (initialized && value)
      ) {
        updateItems = false;
      }
      picker.initColumn(colEl, updateItems);
    });

    // Set value
    if (!initialized) {
      if (value) picker.setValue(value, 0);
      else if (params.value) {
        picker.setValue(params.value, 0);
      }
    } else if (value) {
      picker.setValue(value, 0);
    }

    // Extra focus
    if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
      $inputEl.trigger('focus');
    }

    picker.initialized = true;

    // Trigger events
    if ($el) {
      $el.trigger('picker:open');
    }
    if ($inputEl) {
      $inputEl.trigger('picker:open');
    }
    picker.emit('local::open pickerOpen', picker);
  }

  onOpened() {
    const picker = this;
    picker.opening = false;

    if (picker.$el) {
      picker.$el.trigger('picker:opened');
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger('picker:opened');
    }
    picker.emit('local::opened pickerOpened', picker);
  }

  onClose() {
    const picker = this;
    const app = picker.app;
    picker.opening = false;
    picker.closing = true;

    // Detach events
    picker.detachResizeEvent();

    picker.cols.forEach((col) => {
      if (col.destroy) col.destroy();
    });

    if (picker.$inputEl) {
      if (app.theme === 'md') {
        picker.$inputEl.trigger('blur');
      } else {
        const validate = picker.$inputEl.attr('validate');
        const required = picker.$inputEl.attr('required');
        if (validate && required) {
          app.input.validate(picker.$inputEl);
        }
      }
    }

    if (picker.$el) {
      picker.$el.trigger('picker:close');
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger('picker:close');
    }
    picker.emit('local::close pickerClose', picker);
  }

  onClosed() {
    const picker = this;
    picker.opened = false;
    picker.closing = false;

    if (!picker.inline) {
      Utils.nextTick(() => {
        if (picker.modal && picker.modal.el && picker.modal.destroy) {
          if (!picker.params.routableModals) {
            picker.modal.destroy();
          }
        }
        delete picker.modal;
      });
    }

    if (picker.$el) {
      picker.$el.trigger('picker:closed');
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger('picker:closed');
    }
    picker.emit('local::closed pickerClosed', picker);
  }

  open() {
    const picker = this;
    const { app, opened, inline, $inputEl, $scrollToEl, params } = picker;
    if (opened) return;
    if (picker.cols.length === 0 && params.cols.length) {
      params.cols.forEach((col) => {
        picker.cols.push(col);
      });
    }
    if (inline) {
      picker.$el = $(picker.render());
      picker.$el[0].f7Picker = picker;
      picker.$containerEl.append(picker.$el);
      picker.onOpen();
      picker.onOpened();
      return;
    }
    const isPopover = picker.isPopover();
    const modalType = isPopover ? 'popover' : 'sheet';
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: $scrollToEl,
      content: picker.render(),
      backdrop: typeof params.backdrop !== 'undefined' ? params.backdrop : isPopover,
      on: {
        open() {
          const modal = this;
          picker.modal = modal;
          picker.$el = isPopover ? modal.$el.find('.picker') : modal.$el;
          picker.$el[0].f7Picker = picker;
          picker.onOpen();
        },
        opened() { picker.onOpened(); },
        close() { picker.onClose(); },
        closed() { picker.onClosed(); },
      },
    };
    if (modalType === 'sheet') {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }
    if (params.routableModals && picker.view) {
      picker.view.router.navigate({
        url: picker.url,
        route: {
          path: picker.url,
          [modalType]: modalParams,
        },
      });
    } else {
      picker.modal = app[modalType].create(modalParams);
      picker.modal.open();
    }
  }

  close() {
    const picker = this;
    const { opened, inline } = picker;
    if (!opened) return;
    if (inline) {
      picker.onClose();
      picker.onClosed();
      return;
    }
    if (picker.params.routableModals && picker.view) {
      picker.view.router.back();
    } else {
      picker.modal.close();
    }
  }

  init() {
    const picker = this;

    picker.initInput();

    if (picker.inline) {
      picker.open();
      picker.emit('local::init pickerInit', picker);
      return;
    }

    if (!picker.initialized && picker.params.value) {
      picker.setValue(picker.params.value);
    }

    // Attach input Events
    if (picker.$inputEl) {
      picker.attachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.attachHtmlEvents();
    }
    picker.emit('local::init pickerInit', picker);
  }

  destroy() {
    const picker = this;
    if (picker.destroyed) return;
    const { $el } = picker;
    picker.emit('local::beforeDestroy pickerBeforeDestroy', picker);
    if ($el) $el.trigger('picker:beforedestroy');

    picker.close();

    // Detach Events
    if (picker.$inputEl) {
      picker.detachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.detachHtmlEvents();
    }

    if ($el && $el.length) delete picker.$el[0].f7Picker;
    Utils.deleteProps(picker);
    picker.destroyed = true;
  }
}

var Picker$1 = {
  name: 'picker',
  static: {
    Picker,
  },
  create() {
    const app = this;
    app.picker = ConstructorMethods({
      defaultSelector: '.picker',
      constructor: Picker,
      app,
      domProp: 'f7Picker',
    });
    app.picker.close = function close(el = '.picker') {
      const $el = $(el);
      if ($el.length === 0) return;
      const picker = $el[0].f7Picker;
      if (!picker || (picker && !picker.opened)) return;
      picker.close();
    };
  },
  params: {
    picker: {
      // Picker settings
      updateValuesOnMomentum: false,
      updateValuesOnTouchmove: true,
      updateValuesOnMousewheel: true,
      mousewheel: true,
      rotateEffect: false,
      momentumRatio: 7,
      freeMode: false,
      cols: [],
      // Common opener settings
      containerEl: null,
      openIn: 'auto', // or 'popover' or 'sheet'
      sheetPush: false,
      sheetSwipeToClose: undefined,
      backdrop: undefined, // uses Popover or Sheet defaults
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      scrollToEl: undefined,
      toolbar: true,
      toolbarCloseText: 'Done',
      cssClass: null,
      routableModals: true,
      view: null,
      url: 'select/',
      // Render functions
      renderToolbar: null,
      render: null,
    },
  },
};

const InfiniteScroll = {
  handleScroll(el, e) {
    const app = this;
    const $el = $(el);
    const scrollTop = $el[0].scrollTop;
    const scrollHeight = $el[0].scrollHeight;
    const height = $el[0].offsetHeight;
    let distance = $el[0].getAttribute('data-infinite-distance');

    const virtualListContainer = $el.find('.virtual-list');
    let virtualList;

    const onTop = $el.hasClass('infinite-scroll-top');
    if (!distance) distance = 50;
    if (typeof distance === 'string' && distance.indexOf('%') >= 0) {
      distance = (parseInt(distance, 10) / 100) * height;
    }
    if (distance > height) distance = height;
    if (onTop) {
      if (scrollTop < distance) {
        $el.trigger('infinite', e);
        app.emit('infinite', $el[0], e);
      }
    } else if (scrollTop + height >= scrollHeight - distance) {
      if (virtualListContainer.length > 0) {
        virtualList = virtualListContainer.eq(-1)[0].f7VirtualList;
        if (virtualList && !virtualList.reachEnd && !virtualList.params.updatableScroll) {
          return;
        }
      }
      $el.trigger('infinite', e);
      app.emit('infinite', $el[0], e);
    }
  },
  create(el) {
    const $el = $(el);
    const app = this;
    function scrollHandler(e) {
      app.infiniteScroll.handle(this, e);
    }
    $el.each((index, element) => {
      element.f7InfiniteScrollHandler = scrollHandler;
      element.addEventListener('scroll', element.f7InfiniteScrollHandler);
    });
  },
  destroy(el) {
    const $el = $(el);
    $el.each((index, element) => {
      element.removeEventListener('scroll', element.f7InfiniteScrollHandler);
      delete element.f7InfiniteScrollHandler;
    });
  },
};
var InfiniteScroll$1 = {
  name: 'infiniteScroll',
  create() {
    const app = this;
    Utils.extend(app, {
      infiniteScroll: {
        handle: InfiniteScroll.handleScroll.bind(app),
        create: InfiniteScroll.create.bind(app),
        destroy: InfiniteScroll.destroy.bind(app),
      },
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = $(tabEl);
      const $isEls = $tabEl.find('.infinite-scroll-content');
      if ($tabEl.is('.infinite-scroll-content')) $isEls.add($tabEl);
      $isEls.each((index, el) => {
        app.infiniteScroll.create(el);
      });
    },
    tabBeforeRemove(tabEl) {
      const $tabEl = $(tabEl);
      const app = this;
      const $isEls = $tabEl.find('.infinite-scroll-content');
      if ($tabEl.is('.infinite-scroll-content')) $isEls.add($tabEl);
      $isEls.each((index, el) => {
        app.infiniteScroll.destroy(el);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.infinite-scroll-content').each((index, el) => {
        app.infiniteScroll.create(el);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.infinite-scroll-content').each((index, el) => {
        app.infiniteScroll.destroy(el);
      });
    },
  },
};

class PullToRefresh extends Framework7Class {
  constructor(app, el) {
    super({}, [app]);
    const ptr = this;
    const $el = $(el);
    const $preloaderEl = $el.find('.ptr-preloader');

    ptr.$el = $el;
    ptr.el = $el[0];
    ptr.app = app;

    ptr.bottom = ptr.$el.hasClass('ptr-bottom');

    // Extend defaults with modules params
    ptr.useModulesParams({});

    const isMaterial = app.theme === 'md';
    const isIos = app.theme === 'ios';
    const isAurora = app.theme === 'aurora';

    // Done
    ptr.done = function done() {
      const $transitionTarget = isMaterial ? $preloaderEl : $el;
      $transitionTarget.transitionEnd(() => {
        $el.removeClass('ptr-transitioning ptr-pull-up ptr-pull-down ptr-closing');
        $el.trigger('ptr:done');
        ptr.emit('local::done ptrDone', $el[0]);
      });
      $el.removeClass('ptr-refreshing').addClass('ptr-transitioning ptr-closing');
      return ptr;
    };

    ptr.refresh = function refresh() {
      if ($el.hasClass('ptr-refreshing')) return ptr;
      $el.addClass('ptr-transitioning ptr-refreshing');
      $el.trigger('ptr:refresh', ptr.done);
      ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
      return ptr;
    };

    // Mousewheel
    ptr.mousewheel = $el.attr('data-ptr-mousewheel') === 'true';

    // Events handling
    let touchId;
    let isTouched;
    let isMoved;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let refresh = false;
    let useTranslate = false;
    let forceUseTranslate = false;
    let startTranslate = 0;
    let translate;
    let scrollTop;
    let wasScrolled;
    let triggerDistance;
    let dynamicTriggerDistance;
    let pullStarted;
    let hasNavbar = false;
    let scrollHeight;
    let offsetHeight;
    let maxScrollTop;
    const $pageEl = $el.parents('.page');

    if ($pageEl.find('.navbar').length > 0 || $pageEl.parents('.view').children('.navbars').length > 0) hasNavbar = true;
    if ($pageEl.hasClass('no-navbar')) hasNavbar = false;
    if (!ptr.bottom) {
      const pageNavbarEl = app.navbar.getElByPage($pageEl[0]);
      if (pageNavbarEl) {
        const $pageNavbarEl = $(pageNavbarEl);
        const isLargeTransparent = $pageNavbarEl.hasClass('navbar-large-transparent')
          || (
            $pageNavbarEl.hasClass('navbar-large')
            && $pageNavbarEl.hasClass('navbar-transparent')
          );
        const isTransparent = $pageNavbarEl.hasClass('navbar-transparent') && !$pageNavbarEl.hasClass('navbar-large');
        if (isLargeTransparent) {
          $el.addClass('ptr-with-navbar-large-transparent');
        } else if (isTransparent) {
          $el.addClass('ptr-with-navbar-transparent');
        }
      }
    }
    if (!hasNavbar && !ptr.bottom) $el.addClass('ptr-no-navbar');

    // Define trigger distance
    if ($el.attr('data-ptr-distance')) {
      dynamicTriggerDistance = true;
    } else if (isMaterial) {
      triggerDistance = 66;
    } else if (isIos) {
      triggerDistance = 44;
    } else if (isAurora) {
      triggerDistance = 38;
    }

    function handleTouchStart(e) {
      if (isTouched) {
        if (Device.os === 'android') {
          if ('targetTouches' in e && e.targetTouches.length > 1) return;
        } else return;
      }

      if ($el.hasClass('ptr-refreshing')) {
        return;
      }
      if ($(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) return;

      isMoved = false;
      pullStarted = false;
      isTouched = true;
      isScrolling = undefined;
      wasScrolled = undefined;
      if (e.type === 'touchstart') touchId = e.targetTouches[0].identifier;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      let pageX;
      let pageY;
      let touch;
      if (e.type === 'touchmove') {
        if (touchId && e.touches) {
          for (let i = 0; i < e.touches.length; i += 1) {
            if (e.touches[i].identifier === touchId) {
              touch = e.touches[i];
            }
          }
        }
        if (!touch) touch = e.targetTouches[0];
        pageX = touch.pageX;
        pageY = touch.pageY;
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      }
      if (!pageX || !pageY) return;


      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (!isScrolling) {
        isTouched = false;
        return;
      }

      scrollTop = $el[0].scrollTop;

      if (!isMoved) {
        $el.removeClass('ptr-transitioning');
        let targetIsScrollable;
        scrollHeight = $el[0].scrollHeight;
        offsetHeight = $el[0].offsetHeight;
        if (ptr.bottom) {
          maxScrollTop = scrollHeight - offsetHeight;
        }
        if (scrollTop > scrollHeight) {
          isTouched = false;
          return;
        }
        const $ptrWatchScrollable = $(e.target).closest('.ptr-watch-scroll');
        if ($ptrWatchScrollable.length) {
          $ptrWatchScrollable.each((ptrScrollableIndex, ptrScrollableEl) => {
            if (ptrScrollableEl === el) return;
            if (
              (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight)
              && $(ptrScrollableEl).css('overflow') === 'auto'
              && (
                (!ptr.bottom && ptrScrollableEl.scrollTop > 0)
                || (ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)
              )
            ) {
              targetIsScrollable = true;
            }
          });
        }
        if (targetIsScrollable) {
          isTouched = false;
          return;
        }
        if (dynamicTriggerDistance) {
          triggerDistance = $el.attr('data-ptr-distance');
          if (triggerDistance.indexOf('%') >= 0) triggerDistance = (scrollHeight * parseInt(triggerDistance, 10)) / 100;
        }
        startTranslate = $el.hasClass('ptr-refreshing') ? triggerDistance : 0;
        if (scrollHeight === offsetHeight || Device.os !== 'ios' || isMaterial) {
          useTranslate = true;
        } else {
          useTranslate = false;
        }
        forceUseTranslate = false;
      }
      isMoved = true;
      touchesDiff = pageY - touchesStart.y;

      if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) wasScrolled = true;

      const ptrStarted = ptr.bottom
        ? (touchesDiff < 0 && scrollTop >= maxScrollTop) || scrollTop > maxScrollTop
        : (touchesDiff > 0 && scrollTop <= 0) || scrollTop < 0;

      if (ptrStarted) {
        // iOS 8 fix
        if (Device.os === 'ios' && parseInt(Device.osVersion.split('.')[0], 10) > 7) {
          if (!ptr.bottom && scrollTop === 0 && !wasScrolled) useTranslate = true;
          if (ptr.bottom && scrollTop === maxScrollTop && !wasScrolled) useTranslate = true;
        }

        if (!useTranslate && ptr.bottom && !isMaterial) {
          $el.css('-webkit-overflow-scrolling', 'auto');
          $el.scrollTop(maxScrollTop);
          forceUseTranslate = true;
        }

        if (useTranslate || forceUseTranslate) {
          if (e.cancelable) {
            e.preventDefault();
          }
          translate = (ptr.bottom ? -1 * (Math.abs(touchesDiff) ** 0.85) : touchesDiff ** 0.85) + startTranslate;
          if (isMaterial) {
            $preloaderEl.transform(`translate3d(0,${translate}px,0)`)
              .find('.ptr-arrow').transform(`rotate(${(180 * (Math.abs(touchesDiff) / 66)) + 100}deg)`);
          } else {
            // eslint-disable-next-line
            if (ptr.bottom) {
              $el.children().transform(`translate3d(0,${translate}px,0)`);
            } else {
              $el.transform(`translate3d(0,${translate}px,0)`);
            }
          }
        }

        if (((useTranslate || forceUseTranslate) && (Math.abs(touchesDiff) ** 0.85) > triggerDistance) || (!useTranslate && Math.abs(touchesDiff) >= triggerDistance * 2)) {
          refresh = true;
          $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
        } else {
          refresh = false;
          $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
        }
        if (!pullStarted) {
          $el.trigger('ptr:pullstart');
          ptr.emit('local::pullStart ptrPullStart', $el[0]);
          pullStarted = true;
        }
        $el.trigger('ptr:pullmove', {
          event: e,
          scrollTop,
          translate,
          touchesDiff,
        });
        ptr.emit('local::pullMove ptrPullMove', $el[0], {
          event: e,
          scrollTop,
          translate,
          touchesDiff,
        });
      } else {
        pullStarted = false;
        $el.removeClass('ptr-pull-up ptr-pull-down');
        refresh = false;
      }
    }
    function handleTouchEnd(e) {
      if (e.type === 'touchend' && e.changedTouches && e.changedTouches.length > 0 && touchId) {
        if (e.changedTouches[0].identifier !== touchId) {
          isTouched = false;
          isScrolling = false;
          isMoved = false;
          touchId = null;
          return;
        }
      }
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      if (translate) {
        $el.addClass('ptr-transitioning');
        translate = 0;
      }
      if (isMaterial) {
        $preloaderEl.transform('')
          .find('.ptr-arrow').transform('');
      } else {
        // eslint-disable-next-line
        if (ptr.bottom) {
          $el.children().transform('');
        } else {
          $el.transform('');
        }
      }

      if (!useTranslate && ptr.bottom && !isMaterial) {
        $el.css('-webkit-overflow-scrolling', '');
      }

      if (refresh) {
        $el.addClass('ptr-refreshing');
        $el.trigger('ptr:refresh', ptr.done);
        ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
      } else {
        $el.removeClass('ptr-pull-down');
      }
      isTouched = false;
      isMoved = false;
      if (pullStarted) {
        $el.trigger('ptr:pullend');
        ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
      }
    }

    let mousewheelTimeout;
    let mousewheelMoved;
    let mousewheelAllow = true;
    let mousewheelTranslate = 0;

    function handleMouseWheelRelease() {
      mousewheelAllow = true;
      mousewheelMoved = false;
      mousewheelTranslate = 0;
      if (translate) {
        $el.addClass('ptr-transitioning');
        translate = 0;
      }
      if (isMaterial) {
        $preloaderEl.transform('')
          .find('.ptr-arrow').transform('');
      } else {
        // eslint-disable-next-line
        if (ptr.bottom) {
          $el.children().transform('');
        } else {
          $el.transform('');
        }
      }

      if (refresh) {
        $el.addClass('ptr-refreshing');
        $el.trigger('ptr:refresh', ptr.done);
        ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
      } else {
        $el.removeClass('ptr-pull-down');
      }
      if (pullStarted) {
        $el.trigger('ptr:pullend');
        ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
      }
    }
    function handleMouseWheel(e) {
      if (!mousewheelAllow) return;
      const { deltaX, deltaY } = e;
      if (Math.abs(deltaX) > Math.abs(deltaY)) return;
      if ($el.hasClass('ptr-refreshing')) {
        return;
      }
      if ($(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) return;

      clearTimeout(mousewheelTimeout);

      scrollTop = $el[0].scrollTop;

      if (!mousewheelMoved) {
        $el.removeClass('ptr-transitioning');
        let targetIsScrollable;
        scrollHeight = $el[0].scrollHeight;
        offsetHeight = $el[0].offsetHeight;
        if (ptr.bottom) {
          maxScrollTop = scrollHeight - offsetHeight;
        }
        if (scrollTop > scrollHeight) {
          mousewheelAllow = false;
          return;
        }
        const $ptrWatchScrollable = $(e.target).closest('.ptr-watch-scroll');
        if ($ptrWatchScrollable.length) {
          $ptrWatchScrollable.each((ptrScrollableIndex, ptrScrollableEl) => {
            if (ptrScrollableEl === el) return;
            if (
              (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight)
              && $(ptrScrollableEl).css('overflow') === 'auto'
              && (
                (!ptr.bottom && ptrScrollableEl.scrollTop > 0)
                || (ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)
              )
            ) {
              targetIsScrollable = true;
            }
          });
        }
        if (targetIsScrollable) {
          mousewheelAllow = false;
          return;
        }
        if (dynamicTriggerDistance) {
          triggerDistance = $el.attr('data-ptr-distance');
          if (triggerDistance.indexOf('%') >= 0) triggerDistance = (scrollHeight * parseInt(triggerDistance, 10)) / 100;
        }
      }
      isMoved = true;
      mousewheelTranslate -= deltaY;
      touchesDiff = mousewheelTranslate; // pageY - touchesStart.y;

      if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) wasScrolled = true;

      const ptrStarted = ptr.bottom
        ? (touchesDiff < 0 && scrollTop >= maxScrollTop) || scrollTop > maxScrollTop
        : (touchesDiff > 0 && scrollTop <= 0) || scrollTop < 0;

      if (ptrStarted) {
        if (e.cancelable) {
          e.preventDefault();
        }

        translate = touchesDiff;
        if (Math.abs(translate) > triggerDistance) {
          translate = triggerDistance + ((Math.abs(translate) - triggerDistance) ** 0.7);
          if (ptr.bottom) translate = -translate;
        }

        if (isMaterial) {
          $preloaderEl.transform(`translate3d(0,${translate}px,0)`)
            .find('.ptr-arrow').transform(`rotate(${(180 * (Math.abs(touchesDiff) / 66)) + 100}deg)`);
        } else {
          // eslint-disable-next-line
          if (ptr.bottom) {
            $el.children().transform(`translate3d(0,${translate}px,0)`);
          } else {
            $el.transform(`translate3d(0,${translate}px,0)`);
          }
        }

        if (Math.abs(translate) > triggerDistance) {
          refresh = true;
          $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
        } else {
          refresh = false;
          $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
        }
        if (!pullStarted) {
          $el.trigger('ptr:pullstart');
          ptr.emit('local::pullStart ptrPullStart', $el[0]);
          pullStarted = true;
        }
        $el.trigger('ptr:pullmove', {
          event: e,
          scrollTop,
          translate,
          touchesDiff,
        });
        ptr.emit('local::pullMove ptrPullMove', $el[0], {
          event: e,
          scrollTop,
          translate,
          touchesDiff,
        });
      } else {
        pullStarted = false;
        $el.removeClass('ptr-pull-up ptr-pull-down');
        refresh = false;
      }

      mousewheelTimeout = setTimeout(handleMouseWheelRelease, 300);
    }

    if (!$pageEl.length || !$el.length) return ptr;

    $el[0].f7PullToRefresh = ptr;

    // Events
    ptr.attachEvents = function attachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      if (ptr.mousewheel && !ptr.bottom) {
        $el.on('wheel', handleMouseWheel);
      }
    };
    ptr.detachEvents = function detachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      if (ptr.mousewheel && !ptr.bottom) {
        $el.off('wheel', handleMouseWheel);
      }
    };

    // Install Modules
    ptr.useModules();

    // Init
    ptr.init();

    return ptr;
  }

  init() {
    const ptr = this;
    ptr.attachEvents();
  }

  destroy() {
    let ptr = this;
    ptr.emit('local::beforeDestroy ptrBeforeDestroy', ptr);
    ptr.$el.trigger('ptr:beforedestroy');
    delete ptr.el.f7PullToRefresh;
    ptr.detachEvents();
    Utils.deleteProps(ptr);
    ptr = null;
  }
}

var PullToRefresh$1 = {
  name: 'pullToRefresh',
  create() {
    const app = this;
    app.ptr = Utils.extend(
      ConstructorMethods({
        defaultSelector: '.ptr-content',
        constructor: PullToRefresh,
        app,
        domProp: 'f7PullToRefresh',
      }),
      {
        done(el) {
          const ptr = app.ptr.get(el);
          if (ptr) return ptr.done();
          return undefined;
        },
        refresh(el) {
          const ptr = app.ptr.get(el);
          if (ptr) return ptr.refresh();
          return undefined;
        },
      }
    );
  },
  static: {
    PullToRefresh,
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = $(tabEl);
      const $ptrEls = $tabEl.find('.ptr-content');
      if ($tabEl.is('.ptr-content')) $ptrEls.add($tabEl);
      $ptrEls.each((index, el) => {
        app.ptr.create(el);
      });
    },
    tabBeforeRemove(tabEl) {
      const $tabEl = $(tabEl);
      const app = this;
      const $ptrEls = $tabEl.find('.ptr-content');
      if ($tabEl.is('.ptr-content')) $ptrEls.add($tabEl);
      $ptrEls.each((index, el) => {
        app.ptr.destroy(el);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.ptr-content').each((index, el) => {
        app.ptr.create(el);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.ptr-content').each((index, el) => {
        app.ptr.destroy(el);
      });
    },
  },
};

const Lazy = {
  destroy(pageEl) {
    const $pageEl = $(pageEl).closest('.page');
    if (!$pageEl.length) return;
    if ($pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy();
    }
  },
  create(pageEl) {
    const app = this;
    const $pageEl = $(pageEl).closest('.page').eq(0);

    // Lazy images
    const $lazyLoadImages = $pageEl.find('.lazy');
    if ($lazyLoadImages.length === 0 && !$pageEl.hasClass('lazy')) return;

    // Placeholder
    const placeholderSrc = app.params.lazy.placeholder;

    if (placeholderSrc !== false) {
      $lazyLoadImages.each((index, lazyEl) => {
        if ($(lazyEl).attr('data-src') && !$(lazyEl).attr('src')) $(lazyEl).attr('src', placeholderSrc);
      });
    }

    // load image
    const imagesSequence = [];
    let imageIsLoading = false;

    function onImageComplete(lazyEl) {
      if (imagesSequence.indexOf(lazyEl) >= 0) {
        imagesSequence.splice(imagesSequence.indexOf(lazyEl), 1);
      }
      imageIsLoading = false;
      if (app.params.lazy.sequential && imagesSequence.length > 0) {
        imageIsLoading = true;
        app.lazy.loadImage(imagesSequence[0], onImageComplete);
      }
    }

    function observerCallback(entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          if (app.params.lazy.sequential && imageIsLoading) {
            if (imagesSequence.indexOf(entry.target) < 0) imagesSequence.push(entry.target);
            return;
          }
          // Load image
          imageIsLoading = true;
          app.lazy.loadImage(entry.target, onImageComplete);
          // Detach
          observer.unobserve(entry.target);
        }
      });
    }
    if (app.params.lazy.observer && Support.intersectionObserver) {
      let observer = $pageEl[0].f7LazyObserver;
      if (!observer) {
        observer = new win.IntersectionObserver(observerCallback, {
          root: $pageEl[0],
        });
      }
      $lazyLoadImages.each((index, el) => {
        if (el.f7LazyObserverAdded) return;
        el.f7LazyObserverAdded = true;
        observer.observe(el);
      });
      if (!$pageEl[0].f7LazyDestroy) {
        $pageEl[0].f7LazyDestroy = () => {
          observer.disconnect();
          delete $pageEl[0].f7LazyDestroy;
          delete $pageEl[0].f7LazyObserver;
        };
      }
      return;
    }

    function lazyHandler() {
      app.lazy.load($pageEl, (lazyEl) => {
        if (app.params.lazy.sequential && imageIsLoading) {
          if (imagesSequence.indexOf(lazyEl) < 0) imagesSequence.push(lazyEl);
          return;
        }
        imageIsLoading = true;
        app.lazy.loadImage(lazyEl, onImageComplete);
      });
    }

    function attachEvents() {
      $pageEl[0].f7LazyAttached = true;
      $pageEl.on('lazy', lazyHandler);
      $pageEl.on('scroll', lazyHandler, true);
      $pageEl.find('.tab').on('tab:mounted tab:show', lazyHandler);
      app.on('resize', lazyHandler);
    }
    function detachEvents() {
      $pageEl[0].f7LazyAttached = false;
      delete $pageEl[0].f7LazyAttached;
      $pageEl.off('lazy', lazyHandler);
      $pageEl.off('scroll', lazyHandler, true);
      $pageEl.find('.tab').off('tab:mounted tab:show', lazyHandler);
      app.off('resize', lazyHandler);
    }

    // Store detach function
    if (!$pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy = detachEvents;
    }

    // Attach events
    if (!$pageEl[0].f7LazyAttached) {
      attachEvents();
    }

    // Run loader on page load/init
    lazyHandler();
  },
  isInViewport(lazyEl) {
    const app = this;
    const rect = lazyEl.getBoundingClientRect();
    const threshold = app.params.lazy.threshold || 0;

    return (
      rect.top >= (0 - threshold)
      && rect.left >= (0 - threshold)
      && rect.top <= (app.height + threshold)
      && rect.left <= (app.width + threshold)
    );
  },
  loadImage(imageEl, callback) {
    const app = this;
    const $imageEl = $(imageEl);

    const bg = $imageEl.attr('data-background');
    const src = bg || $imageEl.attr('data-src');

    function onLoad() {
      $imageEl.removeClass('lazy').addClass('lazy-loaded');
      if (bg) {
        $imageEl.css('background-image', `url(${src})`);
      } else if (src) {
        $imageEl.attr('src', src);
      }
      if (callback) callback(imageEl);
      $imageEl.trigger('lazy:loaded');
      app.emit('lazyLoaded', $imageEl[0]);
    }

    if (!src) {
      $imageEl.trigger('lazy:load');
      app.emit('lazyLoad', $imageEl[0]);
      onLoad();
      return;
    }
    function onError() {
      $imageEl.removeClass('lazy').addClass('lazy-loaded');
      if (bg) {
        $imageEl.css('background-image', `url(${app.params.lazy.placeholder || ''})`);
      } else {
        $imageEl.attr('src', app.params.lazy.placeholder || '');
      }
      if (callback) callback(imageEl);
      $imageEl.trigger('lazy:error');
      app.emit('lazyError', $imageEl[0]);
    }
    const image = new win.Image();
    image.onload = onLoad;
    image.onerror = onError;
    image.src = src;

    $imageEl.removeAttr('data-src').removeAttr('data-background');

    // Add loaded callback and events
    $imageEl.trigger('lazy:load');
    app.emit('lazyLoad', $imageEl[0]);
  },
  load(pageEl, callback) {
    const app = this;
    let $pageEl = $(pageEl);
    if (!$pageEl.hasClass('page')) $pageEl = $pageEl.parents('.page').eq(0);
    if ($pageEl.length === 0) {
      return;
    }
    $pageEl.find('.lazy').each((index, lazyEl) => {
      const $lazyEl = $(lazyEl);
      if ($lazyEl.parents('.tab:not(.tab-active)').length > 0) {
        return;
      }
      if (app.lazy.isInViewport(lazyEl)) {
        if (callback) callback(lazyEl);
        else app.lazy.loadImage(lazyEl);
      }
    });
  },

};
var Lazy$1 = {
  name: 'lazy',
  params: {
    lazy: {
      placeholder: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==',
      threshold: 0,
      sequential: true,
      observer: true,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      lazy: {
        create: Lazy.create.bind(app),
        destroy: Lazy.destroy.bind(app),
        loadImage: Lazy.loadImage.bind(app),
        load: Lazy.load.bind(app),
        isInViewport: Lazy.isInViewport.bind(app),
      },
    });
  },
  on: {
    pageInit(page) {
      const app = this;
      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
        app.lazy.create(page.$el);
      }
    },
    pageAfterIn(page) {
      const app = this;
      if (app.params.lazy.observer && Support.intersectionObserver) return;
      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
        app.lazy.create(page.$el);
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
        app.lazy.destroy(page.$el);
      }
    },
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = $(tabEl);
      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
        app.lazy.create($tabEl);
      }
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      if (app.params.lazy.observer && Support.intersectionObserver) return;
      const $tabEl = $(tabEl);
      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
        app.lazy.destroy($tabEl);
      }
    },
  },
};

class DataTable extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const table = this;

    const defaults = {

    };

    // Extend defaults with modules params
    table.useModulesParams(defaults);

    table.params = Utils.extend(defaults, params);

    // El
    const $el = $(table.params.el);
    if ($el.length === 0) return undefined;

    table.$el = $el;
    table.el = $el[0];

    if (table.$el[0].f7DataTable) {
      const instance = table.$el[0].f7DataTable;
      table.destroy();
      return instance;
    }

    table.$el[0].f7DataTable = table;

    Utils.extend(table, {
      collapsible: $el.hasClass('data-table-collapsible'),
      // Headers
      $headerEl: $el.find('.data-table-header'),
      $headerSelectedEl: $el.find('.data-table-header-selected'),
    });

    // Events
    function handleChange(e) {
      if (e.detail && e.detail.sentByF7DataTable) {
        // Scripted event, don't do anything
        return;
      }
      const $inputEl = $(this);
      const checked = $inputEl[0].checked;
      const columnIndex = $inputEl.parents('td,th').index();

      if ($inputEl.parents('thead').length > 0) {
        if (columnIndex === 0) {
          $el
            .find('tbody tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
        }
        $el
          .find(`tbody tr td:nth-child(${columnIndex + 1}) input`)
          .prop('checked', checked)
          .trigger('change', { sentByF7DataTable: true });
        $inputEl.prop('indeterminate', false);
      } else {
        if (columnIndex === 0) {
          $inputEl.parents('tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
        }
        const checkedRows = $el.find(`tbody .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]:checked`).length;
        const totalRows = $el.find('tbody tr').length;
        const $headCheckboxEl = $el.find(`thead .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]`);
        if (!checked) {
          $headCheckboxEl.prop('checked', false);
        } else if (checkedRows === totalRows) {
          $headCheckboxEl.prop('checked', true).trigger('change', { sentByF7DataTable: true });
        }
        $headCheckboxEl.prop('indeterminate', checkedRows > 0 && checkedRows < totalRows);
      }
      table.checkSelectedHeader();
    }
    function handleSortableClick() {
      const $cellEl = $(this);
      const isActive = $cellEl.hasClass('sortable-cell-active');
      const currentSort = $cellEl.hasClass('sortable-desc') ? 'desc' : 'asc';
      let newSort;
      if (isActive) {
        newSort = currentSort === 'desc' ? 'asc' : 'desc';
        $cellEl.removeClass('sortable-desc sortable-asc').addClass(`sortable-${newSort}`);
      } else {
        $el.find('thead .sortable-cell-active').removeClass('sortable-cell-active');
        $cellEl.addClass('sortable-cell-active');
        newSort = currentSort;
      }
      $cellEl.trigger('datatable:sort', newSort);
      table.emit('local::sort dataTableSort', table, newSort);
    }
    table.attachEvents = function attachEvents() {
      table.$el.on('change', '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find('thead .sortable-cell').on('click', handleSortableClick);
    };
    table.detachEvents = function detachEvents() {
      table.$el.off('change', '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find('thead .sortable-cell').off('click', handleSortableClick);
    };

    // Install Modules
    table.useModules();

    // Init
    table.init();

    return table;
  }

  setCollapsibleLabels() {
    const table = this;
    if (!table.collapsible) return;
    table.$el.find('tbody td:not(.checkbox-cell)').each((index, el) => {
      const $el = $(el);
      const elIndex = $el.index();
      const collpsibleTitle = $el.attr('data-collapsible-title');
      if (!collpsibleTitle && collpsibleTitle !== '') {
        $el.attr('data-collapsible-title', table.$el.find('thead th').eq(elIndex).text());
      }
    });
  }

  checkSelectedHeader() {
    const table = this;
    if (table.$headerEl.length > 0 && table.$headerSelectedEl.length > 0) {
      const checkedItems = table.$el.find('tbody .checkbox-cell input:checked').length;
      table.$el[checkedItems > 0 ? 'addClass' : 'removeClass']('data-table-has-checked');
      table.$headerSelectedEl.find('.data-table-selected-count').text(checkedItems);
    }
  }

  init() {
    const table = this;
    table.attachEvents();
    table.setCollapsibleLabels();
    table.checkSelectedHeader();
  }

  destroy() {
    let table = this;

    table.$el.trigger('datatable:beforedestroy');
    table.emit('local::beforeDestroy dataTableBeforeDestroy', table);

    table.attachEvents();

    if (table.$el[0]) {
      table.$el[0].f7DataTable = null;
      delete table.$el[0].f7DataTable;
    }
    Utils.deleteProps(table);
    table = null;
  }
}

var DataTable$1 = {
  name: 'dataTable',
  static: {
    DataTable,
  },
  create() {
    const app = this;
    app.dataTable = ConstructorMethods({
      defaultSelector: '.data-table',
      constructor: DataTable,
      app,
      domProp: 'f7DataTable',
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      $(tabEl).find('.data-table-init').each((index, tableEl) => {
        app.dataTable.destroy(tableEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.data-table-init').each((index, tableEl) => {
        app.dataTable.create({ el: tableEl });
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.data-table-init').each((index, tableEl) => {
        app.dataTable.destroy(tableEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.data-table-init').each((index, tableEl) => {
        app.dataTable.create({ el: tableEl });
      });
    },
  },
  vnode: {
    'data-table-init': {
      insert(vnode) {
        const app = this;
        const tableEl = vnode.elm;
        app.dataTable.create({ el: tableEl });
      },
      destroy(vnode) {
        const app = this;
        const tableEl = vnode.elm;
        app.dataTable.destroy(tableEl);
      },
    },
  },
};

const Fab = {
  morphOpen(fabEl, targetEl) {
    const app = this;
    const $fabEl = $(fabEl);
    const $targetEl = $(targetEl);
    if ($targetEl.length === 0) return;

    $targetEl.transition(0).addClass('fab-morph-target-visible');
    const target = {
      width: $targetEl[0].offsetWidth,
      height: $targetEl[0].offsetHeight,
      offset: $targetEl.offset(),
      borderRadius: $targetEl.css('border-radius'),
      zIndex: $targetEl.css('z-index'),
    };
    const fab = {
      width: $fabEl[0].offsetWidth,
      height: $fabEl[0].offsetHeight,
      offset: $fabEl.offset(),
      translateX: Utils.getTranslate($fabEl[0], 'x'),
      translateY: Utils.getTranslate($fabEl[0], 'y'),
    };

    $fabEl[0].f7FabMorphData = {
      $targetEl,
      target,
      fab,
    };

    const diffX = (fab.offset.left + (fab.width / 2))
                  - (target.offset.left + (target.width / 2))
                  - fab.translateX;
    const diffY = (fab.offset.top + (fab.height / 2))
                  - (target.offset.top + (target.height / 2))
                  - fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;

    let borderRadius = Math.ceil(parseInt(target.borderRadius, 10) / Math.max(scaleX, scaleY));
    if (borderRadius > 0) borderRadius += 2;

    $fabEl[0].f7FabMorphResizeHandler = function resizeHandler() {
      $fabEl.transition(0).transform('');
      $targetEl.transition(0);
      target.width = $targetEl[0].offsetWidth;
      target.height = $targetEl[0].offsetHeight;
      target.offset = $targetEl.offset();
      fab.offset = $fabEl.offset();

      const diffXNew = (fab.offset.left + (fab.width / 2))
                      - (target.offset.left + (target.width / 2))
                      - fab.translateX;
      const diffYNew = (fab.offset.top + (fab.height / 2))
                      - (target.offset.top + (target.height / 2))
                      - fab.translateY;
      const scaleXNew = target.width / fab.width;
      const scaleYNew = target.height / fab.height;

      $fabEl.transform(`translate3d(${-diffXNew}px, ${-diffYNew}px, 0) scale(${scaleXNew}, ${scaleYNew})`);
    };

    $targetEl
      .css('opacity', 0)
      .transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl
      .addClass('fab-opened')
      .css('z-index', target.zIndex - 1)
      .transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $targetEl.transition('');
      Utils.nextFrame(() => {
        $targetEl.css('opacity', 1).transform('scale(1,1)');
        $fabEl
          .transform(`translate3d(${-diffX}px, ${-diffY}px, 0) scale(${scaleX}, ${scaleY})`)
          .css('border-radius', `${borderRadius}px`)
          .css('box-shadow', 'none')
          .css('opacity', '0');
      });
      app.on('resize', $fabEl[0].f7FabMorphResizeHandler);
      if ($targetEl.parents('.page-content').length > 0) {
        $targetEl.parents('.page-content').on('scroll', $fabEl[0].f7FabMorphResizeHandler);
      }
    });
  },
  morphClose(fabEl) {
    const app = this;
    const $fabEl = $(fabEl);
    const morphData = $fabEl[0].f7FabMorphData;
    if (!morphData) return;
    const { $targetEl, target, fab } = morphData;
    if ($targetEl.length === 0) return;

    const diffX = (fab.offset.left + (fab.width / 2))
                  - (target.offset.left + (target.width / 2))
                  - fab.translateX;
    const diffY = (fab.offset.top + (fab.height / 2))
                  - (target.offset.top + (target.height / 2))
                  - fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;

    app.off('resize', $fabEl[0].f7FabMorphResizeHandler);
    if ($targetEl.parents('.page-content').length > 0) {
      $targetEl.parents('.page-content').off('scroll', $fabEl[0].f7FabMorphResizeHandler);
    }

    $targetEl
      .css('opacity', 0)
      .transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl
      .transition('')
      .css('box-shadow', '')
      .css('border-radius', '')
      .css('opacity', '1')
      .transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $fabEl
        .css('z-index', '')
        .removeClass('fab-opened')
        .transform('');
      Utils.nextFrame(() => {
        $fabEl.transitionEnd(() => {
          $targetEl
            .removeClass('fab-morph-target-visible')
            .css('opacity', '')
            .transform('')
            .transition('');
        });
      });
    });
  },
  open(fabEl, targetEl) {
    const app = this;
    const $fabEl = $(fabEl).eq(0);
    const $buttonsEl = $fabEl.find('.fab-buttons');
    if (!$fabEl.length) return;
    if ($fabEl.hasClass('fab-opened')) return;
    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;

    if (app.fab.openedEl) {
      if (app.fab.openedEl === $fabEl[0]) return;
      app.fab.close(app.fab.openedEl);
    }
    app.fab.openedEl = $fabEl[0];
    if ($fabEl.hasClass('fab-morph')) {
      app.fab.morphOpen($fabEl, targetEl || $fabEl.attr('data-morph-to'));
    } else {
      $fabEl.addClass('fab-opened');
    }
    $fabEl.siblings('.fab-backdrop').addClass('backdrop-in');
    $fabEl.trigger('fab:open');
  },
  close(fabEl = '.fab-opened') {
    const app = this;
    const $fabEl = $(fabEl).eq(0);
    const $buttonsEl = $fabEl.find('.fab-buttons');
    if (!$fabEl.length) return;
    if (!$fabEl.hasClass('fab-opened')) return;
    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;
    app.fab.openedEl = null;
    if ($fabEl.hasClass('fab-morph')) {
      app.fab.morphClose($fabEl);
    } else {
      $fabEl.removeClass('fab-opened');
    }
    $fabEl.siblings('.fab-backdrop').removeClass('backdrop-in');
    $fabEl.trigger('fab:close');
  },
  toggle(fabEl) {
    const app = this;
    const $fabEl = $(fabEl);
    if (!$fabEl.hasClass('fab-opened')) app.fab.open(fabEl);
    else app.fab.close(fabEl);
  },
};

var Fab$1 = {
  name: 'fab',
  create() {
    const app = this;
    Utils.extend(app, {
      fab: {
        openedEl: null,
        morphOpen: Fab.morphOpen.bind(app),
        morphClose: Fab.morphClose.bind(app),
        open: Fab.open.bind(app),
        close: Fab.close.bind(app),
        toggle: Fab.toggle.bind(app),
      },
    });
  },
  clicks: {
    '.fab > a': function open($clickedEl) {
      const app = this;
      app.fab.toggle($clickedEl.parents('.fab'));
    },
    '.fab-open': function open($clickedEl, data = {}) {
      const app = this;
      app.fab.open(data.fab);
    },
    '.fab-close': function close($clickedEl, data = {}) {
      const app = this;
      app.fab.close(data.fab);
    },
    '.fab-backdrop': function close() {
      const app = this;
      app.fab.close();
    },
  },
};

class Searchbar extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const sb = this;

    const defaults = {
      el: undefined,
      inputEl: undefined,
      inputEvents: 'change input compositionend',
      disableButton: true,
      disableButtonEl: undefined,
      backdropEl: undefined,
      searchContainer: undefined, // container to search, HTMLElement or CSS selector
      searchItem: 'li', // single item selector, CSS selector
      searchIn: undefined, // where to search in item, CSS selector
      searchGroup: '.list-group',
      searchGroupTitle: '.item-divider, .list-group-title',
      ignore: '.searchbar-ignore',
      foundEl: '.searchbar-found',
      notFoundEl: '.searchbar-not-found',
      hideOnEnableEl: '.searchbar-hide-on-enable',
      hideOnSearchEl: '.searchbar-hide-on-search',
      backdrop: undefined,
      removeDiacritics: true,
      customSearch: false,
      hideDividers: true,
      hideGroups: true,
      disableOnBackdropClick: true,
      expandable: false,
      inline: false,
    };

    // Extend defaults with modules params
    sb.useModulesParams(defaults);

    sb.params = Utils.extend(defaults, params);

    const $el = $(sb.params.el);
    if ($el.length === 0) return sb;

    if ($el[0].f7Searchbar) return $el[0].f7Searchbar;

    $el[0].f7Searchbar = sb;

    let $pageEl;
    const $navbarEl = $el.parents('.navbar');
    if ($el.parents('.page').length > 0) {
      $pageEl = $el.parents('.page');
    } else if ($navbarEl.length > 0) {
      $pageEl = $(app.navbar.getPageByEl($navbarEl[0]));
      if (!$pageEl.length) {
        const $currentPageEl = $el.parents('.view').find('.page-current');
        if ($currentPageEl[0] && $currentPageEl[0].f7Page && $currentPageEl[0].f7Page.navbarEl === $navbarEl[0]) {
          $pageEl = $currentPageEl;
        }
      }
    }

    let $foundEl;
    if (params.foundEl) {
      $foundEl = $(params.foundEl);
    } else if (typeof sb.params.foundEl === 'string' && $pageEl) {
      $foundEl = $pageEl.find(sb.params.foundEl);
    }

    let $notFoundEl;
    if (params.notFoundEl) {
      $notFoundEl = $(params.notFoundEl);
    } else if (typeof sb.params.notFoundEl === 'string' && $pageEl) {
      $notFoundEl = $pageEl.find(sb.params.notFoundEl);
    }

    let $hideOnEnableEl;
    if (params.hideOnEnableEl) {
      $hideOnEnableEl = $(params.hideOnEnableEl);
    } else if (typeof sb.params.hideOnEnableEl === 'string' && $pageEl) {
      $hideOnEnableEl = $pageEl.find(sb.params.hideOnEnableEl);
    }

    let $hideOnSearchEl;
    if (params.hideOnSearchEl) {
      $hideOnSearchEl = $(params.hideOnSearchEl);
    } else if (typeof sb.params.hideOnSearchEl === 'string' && $pageEl) {
      $hideOnSearchEl = $pageEl.find(sb.params.hideOnSearchEl);
    }


    const expandable = sb.params.expandable || $el.hasClass('searchbar-expandable');
    const inline = sb.params.inline || $el.hasClass('searchbar-inline');

    if (typeof sb.params.backdrop === 'undefined') {
      if (!inline) sb.params.backdrop = app.theme !== 'aurora';
      else sb.params.backdrop = false;
    }

    let $backdropEl;
    if (sb.params.backdrop) {
      if (sb.params.backdropEl) {
        $backdropEl = $(sb.params.backdropEl);
      } else if ($pageEl && $pageEl.length > 0) {
        $backdropEl = $pageEl.find('.searchbar-backdrop');
      } else {
        $backdropEl = $el.siblings('.searchbar-backdrop');
      }
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="searchbar-backdrop"></div>');
        if ($pageEl && $pageEl.length) {
          if ($el.parents($pageEl).length > 0 && $navbarEl && $el.parents($navbarEl).length === 0) {
            $backdropEl.insertBefore($el);
          } else {
            $backdropEl.insertBefore($pageEl.find('.page-content').eq(0));
          }
        } else {
          $backdropEl.insertBefore($el);
        }
      }
    }

    let $searchContainer;
    if (sb.params.searchContainer) {
      $searchContainer = $(sb.params.searchContainer);
    }

    let $inputEl;
    if (sb.params.inputEl) {
      $inputEl = $(sb.params.inputEl);
    } else {
      $inputEl = $el.find('input[type="search"]').eq(0);
    }

    let $disableButtonEl;
    if (sb.params.disableButton) {
      if (sb.params.disableButtonEl) {
        $disableButtonEl = $(sb.params.disableButtonEl);
      } else {
        $disableButtonEl = $el.find('.searchbar-disable-button');
      }
    }

    Utils.extend(sb, {
      app,
      view: app.views.get($el.parents('.view')),
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      $searchContainer,
      searchContainer: $searchContainer && $searchContainer[0],
      $inputEl,
      inputEl: $inputEl[0],
      $disableButtonEl,
      disableButtonEl: $disableButtonEl && $disableButtonEl[0],
      disableButtonHasMargin: false,
      $pageEl,
      pageEl: $pageEl && $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl && $navbarEl[0],
      $foundEl,
      foundEl: $foundEl && $foundEl[0],
      $notFoundEl,
      notFoundEl: $notFoundEl && $notFoundEl[0],
      $hideOnEnableEl,
      hideOnEnableEl: $hideOnEnableEl && $hideOnEnableEl[0],
      $hideOnSearchEl,
      hideOnSearchEl: $hideOnSearchEl && $hideOnSearchEl[0],
      previousQuery: '',
      query: '',
      isVirtualList: $searchContainer && $searchContainer.hasClass('virtual-list'),
      virtualList: undefined,
      enabled: false,
      expandable,
      inline,
    });

    // Events
    function preventSubmit(e) {
      e.preventDefault();
    }
    function onInputFocus(e) {
      sb.enable(e);
      sb.$el.addClass('searchbar-focused');
    }
    function onInputBlur() {
      sb.$el.removeClass('searchbar-focused');
      if (app.theme === 'aurora' && (!$disableButtonEl || !$disableButtonEl.length || !sb.params.disableButton) && !sb.query) {
        sb.disable();
      }
    }
    function onInputChange() {
      const value = sb.$inputEl.val().trim();
      if (
        (
          (sb.$searchContainer && sb.$searchContainer.length > 0)
          && (sb.params.searchIn || sb.isVirtualList || sb.params.searchIn === sb.params.searchItem)
        )
        || sb.params.customSearch
      ) {
        sb.search(value, true);
      }
    }
    function onInputClear(e, previousValue) {
      sb.$el.trigger('searchbar:clear', previousValue);
      sb.emit('local::clear searchbarClear', sb, previousValue);
    }
    function disableOnClick(e) {
      sb.disable(e);
    }
    function onPageBeforeOut() {
      if (!sb || (sb && !sb.$el)) return;
      if (sb.enabled) {
        sb.$el.removeClass('searchbar-enabled');
        if (sb.expandable) {
          sb.$el.parents('.navbar').removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition');
        }
      }
    }
    function onPageBeforeIn() {
      if (!sb || (sb && !sb.$el)) return;
      if (sb.enabled) {
        sb.$el.addClass('searchbar-enabled');
        if (sb.expandable) {
          sb.$el.parents('.navbar').addClass('with-searchbar-expandable-enabled-no-transition');
        }
      }
    }
    sb.attachEvents = function attachEvents() {
      $el.on('submit', preventSubmit);
      if (sb.params.disableButton) {
        sb.$disableButtonEl.on('click', disableOnClick);
      }
      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.on('click', disableOnClick);
      }
      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
        sb.$pageEl.on('page:beforeout', onPageBeforeOut);
        sb.$pageEl.on('page:beforein', onPageBeforeIn);
      }
      sb.$inputEl.on('focus', onInputFocus);
      sb.$inputEl.on('blur', onInputBlur);
      sb.$inputEl.on(sb.params.inputEvents, onInputChange);
      sb.$inputEl.on('input:clear', onInputClear);
    };
    sb.detachEvents = function detachEvents() {
      $el.off('submit', preventSubmit);
      if (sb.params.disableButton) {
        sb.$disableButtonEl.off('click', disableOnClick);
      }
      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.off('click', disableOnClick);
      }
      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
        sb.$pageEl.off('page:beforeout', onPageBeforeOut);
        sb.$pageEl.off('page:beforein', onPageBeforeIn);
      }
      sb.$inputEl.off('focus', onInputFocus);
      sb.$inputEl.off('blur', onInputBlur);
      sb.$inputEl.off(sb.params.inputEvents, onInputChange);
      sb.$inputEl.off('input:clear', onInputClear);
    };

    // Install Modules
    sb.useModules();

    // Init
    sb.init();

    return sb;
  }

  clear(e) {
    const sb = this;
    if (!sb.query && e && $(e.target).hasClass('searchbar-clear')) {
      sb.disable();
      return sb;
    }
    const previousQuery = sb.value;
    sb.$inputEl.val('').trigger('change').focus();
    sb.$el.trigger('searchbar:clear', previousQuery);
    sb.emit('local::clear searchbarClear', sb, previousQuery);
    return sb;
  }

  setDisableButtonMargin() {
    const sb = this;
    if (sb.expandable) return;
    const app = sb.app;
    sb.$disableButtonEl.transition(0).show();
    sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, `${-sb.disableButtonEl.offsetWidth}px`);
    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
    sb._clientLeft = sb.$disableButtonEl[0].clientLeft;
    sb.$disableButtonEl.transition('');
    sb.disableButtonHasMargin = true;
  }

  enable(setFocus) {
    const sb = this;
    if (sb.enabled) return sb;
    const app = sb.app;
    sb.enabled = true;
    function enable() {
      if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch) && !sb.$el.hasClass('searchbar-enabled') && !sb.query) {
        sb.backdropShow();
      }
      sb.$el.addClass('searchbar-enabled');
      if (!sb.$disableButtonEl || (sb.$disableButtonEl && sb.$disableButtonEl.length === 0)) {
        sb.$el.addClass('searchbar-enabled-no-disable-button');
      }
      if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
        if (!sb.disableButtonHasMargin) {
          sb.setDisableButtonMargin();
        }
        sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, '0px');
      }
      if (sb.expandable) {
        const $navbarEl = sb.$el.parents('.navbar');
        if ($navbarEl.hasClass('navbar-large') && sb.$pageEl) {
          const $pageContentEl = sb.$pageEl.find('.page-content');
          const $titleLargeEl = $navbarEl.find('.title-large');
          $pageContentEl.addClass('with-searchbar-expandable-enabled');
          if ($navbarEl.hasClass('navbar-large') && $navbarEl.hasClass('navbar-large-collapsed') && $titleLargeEl.length && $pageContentEl.length) {
            $pageContentEl.transition(0);
            $pageContentEl[0].scrollTop -= $titleLargeEl[0].offsetHeight;
            setTimeout(() => {
              $pageContentEl.transition('');
            }, 200);
          }
        }
        if (app.theme === 'md' && $navbarEl.length) {
          $navbarEl.addClass('with-searchbar-expandable-enabled');
        } else {
          $navbarEl.addClass('with-searchbar-expandable-enabled');
          if ($navbarEl.hasClass('navbar-large')) {
            $navbarEl.addClass('navbar-large-collapsed');
          }
        }
      }
      if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.addClass('hidden-by-searchbar');
      sb.$el.trigger('searchbar:enable');
      sb.emit('local::enable searchbarEnable', sb);
    }
    let needsFocus = false;
    if (setFocus === true) {
      if (doc.activeElement !== sb.inputEl) {
        needsFocus = true;
      }
    }
    const isIos = app.device.ios && app.theme === 'ios';
    if (isIos) {
      if (sb.expandable) {
        if (needsFocus) sb.$inputEl.focus();
        enable();
      } else {
        if (needsFocus) sb.$inputEl.focus();
        if (setFocus && (setFocus.type === 'focus' || setFocus === true)) {
          Utils.nextTick(() => {
            enable();
          }, 400);
        } else {
          enable();
        }
      }
    } else {
      if (needsFocus) sb.$inputEl.focus();
      if (app.theme === 'md' && sb.expandable) {
        sb.$el.parents('.page, .view, .navbar-inner, .navbar').scrollLeft(app.rtl ? 100 : 0);
      }
      enable();
    }
    return sb;
  }

  disable() {
    const sb = this;
    if (!sb.enabled) return sb;
    const app = sb.app;
    sb.$inputEl.val('').trigger('change');
    sb.$el.removeClass('searchbar-enabled searchbar-focused searchbar-enabled-no-disable-button');
    if (sb.expandable) {
      const $navbarEl = sb.$el.parents('.navbar');
      const $pageContentEl = sb.$pageEl && sb.$pageEl.find('.page-content');

      if ($navbarEl.hasClass('navbar-large') && $pageContentEl.length) {
        const $titleLargeEl = $navbarEl.find('.title-large');
        sb.$el.transitionEnd(() => {
          $pageContentEl.removeClass('with-searchbar-expandable-closing');
        });
        if ($navbarEl.hasClass('navbar-large') && $navbarEl.hasClass('navbar-large-collapsed') && $titleLargeEl.length) {
          const scrollTop = $pageContentEl[0].scrollTop;
          const titleLargeHeight = $titleLargeEl[0].offsetHeight;
          if (scrollTop > titleLargeHeight) {
            $pageContentEl.transition(0);
            $pageContentEl[0].scrollTop = scrollTop + titleLargeHeight;
            setTimeout(() => {
              $pageContentEl.transition('');
            }, 200);
          }
        }
        $pageContentEl.removeClass('with-searchbar-expandable-enabled').addClass('with-searchbar-expandable-closing');
      }
      if (app.theme === 'md' && $navbarEl.length) {
        $navbarEl
          .removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition')
          .addClass('with-searchbar-expandable-closing');
        sb.$el.transitionEnd(() => {
          $navbarEl.removeClass('with-searchbar-expandable-closing');
        });
      } else {
        $navbarEl
          .removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition')
          .addClass('with-searchbar-expandable-closing');
        sb.$el.transitionEnd(() => {
          $navbarEl.removeClass('with-searchbar-expandable-closing');
        });
        if (sb.$pageEl) {
          sb.$pageEl.find('.page-content').trigger('scroll');
        }
      }
    }
    if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
      sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, `${-sb.disableButtonEl.offsetWidth}px`);
    }
    if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch)) {
      sb.backdropHide();
    }

    sb.enabled = false;

    sb.$inputEl.blur();

    if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.removeClass('hidden-by-searchbar');

    sb.$el.trigger('searchbar:disable');
    sb.emit('local::disable searchbarDisable', sb);
    return sb;
  }

  toggle() {
    const sb = this;
    if (sb.enabled) sb.disable();
    else sb.enable(true);
    return sb;
  }

  backdropShow() {
    const sb = this;
    if (sb.$backdropEl) {
      sb.$backdropEl.addClass('searchbar-backdrop-in');
    }
    return sb;
  }

  backdropHide() {
    const sb = this;
    if (sb.$backdropEl) {
      sb.$backdropEl.removeClass('searchbar-backdrop-in');
    }
    return sb;
  }

  search(query, internal) {
    const sb = this;
    sb.previousQuery = sb.query || '';
    if (query === sb.previousQuery) return sb;

    if (!internal) {
      if (!sb.enabled) {
        sb.enable();
      }
      sb.$inputEl.val(query);
      sb.$inputEl.trigger('input');
    }
    sb.query = query;
    sb.value = query;

    const { $searchContainer, $el, $foundEl, $notFoundEl, $hideOnSearchEl, isVirtualList } = sb;

    // Hide on search element
    if (query.length > 0 && $hideOnSearchEl) {
      $hideOnSearchEl.addClass('hidden-by-searchbar');
    } else if ($hideOnSearchEl) {
      $hideOnSearchEl.removeClass('hidden-by-searchbar');
    }
    // Add active/inactive classes on overlay
    if (
      ($searchContainer && $searchContainer.length && $el.hasClass('searchbar-enabled'))
      || (sb.params.customSearch && $el.hasClass('searchbar-enabled'))
    ) {
      if (query.length === 0) {
        sb.backdropShow();
      } else {
        sb.backdropHide();
      }
    }

    if (sb.params.customSearch) {
      $el.trigger('searchbar:search', { query, previousQuery: sb.previousQuery });
      sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
      return sb;
    }

    let foundItems = [];
    let vlQuery;
    if (isVirtualList) {
      sb.virtualList = $searchContainer[0].f7VirtualList;
      if (query.trim() === '') {
        sb.virtualList.resetFilter();
        if ($notFoundEl) $notFoundEl.hide();
        if ($foundEl) $foundEl.show();
        $el.trigger('searchbar:search', { query, previousQuery: sb.previousQuery });
        sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
        return sb;
      }
      vlQuery = sb.params.removeDiacritics ? Utils.removeDiacritics(query) : query;
      if (sb.virtualList.params.searchAll) {
        foundItems = sb.virtualList.params.searchAll(vlQuery, sb.virtualList.items) || [];
      } else if (sb.virtualList.params.searchByItem) {
        for (let i = 0; i < sb.virtualList.items.length; i += 1) {
          if (sb.virtualList.params.searchByItem(vlQuery, sb.virtualList.params.items[i], i)) {
            foundItems.push(i);
          }
        }
      }
    } else {
      let values;
      if (sb.params.removeDiacritics) values = Utils.removeDiacritics(query.trim().toLowerCase()).split(' ');
      else {
        values = query.trim().toLowerCase().split(' ');
      }
      $searchContainer.find(sb.params.searchItem).removeClass('hidden-by-searchbar').each((itemIndex, itemEl) => {
        const $itemEl = $(itemEl);
        let compareWithText = [];
        let $searchIn = sb.params.searchIn ? $itemEl.find(sb.params.searchIn) : $itemEl;
        if (sb.params.searchIn === sb.params.searchItem) {
          $searchIn = $itemEl;
        }
        $searchIn.each((searchInIndex, searchInEl) => {
          let itemText = $(searchInEl).text().trim().toLowerCase();
          if (sb.params.removeDiacritics) itemText = Utils.removeDiacritics(itemText);
          compareWithText.push(itemText);
        });
        compareWithText = compareWithText.join(' ');
        let wordsMatch = 0;
        for (let i = 0; i < values.length; i += 1) {
          if (compareWithText.indexOf(values[i]) >= 0) wordsMatch += 1;
        }
        if (wordsMatch !== values.length && !(sb.params.ignore && $itemEl.is(sb.params.ignore))) {
          $itemEl.addClass('hidden-by-searchbar');
        } else {
          foundItems.push($itemEl[0]);
        }
      });

      if (sb.params.hideDividers) {
        $searchContainer.find(sb.params.searchGroupTitle).each((titleIndex, titleEl) => {
          const $titleEl = $(titleEl);
          const $nextElements = $titleEl.nextAll(sb.params.searchItem);
          let hide = true;
          for (let i = 0; i < $nextElements.length; i += 1) {
            const $nextEl = $nextElements.eq(i);
            if ($nextEl.is(sb.params.searchGroupTitle)) break;
            if (!$nextEl.hasClass('hidden-by-searchbar')) {
              hide = false;
            }
          }
          const ignore = sb.params.ignore && $titleEl.is(sb.params.ignore);
          if (hide && !ignore) $titleEl.addClass('hidden-by-searchbar');
          else $titleEl.removeClass('hidden-by-searchbar');
        });
      }
      if (sb.params.hideGroups) {
        $searchContainer.find(sb.params.searchGroup).each((groupIndex, groupEl) => {
          const $groupEl = $(groupEl);
          const ignore = sb.params.ignore && $groupEl.is(sb.params.ignore);
          // eslint-disable-next-line
          const notHidden = $groupEl.find(sb.params.searchItem).filter((index, el) => {
            return !$(el).hasClass('hidden-by-searchbar');
          });
          if (notHidden.length === 0 && !ignore) {
            $groupEl.addClass('hidden-by-searchbar');
          } else {
            $groupEl.removeClass('hidden-by-searchbar');
          }
        });
      }
    }

    if (foundItems.length === 0) {
      if ($notFoundEl) $notFoundEl.show();
      if ($foundEl) $foundEl.hide();
    } else {
      if ($notFoundEl) $notFoundEl.hide();
      if ($foundEl) $foundEl.show();
    }
    if (isVirtualList && sb.virtualList) {
      sb.virtualList.filterItems(foundItems);
    }

    $el.trigger('searchbar:search', { query, previousQuery: sb.previousQuery, foundItems });
    sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery, foundItems);

    return sb;
  }

  init() {
    const sb = this;
    if (sb.expandable && sb.$el) sb.$el.addClass('searchbar-expandable');
    if (sb.inline && sb.$el) sb.$el.addClass('searchbar-inline');
    sb.attachEvents();
  }

  destroy() {
    const sb = this;
    sb.emit('local::beforeDestroy searchbarBeforeDestroy', sb);
    sb.$el.trigger('searchbar:beforedestroy');
    sb.detachEvents();
    if (sb.$el[0]) {
      sb.$el[0].f7Searchbar = null;
      delete sb.$el[0].f7Searchbar;
    }
    Utils.deleteProps(sb);
  }
}

var Searchbar$1 = {
  name: 'searchbar',
  static: {
    Searchbar,
  },
  create() {
    const app = this;
    app.searchbar = ConstructorMethods({
      defaultSelector: '.searchbar',
      constructor: Searchbar,
      app,
      domProp: 'f7Searchbar',
      addMethods: 'clear enable disable toggle search'.split(' '),
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.searchbar-init').each((index, searchbarEl) => {
        const $searchbarEl = $(searchbarEl);
        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
      });
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find('.searchbar-init').each((index, searchbarEl) => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.searchbar-init').each((index, searchbarEl) => {
        const $searchbarEl = $(searchbarEl);
        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
      });
      if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.searchbar-init').each((index, searchbarEl) => {
          const $searchbarEl = $(searchbarEl);
          app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
        });
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.searchbar-init').each((index, searchbarEl) => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });
      if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.searchbar-init').each((index, searchbarEl) => {
          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
            searchbarEl.f7Searchbar.destroy();
          }
        });
      }
    },
  },
  clicks: {
    '.searchbar-clear': function clear($clickedEl, data = {}) {
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.clear();
    },
    '.searchbar-enable': function enable($clickedEl, data = {}) {
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.enable(true);
    },
    '.searchbar-disable': function disable($clickedEl, data = {}) {
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.disable();
    },
    '.searchbar-toggle': function toggle($clickedEl, data = {}) {
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.toggle();
    },
  },
  vnode: {
    'searchbar-init': {
      insert(vnode) {
        const app = this;
        const searchbarEl = vnode.elm;
        const $searchbarEl = $(searchbarEl);
        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
      },
      destroy(vnode) {
        const searchbarEl = vnode.elm;
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      },
    },
  },
};

class Messages extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const m = this;

    const defaults = {
      autoLayout: true,
      messages: [],
      newMessagesFirst: false,
      scrollMessages: true,
      scrollMessagesOnEdge: true,
      firstMessageRule: undefined,
      lastMessageRule: undefined,
      tailMessageRule: undefined,
      sameNameMessageRule: undefined,
      sameHeaderMessageRule: undefined,
      sameFooterMessageRule: undefined,
      sameAvatarMessageRule: undefined,
      customClassMessageRule: undefined,
      renderMessage: undefined,
    };

    // Extend defaults with modules params
    m.useModulesParams(defaults);

    m.params = Utils.extend(defaults, params);

    const $el = $(params.el).eq(0);
    if ($el.length === 0) return m;

    if ($el[0].f7Messages) return $el[0].f7Messages;

    $el[0].f7Messages = m;

    const $pageContentEl = $el.closest('.page-content').eq(0);

    Utils.extend(m, {
      messages: m.params.messages,
      $el,
      el: $el[0],
      $pageContentEl,
      pageContentEl: $pageContentEl[0],

    });
    // Install Modules
    m.useModules();

    // Init
    m.init();

    return m;
  }
  // eslint-disable-next-line
  getMessageData(messageEl) {
    const $messageEl = $(messageEl);
    const data = {
      name: $messageEl.find('.message-name').html(),
      header: $messageEl.find('.message-header').html(),
      textHeader: $messageEl.find('.message-text-header').html(),
      textFooter: $messageEl.find('.message-text-footer').html(),
      footer: $messageEl.find('.message-footer').html(),
      isTitle: $messageEl.hasClass('messages-title'),
      type: $messageEl.hasClass('message-sent') ? 'sent' : 'received',
      text: $messageEl.find('.message-text').html(),
      image: $messageEl.find('.message-image').html(),
      imageSrc: $messageEl.find('.message-image img').attr('src'),
      typing: $messageEl.hasClass('message-typing'),
    };
    if (data.isTitle) {
      data.text = $messageEl.html();
    }
    if (data.text && data.textHeader) {
      data.text = data.text.replace(`<div class="message-text-header">${data.textHeader}</div>`, '');
    }
    if (data.text && data.textFooter) {
      data.text = data.text.replace(`<div class="message-text-footer">${data.textFooter}</div>`, '');
    }
    let avatar = $messageEl.find('.message-avatar').css('background-image');
    if (avatar === 'none' || avatar === '') avatar = undefined;
    if (avatar && typeof avatar === 'string') {
      avatar = avatar.replace('url(', '').replace(')', '').replace(/"/g, '').replace(/'/g, '');
    } else {
      avatar = undefined;
    }
    data.avatar = avatar;

    return data;
  }

  getMessagesData() {
    const m = this;
    const data = [];
    m.$el.find('.message, .messages-title').each((index, messageEl) => {
      data.push(m.getMessageData(messageEl));
    });
    return data;
  }

  renderMessage(messageToRender) {
    const m = this;
    const message = Utils.extend({
      type: 'sent',
      attrs: {},
    }, messageToRender);
    if (m.params.renderMessage) {
      return m.params.renderMessage.call(m, message);
    }
    if (message.isTitle) {
      return `<div class="messages-title">${message.text}</div>`;
    }
    const attrs = Object.keys(message.attrs).map(attr => `${attr}="${message.attrs[attr]}"`).join(' ');
    return `
      <div class="message message-${message.type} ${message.isTyping ? 'message-typing' : ''} ${message.cssClass || ''}" ${attrs}>
        ${message.avatar ? `
        <div class="message-avatar" style="background-image:url(${message.avatar})"></div>
        ` : ''}
        <div class="message-content">
          ${message.name ? `<div class="message-name">${message.name}</div>` : ''}
          ${message.header ? `<div class="message-header">${message.header}</div>` : ''}
          <div class="message-bubble">
            ${message.textHeader ? `<div class="message-text-header">${message.textHeader}</div>` : ''}
            ${message.image ? `<div class="message-image">${message.image}</div>` : ''}
            ${message.imageSrc && !message.image ? `<div class="message-image"><img src="${message.imageSrc}"></div>` : ''}
            ${message.text || message.isTyping ? `<div class="message-text">${message.text || ''}${message.isTyping ? '<div class="message-typing-indicator"><div></div><div></div><div></div></div>' : ''}</div>` : ''}
            ${message.textFooter ? `<div class="message-text-footer">${message.textFooter}</div>` : ''}
          </div>
          ${message.footer ? `<div class="message-footer">${message.footer}</div>` : ''}
        </div>
      </div>
    `;
  }

  renderMessages(messagesToRender = this.messages, method = this.params.newMessagesFirst ? 'prepend' : 'append') {
    const m = this;
    const html = messagesToRender.map(message => m.renderMessage(message)).join('');
    m.$el[method](html);
  }

  isFirstMessage(...args) {
    const m = this;
    if (m.params.firstMessageRule) return m.params.firstMessageRule(...args);
    return false;
  }

  isLastMessage(...args) {
    const m = this;
    if (m.params.lastMessageRule) return m.params.lastMessageRule(...args);
    return false;
  }

  isTailMessage(...args) {
    const m = this;
    if (m.params.tailMessageRule) return m.params.tailMessageRule(...args);
    return false;
  }

  isSameNameMessage(...args) {
    const m = this;
    if (m.params.sameNameMessageRule) return m.params.sameNameMessageRule(...args);
    return false;
  }

  isSameHeaderMessage(...args) {
    const m = this;
    if (m.params.sameHeaderMessageRule) return m.params.sameHeaderMessageRule(...args);
    return false;
  }

  isSameFooterMessage(...args) {
    const m = this;
    if (m.params.sameFooterMessageRule) return m.params.sameFooterMessageRule(...args);
    return false;
  }

  isSameAvatarMessage(...args) {
    const m = this;
    if (m.params.sameAvatarMessageRule) return m.params.sameAvatarMessageRule(...args);
    return false;
  }

  isCustomClassMessage(...args) {
    const m = this;
    if (m.params.customClassMessageRule) return m.params.customClassMessageRule(...args);
    return undefined;
  }

  layout() {
    const m = this;
    m.$el.find('.message, .messages-title').each((index, messageEl) => {
      const $messageEl = $(messageEl);
      if (!m.messages) {
        m.messages = m.getMessagesData();
      }
      const classes = [];
      const message = m.messages[index];
      const previousMessage = m.messages[index - 1];
      const nextMessage = m.messages[index + 1];
      if (m.isFirstMessage(message, previousMessage, nextMessage)) {
        classes.push('message-first');
      }
      if (m.isLastMessage(message, previousMessage, nextMessage)) {
        classes.push('message-last');
      }
      if (m.isTailMessage(message, previousMessage, nextMessage)) {
        classes.push('message-tail');
      }
      if (m.isSameNameMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-name');
      }
      if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-header');
      }
      if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-footer');
      }
      if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-avatar');
      }
      let customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);
      if (customMessageClasses && customMessageClasses.length) {
        if (typeof customMessageClasses === 'string') {
          customMessageClasses = customMessageClasses.split(' ');
        }
        customMessageClasses.forEach((customClass) => {
          classes.push(customClass);
        });
      }
      $messageEl.removeClass('message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar');
      classes.forEach((className) => {
        $messageEl.addClass(className);
      });
    });
  }

  clear() {
    const m = this;
    m.messages = [];
    m.$el.html('');
  }

  removeMessage(messageToRemove, layout = true) {
    const m = this;
    // Index or El
    let index;
    let $el;
    if (typeof messageToRemove === 'number') {
      index = messageToRemove;
      $el = m.$el.find('.message, .messages-title').eq(index);
    } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {
      index = m.messages.indexOf(messageToRemove);
      $el = m.$el.children().eq(index);
    } else {
      $el = $(messageToRemove);
      index = $el.index();
    }
    if ($el.length === 0) {
      return m;
    }
    $el.remove();
    m.messages.splice(index, 1);
    if (m.params.autoLayout && layout) m.layout();
    return m;
  }

  removeMessages(messagesToRemove, layout = true) {
    const m = this;
    if (Array.isArray(messagesToRemove)) {
      const messagesToRemoveEls = [];
      messagesToRemove.forEach((messageToRemoveIndex) => {
        messagesToRemoveEls.push(m.$el.find('.message, .messages-title').eq(messageToRemoveIndex));
      });
      messagesToRemoveEls.forEach((messageToRemove) => {
        m.removeMessage(messageToRemove, false);
      });
    } else {
      $(messagesToRemove).each((index, messageToRemove) => {
        m.removeMessage(messageToRemove, false);
      });
    }
    if (m.params.autoLayout && layout) m.layout();
    return m;
  }

  addMessage(...args) {
    const m = this;
    let messageToAdd;
    let animate;
    let method;
    if (typeof args[1] === 'boolean') {
      [messageToAdd, animate, method] = args;
    } else {
      [messageToAdd, method, animate] = args;
    }
    if (typeof animate === 'undefined') {
      animate = true;
    }
    if (typeof method === 'undefined') {
      method = m.params.newMessagesFirst ? 'prepend' : 'append';
    }

    return m.addMessages([messageToAdd], animate, method);
  }

  addMessages(...args) {
    const m = this;
    let messagesToAdd;
    let animate;
    let method;
    if (typeof args[1] === 'boolean') {
      [messagesToAdd, animate, method] = args;
    } else {
      [messagesToAdd, method, animate] = args;
    }
    if (typeof animate === 'undefined') {
      animate = true;
    }
    if (typeof method === 'undefined') {
      method = m.params.newMessagesFirst ? 'prepend' : 'append';
    }

    // Define scroll positions before new messages added
    const scrollHeightBefore = m.pageContentEl.scrollHeight;
    const heightBefore = m.pageContentEl.offsetHeight;
    const scrollBefore = m.pageContentEl.scrollTop;

    // Add message to DOM and data
    let messagesHTML = '';
    const typingMessage = m.messages.filter(el => el.isTyping)[0];
    messagesToAdd.forEach((messageToAdd) => {
      if (typingMessage) {
        if (method === 'append') {
          m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);
        } else {
          m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);
        }
      } else {
        m.messages[method === 'append' ? 'push' : 'unshift'](messageToAdd);
      }
      messagesHTML += m.renderMessage(messageToAdd);
    });
    const $messagesEls = $(messagesHTML);
    if (animate) {
      if (method === 'append' && !m.params.newMessagesFirst) {
        $messagesEls.addClass('message-appear-from-bottom');
      }
      if (method === 'prepend' && m.params.newMessagesFirst) {
        $messagesEls.addClass('message-appear-from-top');
      }
    }
    if (typingMessage) {
      if (method === 'append') {
        $messagesEls.insertBefore(m.$el.find('.message-typing'));
      } else {
        $messagesEls.insertAfter(m.$el.find('.message-typing'));
      }
    } else {
      m.$el[method]($messagesEls);
    }

    // Layout
    if (m.params.autoLayout) m.layout();

    if (method === 'prepend' && !typingMessage) {
      m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);
    }

    if (m.params.scrollMessages && ((method === 'append' && !m.params.newMessagesFirst) || (method === 'prepend' && m.params.newMessagesFirst && !typingMessage))) {
      if (m.params.scrollMessagesOnEdge) {
        let onEdge = false;
        if (m.params.newMessagesFirst && scrollBefore === 0) {
          onEdge = true;
        }
        if (!m.params.newMessagesFirst && (scrollBefore - (scrollHeightBefore - heightBefore) >= -10)) {
          onEdge = true;
        }
        if (onEdge) m.scroll(animate ? undefined : 0);
      } else {
        m.scroll(animate ? undefined : 0);
      }
    }

    return m;
  }

  showTyping(message = {}) {
    const m = this;
    const typingMessage = m.messages.filter(el => el.isTyping)[0];
    if (typingMessage) {
      m.removeMessage(m.messages.indexOf(typingMessage));
    }
    m.addMessage(Utils.extend({
      type: 'received',
      isTyping: true,
    }, message));
    return m;
  }

  hideTyping() {
    const m = this;
    let typingMessageIndex;
    let typingFound;
    m.messages.forEach((message, index) => {
      if (message.isTyping) typingMessageIndex = index;
    });
    if (typeof typingMessageIndex !== 'undefined') {
      if (m.$el.find('.message').eq(typingMessageIndex).hasClass('message-typing')) {
        typingFound = true;
        m.removeMessage(typingMessageIndex);
      }
    }
    if (!typingFound) {
      const $typingMessageEl = m.$el.find('.message-typing');
      if ($typingMessageEl.length) {
        m.removeMessage($typingMessageEl);
      }
    }
    return m;
  }

  scroll(duration = 300, scrollTop) {
    const m = this;
    const currentScroll = m.pageContentEl.scrollTop;
    let newScrollTop;
    if (typeof scrollTop !== 'undefined') newScrollTop = scrollTop;
    else {
      newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;
      if (newScrollTop === currentScroll) return m;
    }
    m.$pageContentEl.scrollTop(newScrollTop, duration);
    return m;
  }

  init() {
    const m = this;
    if (!m.messages || m.messages.length === 0) {
      m.messages = m.getMessagesData();
    }
    if (m.params.messages && m.params.messages.length) {
      m.renderMessages();
    }
    if (m.params.autoLayout) m.layout();
    if (m.params.scrollMessages) m.scroll(0);
  }

  destroy() {
    const m = this;
    m.emit('local::beforeDestroy messagesBeforeDestroy', m);
    m.$el.trigger('messages:beforedestroy');
    if (m.$el[0]) {
      m.$el[0].f7Messages = null;
      delete m.$el[0].f7Messages;
    }
    Utils.deleteProps(m);
  }
}

var Messages$1 = {
  name: 'messages',
  static: {
    Messages,
  },
  create() {
    const app = this;
    app.messages = ConstructorMethods({
      defaultSelector: '.messages',
      constructor: Messages,
      app,
      domProp: 'f7Messages',
      addMethods: 'renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages'.split(' '),
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      $(tabEl).find('.messages-init').each((index, messagesEl) => {
        app.messages.destroy(messagesEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.messages-init').each((index, messagesEl) => {
        app.messages.create({ el: messagesEl });
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.messages-init').each((index, messagesEl) => {
        app.messages.destroy(messagesEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.messages-init').each((index, messagesEl) => {
        app.messages.create({ el: messagesEl });
      });
    },
  },
  vnode: {
    'messages-init': {
      insert(vnode) {
        const app = this;
        const messagesEl = vnode.elm;
        app.messages.create({ el: messagesEl });
      },
      destroy(vnode) {
        const app = this;
        const messagesEl = vnode.elm;
        app.messages.destroy(messagesEl);
      },
    },
  },
};

class Messagebar extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const messagebar = this;

    const defaults = {
      top: false,
      topOffset: 0,
      bottomOffset: 0,
      attachments: [],
      renderAttachments: undefined,
      renderAttachment: undefined,
      maxHeight: null,
      resizePage: true,
    };

    // Extend defaults with modules params
    messagebar.useModulesParams(defaults);

    messagebar.params = Utils.extend(defaults, params);

    // El
    const $el = $(messagebar.params.el);
    if ($el.length === 0) return messagebar;

    if ($el[0].f7Messagebar) return $el[0].f7Messagebar;

    $el[0].f7Messagebar = messagebar;

    // Page and PageContent
    const $pageEl = $el.parents('.page').eq(0);
    const $pageContentEl = $pageEl.find('.page-content').eq(0);

    // Area
    const $areaEl = $el.find('.messagebar-area');

    // Textarea
    let $textareaEl;
    if (messagebar.params.textareaEl) {
      $textareaEl = $(messagebar.params.textareaEl);
    } else {
      $textareaEl = $el.find('textarea');
    }

    // Attachments & Library
    const $attachmentsEl = $el.find('.messagebar-attachments');
    const $sheetEl = $el.find('.messagebar-sheet');

    if (messagebar.params.top) {
      $el.addClass('messagebar-top');
    }

    Utils.extend(messagebar, {
      $el,
      el: $el[0],
      $areaEl,
      areaEl: $areaEl[0],
      $textareaEl,
      textareaEl: $textareaEl[0],
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0],
      attachmentsVisible: $attachmentsEl.hasClass('messagebar-attachments-visible'),
      $sheetEl,
      sheetEl: $sheetEl[0],
      sheetVisible: $sheetEl.hasClass('messagebar-sheet-visible'),
      $pageEl,
      pageEl: $pageEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl,
      top: $el.hasClass('messagebar-top') || messagebar.params.top,
      attachments: [],
    });

    // Events
    function onAppResize() {
      if (messagebar.params.resizePage) {
        messagebar.resizePage();
      }
    }
    function onSubmit(e) {
      e.preventDefault();
    }
    function onAttachmentClick(e) {
      const index = $(this).index();
      if ($(e.target).closest('.messagebar-attachment-delete').length) {
        $(this).trigger('messagebar:attachmentdelete', index);
        messagebar.emit('local::attachmentDelete messagebarAttachmentDelete', messagebar, this, index);
      } else {
        $(this).trigger('messagebar:attachmentclick', index);
        messagebar.emit('local::attachmentClick messagebarAttachmentClick', messagebar, this, index);
      }
    }
    function onTextareaChange() {
      messagebar.checkEmptyState();
      messagebar.$el.trigger('messagebar:change');
      messagebar.emit('local::change messagebarChange', messagebar);
    }
    function onTextareaFocus() {
      messagebar.sheetHide();
      messagebar.$el.addClass('messagebar-focused');
      messagebar.$el.trigger('messagebar:focus');
      messagebar.emit('local::focus messagebarFocus', messagebar);
    }
    function onTextareaBlur() {
      messagebar.$el.removeClass('messagebar-focused');
      messagebar.$el.trigger('messagebar:blur');
      messagebar.emit('local::blur messagebarBlur', messagebar);
    }

    messagebar.attachEvents = function attachEvents() {
      $el.on('textarea:resize', onAppResize);
      $el.on('submit', onSubmit);
      $el.on('click', '.messagebar-attachment', onAttachmentClick);
      $textareaEl.on('change input', onTextareaChange);
      $textareaEl.on('focus', onTextareaFocus);
      $textareaEl.on('blur', onTextareaBlur);
      app.on('resize', onAppResize);
    };
    messagebar.detachEvents = function detachEvents() {
      $el.off('textarea:resize', onAppResize);
      $el.off('submit', onSubmit);
      $el.off('click', '.messagebar-attachment', onAttachmentClick);
      $textareaEl.off('change input', onTextareaChange);
      $textareaEl.off('focus', onTextareaFocus);
      $textareaEl.off('blur', onTextareaBlur);
      app.off('resize', onAppResize);
    };


    // Install Modules
    messagebar.useModules();

    // Init
    messagebar.init();

    return messagebar;
  }

  focus() {
    const messagebar = this;
    messagebar.$textareaEl.focus();
    return messagebar;
  }

  blur() {
    const messagebar = this;
    messagebar.$textareaEl.blur();
    return messagebar;
  }

  clear() {
    const messagebar = this;
    messagebar.$textareaEl.val('').trigger('change');
    return messagebar;
  }

  getValue() {
    const messagebar = this;
    return messagebar.$textareaEl.val().trim();
  }

  setValue(value) {
    const messagebar = this;
    messagebar.$textareaEl.val(value).trigger('change');
    return messagebar;
  }

  setPlaceholder(placeholder) {
    const messagebar = this;
    messagebar.$textareaEl.attr('placeholder', placeholder);
    return messagebar;
  }

  resizePage() {
    const messagebar = this;
    const {
      params,
      $el,
      top,
      $pageEl,
      $pageContentEl,
      $areaEl,
      $textareaEl,
      $sheetEl,
      $attachmentsEl,
    } = messagebar;
    const elHeight = $el[0].offsetHeight;
    let maxHeight = params.maxHeight;
    if (top) ; else {
      const currentPaddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
      const requiredPaddingBottom = elHeight + params.bottomOffset;
      if (requiredPaddingBottom !== currentPaddingBottom && $pageContentEl.length) {
        const currentPaddingTop = parseInt($pageContentEl.css('padding-top'), 10);
        const pageScrollHeight = $pageContentEl[0].scrollHeight;
        const pageOffsetHeight = $pageContentEl[0].offsetHeight;
        const pageScrollTop = $pageContentEl[0].scrollTop;
        const scrollOnBottom = (pageScrollTop === pageScrollHeight - pageOffsetHeight);
        if (!maxHeight) {
          maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css('margin-top'), 10) - parseInt($areaEl.css('margin-bottom'), 10);
        }
        $textareaEl.css('max-height', `${maxHeight}px`);
        $pageContentEl.css('padding-bottom', `${requiredPaddingBottom}px`);
        if (scrollOnBottom) {
          $pageContentEl.scrollTop($pageContentEl[0].scrollHeight - pageOffsetHeight);
        }
        $el.trigger('messagebar:resizepage');
        messagebar.emit('local::resizePage messagebarResizePage', messagebar);
      }
    }
  }

  checkEmptyState() {
    const messagebar = this;
    const { $el, $textareaEl } = messagebar;
    const value = $textareaEl.val().trim();
    if (value && value.length) {
      $el.addClass('messagebar-with-value');
    } else {
      $el.removeClass('messagebar-with-value');
    }
  }

  attachmentsCreate(innerHTML = '') {
    const messagebar = this;
    const $attachmentsEl = $(`<div class="messagebar-attachments">${innerHTML}</div>`);
    $attachmentsEl.insertBefore(messagebar.$textareaEl);
    Utils.extend(messagebar, {
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0],
    });
    return messagebar;
  }

  attachmentsShow(innerHTML = '') {
    const messagebar = this;
    messagebar.$attachmentsEl = messagebar.$el.find('.messagebar-attachments');
    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(innerHTML);
    }
    messagebar.$el.addClass('messagebar-attachments-visible');
    messagebar.attachmentsVisible = true;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }

  attachmentsHide() {
    const messagebar = this;
    messagebar.$el.removeClass('messagebar-attachments-visible');
    messagebar.attachmentsVisible = false;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }

  attachmentsToggle() {
    const messagebar = this;
    if (messagebar.attachmentsVisible) {
      messagebar.attachmentsHide();
    } else {
      messagebar.attachmentsShow();
    }
    return messagebar;
  }

  renderAttachment(attachment) {
    const messagebar = this;
    if (messagebar.params.renderAttachment) {
      return messagebar.params.renderAttachment.call(messagebar, attachment);
    }
    return `
      <div class="messagebar-attachment">
        <img src="${attachment}">
        <span class="messagebar-attachment-delete"></span>
      </div>
    `;
  }

  renderAttachments() {
    const messagebar = this;
    let html;
    if (messagebar.params.renderAttachments) {
      html = messagebar.params.renderAttachments.call(messagebar, messagebar.attachments);
    } else {
      html = `${messagebar.attachments.map(attachment => messagebar.renderAttachment(attachment)).join('')}`;
    }
    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(html);
    } else {
      messagebar.$attachmentsEl.html(html);
    }
  }

  sheetCreate(innerHTML = '') {
    const messagebar = this;
    const $sheetEl = $(`<div class="messagebar-sheet">${innerHTML}</div>`);
    messagebar.$el.append($sheetEl);
    Utils.extend(messagebar, {
      $sheetEl,
      sheetEl: $sheetEl[0],
    });
    return messagebar;
  }

  sheetShow(innerHTML = '') {
    const messagebar = this;
    messagebar.$sheetEl = messagebar.$el.find('.messagebar-sheet');
    if (messagebar.$sheetEl.length === 0) {
      messagebar.sheetCreate(innerHTML);
    }
    messagebar.$el.addClass('messagebar-sheet-visible');
    messagebar.sheetVisible = true;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }

  sheetHide() {
    const messagebar = this;
    messagebar.$el.removeClass('messagebar-sheet-visible');
    messagebar.sheetVisible = false;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }

  sheetToggle() {
    const messagebar = this;
    if (messagebar.sheetVisible) {
      messagebar.sheetHide();
    } else {
      messagebar.sheetShow();
    }
    return messagebar;
  }

  init() {
    const messagebar = this;
    messagebar.attachEvents();
    messagebar.checkEmptyState();
    return messagebar;
  }

  destroy() {
    const messagebar = this;
    messagebar.emit('local::beforeDestroy messagebarBeforeDestroy', messagebar);
    messagebar.$el.trigger('messagebar:beforedestroy');
    messagebar.detachEvents();
    if (messagebar.$el[0]) {
      messagebar.$el[0].f7Messagebar = null;
      delete messagebar.$el[0].f7Messagebar;
    }
    Utils.deleteProps(messagebar);
  }
}

var Messagebar$1 = {
  name: 'messagebar',
  static: {
    Messagebar,
  },
  create() {
    const app = this;
    app.messagebar = ConstructorMethods({
      defaultSelector: '.messagebar',
      constructor: Messagebar,
      app,
      domProp: 'f7Messagebar',
      addMethods: 'clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle'.split(' '),
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      $(tabEl).find('.messagebar-init').each((index, messagebarEl) => {
        app.messagebar.destroy(messagebarEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.messagebar-init').each((index, messagebarEl) => {
        app.messagebar.create(Utils.extend({ el: messagebarEl }, $(messagebarEl).dataset()));
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.messagebar-init').each((index, messagebarEl) => {
        app.messagebar.destroy(messagebarEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.messagebar-init').each((index, messagebarEl) => {
        app.messagebar.create(Utils.extend({ el: messagebarEl }, $(messagebarEl).dataset()));
      });
    },
  },
  vnode: {
    'messagebar-init': {
      insert(vnode) {
        const app = this;
        const messagebarEl = vnode.elm;
        app.messagebar.create(Utils.extend({ el: messagebarEl }, $(messagebarEl).dataset()));
      },
      destroy(vnode) {
        const app = this;
        const messagebarEl = vnode.elm;
        app.messagebar.destroy(messagebarEl);
      },
    },
  },
};

function updateSize () {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== 'undefined') {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined') {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
    return;
  }

  // Subtract paddings
  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

  Utils.extend(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height,
  });
}

function updateSlides () {
  const swiper = this;
  const params = swiper.params;

  const {
    $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];

  function slidesForMargin(slideIndex) {
    if (!params.cssMode) return true;
    if (slideIndex === slides.length - 1) {
      return false;
    }
    return true;
  }

  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.snapGrid.length;

  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
  }

  swiper.virtualSize = -spaceBetween;

  // reset margins
  if (rtl) slides.css({ marginLeft: '', marginTop: '' });
  else slides.css({ marginRight: '', marginBottom: '' });

  let slidesNumberEvenToRows;
  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }
    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  }

  // Calc slides
  let slideSize;
  const slidesPerColumn = params.slidesPerColumn;
  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);
    if (params.slidesPerColumn > 1) {
      // Set slides order
      let newSlideOrderIndex;
      let column;
      let row;
      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
        const groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
        const slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
        const columnsInGroup = groupIndex === 0
          ? params.slidesPerGroup
          : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = (slideIndexInGroup - row * columnsInGroup) + groupIndex * params.slidesPerGroup;

        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
        slide
          .css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex,
          });
      } else if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - (column * slidesPerColumn);
        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
          row += 1;
          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - (row * slidesPerRow);
      }
      slide.css(
        `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,
        (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)
      );
    }
    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      const slideStyles = win.getComputedStyle(slide[0], null);
      const currentTransform = slide[0].style.transform;
      const currentWebKitTransform = slide[0].style.webkitTransform;
      if (currentTransform) {
        slide[0].style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal()
          ? slide.outerWidth(true)
          : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        if (swiper.isHorizontal()) {
          const width = parseFloat(slideStyles.getPropertyValue('width'));
          const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
          const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
          const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
          const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box') {
            slideSize = width + marginLeft + marginRight;
          } else {
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
          }
        } else {
          const height = parseFloat(slideStyles.getPropertyValue('height'));
          const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
          const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
          const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
          const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box') {
            slideSize = height + marginTop + marginBottom;
          } else {
            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
          }
        }
      }
      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        if (swiper.isHorizontal()) {
          slides[i].style.width = `${slideSize}px`;
        } else {
          slides[i].style.height = `${slideSize}px`;
        }
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);


    if (params.centeredSlides) {
      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;

    prevSlideSize = slideSize;

    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  let newSlidesGrid;

  if (
    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
  }
  if (params.setWrapperSize) {
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
  }

  if (params.slidesPerColumn > 1) {
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
    if (params.centeredSlides) {
      newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid = newSlidesGrid;
    }
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    if (swiper.isHorizontal()) {
      if (rtl) slides.filter(slidesForMargin).css({ marginLeft: `${spaceBetween}px` });
      else slides.filter(slidesForMargin).css({ marginRight: `${spaceBetween}px` });
    } else slides.filter(slidesForMargin).css({ marginBottom: `${spaceBetween}px` });
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  Utils.extend(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid,
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}

function updateAutoHeight (speed) {
  const swiper = this;
  const activeSlides = [];
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each((index, slide) => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length) break;
        activeSlides.push(swiper.slides.eq(index)[0]);
      }
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
}

function updateSlidesOffset () {
  const swiper = this;
  const slides = swiper.slides;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

function updateSlidesProgress (translate = (this && this.translate) || 0) {
  const swiper = this;
  const params = swiper.params;

  const { slides, rtlTranslate: rtl } = swiper;

  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();

  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;

  // Visible Slides
  slides.removeClass(params.slideVisibleClass);

  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    const slideProgress = (
      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
    ) / (slide.swiperSlideSize + params.spaceBetween);
    if (params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) {
      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1)
                || (slideAfter > 1 && slideAfter <= swiper.size)
                || (slideBefore <= 0 && slideAfter >= swiper.size);
      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
  }
  swiper.visibleSlides = $(swiper.visibleSlides);
}

function updateProgress (translate) {
  const swiper = this;
  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = (swiper && swiper.translate && (swiper.translate * multiplier)) || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let { progress, isBeginning, isEnd } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / (translatesDiff);
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Utils.extend(swiper, {
    progress,
    isBeginning,
    isEnd,
  });

  if (params.watchSlidesProgress || params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

function updateSlidesClasses () {
  const swiper = this;

  const {
    slides, params, $wrapperEl, activeIndex, realIndex,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;

  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);

  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }

  // Active classes
  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    }
  }
  // Next Slide
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  // Prev Slide
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    }
  }
}

function updateActiveIndex (newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }

  // Get real index
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

  Utils.extend(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex,
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}

function updateClickedSlide (e) {
  const swiper = this;
  const params = swiper.params;
  const slide = $(e.target).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) slideFound = true;
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = $(slide).index();
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};

function getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;

  const {
    params, rtlTranslate: rtl, translate, $wrapperEl,
  } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }

  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;

  return currentTranslate || 0;
}

function setTranslate (translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress,
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate () {
  return (-this.snapGrid[0]);
}

function maxTranslate () {
  return (-this.snapGrid[this.snapGrid.length - 1]);
}

function translateTo (translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;

  const {
    params,
    wrapperEl,
  } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
  else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
  else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: -newTranslate,
          behavior: 'smooth',
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      }
    }
    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}

var translate = {
  getTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo,
};

function setTransition (duration, byController) {
  const swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}

function transitionStart (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, params, previousIndex } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }
    swiper.emit('slideChangeTransitionStart');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}

function transitionEnd$1 (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, previousIndex, params } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }
    swiper.emit('slideChangeTransitionEnd');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}

var transition$1 = {
  setTransition,
  transitionStart,
  transitionEnd: transitionEnd$1,
};

function slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;

  const {
    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl,
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  const translate = -snapGrid[snapIndex];

  // Update progress
  swiper.updateProgress(translate);

  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  let direction;
  if (slideIndex > activeIndex) direction = 'next';
  else if (slideIndex < activeIndex) direction = 'prev';
  else direction = 'reset';


  // Update Index
  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    let t = -translate;
    if (rtl) {
      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
    }
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: t,
          behavior: 'smooth',
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
    }
    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}

function slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let newIndex = index;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideNext (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const { params, animating } = swiper;
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params, animating, snapGrid, slidesGrid, rtlTranslate,
  } = swiper;

  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  const normalizedSlidesGrid = slidesGrid.map((val) => normalize(val));

  const currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    snapGrid.forEach((snap) => {
      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
    });
  }
  let prevIndex;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest (speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
  const swiper = this;
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);

  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if ((translate - currentSnap) > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if ((translate - prevSnap) <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);

  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;

  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (
        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
        || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
      ) {
        swiper.loopFix();
        slideToIndex = $wrapperEl
          .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
          .eq(0)
          .index();

        Utils.nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl
        .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
        .eq(0)
        .index();

      Utils.nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide,
};

function loopCreate () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;
  // Remove duplicated slides
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();

  let slides = $wrapperEl.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = $(doc.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $wrapperEl.append(blankNode);
      }
      slides = $wrapperEl.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;

  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((index, el) => {
    const slide = $(el);
    if (index < swiper.loopedSlides) appendSlides.push(el);
    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
    slide.attr('data-swiper-slide-index', index);
  });
  for (let i = 0; i < appendSlides.length; i += 1) {
    $wrapperEl.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $wrapperEl.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

function loopFix () {
  const swiper = this;

  swiper.emit('beforeLoopFix');

  const {
    activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;

  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate();

  // Fix For Negative Oversliding
  if (activeIndex < loopedSlides) {
    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  swiper.emit('loopFix');
}

function loopDestroy () {
  const swiper = this;
  const { $wrapperEl, params, slides } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy,
};

function setGrabCursor (moving) {
  const swiper = this;
  if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
  const el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

function unsetGrabCursor () {
  const swiper = this;
  if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
  swiper.el.style.cursor = '';
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor,
};

function appendSlide (slides) {
  const swiper = this;
  const { $wrapperEl, params } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
}

function prependSlide (slides) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

function addSlide (index, slides) {
  const swiper = this;
  const { $wrapperEl, params, activeIndex } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  const baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (let i = 0; i < slidesBuffer.length; i += 1) {
    $wrapperEl.append(slidesBuffer[i]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeSlide (slidesIndexes) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides () {
  const swiper = this;

  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

var manipulation = {
  appendSlide,
  prependSlide,
  addSlide,
  removeSlide,
  removeAllSlides,
};

function onTouchStart (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  const $targetEl = $(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }
  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;
  if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (
    edgeSwipeDetection
    && ((startX <= edgeSwipeThreshold)
    || (startX >= win.screen.width - edgeSwipeThreshold))
  ) {
    return;
  }

  Utils.extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined,
  });

  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = Utils.now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  if (e.type !== 'touchstart') {
    let preventDefault = true;
    if ($targetEl.is(data.formElements)) preventDefault = false;
    if (
      doc.activeElement
      && $(doc.activeElement).is(data.formElements)
      && doc.activeElement !== $targetEl[0]
    ) {
      doc.activeElement.blur();
    }

    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if (params.touchStartForcePreventDefault || shouldPreventDefault) {
      e.preventDefault();
    }
  }
  swiper.emit('touchStart', e);
}

function onTouchMove (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches, rtlTranslate: rtl } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  if (data.isTouchEvent && e.type !== 'touchmove') return;
  const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;
    if (data.isTouched) {
      Utils.extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
      });
      data.touchStartTime = Utils.now();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (
        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
        || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
      ) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (
      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
      || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
    ) {
      return;
    }
  }
  if (data.isTouchEvent && doc.activeElement) {
    if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  if (e.targetTouches && e.targetTouches.length > 1) return;

  touches.currentX = pageX;
  touches.currentY = pageY;

  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if ((diffX * diffX) + (diffY * diffY) >= 25) {
        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;

  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;

  diff *= params.touchRatio;
  if (rtl) diff = -diff;

  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;

  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }


  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime,
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: Utils.now(),
    });
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd (event) {
  const swiper = this;
  const data = swiper.touchEventsData;

  const {
    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,
  } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = Utils.now();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = Utils.now();
  Utils.nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;

  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();

        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeModeMomentumVelocityRatio;

      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeModeMomentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;

      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;

      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        swiper.once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeModeSticky) {
          // If freeModeSticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    return;
  }

  // Find current slide
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += (i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup)) {
    const increment = (i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);
    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = (stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
      else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + increment);
      else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize () {
  const swiper = this;

  const { params, el } = swiper;

  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;

  swiper.updateSize();
  swiper.updateSlides();

  swiper.updateSlidesClasses();
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick (e) {
  const swiper = this;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll () {
  const swiper = this;
  const { wrapperEl, rtlTranslate } = swiper;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    if (rtlTranslate) {
      swiper.translate = ((wrapperEl.scrollWidth - wrapperEl.offsetWidth) - wrapperEl.scrollLeft);
    } else {
      swiper.translate = -wrapperEl.scrollLeft;
    }
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === -0) swiper.translate = 0;

  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();

  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}

let dummyEventAttached = false;
function dummyEventListener() {}

function attachEvents() {
  const swiper = this;
  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }

  swiper.onClick = onClick.bind(swiper);

  const capture = !!params.nested;

  // Touch Events
  if (!Support.touch && Support.pointerEvents) {
    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
    doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
    doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (Support.touch) {
      const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);
      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
      if (!dummyEventAttached) {
        doc.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
    }
    if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
      el.addEventListener('mousedown', swiper.onTouchStart, false);
      doc.addEventListener('mousemove', swiper.onTouchMove, capture);
      doc.addEventListener('mouseup', swiper.onTouchEnd, false);
    }
  }
  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el.addEventListener('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl.addEventListener('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
  } else {
    swiper.on('observerUpdate', onResize, true);
  }
}

function detachEvents() {
  const swiper = this;

  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  const capture = !!params.nested;

  // Touch Events
  if (!Support.touch && Support.pointerEvents) {
    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
    doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
    doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (Support.touch) {
      const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    }
    if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
      el.removeEventListener('mousedown', swiper.onTouchStart, false);
      doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
      doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
    }
  }
  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el.removeEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.removeEventListener('scroll', swiper.onScroll);
  }

  // Resize handler
  swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
}

var events = {
  attachEvents,
  detachEvents,
};

function setBreakpoint () {
  const swiper = this;
  const {
    activeIndex, initialized, loopedSlides = 0, params, $el,
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;

  // Get breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints);

  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
    if (breakpointOnlyParams) {
      ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach((param) => {
        const paramValue = breakpointOnlyParams[param];
        if (typeof paramValue === 'undefined') return;
        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
          breakpointOnlyParams[param] = 'auto';
        } else if (param === 'slidesPerView') {
          breakpointOnlyParams[param] = parseFloat(paramValue);
        } else {
          breakpointOnlyParams[param] = parseInt(paramValue, 10);
        }
      });
    }

    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = params.slidesPerColumn > 1;
    const isMultiRow = breakpointParams.slidesPerColumn > 1;
    if (wasMultiRow && !isMultiRow) {
      $el.removeClass(`${params.containerModifierClass}multirow ${params.containerModifierClass}multirow-column`);
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass(`${params.containerModifierClass}multirow`);
      if (breakpointParams.slidesPerColumnFill === 'column') {
        $el.addClass(`${params.containerModifierClass}multirow-column`);
      }
    }

    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

    if (directionChanged && initialized) {
      swiper.changeDirection();
    }

    Utils.extend(swiper.params, breakpointParams);

    Utils.extend(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
    });

    swiper.currentBreakpoint = breakpoint;

    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
    }

    swiper.emit('breakpoint', breakpointParams);
  }
}

function getBreakpoint (breakpoints) {
  // Get breakpoint for window width
  if (!breakpoints) return undefined;
  let breakpoint = false;

  const points = Object.keys(breakpoints).map((point) => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = win.innerHeight * minRatio;
      return { value, point };
    }
    return { value: point, point };
  });

  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const { point, value } = points[i];
    if (value <= win.innerWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = { setBreakpoint, getBreakpoint };

function addClasses () {
  const swiper = this;
  const {
    classNames, params, rtl, $el,
  } = swiper;
  const suffixes = [];

  suffixes.push('initialized');
  suffixes.push(params.direction);

  if (params.freeMode) {
    suffixes.push('free-mode');
  }
  if (params.autoHeight) {
    suffixes.push('autoheight');
  }
  if (rtl) {
    suffixes.push('rtl');
  }
  if (params.slidesPerColumn > 1) {
    suffixes.push('multirow');
    if (params.slidesPerColumnFill === 'column') {
      suffixes.push('multirow-column');
    }
  }
  if (Device.android) {
    suffixes.push('android');
  }
  if (Device.ios) {
    suffixes.push('ios');
  }

  if (params.cssMode) {
    suffixes.push('css-mode');
  }

  suffixes.forEach((suffix) => {
    classNames.push(params.containerModifierClass + suffix);
  });

  $el.addClass(classNames.join(' '));
}

function removeClasses () {
  const swiper = this;
  const { $el, classNames } = swiper;

  $el.removeClass(classNames.join(' '));
}

var classes = { addClasses, removeClasses };

function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
  let image;
  function onReady() {
    if (callback) callback();
  }
  const isPicture = $(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new win.Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

function preloadImages () {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');
  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }
  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(
      imageEl,
      imageEl.currentSrc || imageEl.getAttribute('src'),
      imageEl.srcset || imageEl.getAttribute('srcset'),
      imageEl.sizes || imageEl.getAttribute('sizes'),
      true,
      onReady
    );
  }
}

var images = {
  loadImage,
  preloadImages,
};

function checkOverflow() {
  const swiper = this;
  const params = swiper.params;
  const wasLocked = swiper.isLocked;
  const lastSlidePosition = swiper.slides.length > 0 && (params.slidesOffsetBefore + (params.spaceBetween * (swiper.slides.length - 1)) + ((swiper.slides[0]).offsetWidth) * swiper.slides.length);

  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
    swiper.isLocked = lastSlidePosition <= swiper.size;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked;

  // events
  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    swiper.navigation.update();
  }
}

var checkOverflow$1 = { checkOverflow };

var defaults = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  //
  preventInteractionOnTransition: false,

  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,

  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,

  // Autoheight
  autoHeight: false,

  // Set wrapper width
  setWrapperSize: false,

  // Virtual Translate
  virtualTranslate: false,

  // Effects
  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,

  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0, // in px
  slidesOffsetAfter: 0, // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,

  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,

  // Round length
  roundLengths: false,

  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,

  // Unique Navigation Elements
  uniqueNavElements: true,

  // Resistance
  resistance: true,
  resistanceRatio: 0.85,

  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,

  // Cursor
  grabCursor: false,

  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,

  // Images
  preloadImages: true,
  updateOnImagesReady: true,

  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,

  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null, // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,

  // Passive Listeners
  passiveListeners: true,

  // NS
  containerModifierClass: 'swiper-container-', // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',

  // Callbacks
  runCallbacksOnInit: true,
};

const prototypes = {
  update,
  translate,
  transition: transition$1,
  slide,
  loop,
  grabCursor,
  manipulation,
  events,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes,
  images,
};

const extendedDefaults = {};

class Swiper extends Framework7Class {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};

    params = Utils.extend({}, params);
    if (el && !params.el) params.el = el;

    super(params);

    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        if (!Swiper.prototype[protoMethod]) {
          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        }
      });
    });

    // Swiper Instance
    const swiper = this;
    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }
    Object.keys(swiper.modules).forEach((moduleName) => {
      const module = swiper.modules[moduleName];
      if (module.params) {
        const moduleParamName = Object.keys(module.params)[0];
        const moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== 'object' || moduleParams === null) return;
        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
        if (params[moduleParamName] === true) {
          params[moduleParamName] = { enabled: true };
        }
        if (
          typeof params[moduleParamName] === 'object'
          && !('enabled' in params[moduleParamName])
        ) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
      }
    });

    // Extend defaults with modules params
    const swiperParams = Utils.extend({}, defaults);
    swiper.useModulesParams(swiperParams);

    // Extend defaults with passed params
    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = Utils.extend({}, swiper.params);
    swiper.passedParams = Utils.extend({}, params);

    // Save Dom lib
    swiper.$ = $;

    // Find el
    const $el = $(swiper.params.el);
    el = $el[0];

    if (!el) {
      return undefined;
    }

    if ($el.length > 1) {
      const swipers = [];
      $el.each((index, containerEl) => {
        const newParams = Utils.extend({}, params, { el: containerEl });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }

    el.swiper = swiper;
    $el.data('swiper', swiper);

    // Find Wrapper
    let $wrapperEl;
    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
      $wrapperEl = $(el.shadowRoot.querySelector(`.${swiper.params.wrapperClass}`));
      // Children needs to return slot items
      $wrapperEl.children = (options) => $el.children(options);
    } else {
      $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);
    }
    // Extend Swiper
    Utils.extend(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],

      // Classes
      classNames: [],

      // Slides
      slides: $(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // RTL
      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box',

      // Indexes
      activeIndex: 0,
      realIndex: 0,

      //
      isBeginning: true,
      isEnd: false,

      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,

      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,

      // Touch Events
      touchEvents: (function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        let desktop = ['mousedown', 'mousemove', 'mouseup'];
        if (Support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        }
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3],
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2],
        };
        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }()),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        formElements: 'input, select, option, textarea, button, video, label',
        // Last click time
        lastClickTime: Utils.now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined,
      },

      // Clicks
      allowClick: true,

      // Touches
      allowTouchMove: swiper.params.allowTouchMove,

      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0,
      },

      // Images
      imagesToLoad: [],
      imagesLoaded: 0,

    });

    // Install Modules
    swiper.useModules();

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    return swiper;
  }

  slidesPerViewDynamic() {
    const swiper = this;
    const {
      params, slides, slidesGrid, size: swiperSize, activeIndex,
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }
    return spv;
  }

  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const { snapGrid, params } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode) {
      setTranslate();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }

  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
      return swiper;
    }

    swiper.$el
      .removeClass(`${swiper.params.containerModifierClass}${currentDirection}`)
      .addClass(`${swiper.params.containerModifierClass}${newDirection}`);

    swiper.params.direction = newDirection;

    swiper.slides.each((slideIndex, slideEl) => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });

    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();

    return swiper;
  }

  init() {
    const swiper = this;
    if (swiper.initialized) return;

    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }

    // Slide To Initial Slide
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
    }

    // Attach events
    swiper.attachEvents();

    // Init Flag
    swiper.initialized = true;

    // Emit
    swiper.emit('init');
  }

  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params, $el, $wrapperEl, slides,
    } = swiper;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');
      if (slides && slides.length) {
        slides
          .removeClass([
            params.slideVisibleClass,
            params.slideActiveClass,
            params.slideNextClass,
            params.slidePrevClass,
          ].join(' '))
          .removeAttr('style')
          .removeAttr('data-swiper-slide-index');
      }
    }

    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      swiper.$el.data('swiper', null);
      Utils.deleteProps(swiper);
    }
    swiper.destroyed = true;

    return null;
  }

  static extendDefaults(newDefaults) {
    Utils.extend(extendedDefaults, newDefaults);
  }

  static get extendedDefaults() {
    return extendedDefaults;
  }

  static get defaults() {
    return defaults;
  }

  static get Class() {
    return Framework7Class;
  }

  static get $() {
    return $;
  }
}

var Device$1 = {
  name: 'device',
  proto: {
    device: Device,
  },
  static: {
    device: Device,
  },
};

var Support$1 = {
  name: 'support',
  proto: {
    support: Support,
  },
  static: {
    support: Support,
  },
};

const Browser = (function Browser() {
  function isSafari() {
    const ua = win.navigator.userAgent.toLowerCase();
    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
  }
  return {
    isEdge: !!win.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
  };
}());

var Browser$1 = {
  name: 'browser',
  proto: {
    browser: Browser,
  },
  static: {
    browser: Browser,
  },
};

var Resize = {
  name: 'resize',
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      resize: {
        resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      // Emit resize
      win.addEventListener('resize', swiper.resize.resizeHandler);

      // Emit orientationchange
      win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy() {
      const swiper = this;
      win.removeEventListener('resize', swiper.resize.resizeHandler);
      win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
  },
};

const Observer = {
  func: win.MutationObserver || win.WebkitMutationObserver,
  attach(target, options = {}) {
    const swiper = this;

    const ObserverFunc = Observer.func;
    const observer = new ObserverFunc((mutations) => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };

      if (win.requestAnimationFrame) {
        win.requestAnimationFrame(observerUpdate);
      } else {
        win.setTimeout(observerUpdate, 0);
      }
    });

    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
    });

    swiper.observer.observers.push(observer);
  },
  init() {
    const swiper = this;
    if (!Support.observer || !swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    }
    // Observe container
    swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });

    // Observe wrapper
    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
  },
  destroy() {
    const swiper = this;
    swiper.observer.observers.forEach((observer) => {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  },
};

var Observer$1 = {
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false,
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      observer: {
        init: Observer.init.bind(swiper),
        attach: Observer.attach.bind(swiper),
        destroy: Observer.destroy.bind(swiper),
        observers: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.observer.init();
    },
    destroy() {
      const swiper = this;
      swiper.observer.destroy();
    },
  },
};

const Virtual = {
  update(force) {
    const swiper = this;
    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;
    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      renderSlide,
      offset: previousOffset,
    } = swiper.virtual;
    swiper.updateActiveIndex();
    const activeIndex = swiper.activeIndex || 0;

    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';
    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';

    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
      slidesBefore = slidesPerGroup + addSlidesAfter;
    }
    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

    Utils.extend(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset}px`);
      }
      swiper.updateProgress();
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: (function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()),
      });
      onRendered();
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo) appendIndexes.push(i);
          if (i < previousFrom) prependIndexes.push(i);
        }
      }
    }
    appendIndexes.forEach((index) => {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort((a, b) => b - a).forEach((index) => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
    onRendered();
  },
  renderSlide(slide, index) {
    const swiper = this;
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    const $slideEl = params.renderSlide
      ? $(params.renderSlide.call(swiper, slide, index))
      : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  },
  appendSlide(slides) {
    const swiper = this;
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    swiper.virtual.update(true);
  },
  prependSlide(slides) {
    const swiper = this;
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;

    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach((cachedIndex) => {
        const $cachedEl = cache[cachedIndex];
        const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
        if (cachedElIndex) {
          $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
      });
      swiper.virtual.cache = newCache;
    }
    swiper.virtual.update(true);
    swiper.slideTo(newActiveIndex, 0);
  },
  removeSlide(slidesIndexes) {
    const swiper = this;
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }
        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    swiper.virtual.update(true);
    swiper.slideTo(activeIndex, 0);
  },
  removeAllSlides() {
    const swiper = this;
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    swiper.virtual.update(true);
    swiper.slideTo(0, 0);
  },
};

var Virtual$1 = {
  name: 'virtual',
  params: {
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      addSlidesBefore: 0,
      addSlidesAfter: 0,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      virtual: {
        update: Virtual.update.bind(swiper),
        appendSlide: Virtual.appendSlide.bind(swiper),
        prependSlide: Virtual.prependSlide.bind(swiper),
        removeSlide: Virtual.removeSlide.bind(swiper),
        removeAllSlides: Virtual.removeAllSlides.bind(swiper),
        renderSlide: Virtual.renderSlide.bind(swiper),
        slides: swiper.params.virtual.slides,
        cache: {},
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
      const overwriteParams = {
        watchSlidesProgress: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);

      if (!swiper.params.initialSlide) {
        swiper.virtual.update();
      }
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.update();
    },
  },
};

const Keyboard = {
  handle(event) {
    const swiper = this;
    const { rtlTranslate: rtl } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    // Directions locks
    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40) || kc === 34)) {
      return false;
    }
    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38) || kc === 33)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (swiper.params.keyboard.onlyInViewport && (kc === 33 || kc === 34 || kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const windowWidth = win.innerWidth;
      const windowHeight = win.innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [
        [swiperOffset.left, swiperOffset.top],
        [swiperOffset.left + swiper.width, swiperOffset.top],
        [swiperOffset.left, swiperOffset.top + swiper.height],
        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
      ];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (
          point[0] >= 0 && point[0] <= windowWidth
          && point[1] >= 0 && point[1] <= windowHeight
        ) {
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (kc === 33 || kc === 34 || kc === 37 || kc === 39) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (((kc === 34 || kc === 39) && !rtl) || ((kc === 33 || kc === 37) && rtl)) swiper.slideNext();
      if (((kc === 33 || kc === 37) && !rtl) || ((kc === 34 || kc === 39) && rtl)) swiper.slidePrev();
    } else {
      if (kc === 33 || kc === 34 || kc === 38 || kc === 40) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (kc === 34 || kc === 40) swiper.slideNext();
      if (kc === 33 || kc === 38) swiper.slidePrev();
    }
    swiper.emit('keyPress', kc);
    return undefined;
  },
  enable() {
    const swiper = this;
    if (swiper.keyboard.enabled) return;
    $(doc).on('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = true;
  },
  disable() {
    const swiper = this;
    if (!swiper.keyboard.enabled) return;
    $(doc).off('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = false;
  },
};

var Keyboard$1 = {
  name: 'keyboard',
  params: {
    keyboard: {
      enabled: false,
      onlyInViewport: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      keyboard: {
        enabled: false,
        enable: Keyboard.enable.bind(swiper),
        disable: Keyboard.disable.bind(swiper),
        handle: Keyboard.handle.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.keyboard.enabled) {
        swiper.keyboard.enable();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.keyboard.enabled) {
        swiper.keyboard.disable();
      }
    },
  },
};

function isEventSupported() {
  const eventName = 'onwheel';
  let isSupported = eventName in doc;

  if (!isSupported) {
    const element = doc.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported
    && doc.implementation
    && doc.implementation.hasFeature
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    && doc.implementation.hasFeature('', '') !== true
  ) {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}
const Mousewheel = {
  lastScrollTime: Utils.now(),
  lastEventBeforeSnap: undefined,
  recentWheelEvents: [],
  event() {
    if (win.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
    return isEventSupported() ? 'wheel' : 'mousewheel';
  },
  normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;

    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if (e.shiftKey && !pX) { // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) { // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else { // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = (pX < 1) ? -1 : 1;
    }
    if (pY && !sY) {
      sY = (pY < 1) ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY,
    };
  },
  handleMouseEnter() {
    const swiper = this;
    swiper.mouseEntered = true;
  },
  handleMouseLeave() {
    const swiper = this;
    swiper.mouseEntered = false;
  },
  handle(event) {
    let e = event;
    const swiper = this;
    const params = swiper.params.mousewheel;

    if (swiper.params.cssMode) {
      e.preventDefault();
    }

    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $(swiper.params.mousewheel.eventsTarged);
    }
    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;

    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;

    const data = Mousewheel.normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;
        else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;
      else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }

    if (delta === 0) return true;

    if (params.invert) delta = -delta;

    if (!swiper.params.freeMode) {
      // Register the new event in a variable which stores the relevant data
      const newEvent = {
        time: Utils.now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event,
      };

      // Keep the most recent events
      const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }
      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent);

      // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          swiper.mousewheel.animateSlider(newEvent);
        }
      } else {
        swiper.mousewheel.animateSlider(newEvent);
      }

      // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.
      if (swiper.mousewheel.releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:

      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      const newEvent = { time: Utils.now(), delta: Math.abs(delta), direction: Math.sign(delta) };
      const { lastEventBeforeSnap } = swiper.mousewheel;
      const ignoreWheelEvents = lastEventBeforeSnap
        && newEvent.time < lastEventBeforeSnap.time + 500
        && newEvent.delta <= lastEventBeforeSnap.delta
        && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        swiper.mousewheel.lastEventBeforeSnap = undefined;

        if (swiper.params.loop) {
          swiper.loopFix();
        }
        let position = swiper.getTranslate() + (delta * params.sensitivity);
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;

        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();

        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();

        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
          swiper.updateSlidesClasses();
        }

        if (swiper.params.freeModeSticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momuntum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(swiper.mousewheel.timeout);
          swiper.mousewheel.timeout = undefined;
          const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift(); // only store the last N events
          }
          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15
              && newEvent.time - firstEvent.time < 500
              && firstEvent.delta - newEvent.delta >= 1
              && newEvent.delta <= 6
          ) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            swiper.mousewheel.lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            swiper.mousewheel.timeout = Utils.nextTick(() => {
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }
          if (!swiper.mousewheel.timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            swiper.mousewheel.timeout = Utils.nextTick(() => {
              const snapToThreshold = 0.5;
              swiper.mousewheel.lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        }

        // Emit event
        if (!ignoreWheelEvents) swiper.emit('scroll', e);

        // Stop autoplay
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
        // Return page scroll on edge positions
        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
      }
    }

    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    return false;
  },
  animateSlider(newEvent) {
    const swiper = this;
    // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).
    if (newEvent.delta >= 6 && Utils.now() - swiper.mousewheel.lastScrollTime < 60) {
      // Return false as a default
      return true;
    }
    // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        swiper.emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      swiper.emit('scroll', newEvent.raw);
    }
    // If you got here is because an animation has been triggered so store the current time
    swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();
    // Return false as a default
    return false;
  },
  releaseScroll(newEvent) {
    const swiper = this;
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }
    return false;
  },
  enable() {
    const swiper = this;
    const event = Mousewheel.event();
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
      return true;
    }
    if (!event) return false;
    if (swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $(swiper.params.mousewheel.eventsTarged);
    }
    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
    target.on(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = true;
    return true;
  },
  disable() {
    const swiper = this;
    const event = Mousewheel.event();
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
      return true;
    }
    if (!event) return false;
    if (!swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $(swiper.params.mousewheel.eventsTarged);
    }
    target.off(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = false;
    return true;
  },
};

var Mousewheel$1 = {
  name: 'mousewheel',
  params: {
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarged: 'container',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      mousewheel: {
        enabled: false,
        enable: Mousewheel.enable.bind(swiper),
        disable: Mousewheel.disable.bind(swiper),
        handle: Mousewheel.handle.bind(swiper),
        handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
        handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
        animateSlider: Mousewheel.animateSlider.bind(swiper),
        releaseScroll: Mousewheel.releaseScroll.bind(swiper),
        lastScrollTime: Utils.now(),
        lastEventBeforeSnap: undefined,
        recentWheelEvents: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
        swiper.mousewheel.disable();
      }
      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
    },
    destroy() {
      const swiper = this;
      if (swiper.params.cssMode) {
        swiper.mousewheel.enable();
      }
      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
    },
  },
};

const Navigation = {
  update() {
    // Update Navigation Buttons
    const swiper = this;
    const params = swiper.params.navigation;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        $prevEl.addClass(params.disabledClass);
      } else {
        $prevEl.removeClass(params.disabledClass);
      }
      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        $nextEl.addClass(params.disabledClass);
      } else {
        $nextEl.removeClass(params.disabledClass);
      }
      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  onPrevClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  },
  onNextClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  },
  init() {
    const swiper = this;
    const params = swiper.params.navigation;
    if (!(params.nextEl || params.prevEl)) return;

    let $nextEl;
    let $prevEl;
    if (params.nextEl) {
      $nextEl = $(params.nextEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.nextEl === 'string'
        && $nextEl.length > 1
        && swiper.$el.find(params.nextEl).length === 1
      ) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }
    if (params.prevEl) {
      $prevEl = $(params.prevEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.prevEl === 'string'
        && $prevEl.length > 1
        && swiper.$el.find(params.prevEl).length === 1
      ) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', swiper.navigation.onNextClick);
    }
    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', swiper.navigation.onPrevClick);
    }

    Utils.extend(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0],
    });
  },
  destroy() {
    const swiper = this;
    const { $nextEl, $prevEl } = swiper.navigation;
    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', swiper.navigation.onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }
    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', swiper.navigation.onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  },
};

var Navigation$1 = {
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,

      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      navigation: {
        init: Navigation.init.bind(swiper),
        update: Navigation.update.bind(swiper),
        destroy: Navigation.destroy.bind(swiper),
        onNextClick: Navigation.onNextClick.bind(swiper),
        onPrevClick: Navigation.onPrevClick.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    fromEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    destroy() {
      const swiper = this;
      swiper.navigation.destroy();
    },
    click(e) {
      const swiper = this;
      const { $nextEl, $prevEl } = swiper.navigation;
      if (
        swiper.params.navigation.hideOnClick
        && !$(e.target).is($prevEl)
        && !$(e.target).is($nextEl)
      ) {
        let isHidden;
        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          swiper.emit('navigationShow', swiper);
        } else {
          swiper.emit('navigationHide', swiper);
        }
        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    },
  },
};

const Pagination = {
  update() {
    // Render || Update Pagination bullets/items
    const swiper = this;
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    // Current/Total
    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
        current -= (slidesLength - (swiper.loopedSlides * 2));
      }
      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);
        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }
        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);
      if ($el.length > 1) {
        bullets.each((index, bullet) => {
          const $bullet = $(bullet);
          const bulletIndex = $bullet.index();
          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }
            if (bulletIndex === firstIndex) {
              $bullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
            }
            if (bulletIndex === lastIndex) {
              $bullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        const bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);
        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }
          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
              }
              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
            } else {
              $firstDisplayedBullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
              $lastDisplayedBullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          } else {
            $firstDisplayedBullet
              .prev()
              .addClass(`${params.bulletActiveClass}-prev`)
              .prev()
              .addClass(`${params.bulletActiveClass}-prev-prev`);
            $lastDisplayedBullet
              .next()
              .addClass(`${params.bulletActiveClass}-next`)
              .next()
              .addClass(`${params.bulletActiveClass}-next-next`);
          }
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
        const offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
      }
    }
    if (params.type === 'fraction') {
      $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));
      $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));
    }
    if (params.type === 'progressbar') {
      let progressbarDirection;
      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }
      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;
      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }
      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }
    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', swiper, $el[0]);
    } else {
      swiper.emit('paginationUpdate', swiper, $el[0]);
    }
    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
  },
  render() {
    // Render Container
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

    const $el = swiper.pagination.$el;
    let paginationHTML = '';
    if (params.type === 'bullets') {
      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>`
        + ' / '
        + `<span class="${params.totalClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el) return;

    let $el = $(params.el);
    if ($el.length === 0) return;

    if (
      swiper.params.uniqueNavElements
      && typeof params.el === 'string'
      && $el.length > 1
      && swiper.$el.find(params.el).length === 1
    ) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      swiper.pagination.dynamicBulletIndex = 0;
      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }
    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', `.${params.bulletClass}`, function onClick(e) {
        e.preventDefault();
        let index = $(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    Utils.extend(swiper.pagination, {
      $el,
      el: $el[0],
    });
  },
  destroy() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const $el = swiper.pagination.$el;

    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
    if (params.clickable) {
      $el.off('click', `.${params.bulletClass}`);
    }
  },
};

var Pagination$1 = {
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number) => number,
      formatFractionTotal: (number) => number,
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-', // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable', // NEW
      lockClass: 'swiper-pagination-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      pagination: {
        init: Pagination.init.bind(swiper),
        render: Pagination.render.bind(swiper),
        update: Pagination.update.bind(swiper),
        destroy: Pagination.destroy.bind(swiper),
        dynamicBulletIndex: 0,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy() {
      const swiper = this;
      swiper.pagination.destroy();
    },
    click(e) {
      const swiper = this;
      if (
        swiper.params.pagination.el
        && swiper.params.pagination.hideOnClick
        && swiper.pagination.$el.length > 0
        && !$(e.target).hasClass(swiper.params.pagination.bulletClass)
      ) {
        const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
        if (isHidden === true) {
          swiper.emit('paginationShow', swiper);
        } else {
          swiper.emit('paginationHide', swiper);
        }
        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    },
  },
};

const Scrollbar = {
  setTranslate() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const { scrollbar, rtlTranslate: rtl, progress } = swiper;
    const {
      dragSize, trackSize, $dragEl, $el,
    } = scrollbar;
    const params = swiper.params.scrollbar;

    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      $dragEl[0].style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.timeout);
      $el[0].style.opacity = 1;
      swiper.scrollbar.timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  },
  setTransition(duration) {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  },
  updateSize() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;

    const { scrollbar } = swiper;
    const { $dragEl, $el } = scrollbar;

    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

    const divider = swiper.size / swiper.virtualSize;
    const moveDivider = divider * (trackSize / swiper.size);
    let dragSize;
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }
    Utils.extend(scrollbar, {
      trackSize,
      divider,
      moveDivider,
      dragSize,
    });
    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
  },
  getPointerPosition(e) {
    const swiper = this;
    if (swiper.isHorizontal()) {
      return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientX : e.clientX);
    }
    return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientY : e.clientY);
  },
  setDragPosition(e) {
    const swiper = this;
    const { scrollbar, rtlTranslate: rtl } = swiper;
    const {
      $el,
      dragSize,
      trackSize,
      dragStartPos,
    } = scrollbar;

    let positionRatio;
    positionRatio = ((scrollbar.getPointerPosition(e)) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top']
      - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  },
  onDragStart(e) {
    const swiper = this;
    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;
    swiper.scrollbar.isTouched = true;
    swiper.scrollbar.dragStartPos = (e.target === $dragEl[0] || e.target === $dragEl)
      ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();

    $wrapperEl.transition(100);
    $dragEl.transition(100);
    scrollbar.setDragPosition(e);

    clearTimeout(swiper.scrollbar.dragTimeout);

    $el.transition(0);
    if (params.hide) {
      $el.css('opacity', 1);
    }
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', 'none');
    }
    swiper.emit('scrollbarDragStart', e);
  },
  onDragMove(e) {
    const swiper = this;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    scrollbar.setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    swiper.emit('scrollbarDragMove', e);
  },
  onDragEnd(e) {
    const swiper = this;

    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    swiper.scrollbar.isTouched = false;
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', '');
      $wrapperEl.transition('');
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.dragTimeout);
      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }
    swiper.emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  },
  enableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!Support.touch) {
      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  disableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!Support.touch) {
      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const { scrollbar, $el: $swiperEl } = swiper;
    const params = swiper.params.scrollbar;

    let $el = $(params.el);
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
    if ($dragEl.length === 0) {
      $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }

    Utils.extend(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0],
    });

    if (params.draggable) {
      scrollbar.enableDraggable();
    }
  },
  destroy() {
    const swiper = this;
    swiper.scrollbar.disableDraggable();
  },
};

var Scrollbar$1 = {
  name: 'scrollbar',
  params: {
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      scrollbar: {
        init: Scrollbar.init.bind(swiper),
        destroy: Scrollbar.destroy.bind(swiper),
        updateSize: Scrollbar.updateSize.bind(swiper),
        setTranslate: Scrollbar.setTranslate.bind(swiper),
        setTransition: Scrollbar.setTransition.bind(swiper),
        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
        getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
        onDragStart: Scrollbar.onDragStart.bind(swiper),
        onDragMove: Scrollbar.onDragMove.bind(swiper),
        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
        isTouched: false,
        timeout: null,
        dragTimeout: null,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.scrollbar.init();
      swiper.scrollbar.updateSize();
      swiper.scrollbar.setTranslate();
    },
    update() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    resize() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    observerUpdate() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    setTranslate() {
      const swiper = this;
      swiper.scrollbar.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      swiper.scrollbar.setTransition(duration);
    },
    destroy() {
      const swiper = this;
      swiper.scrollbar.destroy();
    },
  },
};

const Parallax = {
  setTransform(el, progress) {
    const swiper = this;
    const { rtl } = swiper;

    const $el = $(el);
    const rtlFactor = rtl ? -1 : 1;

    const p = $el.attr('data-swiper-parallax') || '0';
    let x = $el.attr('data-swiper-parallax-x');
    let y = $el.attr('data-swiper-parallax-y');
    const scale = $el.attr('data-swiper-parallax-scale');
    const opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if ((x).indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if ((y).indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
      $el[0].style.opacity = currentOpacity;
    }
    if (typeof scale === 'undefined' || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  },
  setTranslate() {
    const swiper = this;
    const {
      $el, slides, progress, snapGrid,
    } = swiper;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
      .each((index, el) => {
        swiper.parallax.setTransform(el, progress);
      });
    slides.each((slideIndex, slideEl) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
        .each((index, el) => {
          swiper.parallax.setTransform(el, slideProgress);
        });
    });
  },
  setTransition(duration = this.params.speed) {
    const swiper = this;
    const { $el } = swiper;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
      .each((index, parallaxEl) => {
        const $parallaxEl = $(parallaxEl);
        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0) parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
  },
};

var Parallax$1 = {
  name: 'parallax',
  params: {
    parallax: {
      enabled: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      parallax: {
        setTransform: Parallax.setTransform.bind(swiper),
        setTranslate: Parallax.setTranslate.bind(swiper),
        setTransition: Parallax.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    init() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTransition(duration);
    },
  },
};

const Zoom = {
  // Calc Scale From Multi-touches
  getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
    return distance;
  },
  // Events
  onGestureStart(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    zoom.fakeGestureTouched = false;
    zoom.fakeGestureMoved = false;
    if (!Support.gestures) {
      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureTouched = true;
      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }
    if (gesture.$imageEl) {
      gesture.$imageEl.transition(0);
    }
    swiper.zoom.isScaling = true;
  },
  onGestureChange(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureMoved = true;
      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (Support.gestures) {
      zoom.scale = e.scale * zoom.currentScale;
    } else {
      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
    }
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);
    }
    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  onGestureEnd(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
        return;
      }
      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
        return;
      }
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    zoom.currentScale = zoom.scale;
    zoom.isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  },
  onTouchStart(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (Device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  },
  onTouchMove(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
      if (swiper.rtl) {
        image.startX = -image.startX;
        image.startY = -image.startY;
      }
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;

    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;

    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;

    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !zoom.isScaling) {
      if (
        swiper.isHorizontal()
        && (
          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
          || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
        )
      ) {
        image.isTouched = false;
        return;
      } if (
        !swiper.isHorizontal()
        && (
          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
          || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
        )
      ) {
        image.isTouched = false;
        return;
      }
    }
    if (e.cancelable) {
      e.preventDefault();
    }
    e.stopPropagation();

    image.isMoved = true;
    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);
    }
    if (image.currentX > image.maxX) {
      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);
    }

    if (image.currentY < image.minY) {
      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);
    }
    if (image.currentY > image.maxY) {
      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();

    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTouchEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);

    image.currentX = newPositionX;
    image.currentY = newPositionY;

    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTransitionEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      if (gesture.$imageEl) {
        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      }
      if (gesture.$imageWrapEl) {
        gesture.$imageWrapEl.transform('translate3d(0,0,0)');
      }

      zoom.scale = 1;
      zoom.currentScale = 1;

      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;
    }
  },
  // Toggle Zoom
  toggle(e) {
    const swiper = this;
    const zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoom.out();
    } else {
      // Zoom In
      zoom.in(e);
    }
  },
  in(e) {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture, image } = zoom;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);

    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left;
      offsetY = gesture.$slideEl.offset().top;
      diffX = (offsetX + (slideWidth / 2)) - touchX;
      diffY = (offsetY + (slideHeight / 2)) - touchY;

      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;

      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;

      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  out() {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture } = zoom;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    zoom.scale = 1;
    zoom.currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = undefined;
  },
  // Attach/Detach Events
  enable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
    const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

    const slideSelector = `.${swiper.params.slideClass}`;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.on('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.on('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    }

    // Move image
    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
  },
  disable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;

    swiper.zoom.enabled = false;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
    const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

    const slideSelector = `.${swiper.params.slideClass}`;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.off('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.off('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    }

    // Move image
    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
  },
};

var Zoom$1 = {
  name: 'zoom',
  params: {
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed',
    },
  },
  create() {
    const swiper = this;
    const zoom = {
      enabled: false,
      scale: 1,
      currentScale: 1,
      isScaling: false,
      gesture: {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3,
      },
      image: {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {},
      },
      velocity: {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined,
      },
    };

    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {
      zoom[methodName] = Zoom[methodName].bind(swiper);
    });
    Utils.extend(swiper, {
      zoom,
    });

    let scale = 1;
    Object.defineProperty(swiper.zoom, 'scale', {
      get() {
        return scale;
      },
      set(value) {
        if (scale !== value) {
          const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
          const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
          swiper.emit('zoomChange', value, imageEl, slideEl);
        }
        scale = value;
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.zoom.enabled) {
        swiper.zoom.enable();
      }
    },
    destroy() {
      const swiper = this;
      swiper.zoom.disable();
    },
    touchStart(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchStart(e);
    },
    touchEnd(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchEnd(e);
    },
    doubleTap(e) {
      const swiper = this;
      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        swiper.zoom.toggle(e);
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        swiper.zoom.onTransitionEnd();
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
        swiper.zoom.onTransitionEnd();
      }
    },
  },
};

const Lazy$2 = {
  loadInSlide(index, loadInDuplicate = true) {
    const swiper = this;
    const params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

    const $slideEl = isVirtual
      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`)
      : swiper.slides.eq(index);

    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images = $images.add($slideEl[0]);
    }
    if ($images.length === 0) return;

    $images.each((imageIndex, imageEl) => {
      const $imageEl = $(imageEl);
      $imageEl.addClass(params.loadingClass);

      const background = $imageEl.attr('data-background');
      const src = $imageEl.attr('data-src');
      const srcset = $imageEl.attr('data-srcset');
      const sizes = $imageEl.attr('data-sizes');
      const $pictureEl = $imageEl.parent('picture');

      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;
        if (background) {
          $imageEl.css('background-image', `url("${background}")`);
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }
          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }
          if ($pictureEl.length) {
            $pictureEl.children('source').each((sourceIndex, sourceEl) => {
              const $source = $(sourceEl);

              if ($source.attr('data-srcset')) {
                $source.attr('srcset', $source.attr('data-srcset'));
                $source.removeAttr('data-srcset');
              }
            });
          }
          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();
        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }
        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      });

      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load() {
    const swiper = this;
    const {
      $wrapperEl, params: swiperParams, slides, activeIndex,
    } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;

    let slidesPerView = swiperParams.slidesPerView;
    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
          return true;
        }
      } else if (slides[index]) return true;
      return false;
    }

    function slideIndex(slideEl) {
      if (isVirtual) {
        return $(slideEl).attr('data-swiper-slide-index');
      }
      return $(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
        const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
        swiper.lazy.loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }
    if (params.loadPrevNext) {
      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
        const amount = params.loadPrevNextAmount;
        const spv = slidesPerView;
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
        // Next Slides
        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
        // Prev Slides
        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));

        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
};

var Lazy$3 = {
  name: 'lazy',
  params: {
    lazy: {
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,

      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      lazy: {
        initialImageLoaded: false,
        load: Lazy$2.load.bind(swiper),
        loadInSlide: Lazy$2.loadInSlide.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    },
    init() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        swiper.lazy.load();
      }
    },
    scroll() {
      const swiper = this;
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    resize() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    scrollbarDragMove() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.params.lazy.enabled && swiper.params.cssMode) {
        swiper.lazy.load();
      }
    },
  },
};

const Controller = {
  LinearSpline: function LinearSpline(x, y) {
    const binarySearch = (function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }());
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
    };
    return this;
  },
  // xxx: for now i will just save one spline function to to
  getInterpolateFunction(c) {
    const swiper = this;
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop
        ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
        : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  },
  setTranslate(setTranslate, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        swiper.controller.getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  },
  setTransition(duration, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          Utils.nextTick(() => {
            c.updateAutoHeight();
          });
        }
        c.$wrapperEl.transitionEnd(() => {
          if (!controlled) return;
          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  },
};
var Controller$1 = {
  name: 'controller',
  params: {
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide', // or 'container'
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      controller: {
        control: swiper.params.controller.control,
        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
        setTranslate: Controller.setTranslate.bind(swiper),
        setTransition: Controller.setTransition.bind(swiper),
      },
    });
  },
  on: {
    update() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    resize() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    setTranslate(translate, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    },
    setTransition(duration, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    },
  },
};

const History$1 = {
  init() {
    const swiper = this;
    if (!swiper.params.history) return;
    if (!win.history || !win.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    const history = swiper.history;
    history.initialized = true;
    history.paths = History$1.getPathValues();
    if (!history.paths.key && !history.paths.value) return;
    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      win.addEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  destroy() {
    const swiper = this;
    if (!swiper.params.history.replaceState) {
      win.removeEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  setHistoryPopState() {
    const swiper = this;
    swiper.history.paths = History$1.getPathValues();
    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
  },
  getPathValues() {
    const pathArray = win.location.pathname.slice(1).split('/').filter((part) => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return { key, value };
  },
  setHistory(key, index) {
    const swiper = this;
    if (!swiper.history.initialized || !swiper.params.history.enabled) return;
    const slide = swiper.slides.eq(index);
    let value = History$1.slugify(slide.attr('data-history'));
    if (!win.location.pathname.includes(key)) {
      value = `${key}/${value}`;
    }
    const currentState = win.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      win.history.replaceState({ value }, null, value);
    } else {
      win.history.pushState({ value }, null, value);
    }
  },
  slugify(text) {
    return text.toString()
      .replace(/\s+/g, '-')
      .replace(/[^\w-]+/g, '')
      .replace(/--+/g, '-')
      .replace(/^-+/, '')
      .replace(/-+$/, '');
  },
  scrollToSlide(speed, value, runCallbacks) {
    const swiper = this;
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHistory = History$1.slugify(slide.attr('data-history'));
        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  },
};

var History$2 = {
  name: 'history',
  params: {
    history: {
      enabled: false,
      replaceState: false,
      key: 'slides',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      history: {
        init: History$1.init.bind(swiper),
        setHistory: History$1.setHistory.bind(swiper),
        setHistoryPopState: History$1.setHistoryPopState.bind(swiper),
        scrollToSlide: History$1.scrollToSlide.bind(swiper),
        destroy: History$1.destroy.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.history.initialized) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.history.initialized && swiper.params.cssMode) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
  },
};

const HashNavigation = {
  onHashCange() {
    const swiper = this;
    swiper.emit('hashChange');
    const newHash = doc.location.hash.replace('#', '');
    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
      if (typeof newIndex === 'undefined') return;
      swiper.slideTo(newIndex);
    }
  },
  setHash() {
    const swiper = this;
    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
    if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
      win.history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));
      swiper.emit('hashSet');
    } else {
      const slide = swiper.slides.eq(swiper.activeIndex);
      const hash = slide.attr('data-hash') || slide.attr('data-history');
      doc.location.hash = hash || '';
      swiper.emit('hashSet');
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;
    swiper.hashNavigation.initialized = true;
    const hash = doc.location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHash = slide.attr('data-hash') || slide.attr('data-history');
        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }
    if (swiper.params.hashNavigation.watchState) {
      $(win).on('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.params.hashNavigation.watchState) {
      $(win).off('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
};
var HashNavigation$1 = {
  name: 'hash-navigation',
  params: {
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      hashNavigation: {
        initialized: false,
        init: HashNavigation.init.bind(swiper),
        destroy: HashNavigation.destroy.bind(swiper),
        setHash: HashNavigation.setHash.bind(swiper),
        onHashCange: HashNavigation.onHashCange.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.hashNavigation.initialized) {
        swiper.hashNavigation.setHash();
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
        swiper.hashNavigation.setHash();
      }
    },
  },
};

const a11y = {
  makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  makeElNotFocusable($el) {
    $el.attr('tabIndex', '-1');
    return $el;
  },
  addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterKey(e) {
    const swiper = this;
    const params = swiper.params.a11y;
    if (e.keyCode !== 13) return;
    const $targetEl = $(e.target);
    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }
      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }
    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }
      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }
    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
      $targetEl[0].click();
    }
  },
  notify(message) {
    const swiper = this;
    const notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation() {
    const swiper = this;

    if (swiper.params.loop || !swiper.navigation) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
        swiper.a11y.makeElNotFocusable($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
        swiper.a11y.makeElFocusable($prevEl);
      }
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
        swiper.a11y.makeElNotFocusable($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
        swiper.a11y.makeElFocusable($nextEl);
      }
    }
  },
  updatePagination() {
    const swiper = this;
    const params = swiper.params.a11y;
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
        const $bulletEl = $(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);
        swiper.a11y.addElRole($bulletEl, 'button');
        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
      });
    }
  },
  init() {
    const swiper = this;

    swiper.$el.append(swiper.a11y.liveRegion);

    // Navigation
    const params = swiper.params.a11y;
    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      swiper.a11y.makeElFocusable($nextEl);
      swiper.a11y.addElRole($nextEl, 'button');
      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      $nextEl.on('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      swiper.a11y.makeElFocusable($prevEl);
      swiper.a11y.addElRole($prevEl, 'button');
      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      $prevEl.on('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();

    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
};
var A11y = {
  name: 'a11y',
  params: {
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      a11y: {
        liveRegion: $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`),
      },
    });
    Object.keys(a11y).forEach((methodName) => {
      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    },
  },
};

const Autoplay = {
  run() {
    const swiper = this;
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }
    clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.timeout = Utils.nextTick(() => {
      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }
      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();
    }, delay);
  },
  start() {
    const swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop() {
    const swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }
    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause(speed) {
    const swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;
    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
    }
  },
};

var Autoplay$1 = {
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      autoplay: {
        running: false,
        paused: false,
        run: Autoplay.run.bind(swiper),
        start: Autoplay.start.bind(swiper),
        stop: Autoplay.stop.bind(swiper),
        pause: Autoplay.pause.bind(swiper),
        onVisibilityChange() {
          if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
            swiper.autoplay.pause();
          }
          if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
            swiper.autoplay.run();
            swiper.autoplay.paused = false;
          }
        },
        onTransitionEnd(e) {
          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
          swiper.autoplay.paused = false;
          if (!swiper.autoplay.running) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.run();
          }
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
      }
    },
    beforeTransitionStart(speed, internal) {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove() {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    touchEnd() {
      const swiper = this;
      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.run();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }
      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
    },
  },
};

const Fade = {
  setTranslate() {
    const swiper = this;
    const { slides } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset = $slideEl[0].swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade
        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl
        .css({
          opacity: slideOpacity,
        })
        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, $wrapperEl } = swiper;
    slides.transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      slides.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFade = {
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      fadeEffect: {
        setTranslate: Fade.setTranslate.bind(swiper),
        setTransition: Fade.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    },
  },
};

const Cube = {
  setTranslate() {
    const swiper = this;
    const {
      $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }
        $cubeShadowEl.css({ height: `${swiperWidth}px` });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + (round * 4 * swiperSize);
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = (3 * swiperSize) + (swiperSize * 4 * round);
      }
      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = (slideIndex * 90) + (progress * 90);
        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);
      }
      $slideEl.transform(transform);
      if (params.slideShadows) {
        // Set shadows
        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }
    $wrapperEl.css({
      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,
      'transform-origin': `50% 50% -${swiperSize / 2}px`,
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
        const multiplier = 1.5 - (
          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
          + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
        );
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }
    const zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
    $wrapperEl
      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
  },
  setTransition(duration) {
    const swiper = this;
    const { $el, slides } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  },
};

var EffectCube = {
  name: 'effect-cube',
  params: {
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      cubeEffect: {
        setTranslate: Cube.setTranslate.bind(swiper),
        setTransition: Cube.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTransition(duration);
    },
  },
};

const Flip = {
  setTranslate() {
    const swiper = this;
    const { slides, rtlTranslate: rtl } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }
      const offset = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (swiper.params.flipEffect.slideShadows) {
        // Set shadows
        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = $(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = $(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
      $slideEl
        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, activeIndex, $wrapperEl } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      // eslint-disable-next-line
      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFlip = {
  name: 'effect-flip',
  params: {
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      flipEffect: {
        setTranslate: Flip.setTranslate.bind(swiper),
        setTransition: Flip.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTransition(duration);
    },
  },
};

const Coverflow = {
  setTranslate() {
    const swiper = this;
    const {
      width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);

      let stretch = params.stretch;
      // Allow percentage to make a relative stretch for responsive sliders
      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = ((parseFloat(params.stretch) / 100) * slideSize);
      }
      let translateY = isHorizontal ? 0 : stretch * (offsetMultiplier);
      let translateX = isHorizontal ? stretch * (offsetMultiplier) : 0;

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;

      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;

      $slideEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append($shadowBeforeEl);
        }
        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append($shadowAfterEl);
        }
        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
      }
    }

    // Set correct perspective for IE10
    if (Support.pointerEvents || Support.prefixedPointerEvents) {
      const ws = $wrapperEl[0].style;
      ws.perspectiveOrigin = `${center}px 50%`;
    }
  },
  setTransition(duration) {
    const swiper = this;
    swiper.slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
  },
};

var EffectCoverflow = {
  name: 'effect-coverflow',
  params: {
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      modifier: 1,
      slideShadows: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      coverflowEffect: {
        setTranslate: Coverflow.setTranslate.bind(swiper),
        setTransition: Coverflow.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;

      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);

      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTransition(duration);
    },
  },
};

const Thumbs = {
  init() {
    const swiper = this;
    const { thumbs: thumbsParams } = swiper.params;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Utils.extend(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
      Utils.extend(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
    } else if (Utils.isObject(thumbsParams.swiper)) {
      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      }));
      swiper.thumbs.swiperCreated = true;
    }
    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
  },
  onThumbClick() {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      let currentIndex = swiper.activeIndex;
      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix();
        // eslint-disable-next-line
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }
      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;
      else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;
      else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
      else slideToIndex = prevIndex;
    }
    swiper.slideTo(slideToIndex);
  },
  update(initial) {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;

    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
      ? thumbsSwiper.slidesPerViewDynamic()
      : thumbsSwiper.params.slidesPerView;

    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      let currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix();
          // eslint-disable-next-line
          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        }
        // Find actual thumbs index to slide to
        const prevThumbsIndex = thumbsSwiper.slides
          .eq(currentThumbsIndex)
          .prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0)
          .index();
        const nextThumbsIndex = thumbsSwiper.slides
          .eq(currentThumbsIndex)
          .nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0)
          .index();
        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;
        else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;
        else newThumbsIndex = prevThumbsIndex;
        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }
      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }

      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex) {
          newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }

    // Activate thumbs
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }

    thumbsToActivate = Math.floor(thumbsToActivate);

    thumbsSwiper.slides.removeClass(thumbActiveClass);
    if (thumbsSwiper.params.loop || (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
      }
    }
  },
};
var Thumbs$1 = {
  name: 'thumbs',
  params: {
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-container-thumbs',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      thumbs: {
        swiper: null,
        init: Thumbs.init.bind(swiper),
        update: Thumbs.update.bind(swiper),
        onThumbClick: Thumbs.onThumbClick.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      const { thumbs } = swiper.params;
      if (!thumbs || !thumbs.swiper) return;
      swiper.thumbs.init();
      swiper.thumbs.update(true);
    },
    slideChange() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    update() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    resize() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    setTransition(duration) {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      thumbsSwiper.setTransition(duration);
    },
    beforeDestroy() {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
        thumbsSwiper.destroy();
      }
    },
  },
};

Swiper.use([
  Device$1,
  Browser$1,
  Support$1,
  Resize,
  Observer$1,
  Virtual$1,
  Keyboard$1,
  Mousewheel$1,
  Navigation$1,
  Pagination$1,
  Scrollbar$1,
  Parallax$1,
  Zoom$1,
  Lazy$3,
  Controller$1,
  History$2,
  HashNavigation$1,
  A11y,
  Autoplay$1,
  EffectFade,
  EffectCube,
  EffectFlip,
  EffectCoverflow,
  Thumbs$1,
]);

function initSwiper(swiperEl) {
  const app = this;
  const $swiperEl = $(swiperEl);
  if ($swiperEl.length === 0) return;
  if ($swiperEl[0].swiper) return;
  let initialSlide;
  let params = {};
  let isTabs;
  let isRoutableTabs;
  if ($swiperEl.hasClass('tabs-swipeable-wrap')) {
    $swiperEl
      .addClass('swiper-container')
      .children('.tabs')
      .addClass('swiper-wrapper')
      .children('.tab')
      .addClass('swiper-slide');
    initialSlide = $swiperEl.children('.tabs').children('.tab-active').index();
    isTabs = true;
    isRoutableTabs = $swiperEl.find('.tabs-routable').length > 0;
  }
  if ($swiperEl.attr('data-swiper')) {
    params = JSON.parse($swiperEl.attr('data-swiper'));
  } else if ($swiperEl[0].f7SwiperParams) {
    params = $swiperEl[0].f7SwiperParams;
  } else {
    params = $swiperEl.dataset();
    Object.keys(params).forEach((key) => {
      const value = params[key];
      if (typeof value === 'string' && value.indexOf('{') === 0 && value.indexOf('}') > 0) {
        try {
          params[key] = JSON.parse(value);
        } catch (e) {
          // not JSON
        }
      }
    });
  }
  if (typeof params.initialSlide === 'undefined' && typeof initialSlide !== 'undefined') {
    params.initialSlide = initialSlide;
  }

  const swiper = app.swiper.create($swiperEl[0], params);
  function updateSwiper() {
    swiper.update();
  }
  const $tabEl = $swiperEl.parents('.tab').filter((tabElIndex, tabEl) => {
    return $(tabEl).parent('.tabs').parent('.tabs-animated-wrap, .tabs-swipeable-wrap').length === 0;
  }).eq(0);
  $swiperEl.parents('.popup, .login-screen, .sheet-modal, .popover').on('modal:open', updateSwiper);
  $swiperEl.parents('.panel').on('panel:open', updateSwiper);
  if ($tabEl && $tabEl.length) {
    $tabEl.on('tab:show', updateSwiper);
  }

  swiper.on('beforeDestroy', () => {
    $swiperEl.parents('.popup, .login-screen, .sheet-modal, .popover').off('modal:open', updateSwiper);
    $swiperEl.parents('.panel').off('panel:open', updateSwiper);
    if ($tabEl && $tabEl.length) {
      $tabEl.off('tab:show', updateSwiper);
    }
  });
  if (isTabs) {
    swiper.on('slideChange', () => {
      if (isRoutableTabs) {
        let view = app.views.get($swiperEl.parents('.view'));
        if (!view) view = app.views.main;
        const router = view.router;
        const tabRoute = router.findTabRoute(swiper.slides.eq(swiper.activeIndex)[0]);
        if (tabRoute) {
          setTimeout(() => {
            router.navigate(tabRoute.path);
          }, 0);
        }
      } else {
        app.tab.show({
          tabEl: swiper.slides.eq(swiper.activeIndex),
        });
      }
    });
  }
}

var Swiper$1 = {
  name: 'swiper',
  static: {
    Swiper,
  },
  create() {
    const app = this;
    app.swiper = ConstructorMethods({
      defaultSelector: '.swiper-container',
      constructor: Swiper,
      domProp: 'swiper',
    });
  },
  on: {
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        app.swiper.destroy(swiperEl);
      });
    },
    pageMounted(page) {
      const app = this;
      page.$el.find('.tabs-swipeable-wrap').each((index, swiperEl) => {
        initSwiper.call(app, swiperEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        initSwiper.call(app, swiperEl);
      });
    },
    pageReinit(page) {
      const app = this;
      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update) swiper.update();
      });
    },
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        initSwiper.call(app, swiperEl);
      });
    },
    tabShow(tabEl) {
      const app = this;
      $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update) swiper.update();
      });
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        app.swiper.destroy(swiperEl);
      });
    },
  },
  vnode: {
    'swiper-init': {
      insert(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        initSwiper.call(app, swiperEl);
      },
      destroy(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        app.swiper.destroy(swiperEl);
      },
    },
    'tabs-swipeable-wrap': {
      insert(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        initSwiper.call(app, swiperEl);
      },
      destroy(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        app.swiper.destroy(swiperEl);
      },
    },
  },
};

class PhotoBrowser extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const pb = this;
    pb.app = app;

    const defaults = Utils.extend({
      on: {},
    }, app.params.photoBrowser);

    // Extend defaults with modules params
    pb.useModulesParams(defaults);

    pb.params = Utils.extend(defaults, params);

    Utils.extend(pb, {
      exposed: false,
      opened: false,
      activeIndex: pb.params.swiper.initialSlide,
      url: pb.params.url,
      swipeToClose: {
        allow: true,
        isTouched: false,
        diff: undefined,
        start: undefined,
        current: undefined,
        started: false,
        activeSlide: undefined,
        timeStart: undefined,
      },
    });

    // Install Modules
    pb.useModules();

    // Init
    pb.init();
  }

  get view() {
    const { params, app } = this;
    return params.view || app.views.main;
  }

  onSlideChange(swiper) {
    const pb = this;
    pb.activeIndex = swiper.activeIndex;

    let current = swiper.activeIndex + 1;
    let total = pb.params.virtualSlides ? pb.params.photos.length : swiper.slides.length;
    if (swiper.params.loop) {
      total -= 2;
      current -= swiper.loopedSlides;
      if (current < 1) current = total + current;
      if (current > total) current -= total;
    }

    const $activeSlideEl = pb.params.virtualSlides
      ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.activeIndex}"]`)
      : swiper.slides.eq(swiper.activeIndex);
    const $previousSlideEl = pb.params.virtualSlides
      ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.previousIndex}"]`)
      : swiper.slides.eq(swiper.previousIndex);

    let $currentEl = pb.$el.find('.photo-browser-current');
    let $totalEl = pb.$el.find('.photo-browser-total');
    let navbarEl;
    if (pb.params.type === 'page' && pb.params.navbar && $currentEl.length === 0 && pb.app.theme === 'ios') {
      navbarEl = pb.app.navbar.getElByPage(pb.$el);
      if (navbarEl) {
        $currentEl = $(navbarEl).find('.photo-browser-current');
        $totalEl = $(navbarEl).find('.photo-browser-total');
      }
    }
    if ($currentEl.length && $totalEl.length) {
      $currentEl.text(current);
      $totalEl.text(total);
      if (!navbarEl) navbarEl = $currentEl.parents('.navbar')[0];
      if (navbarEl) {
        pb.app.navbar.size(navbarEl);
      }
    }

    // Update captions
    if (pb.captions.length > 0) {
      const captionIndex = swiper.params.loop ? $activeSlideEl.attr('data-swiper-slide-index') : pb.activeIndex;
      pb.$captionsContainerEl.find('.photo-browser-caption-active').removeClass('photo-browser-caption-active');
      pb.$captionsContainerEl.find(`[data-caption-index="${captionIndex}"]`).addClass('photo-browser-caption-active');
    }

    // Stop Video
    const previousSlideVideo = $previousSlideEl.find('video');
    if (previousSlideVideo.length > 0) {
      if ('pause' in previousSlideVideo[0]) previousSlideVideo[0].pause();
    }
  }

  onTouchStart() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    if (!swipeToClose.allow) return;
    swipeToClose.isTouched = true;
  }

  onTouchMove(e) {
    const pb = this;
    const swipeToClose = pb.swipeToClose;

    if (!swipeToClose.isTouched) return;
    if (!swipeToClose.started) {
      swipeToClose.started = true;
      swipeToClose.start = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (pb.params.virtualSlides) {
        swipeToClose.activeSlide = pb.swiper.$wrapperEl.children('.swiper-slide-active');
      } else {
        swipeToClose.activeSlide = pb.swiper.slides.eq(pb.swiper.activeIndex);
      }
      swipeToClose.timeStart = Utils.now();
    }
    e.preventDefault();
    swipeToClose.current = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    swipeToClose.diff = swipeToClose.start - swipeToClose.current;
    pb.$el.transition(0).transform(`translate3d(0,${-swipeToClose.diff}px,0)`);
  }

  onTouchEnd() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    swipeToClose.isTouched = false;
    if (!swipeToClose.started) {
      swipeToClose.started = false;
      return;
    }
    swipeToClose.started = false;
    swipeToClose.allow = false;
    const diff = Math.abs(swipeToClose.diff);
    const timeDiff = (new Date()).getTime() - swipeToClose.timeStart;
    if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > 100)) {
      Utils.nextTick(() => {
        if (pb.$el) {
          if (swipeToClose.diff < 0) pb.$el.addClass('swipe-close-to-bottom');
          else pb.$el.addClass('swipe-close-to-top');
        }
        pb.emit('local::swipeToClose', pb);
        pb.$el.transform('').transition('');
        pb.close();
        swipeToClose.allow = true;
      });
      return;
    }
    if (diff !== 0) {
      pb.$el.addClass('photo-browser-transitioning').transitionEnd(() => {
        swipeToClose.allow = true;
        pb.$el.removeClass('photo-browser-transitioning');
      });
    } else {
      swipeToClose.allow = true;
    }
    Utils.nextTick(() => {
      pb.$el.transform('').transition('');
    });
  }

  // Render Functions
  renderNavbar() {
    const pb = this;
    if (pb.params.renderNavbar) return pb.params.renderNavbar.call(pb);

    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';

    const pageBackLinkText = (pb.app.theme === 'ios' || pb.app.theme === 'aurora') && pb.params.pageBackLinkText ? pb.params.pageBackLinkText : '';

    const renderNavbarCount = typeof pb.params.navbarShowCount === 'undefined' ? pb.params.photos.length > 1 : pb.params.navbarShowCount;

    const isPopup = pb.params.type !== 'page';
    const navbarHtml = `
      <div class="navbar navbar-photo-browser ${pb.params.theme === 'dark' ? 'navbar-photo-browser-dark' : ''}">
        <div class="navbar-bg"></div>
        <div class="navbar-inner navbar-inner-centered-title sliding">
          ${!isPopup ? `
          <div class="left">
            <a class="link ${!pageBackLinkText ? 'icon-only' : ''} back">
              <i class="icon icon-back ${iconsColor ? `color-${iconsColor}` : ''}"></i>
              ${pageBackLinkText ? `<span>${pageBackLinkText}</span>` : ''}
            </a>
          </div>
          ` : ''}
          ${renderNavbarCount ? `
          <div class="title">
            <span class="photo-browser-current"></span>
            <span class="photo-browser-of">${pb.params.navbarOfText}</span>
            <span class="photo-browser-total"></span>
          </div>
          ` : ''}
          ${isPopup ? `
          <div class="right">
            <a class="link popup-close" data-popup=".photo-browser-popup">
              <span>${pb.params.popupCloseLinkText}</span>
            </a>
          </div>
          ` : ''}
        </div>
      </div>
    `.trim();
    return navbarHtml;
  }

  renderToolbar() {
    const pb = this;
    if (pb.params.renderToolbar) return pb.params.renderToolbar.call(pb);

    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';

    const toolbarHtml = `
      <div class="toolbar toolbar-bottom tabbar">
        <div class="toolbar-inner">
          <a class="link photo-browser-prev">
            <i class="icon icon-back ${iconsColor ? `color-${iconsColor}` : ''}"></i>
          </a>
          <a class="link photo-browser-next">
            <i class="icon icon-forward ${iconsColor ? `color-${iconsColor}` : ''}"></i>
          </a>
        </div>
      </div>
    `.trim();
    return toolbarHtml;
  }

  renderCaption(caption, index) {
    const pb = this;
    if (pb.params.renderCaption) return pb.params.renderCaption.call(pb, caption, index);
    const captionHtml = `
      <div class="photo-browser-caption" data-caption-index="${index}">
        ${caption}
      </div>
    `.trim();
    return captionHtml;
  }

  renderObject(photo, index) {
    const pb = this;
    if (pb.params.renderObject) return pb.params.renderObject.call(pb, photo, index);
    const objHtml = `
      <div class="photo-browser-slide photo-browser-object-slide swiper-slide" data-swiper-slide-index="${index}">${photo.html ? photo.html : photo}</div>
    `;
    return objHtml;
  }

  renderLazyPhoto(photo, index) {
    const pb = this;
    if (pb.params.renderLazyPhoto) return pb.params.renderLazyPhoto.call(pb, photo, index);
    const photoHtml = `
      <div class="photo-browser-slide photo-browser-slide-lazy swiper-slide" data-swiper-slide-index="${index}">
          <div class="swiper-lazy-preloader"></div>
          <span class="swiper-zoom-container">
              <img data-src="${photo.url ? photo.url : photo}" class="swiper-lazy">
          </span>
      </div>
    `.trim();
    return photoHtml;
  }

  renderPhoto(photo, index) {
    const pb = this;
    if (pb.params.renderPhoto) return pb.params.renderPhoto.call(pb, photo, index);
    const photoHtml = `
      <div class="photo-browser-slide swiper-slide" data-swiper-slide-index="${index}">
        <span class="swiper-zoom-container">
          <img src="${photo.url ? photo.url : photo}">
        </span>
      </div>
    `.trim();
    return photoHtml;
  }

  render() {
    const pb = this;
    if (pb.params.render) return pb.params.render.call(pb, pb.params);
    const html = `
      <div class="photo-browser photo-browser-${pb.params.theme}">
        <div class="view">
          <div class="page photo-browser-page photo-browser-page-${pb.params.theme} no-toolbar ${!pb.params.navbar ? 'no-navbar' : ''}" data-name="photo-browser-page">
            ${pb.params.navbar ? pb.renderNavbar() : ''}
            ${pb.params.toolbar ? pb.renderToolbar() : ''}
            <div class="photo-browser-captions photo-browser-captions-${pb.params.captionsTheme || pb.params.theme}">
              ${pb.params.photos.map((photo, index) => {
                if (photo.caption) return pb.renderCaption(photo.caption, index);
                return '';
              }).join(' ')}
            </div>
            <div class="photo-browser-swiper-container swiper-container">
              <div class="photo-browser-swiper-wrapper swiper-wrapper">
                ${pb.params.virtualSlides ? '' : pb.params.photos.map((photo, index) => {
                  if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
                    return pb.renderObject(photo, index);
                  }
                  if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
                    return pb.renderLazyPhoto(photo, index);
                  }
                  return pb.renderPhoto(photo, index);
                }).join(' ')}
              </div>
            </div>
          </div>
        </div>
      </div>
    `.trim();
    return html;
  }

  renderStandalone() {
    const pb = this;
    if (pb.params.renderStandalone) return pb.params.renderStandalone.call(pb);
    const standaloneHtml = `<div class="popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen">${pb.render()}</div>`;
    return standaloneHtml;
  }

  renderPage() {
    const pb = this;
    if (pb.params.renderPage) return pb.params.renderPage.call(pb);
    const pageHtml = pb.render();

    return pageHtml;
  }

  renderPopup() {
    const pb = this;
    if (pb.params.renderPopup) return pb.params.renderPopup.call(pb);
    const popupHtml = `<div class="popup photo-browser-popup">${pb.render()}</div>`;

    return popupHtml;
  }

  // Callbacks
  onOpen(type, el) {
    const pb = this;
    const app = pb.app;
    const $el = $(el);

    $el[0].f7PhotoBrowser = pb;

    pb.$el = $el;
    pb.el = $el[0];
    pb.openedIn = type;
    pb.opened = true;

    pb.$swiperContainerEl = pb.$el.find('.photo-browser-swiper-container');
    pb.$swiperWrapperEl = pb.$el.find('.photo-browser-swiper-wrapper');
    pb.slides = pb.$el.find('.photo-browser-slide');
    pb.$captionsContainerEl = pb.$el.find('.photo-browser-captions');
    pb.captions = pb.$el.find('.photo-browser-caption');

    // Init Swiper
    let clickTimeout;

    const swiperParams = Utils.extend({}, pb.params.swiper, {
      initialSlide: pb.activeIndex,
      on: {
        click(e) {
          clearTimeout(clickTimeout);

          if (pb.params.exposition) {
            clickTimeout = setTimeout(() => {
              pb.expositionToggle();
            }, 350);
          }
          pb.emit('local::tap', e);
          pb.emit('local::click', e);
        },
        doubleClick(e) {
          clearTimeout(clickTimeout);
          pb.emit('local::doubleTap', e);
          pb.emit('local::doubleClick', e);
        },
        slideChange(...args) {
          const swiper = this;
          pb.onSlideChange(swiper);
          pb.emit('local::slideChange', ...args);
        },
        transitionStart(...args) {
          pb.emit('local::transitionStart', ...args);
        },
        transitionEnd(...args) {
          pb.emit('local::transitionEnd', ...args);
        },
        slideChangeTransitionStart(...args) {
          const swiper = this;
          pb.onSlideChange(swiper);
          pb.emit('local::slideChangeTransitionStart', ...args);
        },
        slideChangeTransitionEnd(...args) {
          pb.emit('local::slideChangeTransitionEnd', ...args);
        },
        lazyImageLoad(...args) {
          pb.emit('local::lazyImageLoad', ...args);
        },
        lazyImageReady(...args) {
          const slideEl = args[0];
          $(slideEl).removeClass('photo-browser-slide-lazy');
          pb.emit('local::lazyImageReady', ...args);
        },
      },
    });
    if (pb.params.swipeToClose && pb.params.type !== 'page') {
      Utils.extend(swiperParams.on, {
        touchStart(e) {
          pb.onTouchStart(e);
          pb.emit('local::touchStart', e);
        },
        touchMoveOpposite(e) {
          pb.onTouchMove(e);
          pb.emit('local::touchMoveOpposite', e);
        },
        touchEnd(e) {
          pb.onTouchEnd(e);
          pb.emit('local::touchEnd', e);
        },
      });
    }
    if (pb.params.virtualSlides) {
      Utils.extend(swiperParams, {
        virtual: {
          slides: pb.params.photos,
          renderSlide(photo, index) {
            if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
              return pb.renderObject(photo, index);
            }
            if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
              return pb.renderLazyPhoto(photo, index);
            }
            return pb.renderPhoto(photo, index);
          },
        },
      });
    }

    pb.swiper = app.swiper.create(pb.$swiperContainerEl, swiperParams);

    if (pb.activeIndex === 0) {
      pb.onSlideChange(pb.swiper);
    }
    if (pb.$el) {
      pb.$el.trigger('photobrowser:open');
    }
    pb.emit('local::open photoBrowserOpen', pb);
  }

  onOpened() {
    const pb = this;
    if (pb.$el && pb.params.type === 'standalone') {
      pb.$el.css('animation', 'none');
    }
    if (pb.$el) {
      pb.$el.trigger('photobrowser:opened');
    }
    pb.emit('local::opened photoBrowserOpened', pb);
  }

  onClose() {
    const pb = this;
    if (pb.destroyed) return;

    // Destroy Swiper
    if (pb.swiper && pb.swiper.destroy) {
      pb.swiper.destroy(true, false);
      pb.swiper = null;
      delete pb.swiper;
    }
    if (pb.$el) {
      pb.$el.trigger('photobrowser:close');
    }
    pb.emit('local::close photoBrowserClose', pb);
  }

  onClosed() {
    const pb = this;
    if (pb.destroyed) return;
    pb.opened = false;
    pb.$el = null;
    pb.el = null;
    delete pb.$el;
    delete pb.el;
    if (pb.$el) {
      pb.$el.trigger('photobrowser:closed');
    }
    pb.emit('local::closed photoBrowserClosed', pb);
  }

  // Open
  openPage() {
    const pb = this;
    if (pb.opened) return pb;

    const pageHtml = pb.renderPage();

    pb.view.router.navigate({
      url: pb.url,
      route: {
        content: pageHtml,
        path: pb.url,
        on: {
          pageBeforeIn(e, page) {
            pb.view.$el.addClass(`with-photo-browser-page with-photo-browser-page-${pb.params.theme}`);
            pb.onOpen('page', page.el);
          },
          pageAfterIn(e, page) {
            pb.onOpened('page', page.el);
          },
          pageBeforeOut(e, page) {
            pb.view.$el.removeClass(`with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-${pb.params.theme}`);
            pb.onClose('page', page.el);
          },
          pageAfterOut(e, page) {
            pb.onClosed('page', page.el);
          },
        },
      },
    });
    return pb;
  }

  openStandalone() {
    const pb = this;
    if (pb.opened) return pb;

    const standaloneHtml = pb.renderStandalone();

    const popupParams = {
      backdrop: false,
      content: standaloneHtml,
      on: {
        popupOpen(popup) {
          pb.onOpen('popup', popup.el);
        },
        popupOpened(popup) {
          pb.onOpened('popup', popup.el);
        },
        popupClose(popup) {
          pb.onClose('popup', popup.el);
        },
        popupClosed(popup) {
          pb.onClosed('popup', popup.el);
        },
      },
    };

    if (pb.params.routableModals && pb.view) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams,
        },
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }
    return pb;
  }

  openPopup() {
    const pb = this;
    if (pb.opened) return pb;

    const popupHtml = pb.renderPopup();

    const popupParams = {
      content: popupHtml,
      push: pb.params.popupPush,
      on: {
        popupOpen(popup) {
          pb.onOpen('popup', popup.el);
        },
        popupOpened(popup) {
          pb.onOpened('popup', popup.el);
        },
        popupClose(popup) {
          pb.onClose('popup', popup.el);
        },
        popupClosed(popup) {
          pb.onClosed('popup', popup.el);
        },
      },
    };

    if (pb.params.routableModals && pb.view) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams,
        },
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }
    return pb;
  }

  // Exposition
  expositionEnable() {
    const pb = this;
    if (pb.params.type === 'page') {
      pb.view.$el.addClass('with-photo-browser-page-exposed');
    }
    if (pb.$el) pb.$el.addClass('photo-browser-exposed');
    if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.addClass('photo-browser-captions-exposed');
    pb.exposed = true;
    return pb;
  }

  expositionDisable() {
    const pb = this;
    if (pb.params.type === 'page') {
      pb.view.$el.removeClass('with-photo-browser-page-exposed');
    }
    if (pb.$el) pb.$el.removeClass('photo-browser-exposed');
    if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.removeClass('photo-browser-captions-exposed');
    pb.exposed = false;
    return pb;
  }

  expositionToggle() {
    const pb = this;
    if (pb.params.type === 'page') {
      pb.view.$el.toggleClass('with-photo-browser-page-exposed');
    }
    if (pb.$el) pb.$el.toggleClass('photo-browser-exposed');
    if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.toggleClass('photo-browser-captions-exposed');
    pb.exposed = !pb.exposed;
    return pb;
  }

  open(index) {
    const pb = this;
    const type = pb.params.type;
    if (pb.opened) {
      if (pb.swiper && typeof index !== 'undefined') {
        pb.swiper.slideTo(parseInt(index, 10));
      }
      return pb;
    }
    if (typeof index !== 'undefined') {
      pb.activeIndex = index;
    }
    if (type === 'standalone') {
      pb.openStandalone();
    }
    if (type === 'page') {
      pb.openPage();
    }
    if (type === 'popup') {
      pb.openPopup();
    }
    return pb;
  }

  close() {
    const pb = this;
    if (!pb.opened) return pb;
    if ((pb.params.routableModals && pb.view) || pb.openedIn === 'page') {
      pb.view.router.back();
    } else {
      pb.modal.once('modalClosed', () => {
        Utils.nextTick(() => {
          if (pb.destroyed) return;
          pb.modal.destroy();
          delete pb.modal;
        });
      });
      pb.modal.close();
    }
    return pb;
  }
  // eslint-disable-next-line
  init() {}

  destroy() {
    let pb = this;
    pb.emit('local::beforeDestroy photoBrowserBeforeDestroy', pb);
    if (pb.$el) {
      pb.$el.trigger('photobrowser:beforedestroy');
      pb.$el[0].f7PhotoBrowser = null;
      delete pb.$el[0].f7PhotoBrowser;
    }
    Utils.deleteProps(pb);
    pb.destroyed = true;
    pb = null;
  }
}

var PhotoBrowser$1 = {
  name: 'photoBrowser',
  params: {
    photoBrowser: {
      photos: [],
      exposition: true,
      expositionHideCaptions: false,
      type: 'standalone',
      navbar: true,
      toolbar: true,
      theme: 'light',
      captionsTheme: undefined,
      iconsColor: undefined,
      popupPush: false,
      swipeToClose: true,
      pageBackLinkText: 'Back',
      popupCloseLinkText: 'Close',
      navbarOfText: 'of',
      navbarShowCount: undefined,
      view: undefined,
      url: 'photos/',
      routableModals: true,
      virtualSlides: true,

      renderNavbar: undefined,
      renderToolbar: undefined,
      renderCaption: undefined,
      renderObject: undefined,
      renderLazyPhoto: undefined,
      renderPhoto: undefined,
      renderPage: undefined,
      renderPopup: undefined,
      renderStandalone: undefined,

      swiper: {
        initialSlide: 0,
        spaceBetween: 20,
        speed: 300,
        loop: false,
        preloadImages: true,
        navigation: {
          nextEl: '.photo-browser-next',
          prevEl: '.photo-browser-prev',
        },
        zoom: {
          enabled: true,
          maxRatio: 3,
          minRatio: 1,
        },
        lazy: {
          enabled: true,
        },
      },
    },
  },
  create() {
    const app = this;
    app.photoBrowser = ConstructorMethods({
      defaultSelector: '.photo-browser-popup, .photo-browser-page',
      constructor: PhotoBrowser,
      app,
      domProp: 'f7PhotoBrowser',
    });
  },
  static: {
    PhotoBrowser,
  },
};

class Notification extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      on: {},
    }, app.params.notification, params);

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const notification = this;

    notification.app = app;

    notification.params = extendedParams;

    const {
      icon,
      title,
      titleRightText,
      subtitle,
      text,
      closeButton,
      closeTimeout,
      cssClass,
      closeOnClick,
    } = notification.params;

    let $el;
    if (!notification.params.el) {
      // Find Element
      const notificationHtml = notification.render({
        icon,
        title,
        titleRightText,
        subtitle,
        text,
        closeButton,
        cssClass,
      });

      $el = $(notificationHtml);
    } else {
      $el = $(notification.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return notification.destroy();
    }

    Utils.extend(notification, {
      $el,
      el: $el[0],
      type: 'notification',
    });

    $el[0].f7Modal = notification;

    if (closeButton) {
      $el.find('.notification-close-button').on('click', () => {
        notification.close();
      });
    }
    $el.on('click', (e) => {
      if (closeButton && $(e.target).closest('.notification-close-button').length) {
        return;
      }
      notification.emit('local::click notificationClick', notification);
      if (closeOnClick) notification.close();
    });

    notification.on('beforeDestroy', () => {
      $el.off('click');
    });

    /* Touch Events */
    let isTouched;
    let isMoved;
    let isScrolling;
    let touchesDiff;
    let touchStartTime;
    let notificationHeight;
    const touchesStart = {};
    function handleTouchStart(e) {
      if (isTouched) return;
      isTouched = true;
      isMoved = false;
      isScrolling = undefined;
      touchStartTime = Utils.now();
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) < Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();
      if (!isMoved) {
        notification.$el.removeClass('notification-transitioning');
        notification.$el.transition(0);
        notificationHeight = notification.$el[0].offsetHeight / 2;
      }
      isMoved = true;
      touchesDiff = (pageY - touchesStart.y);
      let newTranslate = touchesDiff;
      if (touchesDiff > 0) {
        newTranslate = touchesDiff ** 0.8;
      }
      notification.$el.transform(`translate3d(0, ${newTranslate}px, 0)`);
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;
      if (touchesDiff === 0) {
        return;
      }

      const timeDiff = Utils.now() - touchStartTime;
      notification.$el.transition('');
      notification.$el.addClass('notification-transitioning');
      notification.$el.transform('');

      if (
        (touchesDiff < -10 && timeDiff < 300)
        || (-touchesDiff >= notificationHeight / 1)
      ) {
        notification.close();
      }
    }

    function attachTouchEvents() {
      notification.$el.on(app.touchEvents.start, handleTouchStart, { passive: true });
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
    }
    function detachTouchEvents() {
      notification.$el.off(app.touchEvents.start, handleTouchStart, { passive: true });
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
    }

    let timeoutId;
    function closeOnTimeout() {
      timeoutId = Utils.nextTick(() => {
        if (isTouched && isMoved) {
          closeOnTimeout();
          return;
        }
        notification.close();
      }, closeTimeout);
    }
    notification.on('open', () => {
      if (notification.params.swipeToClose) {
        attachTouchEvents();
      }
      $('.notification.modal-in').each((index, openedEl) => {
        const notificationInstance = app.notification.get(openedEl);
        if (openedEl !== notification.el && notificationInstance) {
          notificationInstance.close();
        }
      });
      if (closeTimeout) {
        closeOnTimeout();
      }
    });
    notification.on('close beforeDestroy', () => {
      if (notification.params.swipeToClose) {
        detachTouchEvents();
      }
      win.clearTimeout(timeoutId);
    });

    return notification;
  }

  render() {
    const notification = this;
    if (notification.params.render) return notification.params.render.call(notification, notification);
    const { icon, title, titleRightText, subtitle, text, closeButton, cssClass } = notification.params;
    return `
      <div class="notification ${cssClass || ''}">
        <div class="notification-header">
          ${icon ? `<div class="notification-icon">${icon}</div>` : ''}
          ${title ? `<div class="notification-title">${title}</div>` : ''}
          ${titleRightText ? `<div class="notification-title-right-text">${titleRightText}</div>` : ''}
          ${closeButton ? '<span class="notification-close-button"></span>' : ''}
        </div>
        <div class="notification-content">
          ${subtitle ? `<div class="notification-subtitle">${subtitle}</div>` : ''}
          ${text ? `<div class="notification-text">${text}</div>` : ''}
        </div>
      </div>
    `.trim();
  }
}

var Notification$1 = {
  name: 'notification',
  static: {
    Notification,
  },
  create() {
    const app = this;
    app.notification = Utils.extend(
      {},
      ModalMethods({
        app,
        constructor: Notification,
        defaultSelector: '.notification.modal-in',
      })
    );
  },
  params: {
    notification: {
      icon: null,
      title: null,
      titleRightText: null,
      subtitle: null,
      text: null,
      closeButton: false,
      closeTimeout: null,
      closeOnClick: false,
      swipeToClose: true,
      cssClass: null,
      render: null,
    },
  },
};

class Autocomplete extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const ac = this;
    ac.app = app;

    const defaults = Utils.extend({
      on: {},
    }, app.params.autocomplete);

    if (typeof defaults.searchbarDisableButton === 'undefined') {
      defaults.searchbarDisableButton = app.theme !== 'aurora';
    }

    // Extend defaults with modules params
    ac.useModulesParams(defaults);

    ac.params = Utils.extend(defaults, params);

    let $openerEl;
    if (ac.params.openerEl) {
      $openerEl = $(ac.params.openerEl);
      if ($openerEl.length) $openerEl[0].f7Autocomplete = ac;
    }

    let $inputEl;
    if (ac.params.inputEl) {
      $inputEl = $(ac.params.inputEl);
      if ($inputEl.length) $inputEl[0].f7Autocomplete = ac;
    }

    const id = Utils.id();

    let url = params.url;
    if (!url && $openerEl && $openerEl.length) {
      if ($openerEl.attr('href')) url = $openerEl.attr('href');
      else if ($openerEl.find('a').length > 0) {
        url = $openerEl.find('a').attr('href');
      }
    }
    if (!url || url === '#' || url === '') url = ac.params.url;

    const inputType = ac.params.multiple ? 'checkbox' : 'radio';

    Utils.extend(ac, {
      $openerEl,
      openerEl: $openerEl && $openerEl[0],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      id,
      url,
      value: ac.params.value || [],
      inputType,
      inputName: `${inputType}-${id}`,
      $modalEl: undefined,
      $dropdownEl: undefined,
    });

    let previousQuery = '';
    function onInputChange() {
      let query = ac.$inputEl.val().trim();

      if (!ac.params.source) return;
      ac.params.source.call(ac, query, (items) => {
        let itemsHTML = '';
        const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
        ac.items = items;
        let regExp;
        if (ac.params.highlightMatches) {
          query = query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
          regExp = new RegExp(`(${query})`, 'i');
        }

        let firstValue;
        let firstItem;
        for (let i = 0; i < limit; i += 1) {
          const itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
          const itemText = typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i];
          if (i === 0) {
            firstValue = itemValue;
            firstItem = ac.items[i];
          }
          itemsHTML += ac.renderItem({
            value: itemValue,
            text: ac.params.highlightMatches ? itemText.replace(regExp, '<b>$1</b>') : itemText,
          }, i);
        }
        if (itemsHTML === '' && query === '' && ac.params.dropdownPlaceholderText) {
          itemsHTML += ac.renderItem({
            placeholder: true,
            text: ac.params.dropdownPlaceholderText,
          });
        }
        ac.$dropdownEl.find('ul').html(itemsHTML);
        if (ac.params.typeahead) {
          if (!firstValue || !firstItem) {
            return;
          }
          if (firstValue.toLowerCase().indexOf(query.toLowerCase()) !== 0) {
            return;
          }
          if (previousQuery.toLowerCase() === query.toLowerCase()) {
            ac.value = [];
            return;
          }

          if (previousQuery.toLowerCase().indexOf(query.toLowerCase()) === 0) {
            previousQuery = query;
            ac.value = [];
            return;
          }
          $inputEl.val(firstValue);
          $inputEl[0].setSelectionRange(query.length, firstValue.length);

          const previousValue = typeof ac.value[0] === 'object' ? ac.value[0][ac.params.valueProperty] : ac.value[0];
          if (!previousValue || firstValue.toLowerCase() !== previousValue.toLowerCase()) {
            ac.value = [firstItem];
            ac.emit('local::change autocompleteChange', [firstItem]);
          }
        }

        previousQuery = query;
      });
    }
    function onPageInputChange() {
      const input = this;
      const value = input.value;
      const isValues = $(input).parents('.autocomplete-values').length > 0;
      let item;
      let itemValue;
      let aValue;
      if (isValues) {
        if (ac.inputType === 'checkbox' && !input.checked) {
          for (let i = 0; i < ac.value.length; i += 1) {
            aValue = typeof ac.value[i] === 'string' ? ac.value[i] : ac.value[i][ac.params.valueProperty];
            if (aValue === value || aValue * 1 === value * 1) {
              ac.value.splice(i, 1);
            }
          }
          ac.updateValues();
          ac.emit('local::change autocompleteChange', ac.value);
        }
        return;
      }

      // Find Related Item
      for (let i = 0; i < ac.items.length; i += 1) {
        itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        if (itemValue === value || itemValue * 1 === value * 1) item = ac.items[i];
      }
      if (ac.inputType === 'radio') {
        ac.value = [item];
      } else if (input.checked) {
        ac.value.push(item);
      } else {
        for (let i = 0; i < ac.value.length; i += 1) {
          aValue = typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i];
          if (aValue === value || aValue * 1 === value * 1) {
            ac.value.splice(i, 1);
          }
        }
      }

      // Update Values Block
      ac.updateValues();

      // On Select Callback
      if (((ac.inputType === 'radio' && input.checked) || ac.inputType === 'checkbox')) {
        ac.emit('local::change autocompleteChange', ac.value);
      }
    }
    function onHtmlClick(e) {
      const $targetEl = $(e.target);
      if ($targetEl.is(ac.$inputEl[0]) || (ac.$dropdownEl && $targetEl.closest(ac.$dropdownEl[0]).length)) return;
      ac.close();
    }
    function onOpenerClick() {
      ac.open();
    }
    function onInputFocus() {
      ac.open();
    }
    function onInputBlur() {
      if (ac.$dropdownEl.find('label.active-state').length > 0) return;
      setTimeout(() => {
        ac.close();
      }, 0);
    }
    function onResize() {
      ac.positionDropdown();
    }

    function onKeyDown(e) {
      if (!ac.opened) return;
      if (e.keyCode === 27) {
        // ESC
        e.preventDefault();
        ac.$inputEl.blur();
        return;
      }
      if (e.keyCode === 13) {
        // Enter
        const $selectedItemLabel = ac.$dropdownEl.find('.autocomplete-dropdown-selected label');
        if ($selectedItemLabel.length) {
          e.preventDefault();
          $selectedItemLabel.trigger('click');
          ac.$inputEl.blur();
          return;
        }
        if (ac.params.typeahead) {
          e.preventDefault();
          ac.$inputEl.blur();
        }
        return;
      }
      if (e.keyCode !== 40 && e.keyCode !== 38) return;
      e.preventDefault();
      const $selectedItem = ac.$dropdownEl.find('.autocomplete-dropdown-selected');
      let $newItem;
      if ($selectedItem.length) {
        $newItem = $selectedItem[e.keyCode === 40 ? 'next' : 'prev']('li');
        if (!$newItem.length) {
          $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
        }
      } else {
        $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
      }
      if ($newItem.hasClass('autocomplete-dropdown-placeholder')) return;
      $selectedItem.removeClass('autocomplete-dropdown-selected');
      $newItem.addClass('autocomplete-dropdown-selected');
    }
    function onDropdownClick() {
      const $clickedEl = $(this);
      let clickedItem;
      for (let i = 0; i < ac.items.length; i += 1) {
        const itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        const value = $clickedEl.attr('data-value');
        if (itemValue === value || itemValue * 1 === value * 1) {
          clickedItem = ac.items[i];
        }
      }
      if (ac.params.updateInputValueOnSelect) {
        ac.$inputEl.val(typeof clickedItem === 'object' ? clickedItem[ac.params.valueProperty] : clickedItem);
        ac.$inputEl.trigger('input change');
      }
      ac.value = [clickedItem];
      ac.emit('local::change autocompleteChange', [clickedItem]);
      ac.close();
    }

    ac.attachEvents = function attachEvents() {
      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
        ac.$openerEl.on('click', onOpenerClick);
      }
      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
        ac.$inputEl.on('focus', onInputFocus);
        ac.$inputEl.on(ac.params.inputEvents, onInputChange);
        if (app.device.android) {
          $('html').on('click', onHtmlClick);
        } else {
          ac.$inputEl.on('blur', onInputBlur);
        }
        ac.$inputEl.on('keydown', onKeyDown);
      }
    };
    ac.detachEvents = function attachEvents() {
      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
        ac.$openerEl.off('click', onOpenerClick);
      }
      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
        ac.$inputEl.off('focus', onInputFocus);
        ac.$inputEl.off(ac.params.inputEvents, onInputChange);
        if (app.device.android) {
          $('html').off('click', onHtmlClick);
        } else {
          ac.$inputEl.off('blur', onInputBlur);
        }
        ac.$inputEl.off('keydown', onKeyDown);
      }
    };
    ac.attachDropdownEvents = function attachDropdownEvents() {
      ac.$dropdownEl.on('click', 'label', onDropdownClick);
      app.on('resize', onResize);
    };
    ac.detachDropdownEvents = function detachDropdownEvents() {
      ac.$dropdownEl.off('click', 'label', onDropdownClick);
      app.off('resize', onResize);
    };

    ac.attachPageEvents = function attachPageEvents() {
      ac.$el.on('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
      if (ac.params.closeOnSelect && !ac.params.multiple) {
        ac.$el.once('click', '.list label', () => {
          Utils.nextTick(() => {
            ac.close();
          });
        });
      }
    };
    ac.detachPageEvents = function detachPageEvents() {
      ac.$el.off('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
    };

    // Install Modules
    ac.useModules();

    // Init
    ac.init();

    return ac;
  }

  get view() {
    const ac = this;
    const { $openerEl, $inputEl, app } = ac;
    let view;
    if (ac.params.view) {
      view = ac.params.view;
    } else if ($openerEl || $inputEl) {
      const $el = $openerEl || $inputEl;
      view = $el.closest('.view').length && $el.closest('.view')[0].f7View;
    }
    if (!view) view = app.views.main;
    return view;
  }

  positionDropdown() {
    const ac = this;
    const { $inputEl, app, $dropdownEl } = ac;

    const $pageContentEl = $inputEl.parents('.page-content');
    if ($pageContentEl.length === 0) return;
    const inputOffset = $inputEl.offset();
    const inputOffsetWidth = $inputEl[0].offsetWidth;
    const inputOffsetHeight = $inputEl[0].offsetHeight;
    const $listEl = $inputEl.parents('.list');

    let $listParent;
    $listEl.parents().each((index, parentEl) => {
      if ($listParent) return;
      const $parentEl = $(parentEl);
      if ($parentEl.parent($pageContentEl).length) $listParent = $parentEl;
    });

    const listOffset = $listEl.offset();
    const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
    const listOffsetLeft = $listEl.length > 0 ? listOffset.left - $pageContentEl.offset().left : 0;
    const inputOffsetLeft = inputOffset.left - ($listEl.length > 0 ? listOffset.left : 0) - (app.rtl ? 0 : 0);
    const inputOffsetTop = inputOffset.top - ($pageContentEl.offset().top - $pageContentEl[0].scrollTop);

    const maxHeight = $pageContentEl[0].scrollHeight - paddingBottom - (inputOffsetTop + $pageContentEl[0].scrollTop) - $inputEl[0].offsetHeight;

    const paddingProp = app.rtl ? 'padding-right' : 'padding-left';
    let paddingValue;
    if ($listEl.length && !ac.params.expandInput) {
      paddingValue = (app.rtl ? $listEl[0].offsetWidth - inputOffsetLeft - inputOffsetWidth : inputOffsetLeft) - (app.theme === 'md' ? 16 : 15);
    }

    $dropdownEl.css({
      left: `${$listEl.length > 0 ? listOffsetLeft : inputOffsetLeft}px`,
      top: `${inputOffsetTop + $pageContentEl[0].scrollTop + inputOffsetHeight}px`,
      width: `${$listEl.length > 0 ? $listEl[0].offsetWidth : inputOffsetWidth}px`,
    });
    $dropdownEl.children('.autocomplete-dropdown-inner').css({
      maxHeight: `${maxHeight}px`,
      [paddingProp]: $listEl.length > 0 && !ac.params.expandInput ? `${paddingValue}px` : '',
    });
  }

  focus() {
    const ac = this;
    ac.$el.find('input[type=search]').focus();
  }

  source(query) {
    const ac = this;
    if (!ac.params.source) return;

    const { $el } = ac;

    ac.params.source.call(ac, query, (items) => {
      let itemsHTML = '';
      const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
      ac.items = items;
      for (let i = 0; i < limit; i += 1) {
        let selected = false;
        const itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
        for (let j = 0; j < ac.value.length; j += 1) {
          const aValue = typeof ac.value[j] === 'object' ? ac.value[j][ac.params.valueProperty] : ac.value[j];
          if (aValue === itemValue || aValue * 1 === itemValue * 1) selected = true;
        }
        itemsHTML += ac.renderItem({
          value: itemValue,
          text: typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i],
          inputType: ac.inputType,
          id: ac.id,
          inputName: ac.inputName,
          selected,
        }, i);
      }
      $el.find('.autocomplete-found ul').html(itemsHTML);
      if (items.length === 0) {
        if (query.length !== 0) {
          $el.find('.autocomplete-not-found').show();
          $el.find('.autocomplete-found, .autocomplete-values').hide();
        } else {
          $el.find('.autocomplete-values').show();
          $el.find('.autocomplete-found, .autocomplete-not-found').hide();
        }
      } else {
        $el.find('.autocomplete-found').show();
        $el.find('.autocomplete-not-found, .autocomplete-values').hide();
      }
    });
  }

  updateValues() {
    const ac = this;
    let valuesHTML = '';
    for (let i = 0; i < ac.value.length; i += 1) {
      valuesHTML += ac.renderItem({
        value: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i],
        text: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.textProperty] : ac.value[i],
        inputType: ac.inputType,
        id: ac.id,
        inputName: `${ac.inputName}-checked}`,
        selected: true,
      }, i);
    }
    ac.$el.find('.autocomplete-values ul').html(valuesHTML);
  }

  preloaderHide() {
    const ac = this;
    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
      ac.$dropdownEl.find('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
    } else {
      $('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
    }
  }

  preloaderShow() {
    const ac = this;
    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
      ac.$dropdownEl.find('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
    } else {
      $('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
    }
  }

  renderPreloader() {
    const ac = this;
    return `
      <div class="autocomplete-preloader preloader ${ac.params.preloaderColor ? `color-${ac.params.preloaderColor}` : ''}">${Utils[`${ac.app.theme}PreloaderContent`] || ''}</div>
    `.trim();
  }

  renderSearchbar() {
    const ac = this;
    if (ac.params.renderSearchbar) return ac.params.renderSearchbar.call(ac);
    const searchbarHTML = `
      <form class="searchbar">
        <div class="searchbar-inner">
          <div class="searchbar-input-wrap">
            <input type="search" placeholder="${ac.params.searchbarPlaceholder}"/>
            <i class="searchbar-icon"></i>
            <span class="input-clear-button"></span>
          </div>
          ${ac.params.searchbarDisableButton ? `
          <span class="searchbar-disable-button">${ac.params.searchbarDisableText}</span>
          ` : ''}
        </div>
      </form>
    `.trim();
    return searchbarHTML;
  }

  renderItem(item, index) {
    const ac = this;
    if (ac.params.renderItem) return ac.params.renderItem.call(ac, item, index);
    let itemHtml;
    const itemValue = item.value && typeof item.value === 'string' ? item.value.replace(/"/g, '&quot;') : item.value;
    if (ac.params.openIn !== 'dropdown') {
      itemHtml = `
        <li>
          <label class="item-${item.inputType} item-content">
            <input type="${item.inputType}" name="${item.inputName}" value="${itemValue}" ${item.selected ? 'checked' : ''}>
            <i class="icon icon-${item.inputType}"></i>
            <div class="item-inner">
              <div class="item-title">${item.text}</div>
            </div>
          </label>
        </li>
      `;
    } else if (!item.placeholder) {
      // Dropdown
      itemHtml = `
        <li>
          <label class="item-radio item-content" data-value="${itemValue}">
            <div class="item-inner">
              <div class="item-title">${item.text}</div>
            </div>
          </label>
        </li>
      `;
    } else {
      // Dropwdown placeholder
      itemHtml = `
        <li class="autocomplete-dropdown-placeholder">
          <label class="item-content">
            <div class="item-inner">
              <div class="item-title">${item.text}</div>
            </div>
          </label>
        </li>
      `;
    }
    return itemHtml.trim();
  }

  renderNavbar() {
    const ac = this;
    if (ac.params.renderNavbar) return ac.params.renderNavbar.call(ac);
    let pageTitle = ac.params.pageTitle;
    if (typeof pageTitle === 'undefined' && ac.$openerEl && ac.$openerEl.length) {
      pageTitle = ac.$openerEl.find('.item-title').text().trim();
    }
    const inPopup = ac.params.openIn === 'popup';
    const navbarLeft = inPopup
      ? `
        ${ac.params.preloader ? `
        <div class="left">
          ${ac.renderPreloader()}
        </div>
        ` : ''}
      `
      : `
        <div class="left sliding">
          <a class="link back">
            <i class="icon icon-back"></i>
            <span class="if-not-md">${ac.params.pageBackLinkText}</span>
          </a>
        </div>
      `;
    const navbarRight = inPopup
      ? `
        <div class="right">
          <a class="link popup-close" data-popup=".autocomplete-popup">
            ${ac.params.popupCloseLinkText}
          </a>
        </div>
      `
      : `
        ${ac.params.preloader ? `
        <div class="right">
          ${ac.renderPreloader()}
        </div>
        ` : ''}
      `;
    const navbarHtml = `
      <div class="navbar ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ''}">
        <div class="navbar-bg"></div>
        <div class="navbar-inner ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ''}">
          ${navbarLeft}
          ${pageTitle ? `<div class="title sliding">${pageTitle}</div>` : ''}
          ${navbarRight}
          <div class="subnavbar sliding">${ac.renderSearchbar()}</div>
        </div>
      </div>
    `.trim();
    return navbarHtml;
  }

  renderDropdown() {
    const ac = this;
    if (ac.params.renderDropdown) return ac.params.renderDropdown.call(ac, ac.items);
    const dropdownHtml = `
      <div class="autocomplete-dropdown">
        <div class="autocomplete-dropdown-inner">
          <div class="list ${!ac.params.expandInput ? 'no-safe-areas' : ''}">
            <ul></ul>
          </div>
        </div>
        ${ac.params.preloader ? ac.renderPreloader() : ''}
      </div>
    `.trim();
    return dropdownHtml;
  }

  renderPage(inPopup) {
    const ac = this;
    if (ac.params.renderPage) return ac.params.renderPage.call(ac, ac.items);

    const pageHtml = `
      <div class="page page-with-subnavbar autocomplete-page" data-name="autocomplete-page">
        ${ac.renderNavbar(inPopup)}
        <div class="searchbar-backdrop"></div>
        <div class="page-content">
          <div class="list autocomplete-list autocomplete-found autocomplete-list-${ac.id} ${ac.params.formColorTheme ? `color-${ac.params.formColorTheme}` : ''}">
            <ul></ul>
          </div>
          <div class="list autocomplete-not-found">
            <ul>
              <li class="item-content"><div class="item-inner"><div class="item-title">${ac.params.notFoundText}</div></div></li>
            </ul>
          </div>
          <div class="list autocomplete-values">
            <ul></ul>
          </div>
        </div>
      </div>
    `.trim();
    return pageHtml;
  }

  renderPopup() {
    const ac = this;
    if (ac.params.renderPopup) return ac.params.renderPopup.call(ac, ac.items);
    const popupHtml = `
      <div class="popup autocomplete-popup">
        <div class="view">
          ${ac.renderPage(true)};
        </div>
      </div>
    `.trim();
    return popupHtml;
  }

  onOpen(type, el) {
    const ac = this;
    const app = ac.app;
    const $el = $(el);
    ac.$el = $el;
    ac.el = $el[0];
    ac.openedIn = type;
    ac.opened = true;

    if (ac.params.openIn === 'dropdown') {
      ac.attachDropdownEvents();

      ac.$dropdownEl.addClass('autocomplete-dropdown-in');
      ac.$inputEl.trigger('input');
    } else {
      // Init SB
      let $searchbarEl = $el.find('.searchbar');
      if (ac.params.openIn === 'page' && app.theme === 'ios' && $searchbarEl.length === 0) {
        $searchbarEl = $(app.navbar.getElByPage($el)).find('.searchbar');
      }
      ac.searchbar = app.searchbar.create({
        el: $searchbarEl,
        backdropEl: $el.find('.searchbar-backdrop'),
        customSearch: true,
        on: {
          search(sb, query) {
            if (query.length === 0 && ac.searchbar.enabled) {
              ac.searchbar.backdropShow();
            } else {
              ac.searchbar.backdropHide();
            }
            ac.source(query);
          },
        },
      });

      // Attach page events
      ac.attachPageEvents();

      // Update Values On Page Init
      ac.updateValues();

      // Source on load
      if (ac.params.requestSourceOnOpen) ac.source('');
    }

    ac.emit('local::open autocompleteOpen', ac);
  }

  autoFocus() {
    const ac = this;
    if (ac.searchbar && ac.searchbar.$inputEl) {
      ac.searchbar.$inputEl.focus();
    }
    return ac;
  }

  onOpened() {
    const ac = this;
    if (ac.params.openIn !== 'dropdown' && ac.params.autoFocus) {
      ac.autoFocus();
    }
    ac.emit('local::opened autocompleteOpened', ac);
  }

  onClose() {
    const ac = this;
    if (ac.destroyed) return;

    // Destroy SB
    if (ac.searchbar && ac.searchbar.destroy) {
      ac.searchbar.destroy();
      ac.searchbar = null;
      delete ac.searchbar;
    }

    if (ac.params.openIn === 'dropdown') {
      ac.detachDropdownEvents();
      ac.$dropdownEl.removeClass('autocomplete-dropdown-in').remove();
      ac.$inputEl.parents('.item-content-dropdown-expanded').removeClass('item-content-dropdown-expanded');
    } else {
      ac.detachPageEvents();
    }

    ac.emit('local::close autocompleteClose', ac);
  }

  onClosed() {
    const ac = this;
    if (ac.destroyed) return;
    ac.opened = false;
    ac.$el = null;
    ac.el = null;
    delete ac.$el;
    delete ac.el;

    ac.emit('local::closed autocompleteClosed', ac);
  }

  openPage() {
    const ac = this;
    if (ac.opened) return ac;
    const pageHtml = ac.renderPage();
    ac.view.router.navigate({
      url: ac.url,
      route: {
        content: pageHtml,
        path: ac.url,
        on: {
          pageBeforeIn(e, page) {
            ac.onOpen('page', page.el);
          },
          pageAfterIn(e, page) {
            ac.onOpened('page', page.el);
          },
          pageBeforeOut(e, page) {
            ac.onClose('page', page.el);
          },
          pageAfterOut(e, page) {
            ac.onClosed('page', page.el);
          },
        },
        options: {
          animate: ac.params.animate,
        },
      },
    });
    return ac;
  }

  openPopup() {
    const ac = this;
    if (ac.opened) return ac;
    const popupHtml = ac.renderPopup();

    const popupParams = {
      content: popupHtml,
      animate: ac.params.animate,
      push: ac.params.popupPush,
      swipeToClose: ac.params.popupSwipeToClose,
      on: {
        popupOpen(popup) {
          ac.onOpen('popup', popup.el);
        },
        popupOpened(popup) {
          ac.onOpened('popup', popup.el);
        },
        popupClose(popup) {
          ac.onClose('popup', popup.el);
        },
        popupClosed(popup) {
          ac.onClosed('popup', popup.el);
        },
      },
    };

    if (ac.params.routableModals && ac.view) {
      ac.view.router.navigate({
        url: ac.url,
        route: {
          path: ac.url,
          popup: popupParams,
        },
      });
    } else {
      ac.modal = ac.app.popup.create(popupParams).open(ac.params.animate);
    }
    return ac;
  }

  openDropdown() {
    const ac = this;

    if (!ac.$dropdownEl) {
      ac.$dropdownEl = $(ac.renderDropdown());
    }
    const $listEl = ac.$inputEl.parents('.list');
    if ($listEl.length && ac.$inputEl.parents('.item-content').length > 0 && ac.params.expandInput) {
      ac.$inputEl.parents('.item-content').addClass('item-content-dropdown-expanded');
    }

    const $pageContentEl = ac.$inputEl.parents('.page-content');
    if (ac.params.dropdownContainerEl) {
      $(ac.params.dropdownContainerEl).append(ac.$dropdownEl);
    } else if ($pageContentEl.length === 0) {
      ac.$dropdownEl.insertAfter(ac.$inputEl);
    } else {
      ac.positionDropdown();
      $pageContentEl.append(ac.$dropdownEl);
    }
    ac.onOpen('dropdown', ac.$dropdownEl);
    ac.onOpened('dropdown', ac.$dropdownEl);
  }

  open() {
    const ac = this;
    if (ac.opened) return ac;
    const openIn = ac.params.openIn;
    ac[`open${openIn.split('').map((el, index) => {
      if (index === 0) return el.toUpperCase();
      return el;
    }).join('')}`]();
    return ac;
  }

  close() {
    const ac = this;
    if (!ac.opened) return ac;
    if (ac.params.openIn === 'dropdown') {
      ac.onClose();
      ac.onClosed();
    } else if ((ac.params.routableModals && ac.view) || ac.openedIn === 'page') {
      ac.view.router.back({ animate: ac.params.animate });
    } else {
      ac.modal.once('modalClosed', () => {
        Utils.nextTick(() => {
          if (ac.destroyed) return;
          ac.modal.destroy();
          delete ac.modal;
        });
      });
      ac.modal.close();
    }
    return ac;
  }

  init() {
    const ac = this;
    ac.attachEvents();
  }

  destroy() {
    const ac = this;
    ac.emit('local::beforeDestroy autocompleteBeforeDestroy', ac);
    ac.detachEvents();
    if (ac.$inputEl && ac.$inputEl[0]) {
      delete ac.$inputEl[0].f7Autocomplete;
    }
    if (ac.$openerEl && ac.$openerEl[0]) {
      delete ac.$openerEl[0].f7Autocomplete;
    }
    Utils.deleteProps(ac);
    ac.destroyed = true;
  }
}

var Autocomplete$1 = {
  name: 'autocomplete',
  params: {
    autocomplete: {
      openerEl: undefined,
      inputEl: undefined,
      view: undefined,

      // DropDown
      dropdownContainerEl: undefined,
      dropdownPlaceholderText: undefined,
      typeahead: false,
      highlightMatches: true,
      expandInput: false,
      updateInputValueOnSelect: true,
      inputEvents: 'input',

      value: undefined,
      multiple: false,

      source: undefined,
      limit: undefined,
      valueProperty: 'id',
      textProperty: 'text',

      openIn: 'page', // or 'popup' or 'dropdown'
      pageBackLinkText: 'Back',
      popupCloseLinkText: 'Close',
      pageTitle: undefined,
      searchbarPlaceholder: 'Search...',
      searchbarDisableText: 'Cancel',
      searchbarDisableButton: undefined,

      popupPush: false,
      popupSwipeToClose: undefined,

      animate: true,

      autoFocus: false,
      closeOnSelect: false,
      notFoundText: 'Nothing found',
      requestSourceOnOpen: false,

      // Preloader
      preloaderColor: undefined,
      preloader: false,

      // Colors
      formColorTheme: undefined,
      navbarColorTheme: undefined,

      // Routing
      routableModals: true,
      url: 'select/',

      // Custom render functions
      renderDropdown: undefined,
      renderPage: undefined,
      renderPopup: undefined,
      renderItem: undefined,
      renderSearchbar: undefined,
      renderNavbar: undefined,

    },
  },
  static: {
    Autocomplete,
  },
  create() {
    const app = this;
    app.autocomplete = Utils.extend(
      ConstructorMethods({
        defaultSelector: undefined,
        constructor: Autocomplete,
        app,
        domProp: 'f7Autocomplete',
      }),
      {
        open(autocompleteEl) {
          const ac = app.autocomplete.get(autocompleteEl);
          if (ac && ac.open) return ac.open();
          return undefined;
        },
        close(autocompleteEl) {
          const ac = app.autocomplete.get(autocompleteEl);
          if (ac && ac.close) return ac.close();
          return undefined;
        },
      }
    );
  },
};

class Tooltip extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const tooltip = this;

    const defaults = Utils.extend({}, app.params.tooltip);

    // Extend defaults with modules params
    tooltip.useModulesParams(defaults);

    tooltip.params = Utils.extend(defaults, params);
    if (typeof params.offset === 'undefined' && Support.touch && tooltip.params.trigger === 'hover') {
      tooltip.params.offset = 10;
    }

    const { targetEl } = tooltip.params;
    if (!targetEl) return tooltip;

    const $targetEl = $(targetEl);
    if ($targetEl.length === 0) return tooltip;

    if ($targetEl[0].f7Tooltip) return $targetEl[0].f7Tooltip;

    const $el = $(tooltip.render()).eq(0);

    Utils.extend(tooltip, {
      app,
      $targetEl,
      targetEl: $targetEl && $targetEl[0],
      $el,
      el: $el && $el[0],
      text: tooltip.params.text || '',
      visible: false,
      opened: false,
    });

    $targetEl[0].f7Tooltip = tooltip;

    const touchesStart = {};
    let isTouched;
    function handleClick() {
      if (tooltip.opened) tooltip.hide();
      else tooltip.show(this);
    }
    function handleClickOut(e) {
      if (tooltip.opened && (
        $(e.target).closest($targetEl).length
        || $(e.target).closest(tooltip.$el).length
      )) return;
      tooltip.hide();
    }
    function handleTouchStart(e) {
      if (isTouched) return;
      isTouched = true;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      tooltip.show(this);
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      const x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      const distance = (
        ((x - touchesStart.x) ** 2)
        + ((y - touchesStart.y) ** 2)
      ) ** 0.5;
      if (distance > 50) {
        isTouched = false;
        tooltip.hide();
      }
    }
    function handleTouchEnd() {
      if (!isTouched) return;
      isTouched = false;
      tooltip.hide();
    }
    function handleMouseEnter() {
      tooltip.show(this);
    }
    function handleMouseLeave() {
      tooltip.hide();
    }
    function handleTransitionEnd() {
      if (!$el.hasClass('tooltip-in')) {
        $el.removeClass('tooltip-out').remove();
      }
    }

    tooltip.attachEvents = function attachEvents() {
      $el.on('transitionend', handleTransitionEnd);
      if (tooltip.params.trigger === 'click') {
        $targetEl.on('click', handleClick);
        $('html').on('click', handleClickOut);
        return;
      }
      if (Support.touch) {
        const passive = Support.passiveListener ? { passive: true } : false;
        $targetEl.on(app.touchEvents.start, handleTouchStart, passive);
        app.on('touchmove', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      } else {
        $targetEl.on((Support.pointerEvents ? 'pointerenter' : 'mouseenter'), handleMouseEnter);
        $targetEl.on((Support.pointerEvents ? 'pointerleave' : 'mouseleave'), handleMouseLeave);
      }
    };
    tooltip.detachEvents = function detachEvents() {
      $el.off('transitionend', handleTransitionEnd);
      if (tooltip.params.trigger === 'click') {
        $targetEl.off('click', handleClick);
        $('html').off('click', handleClickOut);
        return;
      }
      if (Support.touch) {
        const passive = Support.passiveListener ? { passive: true } : false;
        $targetEl.off(app.touchEvents.start, handleTouchStart, passive);
        app.off('touchmove', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      } else {
        $targetEl.off((Support.pointerEvents ? 'pointerenter' : 'mouseenter'), handleMouseEnter);
        $targetEl.off((Support.pointerEvents ? 'pointerleave' : 'mouseleave'), handleMouseLeave);
      }
    };

    // Install Modules
    tooltip.useModules();

    tooltip.init();

    return tooltip;
  }

  position(targetEl) {
    const tooltip = this;
    const { $el, app } = tooltip;
    const tooltipOffset = tooltip.params.offset || 0;
    $el.css({ left: '', top: '' });
    const $targetEl = $(targetEl || tooltip.targetEl);
    const [width, height] = [$el.width(), $el.height()];

    $el.css({ left: '', top: '' });

    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();
      if (typeof targetWidth === 'undefined' && typeof targetHeight === 'undefined') {
        const clientRect = $targetEl[0].getBoundingClientRect();
        targetWidth = clientRect.width;
        targetHeight = clientRect.height;
      }

      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - app.left;
      targetOffsetTop = targetOffset.top - app.top;

      const targetParentPage = $targetEl.parents('.page');
      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    }
    let [left, top] = [0, 0, 0];

    // Top Position
    let position = 'top';

    if (height + tooltipOffset < targetOffsetTop) {
      // On top
      top = targetOffsetTop - height - tooltipOffset;
    } else if (height < app.height - targetOffsetTop - targetHeight) {
      // On bottom
      position = 'bottom';
      top = targetOffsetTop + targetHeight + tooltipOffset;
    } else {
      // On middle
      position = 'middle';
      top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
      if (top <= 0) {
        top = 8;
      } else if (top + height >= app.height) {
        top = app.height - height - 8;
      }
    }

    // Horizontal Position
    if (position === 'top' || position === 'bottom') {
      left = ((targetWidth / 2) + targetOffsetLeft) - (width / 2);
      if (left < 8) left = 8;
      if (left + width > app.width) left = app.width - width - 8;
      if (left < 0) left = 0;
    } else if (position === 'middle') {
      left = targetOffsetLeft - width;
      if (left < 8 || (left + width > app.width)) {
        if (left < 8) left = targetOffsetLeft + targetWidth;
        if (left + width > app.width) left = app.width - width - 8;
      }
    }

    // Apply Styles
    $el.css({ top: `${top}px`, left: `${left}px` });
  }

  show(aroundEl) {
    const tooltip = this;
    const { app, $el, $targetEl } = tooltip;
    app.root.append($el);
    tooltip.position(aroundEl);
    const $aroundEl = $(aroundEl);
    tooltip.visible = true;
    tooltip.opened = true;
    $targetEl.trigger('tooltip:show');
    $el.trigger('tooltip:show');
    if ($aroundEl.length && $aroundEl[0] !== $targetEl[0]) {
      $aroundEl.trigger('tooltip:show');
    }
    tooltip.emit('local::show tooltipShow', tooltip);
    $el.removeClass('tooltip-out').addClass('tooltip-in');
    return tooltip;
  }

  hide() {
    const tooltip = this;
    const { $el, $targetEl } = tooltip;
    tooltip.visible = false;
    tooltip.opened = false;
    $targetEl.trigger('tooltip:hide');
    $el.trigger('tooltip:hide');
    tooltip.emit('local::hide tooltipHide', tooltip);
    $el.addClass('tooltip-out').removeClass('tooltip-in');
    return tooltip;
  }

  render() {
    const tooltip = this;
    if (tooltip.params.render) return tooltip.params.render.call(tooltip, tooltip);
    const { cssClass, text } = tooltip.params;
    return `
      <div class="tooltip ${cssClass || ''}">
        <div class="tooltip-content">${text || ''}</div>
      </div>
    `.trim();
  }

  setText(newText) {
    const tooltip = this;
    if (typeof newText === 'undefined') {
      return tooltip;
    }
    tooltip.params.text = newText;
    tooltip.text = newText;
    if (tooltip.$el) {
      tooltip.$el.children('.tooltip-content').html(newText);
    }
    if (tooltip.opened) {
      tooltip.position();
    }
    return tooltip;
  }

  init() {
    const tooltip = this;
    tooltip.attachEvents();
  }

  destroy() {
    const tooltip = this;
    if (!tooltip.$targetEl || tooltip.destroyed) return;
    tooltip.$targetEl.trigger('tooltip:beforedestroy');
    tooltip.emit('local::beforeDestroy tooltipBeforeDestroy', tooltip);
    tooltip.$el.remove();
    delete tooltip.$targetEl[0].f7Tooltip;
    tooltip.detachEvents();
    Utils.deleteProps(tooltip);
    tooltip.destroyed = true;
  }
}

var Tooltip$1 = {
  name: 'tooltip',
  static: {
    Tooltip,
  },
  create() {
    const app = this;
    app.tooltip = ConstructorMethods({
      defaultSelector: '.tooltip',
      constructor: Tooltip,
      app,
      domProp: 'f7Tooltip',
    });
    app.tooltip.show = function show(el) {
      const $el = $(el);
      if ($el.length === 0) return undefined;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip) return undefined;
      tooltip.show($el[0]);
      return tooltip;
    };
    app.tooltip.hide = function hide(el) {
      const $el = $(el);
      if ($el.length === 0) return undefined;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip) return undefined;
      tooltip.hide();
      return tooltip;
    };
    app.tooltip.setText = function text(el, newText) {
      const $el = $(el);
      if ($el.length === 0) return undefined;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip) return undefined;
      tooltip.setText(newText);
      return tooltip;
    };
  },
  params: {
    tooltip: {
      targetEl: null,
      text: null,
      cssClass: null,
      render: null,
      offset: 0,
      trigger: 'hover',
    },
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.tooltip-init').each((index, el) => {
        const text = $(el).attr('data-tooltip');
        if (!text) return;
        app.tooltip.create({ targetEl: el, text });
      });
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find('.tooltip-init').each((index, el) => {
        if (el.f7Tooltip) el.f7Tooltip.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.tooltip-init').each((index, el) => {
        const text = $(el).attr('data-tooltip');
        if (!text) return;
        app.tooltip.create({ targetEl: el, text });
      });
      if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.tooltip-init').each((index, el) => {
          const text = $(el).attr('data-tooltip');
          if (!text) return;
          app.tooltip.create({ targetEl: el, text });
        });
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.tooltip-init').each((index, el) => {
        if (el.f7Tooltip) el.f7Tooltip.destroy();
      });
      if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.tooltip-init').each((index, el) => {
          if (el.f7Tooltip) el.f7Tooltip.destroy();
        });
      }
    },
  },
  vnode: {
    'tooltip-init': {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        const text = $(el).attr('data-tooltip');
        if (!text) return;
        app.tooltip.create({ targetEl: el, text });
      },
      update(vnode) {
        const el = vnode.elm;
        if (!el.f7Tooltip) return;
        if (vnode && vnode.data && vnode.data.attrs && vnode.data.attrs['data-tooltip']) {
          el.f7Tooltip.setText(vnode.data.attrs['data-tooltip']);
        }
      },
      destroy(vnode) {
        const el = vnode.elm;
        if (el.f7Tooltip) el.f7Tooltip.destroy();
      },
    },
  },
};

class Gauge extends Framework7Class {
  constructor(app, params = {}) {
    // Extends with open/close Modal methods;
    super(params, [app]);

    const gauge = this;

    const defaults = Utils.extend({}, app.params.gauge);

    // Extend defaults with modules params
    gauge.useModulesParams(defaults);

    gauge.params = Utils.extend(defaults, params);

    const { el } = gauge.params;
    if (!el) return gauge;

    const $el = $(el);
    if ($el.length === 0) return gauge;

    if ($el[0].f7Gauge) return $el[0].f7Gauge;

    Utils.extend(gauge, {
      app,
      $el,
      el: $el && $el[0],
    });

    $el[0].f7Gauge = gauge;

    // Install Modules
    gauge.useModules();

    gauge.init();

    return gauge;
  }

  calcRadius() {
    const gauge = this;
    const { size, borderWidth } = gauge.params;
    return (size / 2) - (borderWidth / 2);
  }

  calcBorderLength() {
    const gauge = this;
    const radius = gauge.calcRadius();
    return 2 * Math.PI * radius;
  }

  render() {
    const gauge = this;
    if (gauge.params.render) return gauge.params.render.call(gauge, gauge);

    const {
      type,
      value,
      size,
      bgColor,
      borderBgColor,
      borderColor,
      borderWidth,
      valueText,
      valueTextColor,
      valueFontSize,
      valueFontWeight,
      labelText,
      labelTextColor,
      labelFontSize,
      labelFontWeight,
    } = gauge.params;

    const semiCircle = type === 'semicircle';
    const radius = gauge.calcRadius();
    const length = gauge.calcBorderLength();
    const progress = Math.max(Math.min(value, 1), 0);

    return `
      <svg class="gauge-svg" width="${size}px" height="${semiCircle ? size / 2 : size}px" viewBox="0 0 ${size} ${semiCircle ? size / 2 : size}">
        ${semiCircle ? `
          <path
            class="gauge-back-semi"
            d="M${size - (borderWidth / 2)},${size / 2} a1,1 0 0,0 -${size - borderWidth},0"
            stroke="${borderBgColor}"
            stroke-width="${borderWidth}"
            fill="${bgColor || 'none'}"
          />
          <path
            class="gauge-front-semi"
            d="M${size - (borderWidth / 2)},${size / 2} a1,1 0 0,0 -${size - borderWidth},0"
            stroke="${borderColor}"
            stroke-width="${borderWidth}"
            stroke-dasharray="${length / 2}"
            stroke-dashoffset="${(length / 2) * (1 + progress)}"
            fill="${borderBgColor ? 'none' : (bgColor || 'none')}"
          />
        ` : `
          ${borderBgColor ? `
            <circle
              class="gauge-back-circle"
              stroke="${borderBgColor}"
              stroke-width="${borderWidth}"
              fill="${bgColor || 'none'}"
              cx="${size / 2}"
              cy="${size / 2}"
              r="${radius}"
            ></circle>
          ` : ''}
          <circle
            class="gauge-front-circle"
            transform="${`rotate(-90 ${size / 2} ${size / 2})`}"
            stroke="${borderColor}"
            stroke-width="${borderWidth}"
            stroke-dasharray="${length}"
            stroke-dashoffset="${length * (1 - progress)}"
            fill="${borderBgColor ? 'none' : bgColor || 'none'}"
            cx="${size / 2}"
            cy="${size / 2}"
            r="${radius}"
          ></circle>
        `}
        ${valueText ? `
          <text
            class="gauge-value-text"
            x="50%"
            y="${semiCircle ? '100%' : '50%'}"
            font-weight="${valueFontWeight}"
            font-size="${valueFontSize}"
            fill="${valueTextColor}"
            dy="${semiCircle ? (labelText ? -labelFontSize - 15 : -5) : 0}"
            text-anchor="middle"
            dominant-baseline="${!semiCircle && 'middle'}"
          >${valueText}</text>
        ` : ''}
        ${labelText ? `
          <text
            class="gauge-label-text"
            x="50%"
            y="${semiCircle ? '100%' : '50%'}"
            font-weight="${labelFontWeight}"
            font-size="${labelFontSize}"
            fill="${labelTextColor}"
            dy="${semiCircle ? -5 : (valueText ? ((valueFontSize / 2) + 10) : 0)}"
            text-anchor="middle"
            dominant-baseline="${!semiCircle && 'middle'}"
          >${labelText}</text>
        ` : ''}
      </svg>
    `.trim();
  }

  update(newParams = {}) {
    const gauge = this;
    const { params, $gaugeSvgEl } = gauge;

    Object.keys(newParams).forEach((param) => {
      if (typeof newParams[param] !== 'undefined') {
        params[param] = newParams[param];
      }
    });
    if ($gaugeSvgEl.length === 0) return gauge;

    const {
      value,
      size,
      bgColor,
      borderBgColor,
      borderColor,
      borderWidth,
      valueText,
      valueTextColor,
      valueFontSize,
      valueFontWeight,
      labelText,
      labelTextColor,
      labelFontSize,
      labelFontWeight,
    } = params;

    const length = gauge.calcBorderLength();
    const progress = Math.max(Math.min(value, 1), 0);
    const radius = gauge.calcRadius();
    const semiCircle = params.type === 'semicircle';

    const svgAttrs = {
      width: `${size}px`,
      height: `${semiCircle ? size / 2 : size}px`,
      viewBox: `0 0 ${size} ${semiCircle ? size / 2 : size}`,
    };
    Object.keys(svgAttrs).forEach((attr) => {
      $gaugeSvgEl.attr(attr, svgAttrs[attr]);
    });
    if (semiCircle) {
      const backAttrs = {
        d: `M${size - (borderWidth / 2)},${size / 2} a1,1 0 0,0 -${size - borderWidth},0`,
        stroke: borderBgColor,
        'stroke-width': borderWidth,
        fill: bgColor || 'none',
      };
      const frontAttrs = {
        d: `M${size - (borderWidth / 2)},${size / 2} a1,1 0 0,0 -${size - borderWidth},0`,
        stroke: borderColor,
        'stroke-width': borderWidth,
        'stroke-dasharray': length / 2,
        'stroke-dashoffset': (length / 2) * (1 + progress),
        fill: borderBgColor ? 'none' : (bgColor || 'none'),
      };
      Object.keys(backAttrs).forEach((attr) => {
        $gaugeSvgEl.find('.gauge-back-semi').attr(attr, backAttrs[attr]);
      });
      Object.keys(frontAttrs).forEach((attr) => {
        $gaugeSvgEl.find('.gauge-front-semi').attr(attr, frontAttrs[attr]);
      });
    } else {
      const backAttrs = {
        stroke: borderBgColor,
        'stroke-width': borderWidth,
        fill: bgColor || 'none',
        cx: size / 2,
        cy: size / 2,
        r: radius,
      };
      const frontAttrs = {
        transform: `rotate(-90 ${size / 2} ${size / 2})`,
        stroke: borderColor,
        'stroke-width': borderWidth,
        'stroke-dasharray': length,
        'stroke-dashoffset': length * (1 - progress),
        fill: borderBgColor ? 'none' : bgColor || 'none',
        cx: size / 2,
        cy: size / 2,
        r: radius,
      };
      Object.keys(backAttrs).forEach((attr) => {
        $gaugeSvgEl.find('.gauge-back-circle').attr(attr, backAttrs[attr]);
      });
      Object.keys(frontAttrs).forEach((attr) => {
        $gaugeSvgEl.find('.gauge-front-circle').attr(attr, frontAttrs[attr]);
      });
    }
    if (valueText) {
      if (!$gaugeSvgEl.find('.gauge-value-text').length) {
        $gaugeSvgEl.append('<text class="gauge-value-text"></text>');
      }
      const textAttrs = {
        x: '50%',
        y: semiCircle ? '100%' : '50%',
        'font-weight': valueFontWeight,
        'font-size': valueFontSize,
        fill: valueTextColor,
        dy: semiCircle ? (labelText ? -labelFontSize - 15 : -5) : 0,
        'text-anchor': 'middle',
        'dominant-baseline': !semiCircle && 'middle',
      };
      Object.keys(textAttrs).forEach((attr) => {
        $gaugeSvgEl.find('.gauge-value-text').attr(attr, textAttrs[attr]);
      });
      $gaugeSvgEl.find('.gauge-value-text').text(valueText);
    } else {
      $gaugeSvgEl.find('.gauge-value-text').remove();
    }
    if (labelText) {
      if (!$gaugeSvgEl.find('.gauge-label-text').length) {
        $gaugeSvgEl.append('<text class="gauge-label-text"></text>');
      }
      const labelAttrs = {
        x: '50%',
        y: semiCircle ? '100%' : '50%',
        'font-weight': labelFontWeight,
        'font-size': labelFontSize,
        fill: labelTextColor,
        dy: semiCircle ? -5 : (valueText ? ((valueFontSize / 2) + 10) : 0),
        'text-anchor': 'middle',
        'dominant-baseline': !semiCircle && 'middle',
      };
      Object.keys(labelAttrs).forEach((attr) => {
        $gaugeSvgEl.find('.gauge-label-text').attr(attr, labelAttrs[attr]);
      });
      $gaugeSvgEl.find('.gauge-label-text').text(labelText);
    } else {
      $gaugeSvgEl.find('.gauge-label-text').remove();
    }
    return gauge;
  }

  init() {
    const gauge = this;
    const $gaugeSvgEl = $(gauge.render()).eq(0);
    $gaugeSvgEl.f7Gauge = gauge;
    Utils.extend(gauge, {
      $gaugeSvgEl,
      gaugeSvgEl: $gaugeSvgEl && $gaugeSvgEl[0],
    });
    gauge.$el.append($gaugeSvgEl);
    return gauge;
  }

  destroy() {
    const gauge = this;
    if (!gauge.$el || gauge.destroyed) return;
    gauge.$el.trigger('gauge:beforedestroy');
    gauge.emit('local::beforeDestroy gaugeBeforeDestroy', gauge);
    gauge.$gaugeSvgEl.remove();
    delete gauge.$el[0].f7Gauge;
    Utils.deleteProps(gauge);
    gauge.destroyed = true;
  }
}

var Gauge$1 = {
  name: 'gauge',
  static: {
    Gauge,
  },
  create() {
    const app = this;
    app.gauge = ConstructorMethods({
      defaultSelector: '.gauge',
      constructor: Gauge,
      app,
      domProp: 'f7Gauge',
    });
    app.gauge.update = function update(el, newParams) {
      const $el = $(el);
      if ($el.length === 0) return undefined;
      const gauge = app.gauge.get(el);
      if (!gauge) return undefined;
      gauge.update(newParams);
      return gauge;
    };
  },
  params: {
    gauge: {
      el: null,
      type: 'circle',
      value: 0,
      size: 200,
      bgColor: 'transparent',
      borderBgColor: '#eeeeee',
      borderColor: '#000000',
      borderWidth: 10,
      valueText: null,
      valueTextColor: '#000000',
      valueFontSize: 31,
      valueFontWeight: 500,
      labelText: null,
      labelTextColor: '#888888',
      labelFontSize: 14,
      labelFontWeight: 400,
    },
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.gauge-init').each((index, el) => {
        app.gauge.create(Utils.extend({ el }, $(el).dataset() || {}));
      });
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find('.gauge-init').each((index, el) => {
        if (el.f7Gauge) el.f7Gauge.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.gauge-init').each((index, el) => {
        app.gauge.create(Utils.extend({ el }, $(el).dataset() || {}));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find('.gauge-init').each((index, el) => {
        if (el.f7Gauge) el.f7Gauge.destroy();
      });
    },
  },
  vnode: {
    'gauge-init': {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        app.gauge.create(Utils.extend({ el }, $(el).dataset() || {}));
      },
      destroy(vnode) {
        const el = vnode.elm;
        if (el.f7Gauge) el.f7Gauge.destroy();
      },
    },
  },
};

var Skeleton = {
  name: 'skeleton',
};

const Menu = {
  open(el = '.menu-item-dropdown') {
    const app = this;
    if (!el) return;
    const $el = $(el).closest('.menu-item-dropdown');
    if (!$el.length) return;
    const $menuEl = $el.closest('.menu').eq(0);
    if ($menuEl.length) {
      const zIndex = $menuEl.css('z-index');
      const originalZIndex = $menuEl[0].style.zIndex;
      $menuEl.css('z-index', parseInt(zIndex || 0, 0) + 1);
      $menuEl[0].f7MenuZIndex = originalZIndex;
    }
    $el.eq(0).addClass('menu-item-dropdown-opened').trigger('menu:opened');
    app.emit('menuOpened', $el.eq(0)[0]);
  },
  close(el = '.menu-item-dropdown-opened') {
    const app = this;
    if (!el) return;
    const $el = $(el).closest('.menu-item-dropdown-opened');
    if (!$el.length) return;
    const $menuEl = $el.closest('.menu').eq(0);
    if ($menuEl.length) {
      const zIndex = $menuEl[0].f7MenuZIndex;
      $menuEl.css('z-index', zIndex);
      delete $menuEl[0].f7MenuZIndex;
    }
    $el.eq(0).removeClass('menu-item-dropdown-opened').trigger('menu:closed');
    app.emit('menuClosed', $el.eq(0)[0]);
  },
};

var Menu$1 = {
  name: 'menu',
  create() {
    const app = this;
    app.menu = {
      open: Menu.open.bind(app),
      close: Menu.close.bind(app),
    };
  },
  on: {
    click(e) {
      const app = this;
      const openedMenus = $('.menu-item-dropdown-opened');
      if (!openedMenus.length) return;
      openedMenus.each((index, el) => {
        if (!$(e.target).closest('.menu-item-dropdown-opened').length) {
          app.menu.close(el);
        }
      });
    },
  },
  clicks: {
    '.menu-item-dropdown': function onClick($clickedEl, dataset, e) {
      const app = this;
      if ($clickedEl.hasClass('menu-item-dropdown-opened')) {
        if ($(e.target).closest('.menu-dropdown').length) return;
        app.menu.close($clickedEl);
      } else {
        app.menu.open($clickedEl);
      }
    },
    '.menu-close': function onClick() {
      const app = this;
      app.menu.close();
    },
  },
};

var moduleAlphaSlider = {
  render(self) {
    const { sliderLabel, sliderValue, sliderValueEditable, alphaLabelText } = self.params;
    return `
      <div class="color-picker-module color-picker-module-alpha-slider">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${alphaLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-alpha"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.01" min="0" max="1" class="color-picker-value-alpha">
              ` : `
                <span class="color-picker-value-alpha"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  },
  init(self) {
    self.alphaRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-alpha'),
      min: 0,
      max: 1,
      step: 0.01,
      value: 1,
      on: {
        change(range, value) {
          const alpha = Math.floor(value * 100) / 100;
          self.setValue({ alpha });
        },
      },
    });
    function handleInputChange(e) {
      const alpha = self.value.alpha;
      let value = parseFloat(e.target.value);
      if (Number.isNaN(value)) {
        e.target.value = alpha;
        return;
      }
      value = Math.max(0, Math.min(1, value));
      self.setValue({ alpha: value });
    }

    self.$el.on('change', '.color-picker-module-alpha-slider input', handleInputChange);

    self.destroyAlphaSliderEvents = function destroyAlphaSliderEvents() {
      self.$el.off('change', '.color-picker-module-alpha-slider input', handleInputChange);
    };
  },
  update(self) {
    const {
      value,
    } = self;
    const { sliderValue, sliderValueEditable } = self.params;

    const { alpha } = value;
    self.alphaRangeSlider.value = alpha;
    self.alphaRangeSlider.layout();
    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-alpha').val(alpha);
    } else {
      self.$el.find('span.color-picker-value-alpha').text(alpha);
    }
  },
  destroy(self) {
    if (self.alphaRangeSlider && self.alphaRangeSlider.destroy) {
      self.alphaRangeSlider.destroy();
    }
    delete self.alphaRangeSlider;

    if (self.destroyAlphaSliderEvents) self.destroyAlphaSliderEvents();
    delete self.destroyAlphaSliderEvents;
  },
};

var moduleCurrentColor = {
  render() {
    return `
      <div class="color-picker-module color-picker-module-current-color">
        <div class="color-picker-current-color"></div>
      </div>
    `;
  },
  update(self) {
    self.$el.find('.color-picker-module-current-color .color-picker-current-color').css(
      'background-color',
      self.value.hex,
    );
  },
};

var moduleHex = {
  render(self) {
    const { hexLabel, hexLabelText, hexValueEditable } = self.params;
    return `
      <div class="color-picker-module color-picker-module-hex">
        <div class="color-picker-hex-wrap">
          ${hexLabel ? `
            <div class="color-picker-hex-label">${hexLabelText}</div>
          ` : ''}
          <div class="color-picker-hex-value">
            ${hexValueEditable ? `
              <input type="text" class="color-picker-value-hex">
            ` : `
              <span class="color-picker-value-hex"></span>
            `}
          </div>
        </div>
      </div>
    `;
  },
  init(self) {
    function handleInputChange(e) {
      const hex = self.value.hex;
      let value = e.target.value.replace(/#/g, '');
      if (Number.isNaN(value) || !value || (value.length !== 3 && value.length !== 6)) {
        e.target.value = hex;
        return;
      }
      const min = 0;
      const current = parseInt(value, 16);
      const max = parseInt('ffffff', 16); // eslint-disable-line
      if (current > max) {
        value = 'fff';
      }
      if (current < min) {
        value = '000';
      }
      self.setValue({ hex: value });
    }

    self.$el.on('change', '.color-picker-module-hex input', handleInputChange);

    self.destroyHexEvents = function destroyHexEvents() {
      self.$el.off('change', '.color-picker-module-hex input', handleInputChange);
    };
  },
  update(self) {
    const {
      value,
    } = self;

    const { hexValueEditable } = self.params;

    const { hex } = value;
    if (hexValueEditable) {
      self.$el.find('input.color-picker-value-hex').val(hex);
    } else {
      self.$el.find('span.color-picker-value-hex').text(hex);
    }
  },
  destroy(self) {
    if (self.destroyHexEvents) self.destroyHexEvents();
    delete self.destroyHexEvents;
  },
};

var moduleHsbSliders = {
  render(self) {
    const { sliderLabel, sliderValue, sliderValueEditable, hueLabelText, saturationLabelText, brightnessLabelText } = self.params;
    return `
      <div class="color-picker-module color-picker-module-hsb-sliders">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${hueLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-hue"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="360" class="color-picker-value-hue" data-color-index="0">
              ` : `
                <span class="color-picker-value-hue"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${saturationLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-saturation"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="100" class="color-picker-value-saturation" data-color-index="1">
              ` : `
                <span class="color-picker-value-saturation"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${brightnessLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-brightness"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="100" class="color-picker-value-brightness" data-color-index="2">
              ` : `
                <span class="color-picker-value-brightness"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  },
  init(self) {
    self.hueRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-hue'),
      min: 0,
      max: 360,
      step: 0.1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({ hue: value });
        },
      },
    });
    self.saturationRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-saturation'),
      min: 0,
      max: 1,
      step: 0.001,
      value: 0,
      on: {
        change(range, value) {
          const s = Math.floor(value * 1000) / 1000;
          self.setValue({ hsb: [self.value.hsb[0], s, self.value.hsb[2]] });
        },
      },
    });
    self.brightnessRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-brightness'),
      min: 0,
      max: 1,
      step: 0.001,
      value: 0,
      on: {
        change(range, value) {
          const b = Math.floor(value * 1000) / 1000;
          self.setValue({ hsb: [self.value.hsb[0], self.value.hsb[1], b] });
        },
      },
    });

    function handleInputChange(e) {
      const hsb = [...self.value.hsb];
      const index = parseInt($(e.target).attr('data-color-index'), 10);
      let value = parseFloat(e.target.value);
      if (Number.isNaN(value)) {
        e.target.value = hsb[index];
        return;
      }
      if (index === 0) {
        value = Math.max(0, Math.min(360, value));
      } else {
        value = Math.max(0, Math.min(100, value)) / 100;
      }

      hsb[index] = value;
      self.setValue({ hsb });
    }

    self.$el.on('change', '.color-picker-module-hsb-sliders input', handleInputChange);

    self.destroyHsbSlidersEvents = function destroyHsbSlidersEvents() {
      self.$el.off('change', '.color-picker-module-hsb-sliders input', handleInputChange);
    };
  },
  update(self) {
    const {
      app,
      value,
    } = self;
    const { sliderValue, sliderValueEditable } = self.params;

    const { hsb, hue } = value;

    self.hueRangeSlider.value = hue;
    self.saturationRangeSlider.value = hsb[1];
    self.brightnessRangeSlider.value = hsb[2];

    self.hueRangeSlider.layout();
    self.saturationRangeSlider.layout();
    self.brightnessRangeSlider.layout();

    const hslCurrent = Utils.colorHsbToHsl(hsb[0], hsb[1], 1);
    const hslLeft = Utils.colorHsbToHsl(hsb[0], 0, 1);
    const hslRight = Utils.colorHsbToHsl(hsb[0], 1, 1);
    const brightness = hsb[2];

    self.hueRangeSlider.$el[0].style.setProperty(
      '--f7-range-knob-color',
      `hsl(${hue}, 100%, 50%)`
    );
    self.saturationRangeSlider.$el[0].style.setProperty(
      '--f7-range-knob-color',
      `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`
    );
    self.brightnessRangeSlider.$el[0].style.setProperty(
      '--f7-range-knob-color',
      `rgb(${brightness * 255}, ${brightness * 255}, ${brightness * 255})`
    );
    self.saturationRangeSlider.$el.find('.range-bar').css(
      'background-image',
      `linear-gradient(${app.rtl ? 'to left' : 'to right'}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`
    );

    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-hue').val(`${hue}`);
      self.$el.find('input.color-picker-value-saturation').val(`${hsb[1] * 1000 / 10}`);
      self.$el.find('input.color-picker-value-brightness').val(`${hsb[2] * 1000 / 10}`);
    } else if (sliderValue) {
      self.$el.find('span.color-picker-value-hue').text(`${hue}`);
      self.$el.find('span.color-picker-value-saturation').text(`${hsb[1] * 1000 / 10}`);
      self.$el.find('span.color-picker-value-brightness').text(`${hsb[2] * 1000 / 10}`);
    }
  },
  destroy(self) {
    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
      self.hueRangeSlider.destroy();
    }
    if (self.saturationRangeSlider && self.saturationRangeSlider.destroy) {
      self.saturationRangeSlider.destroy();
    }
    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
      self.brightnessRangeSlider.destroy();
    }

    delete self.hueRangeSlider;
    delete self.saturationRangeSlider;
    delete self.brightnessRangeSlider;

    if (self.destroyHsbSlidersEvents) self.destroyHsbSlidersEvents();
    delete self.destroyHsbSlidersEvents;
  },
};

var moduleHueSlider = {
  render(self) {
    const { sliderLabel, sliderValue, sliderValueEditable, hueLabelText } = self.params;
    return `
      <div class="color-picker-module color-picker-module-hue-slider">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${hueLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-hue"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="360" class="color-picker-value-hue">
              ` : `
                <span class="color-picker-value-hue"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  },
  init(self) {
    self.hueRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-hue'),
      min: 0,
      max: 360,
      step: 0.1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({ hue: value });
        },
      },
    });
  },
  update(self) {
    const {
      value,
    } = self;
    const { sliderValue, sliderValueEditable } = self.params;

    const { hue } = value;

    self.hueRangeSlider.value = hue;
    self.hueRangeSlider.layout();
    self.hueRangeSlider.$el[0].style.setProperty(
      '--f7-range-knob-color',
      `hsl(${hue}, 100%, 50%)`
    );
    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-hue').val(`${hue}`);
    } else if (sliderValue) {
      self.$el.find('span.color-picker-value-hue').text(`${hue}`);
    }
  },
  destroy(self) {
    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
      self.hueRangeSlider.destroy();
    }
    delete self.hueRangeSlider;
  },
};

var moduleBrightnessSlider = {
  render(self) {
    const { sliderLabel, sliderValue, sliderValueEditable, brightnessLabelText } = self.params;
    return `
      <div class="color-picker-module color-picker-module-brightness-slider">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${brightnessLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-brightness"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="100" class="color-picker-value-brightness">
              ` : `
                <span class="color-picker-value-brightness"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  },
  init(self) {
    self.brightnessRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-brightness'),
      min: 0,
      max: 1,
      step: 0.001,
      value: 0,
      on: {
        change(range, value) {
          const b = Math.floor(value * 1000) / 1000;
          self.setValue({ hsb: [self.value.hsb[0], self.value.hsb[1], b] });
        },
      },
    });
  },
  update(self) {
    const {
      value,
      app,
    } = self;
    const { sliderValue, sliderValueEditable } = self.params;

    const { hsb } = value;

    self.brightnessRangeSlider.value = hsb[2];
    self.brightnessRangeSlider.layout();

    const hslCurrent = Utils.colorHsbToHsl(hsb[0], hsb[1], hsb[2]);
    const hslLeft = Utils.colorHsbToHsl(hsb[0], hsb[1], 0);
    const hslRight = Utils.colorHsbToHsl(hsb[0], hsb[1], 1);

    self.brightnessRangeSlider.$el[0].style.setProperty(
      '--f7-range-knob-color',
      `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`
    );
    self.brightnessRangeSlider.$el.find('.range-bar').css(
      'background-image',
      `linear-gradient(${app.rtl ? 'to left' : 'to right'}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`
    );
    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-brightness').val(`${hsb[2] * 1000 / 10}`);
    } else if (sliderValue) {
      self.$el.find('span.color-picker-value-brightness').text(`${hsb[2] * 1000 / 10}`);
    }
  },
  destroy(self) {
    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
      self.brightnessRangeSlider.destroy();
    }
    delete self.brightnessRangeSlider;
  },
};

var modulePalette = {
  render(self) {
    return `
      <div class="color-picker-module color-picker-module-palette">
        <div class="color-picker-palette">
          ${self.params.palette.map((p) => {
            if (Array.isArray(p)) {
              let row = '<div class="color-picker-palette-row">';
              row += p.map(c => `
                <div class="color-picker-palette-value" data-palette-color="${c}" style="background-color: ${c}"></div>
              `).join('');
              row += '</div>';
              return row;
            }
            return `
              <div class="color-picker-palette-value" data-palette-color="${p}" style="background-color: ${p}"></div>
            `;
          }).join('')}
        </div>
      </div>
    `;
  },
  init(self) {
    function handlePaletteClick(e) {
      const hex = $(e.target).attr('data-palette-color');
      self.setValue({
        hex,
      });
    }

    self.$el.on('click', '.color-picker-module-palette .color-picker-palette-value', handlePaletteClick);

    self.destroyPaletteEvents = function destroyPaletteEvents() {
      self.$el.off('click', '.color-picker-module-hex input', handlePaletteClick);
    };
  },
  destroy(self) {
    if (self.destroyPaletteEvents) {
      self.destroyPaletteEvents();
    }
    delete self.destroyPaletteEvents;
  },
};

var moduleInitialCurrentColors = {
  render() {
    return `
      <div class="color-picker-module color-picker-module-initial-current-colors">
        <div class="color-picker-initial-current-colors">
          <div class="color-picker-initial-color"></div>
          <div class="color-picker-current-color"></div>
        </div>
      </div>
    `;
  },
  init(self) {
    function handleInitialColorClick() {
      if (self.initialValue) {
        const { hex, alpha } = self.initialValue;
        self.setValue({
          hex,
          alpha,
        });
      }
    }
    self.$el.on('click', '.color-picker-initial-color', handleInitialColorClick);
    self.destroyInitialCurrentEvents = function destroyInitialCurrentEvents() {
      self.$el.off('click', '.color-picker-initial-color', handleInitialColorClick);
    };
  },
  update(self) {
    self.$el.find('.color-picker-module-initial-current-colors .color-picker-initial-color').css(
      'background-color',
      self.initialValue.hex,
    );
    self.$el.find('.color-picker-module-initial-current-colors .color-picker-current-color').css(
      'background-color',
      self.value.hex,
    );
  },
  destroy(self) {
    if (self.destroyInitialCurrentEvents) {
      self.destroyInitialCurrentEvents();
    }
    delete self.destroyInitialCurrentEvents;
  },
};

var moduleRgbBars = {
  render(self) {
    const { barLabel, barValue, barValueEditable, redLabelText, greenLabelText, blueLabelText } = self.params;
    return `
      <div class="color-picker-module color-picker-module-rgb-bars">
        <div class="color-picker-bar-wrap">
          ${barLabel ? `
            <div class="color-picker-bar-label">${redLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-bar color-picker-bar-red"></div>
          ${barValue ? `
            <div class="color-picker-bar-value">
              ${barValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-bar-red" data-color-index="0">
              ` : `
                <span class="color-picker-value-bar-red"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-bar-wrap">
          ${barLabel ? `
            <div class="color-picker-bar-label">${greenLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-bar color-picker-bar-green"></div>
          ${barValue ? `
            <div class="color-picker-bar-value">
              ${barValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-bar-green" data-color-index="1">
              ` : `
                <span class="color-picker-value-bar-green"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-bar-wrap">
          ${barLabel ? `
            <div class="color-picker-bar-label">${blueLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-bar color-picker-bar-blue"></div>
          ${barValue ? `
            <div class="color-picker-bar-value">
              ${barValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-bar-blue" data-color-index="2">
              ` : `
                <span class="color-picker-value-bar-blue"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  },
  init(self) {
    self.redBar = self.app.range.create({
      el: self.$el.find('.color-picker-bar-red'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({ rgb: [value, self.value.rgb[1], self.value.rgb[2]] });
        },
      },
    });
    self.greenBar = self.app.range.create({
      el: self.$el.find('.color-picker-bar-green'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({ rgb: [self.value.rgb[0], value, self.value.rgb[2]] });
        },
      },
    });
    self.blueBar = self.app.range.create({
      el: self.$el.find('.color-picker-bar-blue'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({ rgb: [self.value.rgb[0], self.value.rgb[1], value] });
        },
      },
    });

    function handleInputChange(e) {
      const rgb = [...self.value.rgb];
      const index = parseInt($(e.target).attr('data-color-index'), 10);
      let value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) {
        e.target.value = rgb[index];
        return;
      }
      value = Math.max(0, Math.min(255, value));
      rgb[index] = value;
      self.setValue({ rgb });
    }

    self.$el.on('change', '.color-picker-module-rgb-bars input', handleInputChange);

    self.destroyRgbBarsEvents = function destroyRgbBarsEvents() {
      self.$el.off('change', '.color-picker-module-rgb-bars input', handleInputChange);
    };
  },
  update(self) {
    const {
      value,
      redBar,
      greenBar,
      blueBar,
    } = self;

    const { barValue, barValueEditable } = self.params;

    const { rgb } = value;

    redBar.value = rgb[0];
    greenBar.value = rgb[1];
    blueBar.value = rgb[2];

    redBar.layout();
    greenBar.layout();
    blueBar.layout();

    redBar.$el.find('.range-bar').css('background-image', `linear-gradient(to top, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
    greenBar.$el.find('.range-bar').css('background-image', `linear-gradient(to top, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
    blueBar.$el.find('.range-bar').css('background-image', `linear-gradient(to top, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);

    if (barValue && barValueEditable) {
      self.$el.find('input.color-picker-value-bar-red').val(rgb[0]);
      self.$el.find('input.color-picker-value-bar-green').val(rgb[1]);
      self.$el.find('input.color-picker-value-bar-blue').val(rgb[2]);
    } else if (barValue) {
      self.$el.find('span.color-picker-value-bar-red').text(rgb[0]);
      self.$el.find('span.color-picker-value-bar-green').text(rgb[1]);
      self.$el.find('span.color-picker-value-bar-blue').text(rgb[2]);
    }
  },
  destroy(self) {
    if (self.redBar && self.redBar.destroy) {
      self.redBar.destroy();
    }
    if (self.greenBar && self.greenBar.destroy) {
      self.greenBar.destroy();
    }
    if (self.blueBar && self.blueBar.destroy) {
      self.blueBar.destroy();
    }

    delete self.redBar;
    delete self.greenBar;
    delete self.blueBar;

    if (self.destroyRgbBarsEvents) self.destroyRgbBarsEvents();
    delete self.destroyRgbBarsEvents;
  },
};

var moduleRgbSliders = {
  render(self) {
    const { sliderLabel, sliderValue, sliderValueEditable, redLabelText, greenLabelText, blueLabelText } = self.params;
    return `
      <div class="color-picker-module color-picker-module-rgb-sliders">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${redLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-red"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-red" data-color-index="0">
              ` : `
                <span class="color-picker-value-red"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${greenLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-green"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-green" data-color-index="1">
              ` : `
                <span class="color-picker-value-green"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${blueLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-blue"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-blue" data-color-index="2">
              ` : `
                <span class="color-picker-value-blue"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  },
  init(self) {
    self.redRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-red'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({ rgb: [value, self.value.rgb[1], self.value.rgb[2]] });
        },
      },
    });
    self.greenRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-green'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({ rgb: [self.value.rgb[0], value, self.value.rgb[2]] });
        },
      },
    });
    self.blueRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-blue'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({ rgb: [self.value.rgb[0], self.value.rgb[1], value] });
        },
      },
    });

    function handleInputChange(e) {
      const rgb = [...self.value.rgb];
      const index = parseInt($(e.target).attr('data-color-index'), 10);
      let value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) {
        e.target.value = rgb[index];
        return;
      }
      value = Math.max(0, Math.min(255, value));
      rgb[index] = value;
      self.setValue({ rgb });
    }

    self.$el.on('change', '.color-picker-module-rgb-sliders input', handleInputChange);

    self.destroyRgbSlidersEvents = function destroyRgbSlidersEvents() {
      self.$el.off('change', '.color-picker-module-rgb-sliders input', handleInputChange);
    };
  },
  update(self) {
    const {
      app,
      value,
      redRangeSlider,
      greenRangeSlider,
      blueRangeSlider,
    } = self;

    const { sliderValue, sliderValueEditable } = self.params;

    const { rgb } = value;

    redRangeSlider.value = rgb[0];
    greenRangeSlider.value = rgb[1];
    blueRangeSlider.value = rgb[2];

    redRangeSlider.layout();
    greenRangeSlider.layout();
    blueRangeSlider.layout();

    redRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    greenRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    blueRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);

    const direction = app.rtl ? 'to left' : 'to right';

    redRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${direction}, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
    greenRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${direction}, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
    blueRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${direction}, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);

    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-red').val(rgb[0]);
      self.$el.find('input.color-picker-value-green').val(rgb[1]);
      self.$el.find('input.color-picker-value-blue').val(rgb[2]);
    } else if (sliderValue) {
      self.$el.find('span.color-picker-value-red').text(rgb[0]);
      self.$el.find('span.color-picker-value-green').text(rgb[1]);
      self.$el.find('span.color-picker-value-blue').text(rgb[2]);
    }
  },
  destroy(self) {
    if (self.redRangeSlider && self.redRangeSlider.destroy) {
      self.redRangeSlider.destroy();
    }
    if (self.greenRangeSlider && self.greenRangeSlider.destroy) {
      self.greenRangeSlider.destroy();
    }
    if (self.blueRangeSlider && self.blueRangeSlider.destroy) {
      self.blueRangeSlider.destroy();
    }

    delete self.redRangeSlider;
    delete self.greenRangeSlider;
    delete self.blueRangeSlider;

    if (self.destroyRgbSlidersEvents) self.destroyRgbSlidersEvents();
    delete self.destroyRgbSlidersEvents;
  },
};

var moduleSbSpectrum = {
  render() {
    return `
      <div class="color-picker-module color-picker-module-sb-spectrum">
        <div class="color-picker-sb-spectrum" style="background-color: hsl(0, 100%, 50%)">
          <div class="color-picker-sb-spectrum-handle"></div>
        </div>
      </div>
    `;
  },
  init(self) {
    const { app } = self;

    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;

    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;

    const { $el } = self;

    function setSBFromSpecterCoords(x, y) {
      let s = (x - specterRect.left) / specterRect.width;
      let b = (y - specterRect.top) / specterRect.height;
      s = Math.max(0, Math.min(1, s));
      b = 1 - Math.max(0, Math.min(1, b));

      self.setValue({ hsb: [self.value.hue, s, b] });
    }

    function handleTouchStart(e) {
      if (isMoved || isTouched) return;
      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = $(e.target);
      specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;
      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
      }
      if (specterIsTouched) {
        specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
        setSBFromSpecterCoords(touchStartX, touchStartY);
      }
      if (specterHandleIsTouched || specterIsTouched) {
        $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
      }
    }
    function handleTouchMove(e) {
      if (!(specterIsTouched || specterHandleIsTouched)) return;
      touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      if (!isMoved) {
        // First move
        isMoved = true;
        if (specterHandleIsTouched) {
          specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
        }
      }
      if (specterIsTouched || specterHandleIsTouched) {
        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }
    function handleTouchEnd() {
      isMoved = false;
      if (specterIsTouched || specterHandleIsTouched) {
        $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
      }
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }

    function handleResize() {
      self.modules['sb-spectrum'].update(self);
    }

    const passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;

    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    app.on('resize', handleResize);

    self.destroySpectrumEvents = function destroySpectrumEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('resize', handleResize);
    };
  },
  update(self) {
    const {
      value,
    } = self;

    const { hsl, hsb } = value;

    const specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
    const specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;

    self.$el.find('.color-picker-sb-spectrum')
      .css('background-color', `hsl(${hsl[0]}, 100%, 50%)`);

    self.$el.find('.color-picker-sb-spectrum-handle')
      .css('background-color', `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`)
      .transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
  },
  destroy(self) {
    if (self.destroySpectrumEvents) self.destroySpectrumEvents();
    delete self.destroySpectrumEvents;
  },
};

var moduleHsSpectrum = {
  render() {
    return `
      <div class="color-picker-module color-picker-module-hs-spectrum">
        <div class="color-picker-hs-spectrum">
          <div class="color-picker-hs-spectrum-handle"></div>
        </div>
      </div>
    `;
  },
  init(self) {
    const { app } = self;

    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;

    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;

    const { $el } = self;

    function setHSFromSpecterCoords(x, y) {
      let h = (x - specterRect.left) / specterRect.width * 360;
      let s = (y - specterRect.top) / specterRect.height;
      h = Math.max(0, Math.min(360, h));
      s = 1 - Math.max(0, Math.min(1, s));

      self.setValue({ hsb: [h, s, self.value.hsb[2]] });
    }

    function handleTouchStart(e) {
      if (isMoved || isTouched) return;
      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = $(e.target);
      specterHandleIsTouched = $targetEl.closest('.color-picker-hs-spectrum-handle').length > 0;
      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest('.color-picker-hs-spectrum').length > 0;
      }
      if (specterIsTouched) {
        specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
        setHSFromSpecterCoords(touchStartX, touchStartY);
      }
      if (specterHandleIsTouched || specterIsTouched) {
        $el.find('.color-picker-hs-spectrum-handle').addClass('color-picker-hs-spectrum-handle-pressed');
      }
    }
    function handleTouchMove(e) {
      if (!(specterIsTouched || specterHandleIsTouched)) return;
      touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      if (!isMoved) {
        // First move
        isMoved = true;
        if (specterHandleIsTouched) {
          specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
        }
      }
      if (specterIsTouched || specterHandleIsTouched) {
        setHSFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }
    function handleTouchEnd() {
      isMoved = false;
      if (specterIsTouched || specterHandleIsTouched) {
        $el.find('.color-picker-hs-spectrum-handle').removeClass('color-picker-hs-spectrum-handle-pressed');
      }
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }

    function handleResize() {
      self.modules['hs-spectrum'].update(self);
    }

    const passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;

    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    app.on('resize', handleResize);

    self.destroySpectrumEvents = function destroySpectrumEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('resize', handleResize);
    };
  },
  update(self) {
    const {
      value,
    } = self;

    const { hsb } = value;

    const specterWidth = self.$el.find('.color-picker-hs-spectrum')[0].offsetWidth;
    const specterHeight = self.$el.find('.color-picker-hs-spectrum')[0].offsetHeight;

    const hslBright = Utils.colorHsbToHsl(hsb[0], hsb[1], 1);

    self.$el.find('.color-picker-hs-spectrum-handle')
      .css('background-color', `hsl(${hslBright[0]}, ${hslBright[1] * 100}%, ${hslBright[2] * 100}%)`)
      .transform(`translate(${specterWidth * (hsb[0] / 360)}px, ${specterHeight * (1 - hsb[1])}px)`);
  },
  destroy(self) {
    if (self.destroySpectrumEvents) self.destroySpectrumEvents();
    delete self.destroySpectrumEvents;
  },
};

function svgWheelCircles() {
  const total = 256;
  let circles = '';
  for (let i = total; i > 0; i -= 1) {
    const angle = i * Math.PI / (total / 2);
    const hue = 360 / total * i;
    circles += `<circle cx="${150 - Math.sin(angle) * 125}" cy="${150 - Math.cos(angle) * 125}" r="25" fill="hsl(${hue}, 100%, 50%)"></circle>`;
  }
  return circles;
}
var moduleWheel = {
  render() {
    return `
      <div class="color-picker-module color-picker-module-wheel">
        <div class="color-picker-wheel">
          <svg viewBox="0 0 300 300" width="300" height="300">${svgWheelCircles()}</svg>
          <div class="color-picker-wheel-handle"></div>
          <div class="color-picker-sb-spectrum" style="background-color: hsl(0, 100%, 50%)">
            <div class="color-picker-sb-spectrum-handle"></div>
          </div>
        </div>
      </div>
    `;
  },
  init(self) {
    const { app } = self;

    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;

    let wheelRect;
    let wheelIsTouched;
    let wheelHandleIsTouched;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;

    const { $el } = self;

    function setHueFromWheelCoords(x, y) {
      const wheelCenterX = wheelRect.left + wheelRect.width / 2;
      const wheelCenterY = wheelRect.top + wheelRect.height / 2;
      const angleRad = Math.atan2(y - wheelCenterY, x - wheelCenterX);
      let angleDeg = angleRad * 180 / Math.PI + 90;
      if (angleDeg < 0) angleDeg += 360;
      angleDeg = 360 - angleDeg;
      self.setValue({ hue: angleDeg });
    }
    function setSBFromSpecterCoords(x, y) {
      let s = (x - specterRect.left) / specterRect.width;
      let b = (y - specterRect.top) / specterRect.height;
      s = Math.max(0, Math.min(1, s));
      b = 1 - Math.max(0, Math.min(1, b));

      self.setValue({ hsb: [self.value.hue, s, b] });
    }

    function handleTouchStart(e) {
      if (isMoved || isTouched) return;
      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = $(e.target);
      wheelHandleIsTouched = $targetEl.closest('.color-picker-wheel-handle').length > 0;
      wheelIsTouched = $targetEl.closest('circle').length > 0;
      specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;
      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
      }
      if (wheelIsTouched) {
        wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
        setHueFromWheelCoords(touchStartX, touchStartY);
      }
      if (specterIsTouched) {
        specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
        setSBFromSpecterCoords(touchStartX, touchStartY);
      }
      if (specterHandleIsTouched || specterIsTouched) {
        $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
      }
    }
    function handleTouchMove(e) {
      if (!(wheelIsTouched || wheelHandleIsTouched) && !(specterIsTouched || specterHandleIsTouched)) return;
      touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      if (!isMoved) {
        // First move
        isMoved = true;
        if (wheelHandleIsTouched) {
          wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
        }
        if (specterHandleIsTouched) {
          specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
        }
      }
      if (wheelIsTouched || wheelHandleIsTouched) {
        setHueFromWheelCoords(touchCurrentX, touchCurrentY);
      }
      if (specterIsTouched || specterHandleIsTouched) {
        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }
    function handleTouchEnd() {
      isMoved = false;
      if (specterIsTouched || specterHandleIsTouched) {
        $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
      }
      wheelIsTouched = false;
      wheelHandleIsTouched = false;
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }

    function handleResize() {
      self.modules.wheel.update(self);
    }

    const passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;

    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    app.on('resize', handleResize);

    self.destroyWheelEvents = function destroyWheelEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('resize', handleResize);
    };
  },
  update(self) {
    const {
      value,
    } = self;

    const { hsl, hsb } = value;

    const specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
    const specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;
    const wheelSize = self.$el.find('.color-picker-wheel')[0].offsetWidth;
    const wheelHalfSize = wheelSize / 2;
    const angleRad = value.hue * Math.PI / 180;
    const handleSize = wheelSize / 6;
    const handleHalfSize = handleSize / 2;
    const tX = wheelHalfSize - Math.sin(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
    const tY = wheelHalfSize - Math.cos(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
    self.$el.find('.color-picker-wheel-handle')
      .css('background-color', `hsl(${hsl[0]}, 100%, 50%)`)
      .transform(`translate(${tX}px, ${tY}px)`);

    self.$el.find('.color-picker-sb-spectrum')
      .css('background-color', `hsl(${hsl[0]}, 100%, 50%)`);

    self.$el.find('.color-picker-sb-spectrum-handle')
      .css('background-color', `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`)
      .transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
  },
  destroy(self) {
    if (self.destroyWheelEvents) self.destroyWheelEvents();
    delete self.destroyWheelEvents;
  },
};

class ColorPicker extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const self = this;

    self.params = Utils.extend({}, app.params.colorPicker, params);

    let $containerEl;
    if (self.params.containerEl) {
      $containerEl = $(self.params.containerEl);
      if ($containerEl.length === 0) return self;
    }

    let $inputEl;
    if (self.params.inputEl) {
      $inputEl = $(self.params.inputEl);
    }

    let $targetEl;
    if (self.params.targetEl) {
      $targetEl = $(self.params.targetEl);
    }

    Utils.extend(self, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      $targetEl,
      targetEl: $targetEl && $targetEl[0],
      initialized: false,
      opened: false,
      url: self.params.url,
      modules: {
        'alpha-slider': moduleAlphaSlider,
        'current-color': moduleCurrentColor,
        'hex': moduleHex, // eslint-disable-line
        'hsb-sliders': moduleHsbSliders,
        'hue-slider': moduleHueSlider,
        'brightness-slider': moduleBrightnessSlider,
        'palette': modulePalette, // eslint-disable-line
        'initial-current-colors': moduleInitialCurrentColors,
        'rgb-bars': moduleRgbBars,
        'rgb-sliders': moduleRgbSliders,
        'sb-spectrum': moduleSbSpectrum,
        'hs-spectrum': moduleHsSpectrum,
        'wheel': moduleWheel, // eslint-disable-line
      },
    });

    function onInputClick() {
      self.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onTargetClick() {
      self.open();
    }
    function onHtmlClick(e) {
      if (self.destroyed || !self.params) return;
      if (self.params.openIn === 'page') return;
      const $clickTargetEl = $(e.target);
      if (!self.opened || self.closing) return;
      if ($clickTargetEl.closest('[class*="backdrop"]').length) return;
      if ($clickTargetEl.closest('.color-picker-popup, .color-picker-popover').length) return;
      if ($inputEl && $inputEl.length > 0) {
        if ($clickTargetEl[0] !== $inputEl[0] && $clickTargetEl.closest('.sheet-modal').length === 0) {
          self.close();
        }
      } else if ($(e.target).closest('.sheet-modal').length === 0) {
        self.close();
      }
    }

    // Events
    Utils.extend(self, {
      attachInputEvents() {
        self.$inputEl.on('click', onInputClick);
        if (self.params.inputReadOnly) {
          self.$inputEl.on('focus mousedown', onInputFocus);
          if (self.$inputEl[0]) {
            self.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        self.$inputEl.off('click', onInputClick);
        if (self.params.inputReadOnly) {
          self.$inputEl.off('focus mousedown', onInputFocus);
          if (self.$inputEl[0]) {
            delete self.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachTargetEvents() {
        self.$targetEl.on('click', onTargetClick);
      },
      detachTargetEvents() {
        self.$targetEl.off('click', onTargetClick);
      },
      attachHtmlEvents() {
        app.on('click', onHtmlClick);
      },
      detachHtmlEvents() {
        app.off('click', onHtmlClick);
      },
    });

    self.init();

    return self;
  }

  get view() {
    const { $inputEl, $targetEl, app, params } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else {
      if ($inputEl) {
        view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
      }
      if (!view && $targetEl) {
        view = $targetEl.parents('.view').length && $targetEl.parents('.view')[0].f7View;
      }
    }
    if (!view) view = app.views.main;

    return view;
  }

  attachEvents() {
    const self = this;
    self.centerModules = self.centerModules.bind(self);
    if (self.params.centerModules) {
      self.app.on('resize', self.centerModules);
    }
  }

  detachEvents() {
    const self = this;
    if (self.params.centerModules) {
      self.app.off('resize', self.centerModules);
    }
  }

  centerModules() {
    const self = this;
    if (!self.opened || !self.$el || self.inline) return;
    const $pageContentEl = self.$el.find('.page-content');
    if (!$pageContentEl.length) return;
    const { scrollHeight, offsetHeight } = $pageContentEl[0];
    if (scrollHeight <= offsetHeight) {
      $pageContentEl.addClass('justify-content-center');
    } else {
      $pageContentEl.removeClass('justify-content-center');
    }
  }

  initInput() {
    const self = this;
    if (!self.$inputEl) return;
    if (self.params.inputReadOnly) self.$inputEl.prop('readOnly', true);
  }

  getModalType() {
    const self = this;
    const { app, modal, params } = self;
    const { openIn, openInPhone } = params;
    if (modal && modal.type) return modal.type;
    if (openIn !== 'auto') return openIn;
    if (self.inline) return null;
    if (app.device.ios) {
      return app.device.ipad ? 'popover' : openInPhone;
    }
    if (app.width >= 768 || (app.device.desktop && app.theme === 'aurora')) {
      return 'popover';
    }

    return openInPhone;
  }

  formatValue() {
    const self = this;
    const { value } = self;
    if (self.params.formatValue) {
      return self.params.formatValue.call(self, value);
    }
    return value.hex;
  }

  // eslint-disable-next-line
  normalizeHsValues(arr) {
    return [
      Math.floor(arr[0] * 10) / 10,
      Math.floor(arr[1] * 1000) / 1000,
      Math.floor(arr[2] * 1000) / 1000,
    ];
  }

  setValue(value = {}, updateModules = true) {
    const self = this;
    if (typeof value === 'undefined') return;

    let {
      hex,
      rgb,
      hsl,
      hsb,
      alpha = 1,
      hue,
      rgba,
      hsla,
    } = (self.value || {});

    const needChangeEvent = self.value || (!self.value && !self.params.value);
    let valueChanged;
    Object.keys(value).forEach((k) => {
      if (!self.value || typeof self.value[k] === 'undefined') {
        valueChanged = true;
        return;
      }
      const v = value[k];
      if (Array.isArray(v)) {
        v.forEach((subV, subIndex) => {
          if (subV !== self.value[k][subIndex]) {
            valueChanged = true;
          }
        });
      } else if (v !== self.value[k]) {
        valueChanged = true;
      }
    });
    if (!valueChanged) return;

    if (value.rgb || value.rgba) {
      const [r, g, b, a = alpha] = (value.rgb || value.rgba);
      rgb = [r, g, b];
      hex = Utils.colorRgbToHex(...rgb);
      hsl = Utils.colorRgbToHsl(...rgb);
      hsb = Utils.colorHslToHsb(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }

    if (value.hsl || value.hsla) {
      const [h, s, l, a = alpha] = (value.hsl || value.hsla);
      hsl = [h, s, l];
      rgb = Utils.colorHslToRgb(...hsl);
      hex = Utils.colorRgbToHex(...rgb);
      hsb = Utils.colorHslToHsb(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }

    if (value.hsb) {
      const [h, s, b, a = alpha] = value.hsb;
      hsb = [h, s, b];
      hsl = Utils.colorHsbToHsl(...hsb);
      rgb = Utils.colorHslToRgb(...hsl);
      hex = Utils.colorRgbToHex(...rgb);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }

    if (value.hex) {
      rgb = Utils.colorHexToRgb(value.hex);
      hex = Utils.colorRgbToHex(...rgb);
      hsl = Utils.colorRgbToHsl(...rgb);
      hsb = Utils.colorHslToHsb(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      rgba = [rgb[0], rgb[1], rgb[2], alpha];
      hsla = [hsl[0], hsl[1], hsl[2], alpha];
    }

    if (typeof value.alpha !== 'undefined') {
      alpha = value.alpha;
      if (typeof rgb !== 'undefined') {
        rgba = [rgb[0], rgb[1], rgb[2], alpha];
      }
      if (typeof hsl !== 'undefined') {
        hsla = [hsl[0], hsl[1], hsl[2], alpha];
      }
    }

    if (typeof value.hue !== 'undefined') {
      const [h, s, l] = hsl; // eslint-disable-line
      hsl = [value.hue, s, l];
      hsb = Utils.colorHslToHsb(...hsl);
      rgb = Utils.colorHslToRgb(...hsl);
      hex = Utils.colorRgbToHex(...rgb);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      rgba = [rgb[0], rgb[1], rgb[2], alpha];
      hsla = [hsl[0], hsl[1], hsl[2], alpha];
    }
    self.value = {
      hex,
      alpha,
      hue,
      rgb,
      hsl,
      hsb,
      rgba,
      hsla,
    };
    if (!self.initialValue) self.initialValue = Utils.extend({}, self.value);
    self.updateValue(needChangeEvent);
    if (self.opened && updateModules) {
      self.updateModules();
    }
  }

  getValue() {
    const self = this;
    return self.value;
  }

  updateValue(fireEvents = true) {
    const self = this;
    const { $inputEl, value, $targetEl } = self;
    if ($targetEl && self.params.targetElSetBackgroundColor) {
      const { rgba } = value;
      $targetEl.css('background-color', `rgba(${rgba.join(', ')})`);
    }
    if (fireEvents) {
      self.emit('local::change colorPickerChange', self, value);
    }

    if ($inputEl && $inputEl.length) {
      const inputValue = self.formatValue(value);
      if ($inputEl && $inputEl.length) {
        $inputEl.val(inputValue);
        if (fireEvents) {
          $inputEl.trigger('change');
        }
      }
    }
  }

  updateModules() {
    const self = this;
    const { modules } = self;
    self.params.modules.forEach((m) => {
      if (typeof m === 'string' && modules[m] && modules[m].update) {
        modules[m].update(self);
      } else if (m && m.update) {
        m.update(self);
      }
    });
  }

  update() {
    const self = this;
    self.updateModules();
  }

  renderPicker() {
    const self = this;
    const { params, modules } = self;
    let html = '';

    params.modules.forEach((m) => {
      if (typeof m === 'string' && modules[m] && modules[m].render) {
        html += modules[m].render(self);
      } else if (m && m.render) {
        html += m.render(self);
      }
    });

    return html;
  }

  renderNavbar() {
    const self = this;
    if (self.params.renderNavbar) {
      return self.params.renderNavbar.call(self, self);
    }
    const { openIn, navbarTitleText, navbarBackLinkText, navbarCloseText } = self.params;
    return `
    <div class="navbar">
      <div class="navbar-bg"></div>
      <div class="navbar-inner sliding">
        ${openIn === 'page' ? `
        <div class="left">
          <a class="link back">
            <i class="icon icon-back"></i>
            <span class="if-not-md">${navbarBackLinkText}</span>
          </a>
        </div>
        ` : ''}
        <div class="title">${navbarTitleText}</div>
        ${openIn !== 'page' ? `
        <div class="right">
          <a class="link popup-close" data-popup=".color-picker-popup">${navbarCloseText}</a>
        </div>
        ` : ''}
      </div>
    </div>
  `.trim();
  }

  renderToolbar() {
    const self = this;
    if (self.params.renderToolbar) {
      return self.params.renderToolbar.call(self, self);
    }
    return `
    <div class="toolbar toolbar-top no-shadow">
      <div class="toolbar-inner">
        <div class="left"></div>
        <div class="right">
          <a class="link sheet-close popover-close" data-sheet=".color-picker-sheet-modal" data-popover=".color-picker-popover">${self.params.toolbarCloseText}</a>
        </div>
      </div>
    </div>
  `.trim();
  }

  renderInline() {
    const self = this;
    const { cssClass, groupedModules } = self.params;
    const inlineHtml = `
    <div class="color-picker color-picker-inline ${groupedModules ? 'color-picker-grouped-modules' : ''} ${cssClass || ''}">
      ${self.renderPicker()}
    </div>
  `.trim();

    return inlineHtml;
  }

  renderSheet() {
    const self = this;
    const { cssClass, toolbarSheet, groupedModules } = self.params;
    const sheetHtml = `
    <div class="sheet-modal color-picker color-picker-sheet-modal ${groupedModules ? 'color-picker-grouped-modules' : ''} ${cssClass || ''}">
      ${toolbarSheet ? self.renderToolbar() : ''}
      <div class="sheet-modal-inner">
        <div class="page-content">
          ${self.renderPicker()}
        </div>
      </div>
    </div>
  `.trim();

    return sheetHtml;
  }

  renderPopover() {
    const self = this;
    const { cssClass, toolbarPopover, groupedModules } = self.params;
    const popoverHtml = `
    <div class="popover color-picker-popover ${cssClass || ''}">
      <div class="popover-inner">
        <div class="color-picker ${groupedModules ? 'color-picker-grouped-modules' : ''}">
          ${toolbarPopover ? self.renderToolbar() : ''}
          <div class="page-content">
            ${self.renderPicker()}
          </div>
        </div>
      </div>
    </div>
  `.trim();

    return popoverHtml;
  }

  renderPopup() {
    const self = this;
    const { cssClass, navbarPopup, groupedModules } = self.params;
    const popupHtml = `
    <div class="popup color-picker-popup ${cssClass || ''}">
      <div class="page">
        ${navbarPopup ? self.renderNavbar() : ''}
        <div class="color-picker ${groupedModules ? 'color-picker-grouped-modules' : ''}">
          <div class="page-content">
            ${self.renderPicker()}
          </div>
        </div>
      </div>
    </div>
  `.trim();

    return popupHtml;
  }

  renderPage() {
    const self = this;
    const { cssClass, groupedModules } = self.params;
    const pageHtml = `
    <div class="page color-picker-page ${cssClass || ''}" data-name="color-picker-page">
      ${self.renderNavbar()}
      <div class="color-picker ${groupedModules ? 'color-picker-grouped-modules' : ''}">
        <div class="page-content">
          ${self.renderPicker()}
        </div>
      </div>
    </div>
  `.trim();
    return pageHtml;
  }

  // eslint-disable-next-line
  render() {
    const self = this;
    const { params } = self;
    if (params.render) return params.render.call(self);
    if (self.inline) return self.renderInline();
    if (params.openIn === 'page') {
      return self.renderPage();
    }

    const modalType = self.getModalType();
    if (modalType === 'popover') return self.renderPopover();
    if (modalType === 'sheet') return self.renderSheet();
    if (modalType === 'popup') return self.renderPopup();
  }

  onOpen() {
    const self = this;
    const { initialized, $el, app, $inputEl, inline, value, params, modules } = self;
    self.closing = false;
    self.opened = true;
    self.opening = true;

    // Init main events
    self.attachEvents();

    params.modules.forEach((m) => {
      if (typeof m === 'string' && modules[m] && modules[m].init) {
        modules[m].init(self);
      } else if (m && m.init) {
        m.init(self);
      }
    });

    const updateValue = !value && params.value;

    // Set value
    if (!initialized) {
      if (value) self.setValue(value);
      else if (params.value) {
        self.setValue(params.value, false);
      } else if (!params.value) {
        self.setValue({ hex: '#ff0000' }, false);
      }
    } else if (value) {
      self.initialValue = Utils.extend({}, value);
      self.setValue(value, false);
    }

    // Update input value
    if (updateValue) self.updateValue();
    self.updateModules();

    // Center modules
    if (params.centerModules) {
      self.centerModules();
    }

    // Extra focus
    if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
      $inputEl.trigger('focus');
    }

    self.initialized = true;

    // Trigger events
    if ($el) {
      $el.trigger('colorpicker:open');
    }
    if ($inputEl) {
      $inputEl.trigger('colorpicker:open');
    }
    self.emit('local::open colorPickerOpen', self);
  }

  onOpened() {
    const self = this;
    self.opening = false;
    if (self.$el) {
      self.$el.trigger('colorpicker:opened');
    }
    if (self.$inputEl) {
      self.$inputEl.trigger('colorpicker:opened');
    }
    self.emit('local::opened colorPickerOpened', self);
  }

  onClose() {
    const self = this;
    const { app, params, modules } = self;
    self.opening = false;
    self.closing = true;

    // Detach events
    self.detachEvents();

    if (self.$inputEl) {
      if (app.theme === 'md') {
        self.$inputEl.trigger('blur');
      } else {
        const validate = self.$inputEl.attr('validate');
        const required = self.$inputEl.attr('required');
        if (validate && required) {
          app.input.validate(self.$inputEl);
        }
      }
    }
    params.modules.forEach((m) => {
      if (typeof m === 'string' && modules[m] && modules[m].destroy) {
        modules[m].destroy(self);
      } else if (m && m.destroy) {
        m.destroy(self);
      }
    });

    if (self.$el) {
      self.$el.trigger('colorpicker:close');
    }
    if (self.$inputEl) {
      self.$inputEl.trigger('colorpicker:close');
    }
    self.emit('local::close colorPickerClose', self);
  }

  onClosed() {
    const self = this;
    self.opened = false;
    self.closing = false;

    if (!self.inline) {
      Utils.nextTick(() => {
        if (self.modal && self.modal.el && self.modal.destroy) {
          if (!self.params.routableModals) {
            self.modal.destroy();
          }
        }
        delete self.modal;
      });
    }
    if (self.$el) {
      self.$el.trigger('colorpicker:closed');
    }
    if (self.$inputEl) {
      self.$inputEl.trigger('colorpicker:closed');
    }
    self.emit('local::closed colorPickerClosed', self);
  }

  open() {
    const self = this;
    const { app, opened, inline, $inputEl, $targetEl, params } = self;
    if (opened) return;

    if (inline) {
      self.$el = $(self.render());
      self.$el[0].f7ColorPicker = self;
      self.$containerEl.append(self.$el);
      self.onOpen();
      self.onOpened();
      return;
    }

    const colorPickerContent = self.render();

    if (params.openIn === 'page') {
      self.view.router.navigate({
        url: self.url,
        route: {
          content: colorPickerContent,
          path: self.url,
          on: {
            pageBeforeIn(e, page) {
              self.$el = page.$el.find('.color-picker');
              self.$el[0].f7ColorPicker = self;
              self.onOpen();
            },
            pageAfterIn() {
              self.onOpened();
            },
            pageBeforeOut() {
              self.onClose();
            },
            pageAfterOut() {
              self.onClosed();
              if (self.$el && self.$el[0]) {
                self.$el[0].f7ColorPicker = null;
                delete self.$el[0].f7ColorPicker;
              }
            },
          },
        },
      });
    } else {
      const modalType = self.getModalType();
      let backdrop = params.backdrop;
      if (backdrop === null || typeof backdrop === 'undefined') {
        if (modalType === 'popover' && app.params.popover.backdrop !== false) backdrop = true;
        if (modalType === 'popup') backdrop = true;
      }
      const modalParams = {
        targetEl: ($targetEl || $inputEl),
        scrollToEl: params.scrollToInput ? ($targetEl || $inputEl) : undefined,
        content: colorPickerContent,
        backdrop,
        closeByBackdropClick: params.closeByBackdropClick,
        on: {
          open() {
            const modal = this;
            self.modal = modal;
            self.$el = modalType === 'popover' || modalType === 'popup' ? modal.$el.find('.color-picker') : modal.$el;
            self.$el[0].f7ColorPicker = self;
            self.onOpen();
          },
          opened() { self.onOpened(); },
          close() { self.onClose(); },
          closed() {
            self.onClosed();
            if (self.$el && self.$el[0]) {
              self.$el[0].f7ColorPicker = null;
              delete self.$el[0].f7ColorPicker;
            }
          },
        },
      };
      if (modalType === 'popup') {
        modalParams.push = params.popupPush;
        modalParams.swipeToClose = params.popupSwipeToClose;
      }
      if (modalType === 'sheet') {
        modalParams.push = params.sheetPush;
        modalParams.swipeToClose = params.sheetSwipeToClose;
      }
      if (params.routableModals && self.view) {
        self.view.router.navigate({
          url: self.url,
          route: {
            path: self.url,
            [modalType]: modalParams,
          },
        });
      } else {
        self.modal = app[modalType].create(modalParams);
        self.modal.open();
      }
    }
  }

  close() {
    const self = this;
    const { opened, inline } = self;
    if (!opened) return;
    if (inline) {
      self.onClose();
      self.onClosed();
      return;
    }
    if ((self.params.routableModals && self.view) || self.params.openIn === 'page') {
      self.view.router.back();
    } else {
      self.modal.close();
    }
  }

  init() {
    const self = this;

    self.initInput();

    if (self.inline) {
      self.open();
      self.emit('local::init colorPickerInit', self);
      return;
    }

    if (!self.initialized && self.params.value) {
      self.setValue(self.params.value);
    }

    // Attach input Events
    if (self.$inputEl) {
      self.attachInputEvents();
    }
    if (self.$targetEl) {
      self.attachTargetEvents();
    }
    if (self.params.closeByOutsideClick) {
      self.attachHtmlEvents();
    }
    self.emit('local::init colorPickerInit', self);
  }

  destroy() {
    const self = this;
    if (self.destroyed) return;
    const { $el } = self;
    self.emit('local::beforeDestroy colorPickerBeforeDestroy', self);
    if ($el) $el.trigger('colorpicker:beforedestroy');

    self.close();

    // Detach Events
    self.detachEvents();
    if (self.$inputEl) {
      self.detachInputEvents();
    }
    if (self.$targetEl) {
      self.detachTargetEvents();
    }
    if (self.params.closeByOutsideClick) {
      self.detachHtmlEvents();
    }

    if ($el && $el.length) delete self.$el[0].f7ColorPicker;
    Utils.deleteProps(self);
    self.destroyed = true;
  }
}

var ColorPicker$1 = {
  name: 'colorPicker',
  static: {
    ColorPicker,
  },
  create() {
    const app = this;
    app.colorPicker = ConstructorMethods({
      defaultSelector: '.color-picker',
      constructor: ColorPicker,
      app,
      domProp: 'f7ColorPicker',
    });
    app.colorPicker.close = function close(el = '.color-picker') {
      const $el = $(el);
      if ($el.length === 0) return;
      const colorPicker = $el[0].f7ColorPicker;
      if (!colorPicker || (colorPicker && !colorPicker.opened)) return;
      colorPicker.close();
    };
  },
  params: {
    colorPicker: {
      // Color picker settings
      value: null,
      modules: [
        'wheel',
      ],
      palette: [
        ['#FFEBEE', '#FFCDD2', '#EF9A9A', '#E57373', '#EF5350', '#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C'],
        ['#F3E5F5', '#E1BEE7', '#CE93D8', '#BA68C8', '#AB47BC', '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C'],
        ['#E8EAF6', '#C5CAE9', '#9FA8DA', '#7986CB', '#5C6BC0', '#3F51B5', '#3949AB', '#303F9F', '#283593', '#1A237E'],
        ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#01579B'],
        ['#E0F2F1', '#B2DFDB', '#80CBC4', '#4DB6AC', '#26A69A', '#009688', '#00897B', '#00796B', '#00695C', '#004D40'],
        ['#F1F8E9', '#DCEDC8', '#C5E1A5', '#AED581', '#9CCC65', '#8BC34A', '#7CB342', '#689F38', '#558B2F', '#33691E'],
        ['#FFFDE7', '#FFF9C4', '#FFF59D', '#FFF176', '#FFEE58', '#FFEB3B', '#FDD835', '#FBC02D', '#F9A825', '#F57F17'],
        ['#FFF3E0', '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726', '#FF9800', '#FB8C00', '#F57C00', '#EF6C00', '#E65100'],
      ],
      groupedModules: false,
      centerModules: true,

      sliderLabel: false,
      sliderValue: false,
      sliderValueEdiable: false,

      barLabel: false,
      barValue: false,
      barValueEdiable: false,

      hexLabel: false,
      hexValueEditable: false,

      redLabelText: 'R',
      greenLabelText: 'G',
      blueLabelText: 'B',
      hueLabelText: 'H',
      saturationLabelText: 'S',
      brightnessLabelText: 'B',
      hexLabelText: 'HEX',
      alphaLabelText: 'A',

      // Common opener settings
      containerEl: null,
      openIn: 'popover', // or 'popover' or 'sheet' or 'popup' or 'page' or 'auto'
      openInPhone: 'popup', // or 'popover' or 'sheet' or 'popup' or 'page'
      popupPush: false,
      popupSwipeToClose: undefined,
      sheetPush: false,
      sheetSwipeToClose: undefined,
      formatValue: null,
      targetEl: null,
      targetElSetBackgroundColor: false,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      toolbarSheet: true,
      toolbarPopover: false,
      toolbarCloseText: 'Done',
      navbarPopup: true,
      navbarCloseText: 'Done',
      navbarTitleText: 'Color',
      navbarBackLinkText: 'Back',
      cssClass: null,
      routableModals: true,
      view: null,
      url: 'color/',
      backdrop: null,
      closeByBackdropClick: true,
      // Render functions
      renderToolbar: null,
      renderNavbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      renderPopup: null,
      render: null,
    },
  },
};

const Treeview = {
  open(itemEl) {
    const app = this;
    const $itemEl = $(itemEl).eq(0);
    if (!$itemEl.length) return;
    $itemEl.addClass('treeview-item-opened');
    $itemEl.trigger('treeview:open');
    app.emit('treeviewOpen', $itemEl[0]);
    function done(cancel) {
      if (cancel) {
        $itemEl.removeClass('treeview-item-opened');
        $itemEl.trigger('treeview:close');
        app.emit('treeviewClose', $itemEl[0]);
      } else {
        $itemEl[0].f7TreeviewChildrenLoaded = true;
      }
      $itemEl.find('.treeview-toggle').removeClass('treeview-toggle-hidden');
      $itemEl.find('.treeview-preloader').remove();
    }

    if ($itemEl.hasClass('treeview-load-children') && !$itemEl[0].f7TreeviewChildrenLoaded) {
      $itemEl.trigger('treeview:loadchildren', done);
      app.emit('treeviewLoadChildren', $itemEl[0], done);
      $itemEl.find('.treeview-toggle').addClass('treeview-toggle-hidden');
      $itemEl.find('.treeview-item-root').prepend(`<div class="preloader treeview-preloader">${Utils[`${app.theme}PreloaderContent`]}</div>`);
    }
  },
  close(itemEl) {
    const app = this;
    const $itemEl = $(itemEl).eq(0);
    if (!$itemEl.length) return;
    $itemEl.removeClass('treeview-item-opened');
    $itemEl.trigger('treeview:close');
    app.emit('treeviewClose', $itemEl[0]);
  },
  toggle(itemEl) {
    const app = this;
    const $itemEl = $(itemEl).eq(0);
    if (!$itemEl.length) return;
    const wasOpened = $itemEl.hasClass('treeview-item-opened');
    app.treeview[wasOpened ? 'close' : 'open']($itemEl);
  },
};

var Treeview$1 = {
  name: 'treeview',
  create() {
    const app = this;
    Utils.extend(app, {
      treeview: {
        open: Treeview.open.bind(app),
        close: Treeview.close.bind(app),
        toggle: Treeview.toggle.bind(app),
      },
    });
  },
  clicks: {
    '.treeview-toggle': function toggle($clickedEl, clickedData, e) {
      const app = this;
      if ($clickedEl.parents('.treeview-item-toggle').length) return;
      const $treeviewItemEl = $clickedEl.parents('.treeview-item').eq(0);
      if (!$treeviewItemEl.length) return;
      e.preventF7Router = true;
      app.treeview.toggle($treeviewItemEl[0]);
    },
    '.treeview-item-toggle': function toggle($clickedEl, clickedData, e) {
      const app = this;
      const $treeviewItemEl = $clickedEl.closest('.treeview-item').eq(0);
      if (!$treeviewItemEl.length) return;
      e.preventF7Router = true;
      app.treeview.toggle($treeviewItemEl[0]);
    },
  },
};

const textEditorButtonsMap = {
  // f7-icon, material-icon, command
  bold: ['bold', 'format_bold', 'bold'],
  italic: ['italic', 'format_italic', 'italic'],
  underline: ['underline', 'format_underlined', 'underline'],
  strikeThrough: ['strikethrough', 'strikethrough_s', 'strikeThrough'],
  orderedList: ['list_number', 'format_list_numbered', 'insertOrderedList'],
  unorderedList: ['list_bullet', 'format_list_bulleted', 'insertUnorderedList'],
  link: ['link', 'link', 'createLink'],
  image: ['photo', 'image', 'insertImage'],
  paragraph: ['paragraph', '<i class="icon"></i>', 'formatBlock.P'],
  h1: ['<i class="icon">H<sub>1</sub></i>', '<i class="icon">H<sub>1</sub></i>', 'formatBlock.H1'],
  h2: ['<i class="icon">H<sub>2</sub></i>', '<i class="icon">H<sub>2</sub></i>', 'formatBlock.H2'],
  h3: ['<i class="icon">H<sub>3</sub></i>', '<i class="icon">H<sub>3</sub></i>', 'formatBlock.H3'],
  alignLeft: ['text_alignleft', 'format_align_left', 'justifyLeft'],
  alignCenter: ['text_aligncenter', 'format_align_center', 'justifyCenter'],
  alignRight: ['text_alignright', 'format_align_right', 'justifyRight'],
  alignJustify: ['text_justify', 'format_align_justify', 'justifyFull'],
  subscript: ['textformat_subscript', '<i class="icon">A<sub>1</sub></i>', 'subscript'],
  superscript: ['textformat_superscript', '<i class="icon">A<sup>1</sup></i>', 'superscript'],
  indent: ['increase_indent', 'format_indent_increase', 'indent'],
  outdent: ['decrease_indent', 'format_indent_decrease', 'outdent'],
};

class TextEditor extends Framework7Class {
  constructor(app, params) {
    super(params, [app]);
    const self = this;

    const defaults = Utils.extend({}, app.params.textEditor);

    // Extend defaults with modules params
    self.useModulesParams(defaults);

    self.params = Utils.extend(defaults, params);

    const el = self.params.el;
    if (!el) return self;

    const $el = $(el);
    if ($el.length === 0) return self;

    if ($el[0].f7TextEditor) return $el[0].f7TextEditor;

    let $contentEl = $el.children('.text-editor-content');
    if (!$contentEl.length) {
      $el.append('<div class="text-editor-content" contenteditable></div>');
      $contentEl = $el.children('.text-editor-content');
    }

    Utils.extend(self, {
      app,
      $el,
      el: $el[0],
      $contentEl,
      contentEl: $contentEl[0],
    });
    if ('value' in params) {
      self.value = self.params.value;
    }

    if (self.params.mode === 'keyboard-toolbar') {
      if (!app.device.cordova && !app.device.android) {
        self.params.mode = 'popover';
      }
    }

    if (typeof self.params.buttons === 'string') {
      try {
        self.params.buttons = JSON.parse(self.params.buttons);
      } catch (err) {
        throw new Error('Framework7: TextEditor: wrong "buttons" parameter format');
      }
    }

    $el[0].f7TextEditor = self;

    // Bind
    self.onButtonClick = self.onButtonClick.bind(self);
    self.onFocus = self.onFocus.bind(self);
    self.onBlur = self.onBlur.bind(self);
    self.onInput = self.onInput.bind(self);
    self.onPaste = self.onPaste.bind(self);
    self.onSelectionChange = self.onSelectionChange.bind(self);
    self.closeKeyboardToolbar = self.closeKeyboardToolbar.bind(self);

    // Handle Events
    self.attachEvents = function attachEvents() {
      if (self.params.mode === 'toolbar') {
        self.$el.find('.text-editor-toolbar').on('click', 'button', self.onButtonClick);
      }
      if (self.params.mode === 'keyboard-toolbar') {
        self.$keyboardToolbarEl.on('click', 'button', self.onButtonClick);
        self.$el.parents('.page').on('page:beforeout', self.closeKeyboardToolbar);
      }
      if (self.params.mode === 'popover' && self.popover) {
        self.popover.$el.on('click', 'button', self.onButtonClick);
      }
      self.$contentEl.on('paste', self.onPaste);
      self.$contentEl.on('focus', self.onFocus);
      self.$contentEl.on('blur', self.onBlur);
      self.$contentEl.on('input', self.onInput, true);
      $(doc).on('selectionchange', self.onSelectionChange);
    };
    self.detachEvents = function detachEvents() {
      if (self.params.mode === 'toolbar') {
        self.$el.find('.text-editor-toolbar').off('click', 'button', self.onButtonClick);
      }
      if (self.params.mode === 'keyboard-toolbar') {
        self.$keyboardToolbarEl.off('click', 'button', self.onButtonClick);
        self.$el.parents('.page').off('page:beforeout', self.closeKeyboardToolbar);
      }
      if (self.params.mode === 'popover' && self.popover) {
        self.popover.$el.off('click', 'button', self.onButtonClick);
      }
      self.$contentEl.off('paste', self.onPaste);
      self.$contentEl.off('focus', self.onFocus);
      self.$contentEl.off('blur', self.onBlur);
      self.$contentEl.off('input', self.onInput, true);
      $(doc).off('selectionchange', self.onSelectionChange);
    };

    // Install Modules
    self.useModules();

    // Init
    self.init();

    return self;
  }

  setValue(newValue) {
    const self = this;
    const currentValue = self.value;
    if (currentValue === newValue) return self;
    self.value = newValue;
    self.$contentEl.html(newValue);
    self.$el.trigger('texteditor:change', self.value);
    self.emit('local::change textEditorChange', self, self.value);
    return self;
  }

  getValue() {
    const self = this;
    return self.value;
  }

  createLink() {
    const self = this;
    const currentSelection = win.getSelection();
    const selectedNodes = [];
    let $selectedLinks;
    if (currentSelection && currentSelection.anchorNode && $(currentSelection.anchorNode).parents(self.$el).length) {
      let anchorNode = currentSelection.anchorNode;
      while (anchorNode) {
        selectedNodes.push(anchorNode);
        if (!anchorNode.nextSibling || anchorNode === currentSelection.focusNode) {
          anchorNode = null;
        }
        if (anchorNode) {
          anchorNode = anchorNode.nextSibling;
        }
      }
      $selectedLinks = $(selectedNodes).closest('a').add($(selectedNodes).children('a'));
    }
    if ($selectedLinks && $selectedLinks.length) {
      $selectedLinks.each((linkIndex, linkNode) => {
        const selection = win.getSelection();
        const range = doc.createRange();
        range.selectNodeContents(linkNode);
        selection.removeAllRanges();
        selection.addRange(range);
        doc.execCommand('unlink', false);
        selection.removeAllRanges();
      });
      return self;
    }
    const currentRange = self.getSelectionRange();
    if (!currentRange) return self;
    const dialog = self.app.dialog.prompt(self.params.linkUrlText, '', (link) => {
      if (link && link.trim().length) {
        self.setSelectionRange(currentRange);
        doc.execCommand('createLink', false, link.trim());
      }
    });
    dialog.$el.find('input').focus();
    return self;
  }

  insertImage() {
    const self = this;
    const currentRange = self.getSelectionRange();
    if (!currentRange) return self;
    const dialog = self.app.dialog.prompt(self.params.imageUrlText, '', (imageUrl) => {
      if (imageUrl && imageUrl.trim().length) {
        self.setSelectionRange(currentRange);
        doc.execCommand('insertImage', false, imageUrl.trim());
      }
    });
    dialog.$el.find('input').focus();
    return self;
  }

  removePlaceholder() {
    const self = this;
    self.$contentEl.find('.text-editor-placeholder').remove();
  }

  insertPlaceholder() {
    const self = this;
    self.$contentEl.append(`<div class="text-editor-placeholder">${self.params.placeholder}</div>`);
  }

  onSelectionChange() {
    const self = this;
    if (self.params.mode === 'toolbar') return;
    const selection = win.getSelection();
    const selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
    if (self.params.mode === 'keyboard-toolbar') {
      if (!selectionIsInContent) {
        self.closeKeyboardToolbar();
      } else {
        self.openKeyboardToolbar();
      }
      return;
    }
    if (self.params.mode === 'popover') {
      const selectionIsInPopover = $(selection.anchorNode).parents(self.popover.el).length || selection.anchorNode === self.popover.el;
      if (!selectionIsInContent && !selectionIsInPopover) {
        self.closePopover();
        return;
      }
      if (!selection.isCollapsed && selection.rangeCount) {
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        const rootEl = self.app.root[0] || doc.body;
        self.openPopover(rect.x + (win.scrollX || 0) - rootEl.offsetLeft, rect.y + (win.scrollY || 0) - rootEl.offsetTop, rect.width, rect.height);
      } else if (selection.isCollapsed) {
        self.closePopover();
      }
    }
  }

  onPaste(e) {
    const self = this;
    if (self.params.clearFormattingOnPaste && e.clipboardData && e.clipboardData.getData) {
      const text = e.clipboardData.getData('text/plain');
      e.preventDefault();
      doc.execCommand('insertText', false, text);
    }
  }

  onInput() {
    const self = this;
    const value = self.$contentEl.html();

    self.$el.trigger('texteditor:input');
    self.emit('local:input textEditorInput', self);

    self.value = value;
    self.$el.trigger('texteditor:change', self.value);
    self.emit('local::change textEditorChange', self, self.value);
  }

  onFocus() {
    const self = this;
    self.removePlaceholder();
    self.$contentEl.focus();
    self.$el.trigger('texteditor:focus');
    self.emit('local::focus textEditorFocus', self);
  }

  onBlur() {
    const self = this;
    if (self.params.placeholder && self.$contentEl.html() === '') {
      self.insertPlaceholder();
    }
    if (self.params.mode === 'popover') {
      const selection = win.getSelection();
      const selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
      const inPopover = doc.activeElement && self.popover && $(doc.activeElement).closest(self.popover.$el).length;
      if (!inPopover && !selectionIsInContent) {
        self.closePopover();
      }
    }
    if (self.params.mode === 'keyboard-toolbar') {
      const selection = win.getSelection();
      const selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
      if (!selectionIsInContent) {
        self.closeKeyboardToolbar();
      }
    }
    self.$el.trigger('texteditor:blur');
    self.emit('local::blur textEditorBlur', self);
  }

  onButtonClick(e) {
    const self = this;
    const selection = win.getSelection();
    const selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
    if (!selectionIsInContent) return;
    const $buttonEl = $(e.target).closest('button');
    if ($buttonEl.parents('form').length) {
      e.preventDefault();
    }
    const button = $buttonEl.attr('data-button');
    const buttonData = self.params.customButtons && self.params.customButtons[button];
    if (!button || !(textEditorButtonsMap[button] || buttonData)) return;
    $buttonEl.trigger('texteditor:buttonclick', button);
    self.emit('local::buttonClick textEditorButtonClick', self, button);
    if (buttonData) {
      if (buttonData.onClick) buttonData.onClick(self, $buttonEl[0]);
      return;
    }
    const command = textEditorButtonsMap[button][2];
    if (command === 'createLink') {
      self.createLink();
      return;
    }
    if (command === 'insertImage') {
      self.insertImage();
      return;
    }
    if (command.indexOf('formatBlock') === 0) {
      const tagName = command.split('.')[1];
      const $anchorNode = $(selection.anchorNode);
      if ($anchorNode.parents(tagName.toLowerCase()).length || $anchorNode.is(tagName)) {
        doc.execCommand('formatBlock', false, 'div');
      } else {
        doc.execCommand('formatBlock', false, tagName);
      }
      return;
    }
    doc.execCommand(command, false);
  }

  // eslint-disable-next-line
  getSelectionRange() {
    if (win.getSelection) {
      const sel = win.getSelection();
      if (sel.getRangeAt && sel.rangeCount) {
        return sel.getRangeAt(0);
      }
    } else if (doc.selection && doc.selection.createRange) {
      return doc.selection.createRange();
    }
    return null;
  }

  // eslint-disable-next-line
  setSelectionRange(range) {
    if (range) {
      if (win.getSelection) {
        const sel = win.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      } else if (doc.selection && range.select) {
        range.select();
      }
    }
  }

  renderButtons() {
    const self = this;
    let html = '';
    function renderButton(button) {
      const iconClass = self.app.theme === 'md' ? 'material-icons' : 'f7-icons';
      if (self.params.customButtons && self.params.customButtons[button]) {
        const buttonData = self.params.customButtons[button];
        return `<button type="button" class="text-editor-button" data-button="${button}">${buttonData.content || ''}</button>`;
      }
      if (!textEditorButtonsMap[button]) return '';
      const iconContent = textEditorButtonsMap[button][self.app.theme === 'md' ? 1 : 0];
      return `<button type="button" class="text-editor-button" data-button="${button}">${iconContent.indexOf('<') >= 0 ? iconContent : `<i class="${iconClass}">${iconContent}</i>`}</button>`.trim();
    }
    self.params.buttons.forEach((button, buttonIndex) => {
      if (Array.isArray(button)) {
        button.forEach((b) => {
          html += renderButton(b);
        });
        if (buttonIndex < self.params.buttons.length - 1 && self.params.dividers) {
          html += '<div class="text-editor-button-divider"></div>';
        }
      } else {
        html += renderButton(button);
      }
    });
    return html;
  }

  createToolbar() {
    const self = this;
    self.$el.prepend(`<div class="text-editor-toolbar">${self.renderButtons()}</div>`);
  }

  createKeyboardToolbar() {
    const self = this;
    const isDark = self.$el.closest('.theme-dark').length > 0 || self.app.device.prefersColorScheme() === 'dark';
    self.$keyboardToolbarEl = $(`<div class="toolbar toolbar-bottom text-editor-keyboard-toolbar ${isDark ? 'theme-dark' : ''}"><div class="toolbar-inner">${self.renderButtons()}</div></div>`);
  }

  createPopover() {
    const self = this;
    const isDark = self.$el.closest('.theme-dark').length > 0;
    self.popover = self.app.popover.create({
      content: `
        <div class="popover ${isDark ? 'theme-light' : 'theme-dark'} text-editor-popover">
          <div class="popover-inner">${self.renderButtons()}</div>
        </div>
      `,
      closeByOutsideClick: false,
      backdrop: false,
    });
  }

  openKeyboardToolbar() {
    const self = this;
    if (self.$keyboardToolbarEl.parent(self.app.root).length) return;
    self.$el.trigger('texteditor:keyboardopen');
    self.emit('local::keyboardOpen textEditorKeyboardOpen', self);
    self.app.root.append(self.$keyboardToolbarEl);
  }

  closeKeyboardToolbar() {
    const self = this;
    self.$keyboardToolbarEl.remove();
    self.$el.trigger('texteditor:keyboardclose');
    self.emit('local::keyboardClose textEditorKeyboardClose', self);
  }

  openPopover(targetX, targetY, targetWidth, targetHeight) {
    const self = this;

    if (!self.popover) return;
    Object.assign(self.popover.params, {
      targetX,
      targetY,
      targetWidth,
      targetHeight,
    });
    clearTimeout(self.popoverTimeout);
    self.popoverTimeout = setTimeout(() => {
      if (!self.popover) return;
      if (self.popover.opened) {
        self.popover.resize();
      } else {
        self.$el.trigger('texteditor:popoveropen');
        self.emit('local::popoverOpen textEditorPopoverOpen', self);
        self.popover.open();
      }
    }, 400);
  }

  closePopover() {
    const self = this;
    clearTimeout(self.popoverTimeout);
    if (!self.popover || !self.popover.opened) return;
    self.popoverTimeout = setTimeout(() => {
      if (!self.popover) return;
      self.$el.trigger('texteditor:popoverclose');
      self.emit('local::popoverClose textEditorPopoverClose', self);
      self.popover.close();
    }, 400);
  }

  init() {
    const self = this;
    if (self.value) {
      self.$contentEl.html(self.value);
    } else {
      self.value = self.$contentEl.html();
    }
    if (self.params.placeholder && self.value === '') {
      self.insertPlaceholder();
    }
    if (self.params.mode === 'toolbar') {
      self.createToolbar();
    } else if (self.params.mode === 'popover') {
      self.createPopover();
    } else if (self.params.mode === 'keyboard-toolbar') {
      self.createKeyboardToolbar();
    }

    self.attachEvents();
    self.$el.trigger('texteditor:init');
    self.emit('local::init textEditorInit', self);
    return self;
  }

  destroy() {
    let self = this;
    self.$el.trigger('texteditor:beforedestroy');
    self.emit('local::beforeDestroy textEditorBeforeDestroy', self);
    self.detachEvents();
    if (self.params.mode === 'keyboard-toolbar' && self.$keyboardToolbarEl) {
      self.$keyboardToolbarEl.remove();
    }
    if (self.popover) {
      self.popover.close(false);
      self.popover.destroy();
    }
    delete self.$el[0].f7TextEditor;
    Utils.deleteProps(self);
    self = null;
  }
}

var TextEditor$1 = {
  name: 'textEditor',
  params: {
    textEditor: {
      el: null,
      mode: 'toolbar', // or 'popover'
      value: undefined, // will use html content
      customButtons: null,
      buttons: [
        ['bold', 'italic', 'underline', 'strikeThrough'],
        ['orderedList', 'unorderedList'],
        ['link', 'image'],
        ['paragraph', 'h1', 'h2', 'h3'],
        ['alignLeft', 'alignCenter', 'alignRight', 'alignJustify'],
        ['subscript', 'superscript'],
        ['indent', 'outdent'],
      ],
      dividers: true,
      imageUrlText: 'Insert image URL',
      linkUrlText: 'Insert link URL',
      placeholder: null,
      clearFormattingOnPaste: true,
    },
  },
  create() {
    const app = this;
    app.textEditor = Utils.extend(
      ConstructorMethods({
        defaultSelector: '.text-editor',
        constructor: TextEditor,
        app,
        domProp: 'f7TextEditor',
      }),
    );
  },
  static: {
    TextEditor,
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      $(tabEl).find('.text-editor-init').each((index, editorEl) => {
        const dataset = $(editorEl).dataset();
        app.textEditor.create(Utils.extend({ el: editorEl }, dataset || {}));
      });
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find('.text-editor-init').each((index, editorEl) => {
        if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.text-editor-init').each((index, editorEl) => {
        const dataset = $(editorEl).dataset();
        app.textEditor.create(Utils.extend({ el: editorEl }, dataset || {}));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find('.text-editor-init').each((index, editorEl) => {
        if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
      });
    },
  },
  vnode: {
    'text-editor-init': {
      insert(vnode) {
        const app = this;
        const editorEl = vnode.elm;
        const dataset = $(editorEl).dataset();
        app.textEditor.create(Utils.extend({ el: editorEl }, dataset || {}));
      },
      destroy(vnode) {
        const editorEl = vnode.elm;
        if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
      },
    },
  },
};

var Elevation = {
  name: 'elevation',
};

var Typography = {
  name: 'typography',
};

class ViAd extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const vi = this;
    if (!win.vi) {
      throw new Error('Framework7: vi SDK not found.');
    }

    let orientation;
    if (typeof win.orientation !== 'undefined') {
      orientation = win.orientation === -90 || win.orientation === 90 ? 'horizontal' : 'vertical';
    }
    const defaults = Utils.extend(
      {},
      app.params.vi,
      {
        appId: app.id,
        appVer: app.version,
        language: app.language,
        width: app.width,
        height: app.height,
        os: Device.os,
        osVersion: Device.osVersion,
        orientation,
      }
    );

    // Extend defaults with modules params
    vi.useModulesParams(defaults);

    vi.params = Utils.extend(defaults, params);

    const adParams = {};
    const skipParams = ('on autoplay fallbackOverlay fallbackOverlayText enabled').split(' ');
    Object.keys(vi.params).forEach((paramName) => {
      if (skipParams.indexOf(paramName) >= 0) return;
      const paramValue = vi.params[paramName];
      if ([null, undefined].indexOf(paramValue) >= 0) return;
      adParams[paramName] = paramValue;
    });

    if (!vi.params.appId) {
      throw new Error('Framework7: "app.id" is required to display an ad. Make sure you have specified it on app initialization.');
    }
    if (!vi.params.placementId) {
      throw new Error('Framework7: "placementId" is required to display an ad.');
    }

    function onResize() {
      const $viFrame = $('iframe#viAd');
      if ($viFrame.length === 0) return;
      $viFrame
        .css({
          width: `${app.width}px`,
          height: `${app.height}px`,
        });
    }

    function removeOverlay() {
      if (!vi.$overlayEl) return;
      vi.$overlayEl.off('click touchstart');
      vi.$overlayEl.remove();
    }
    function createOverlay(videoEl) {
      if (!videoEl) return;
      vi.$overlayEl = $(`
        <div class="vi-overlay">
          ${vi.params.fallbackOverlayText ? `<div class="vi-overlay-text">${vi.params.fallbackOverlayText}</div>` : ''}
          <div class="vi-overlay-play-button"></div>
        </div>
      `.trim());

      let touchStartTime;
      vi.$overlayEl.on('touchstart', () => {
        touchStartTime = Utils.now();
      });
      vi.$overlayEl.on('click', () => {
        const timeDiff = Utils.now() - touchStartTime;
        if (timeDiff > 300) return;
        if (videoEl) {
          videoEl.play();
          removeOverlay();
          return;
        }
        vi.start();
        removeOverlay();
      });
      app.root.append(vi.$overlayEl);
    }

    // Create ad
    vi.ad = new win.vi.Ad(adParams);

    Utils.extend(vi.ad, {
      onAdReady() {
        app.on('resize', onResize);
        vi.emit('local::ready');
        if (vi.params.autoplay) {
          vi.start();
        }
      },
      onAdStarted() {
        vi.emit('local::started');
      },
      onAdClick(targetUrl) {
        vi.emit('local::click', targetUrl);
      },
      onAdImpression() {
        vi.emit('local::impression');
      },
      onAdStopped(reason) {
        app.off('resize', onResize);
        removeOverlay();

        vi.emit('local::stopped', reason);
        if (reason === 'complete') {
          vi.emit('local::complete');
          vi.emit('local::completed');
        }
        if (reason === 'userexit') {
          vi.emit('local::userexit');
        }
        vi.destroyed = true;
      },
      onAutoPlayFailed(reason, videoEl) {
        vi.emit('local::autoplayFailed', reason, videoEl);
        if (reason && reason.name && reason.name.indexOf('NotAllowedError') !== -1 && vi.params.fallbackOverlay) {
          createOverlay(videoEl);
        }
      },
      onAdError(msg) {
        removeOverlay();
        app.off('resize', onResize);
        vi.emit('local::error', msg);
        vi.destroyed = true;
      },
    });

    vi.init();

    Utils.extend(vi, {
      app,
    });
  }

  start() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.startAd();
  }

  pause() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.pauseAd();
  }

  resume() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.resumeAd();
  }

  stop() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.stopAd();
  }

  init() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.initAd();
  }

  destroy() {
    const vi = this;
    vi.destroyed = true;
    vi.emit('local::beforeDestroy');
    Utils.deleteProps(vi);
  }
}

var Vi = {
  name: 'vi',
  params: {
    vi: {
      enabled: false,
      autoplay: true,
      fallbackOverlay: true,
      fallbackOverlayText: 'Please watch this ad',
      showMute: true,
      startMuted: (Device.ios || Device.android) && !Device.cordova,
      appId: null,
      appVer: null,
      language: null,
      width: null,
      height: null,
      placementId: 'pltd4o7ibb9rc653x14',
      placementType: 'interstitial',
      videoSlot: null,
      showProgress: true,
      showBranding: true,
      os: null,
      osVersion: null,
      orientation: null,
      age: null,
      gender: null,
      advertiserId: null,
      latitude: null,
      longitude: null,
      accuracy: null,
      storeId: null,
      ip: null,
      manufacturer: null,
      model: null,
      connectionType: null,
      connectionProvider: null,
    },
  },
  create() {
    const app = this;
    app.vi = {
      sdkReady: false,
      createAd(adParams) {
        return new ViAd(app, adParams);
      },
      loadSdk() {
        if (app.vi.sdkReady) return;
        const script = doc.createElement('script');
        script.onload = function onload() {
          app.emit('viSdkReady');
          app.vi.sdkReady = true;
        };
        script.src = 'https://c.vi-serve.com/viadshtml/vi.min.js';
        $('head').append(script);
      },
    };
  },
  on: {
    init() {
      const app = this;
      if (app.params.vi.enabled || (app.passedParams.vi && app.passedParams.vi.enabled !== false)) app.vi.loadSdk();
    },
  },
};

// Install Core Modules & Components

Framework7.use([
  DeviceModule,
  SupportModule,
  UtilsModule,
  ResizeModule,
  RequestModule,
  TouchModule,
  ClicksModule,
  RouterModule,
  HistoryModule,
  ServiceWorkerModule,
  Statusbar$1,
  View$1,
  Navbar$1,
  Toolbar$1,
  Subnavbar,
  TouchRipple$1,
  Modal$1,
  Appbar,
  Dialog$1,
  Popup$1,
  LoginScreen$1,
  Popover$1,
  Actions$1,
  Sheet$1,
  Toast$1,
  Preloader$1,
  Progressbar$1,
  Sortable$1,
  Swipeout$1,
  Accordion$1,
  ContactsList,
  VirtualList$1,
  ListIndex$1,
  Timeline,
  Tabs,
  Panel$1,
  Card,
  Chip,
  Form,
  Input$1,
  Checkbox,
  Radio,
  Toggle$1,
  Range$1,
  Stepper$1,
  SmartSelect$1,
  Grid$1,
  Calendar$1,
  Picker$1,
  InfiniteScroll$1,
  PullToRefresh$1,
  Lazy$1,
  DataTable$1,
  Fab$1,
  Searchbar$1,
  Messages$1,
  Messagebar$1,
  Swiper$1,
  PhotoBrowser$1,
  Notification$1,
  Autocomplete$1,
  Tooltip$1,
  Gauge$1,
  Skeleton,
  Menu$1,
  ColorPicker$1,
  Treeview$1,
  TextEditor$1,
  Elevation,
  Typography,
  Vi
]);

function noop() { }
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function validate_store(store, name) {
    if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
    }
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}
function set_store_value(store, ret, value = ret) {
    store.set(value);
    return ret;
}

function append$1(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach$1(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function text$1(data) {
    return document.createTextNode(data);
}
function space() {
    return text$1(' ');
}
function empty$1() {
    return text$1('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function attr$1(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set) {
            node[key] = attributes[key];
        }
        else {
            attr$1(node, key, attributes[key]);
        }
    }
}
function children$1(element) {
    return Array.from(element.childNodes);
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}
class HtmlTag {
    constructor(anchor = null) {
        this.a = anchor;
        this.e = this.n = null;
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            this.e = element(target.nodeName);
            this.t = target;
            this.h(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach$1);
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update$1(component.$$);
        }
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update$1($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}
function validate_each_keys(ctx, list, get_context, get_key) {
    const keys = new Set();
    for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));
        if (keys.has(key)) {
            throw new Error(`Cannot have duplicate keys in a keyed each`);
        }
        keys.add(key);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if ($$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children$1(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach$1);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set() {
        // overridden by instance, if it has props
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.24.0' }, detail)));
}
function append_dev(target, node) {
    dispatch_dev("SvelteDOMInsert", { target, node });
    append$1(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev("SvelteDOMInsert", { target, node, anchor });
    insert(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev("SvelteDOMRemove", { node });
    detach$1(node);
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
        modifiers.push('preventDefault');
    if (has_stop_propagation)
        modifiers.push('stopPropagation');
    dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
    const dispose = listen(node, event, handler, options);
    return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
        dispose();
    };
}
function attr_dev(node, attribute, value) {
    attr$1(node, attribute, value);
    if (value == null)
        dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
    else
        dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
}
function prop_dev(node, property, value) {
    node[property] = value;
    dispatch_dev("SvelteDOMSetProperty", { node, property, value });
}
function set_data_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data)
        return;
    dispatch_dev("SvelteDOMSetData", { node: text, data });
    text.data = data;
}
function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';
        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
            msg += ' You can use a spread to convert this iterable into an array.';
        }
        throw new Error(msg);
    }
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error(`'target' is a required option`);
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn(`Component was already destroyed`); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}

const Utils$1 = {
  text(text) {
    if (typeof text === 'undefined' || text === null) return '';
    return text;
  },
  noUndefinedProps(obj) {
    const o = {};
    Object.keys(obj).forEach((key) => {
      if (typeof obj[key] !== 'undefined') o[key] = obj[key];
    });
    return o;
  },
  isTrueProp(val) {
    return val === true || val === '';
  },
  isStringProp(val) {
    return typeof val === 'string' && val !== '';
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  now() {
    return Date.now();
  },
  extend(...args) {
    let deep = true;
    let to;
    let from;
    if (typeof args[0] === 'boolean') {
      [deep, to] = args;
      args.splice(0, 2);
      from = args;
    } else {
      [to] = args;
      args.splice(0, 1);
      from = args;
    }
    for (let i = 0; i < from.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (!deep) {
              to[nextKey] = nextSource[nextKey];
            } else if (Utils$1.isObject(to[nextKey]) && Utils$1.isObject(nextSource[nextKey])) {
              Utils$1.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils$1.isObject(to[nextKey]) && Utils$1.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils$1.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
  flattenArray(...args) {
    const arr = [];
    args.forEach((arg) => {
      if (Array.isArray(arg)) arr.push(...Utils$1.flattenArray(...arg));
      else arr.push(arg);
    });
    return arr;
  },
  classNames(...args) {
    const classes = [];
    args.forEach((arg) => {
      if (typeof arg === 'object' && arg.constructor === Object) {
        Object.keys(arg).forEach((key) => {
          if (arg[key]) classes.push(key);
        });
      } else if (arg) classes.push(arg);
    });
    const uniqueClasses = [];
    classes.forEach((c) => {
      if (uniqueClasses.indexOf(c) < 0) uniqueClasses.push(c);
    });
    return uniqueClasses.join(' ');
  },
  bindMethods(context, methods = []) {
    for (let i = 0; i < methods.length; i += 1) {
      if (context[methods[i]]) context[methods[i]] = context[methods[i]].bind(context);
    }
  },
};

const Mixins = {
  colorProps: {
    color: String,
    colorTheme: String,
    textColor: String,
    bgColor: String,
    borderColor: String,
    rippleColor: String,
    themeDark: Boolean,
  },
  colorClasses(props) {
    const {
      color,
      colorTheme,
      textColor,
      bgColor,
      borderColor,
      rippleColor,
      themeDark,
    } = props;

    return {
      'theme-dark': themeDark,
      [`color-${color}`]: color,
      [`color-theme-${colorTheme}`]: colorTheme,
      [`text-color-${textColor}`]: textColor,
      [`bg-color-${bgColor}`]: bgColor,
      [`border-color-${borderColor}`]: borderColor,
      [`ripple-color-${rippleColor}`]: rippleColor,
    };
  },
  linkIconProps: {
    icon: String,
    iconMaterial: String,
    iconF7: String,
    iconIos: String,
    iconMd: String,
    iconAurora: String,
    iconColor: String,
    iconSize: [String, Number],
  },
  linkRouterProps: {
    back: Boolean,
    external: Boolean,
    force: Boolean,
    animate: {
      type: Boolean,
      default: undefined,
    },
    ignoreCache: Boolean,
    reloadCurrent: Boolean,
    reloadAll: Boolean,
    reloadPrevious: Boolean,
    reloadDetail: {
      type: Boolean,
      default: undefined,
    },
    routeTabId: String,
    view: String,
    routeProps: Object,
    preventRouter: Boolean,
    transition: String,
  },
  linkRouterAttrs(props) {
    const {
      force,
      reloadCurrent,
      reloadPrevious,
      reloadAll,
      reloadDetail,
      animate,
      ignoreCache,
      routeTabId,
      view,
      transition,
    } = props;

    let dataAnimate;
    if ('animate' in props && typeof animate !== 'undefined') {
      dataAnimate = animate.toString();
    }

    let dataReloadDetail;
    if ('reloadDetail' in props && typeof reloadDetail !== 'undefined') {
      dataReloadDetail = reloadDetail.toString();
    }

    return {
      'data-force': force || undefined,
      'data-reload-current': reloadCurrent || undefined,
      'data-reload-all': reloadAll || undefined,
      'data-reload-previous': reloadPrevious || undefined,
      'data-reload-detail': dataReloadDetail,
      'data-animate': dataAnimate,
      'data-ignore-cache': ignoreCache || undefined,
      'data-route-tab-id': routeTabId || undefined,
      'data-view': Utils$1.isStringProp(view) ? view : undefined,
      'data-transition': Utils$1.isStringProp(transition) ? transition : undefined,
    };
  },
  linkRouterClasses(props) {
    const { back, linkBack, external, preventRouter } = props;

    return {
      back: back || linkBack,
      external,
      'prevent-router': preventRouter,
    };
  },
  linkActionsProps: {
    searchbarEnable: [Boolean, String],
    searchbarDisable: [Boolean, String],

    searchbarClear: [Boolean, String],
    searchbarToggle: [Boolean, String],

    // Panel
    panelOpen: [Boolean, String],
    panelClose: [Boolean, String],
    panelToggle: [Boolean, String],

    // Popup
    popupOpen: [Boolean, String],
    popupClose: [Boolean, String],

    // Actions
    actionsOpen: [Boolean, String],
    actionsClose: [Boolean, String],

    // Popover
    popoverOpen: [Boolean, String],
    popoverClose: [Boolean, String],

    // Login Screen
    loginScreenOpen: [Boolean, String],
    loginScreenClose: [Boolean, String],

    // Picker
    sheetOpen: [Boolean, String],
    sheetClose: [Boolean, String],

    // Sortable
    sortableEnable: [Boolean, String],
    sortableDisable: [Boolean, String],
    sortableToggle: [Boolean, String],

    // Card
    cardOpen: [Boolean, String],
    cardPreventOpen: [Boolean, String],
    cardClose: [Boolean, String],

    // Menu
    menuClose: {
      type: [Boolean, String],
      default: undefined,
    },
  },
  linkActionsAttrs(props) {
    const {
      searchbarEnable,
      searchbarDisable,
      searchbarClear,
      searchbarToggle,
      panelOpen,
      panelClose,
      panelToggle,
      popupOpen,
      popupClose,
      actionsOpen,
      actionsClose,
      popoverOpen,
      popoverClose,
      loginScreenOpen,
      loginScreenClose,
      sheetOpen,
      sheetClose,
      sortableEnable,
      sortableDisable,
      sortableToggle,
      cardOpen,
      cardClose,
    } = props;

    return {
      'data-searchbar': (Utils$1.isStringProp(searchbarEnable) && searchbarEnable)
                        || (Utils$1.isStringProp(searchbarDisable) && searchbarDisable)
                        || (Utils$1.isStringProp(searchbarClear) && searchbarClear)
                        || (Utils$1.isStringProp(searchbarToggle) && searchbarToggle) || undefined,
      'data-panel': (Utils$1.isStringProp(panelOpen) && panelOpen)
                    || (Utils$1.isStringProp(panelClose) && panelClose)
                    || (Utils$1.isStringProp(panelToggle) && panelToggle) || undefined,
      'data-popup': (Utils$1.isStringProp(popupOpen) && popupOpen)
                    || (Utils$1.isStringProp(popupClose) && popupClose) || undefined,
      'data-actions': (Utils$1.isStringProp(actionsOpen) && actionsOpen)
                    || (Utils$1.isStringProp(actionsClose) && actionsClose) || undefined,
      'data-popover': (Utils$1.isStringProp(popoverOpen) && popoverOpen)
                      || (Utils$1.isStringProp(popoverClose) && popoverClose) || undefined,
      'data-sheet': (Utils$1.isStringProp(sheetOpen) && sheetOpen)
                    || (Utils$1.isStringProp(sheetClose) && sheetClose) || undefined,
      'data-login-screen': (Utils$1.isStringProp(loginScreenOpen) && loginScreenOpen)
                           || (Utils$1.isStringProp(loginScreenClose) && loginScreenClose) || undefined,
      'data-sortable': (Utils$1.isStringProp(sortableEnable) && sortableEnable)
                       || (Utils$1.isStringProp(sortableDisable) && sortableDisable)
                       || (Utils$1.isStringProp(sortableToggle) && sortableToggle) || undefined,
      'data-card': (Utils$1.isStringProp(cardOpen) && cardOpen)
                    || (Utils$1.isStringProp(cardClose) && cardClose) || undefined,
    };
  },
  linkActionsClasses(props) {
    const {
      searchbarEnable,
      searchbarDisable,
      searchbarClear,
      searchbarToggle,
      panelOpen,
      panelClose,
      panelToggle,
      popupOpen,
      popupClose,
      actionsClose,
      actionsOpen,
      popoverOpen,
      popoverClose,
      loginScreenOpen,
      loginScreenClose,
      sheetOpen,
      sheetClose,
      sortableEnable,
      sortableDisable,
      sortableToggle,
      cardOpen,
      cardPreventOpen,
      cardClose,
      menuClose,
    } = props;

    return {
      'searchbar-enable': searchbarEnable || searchbarEnable === '',
      'searchbar-disable': searchbarDisable || searchbarDisable === '',
      'searchbar-clear': searchbarClear || searchbarClear === '',
      'searchbar-toggle': searchbarToggle || searchbarToggle === '',
      'panel-close': panelClose || panelClose === '',
      'panel-open': panelOpen || panelOpen === '',
      'panel-toggle': panelToggle || panelToggle === '',
      'popup-close': popupClose || popupClose === '',
      'popup-open': popupOpen || popupOpen === '',
      'actions-close': actionsClose || actionsClose === '',
      'actions-open': actionsOpen || actionsOpen === '',
      'popover-close': popoverClose || popoverClose === '',
      'popover-open': popoverOpen || popoverOpen === '',
      'sheet-close': sheetClose || sheetClose === '',
      'sheet-open': sheetOpen || sheetOpen === '',
      'login-screen-close': loginScreenClose || loginScreenClose === '',
      'login-screen-open': loginScreenOpen || loginScreenOpen === '',
      'sortable-enable': sortableEnable || sortableEnable === '',
      'sortable-disable': sortableDisable || sortableDisable === '',
      'sortable-toggle': sortableToggle || sortableToggle === '',
      'card-close': cardClose || cardClose === '',
      'card-open': cardOpen || cardOpen === '',
      'card-prevent-open': cardPreventOpen || cardPreventOpen === '',
      'menu-close': menuClose || menuClose === '',
    };
  },
};

function restProps(rest = {}) {
  const props = {};
  Object.keys(rest).forEach((key) => {
    if (key.indexOf('on') !== 0) {
      props[key] = rest[key];
    }
  });
  return props;
}

// eslint-disable-next-line
let f7Instance;

const f7 = {
  instance: null,
  Framework7: null,
  events: null,
  init(rootEl, params = {}, routes) {
    const { events, Framework7 } = f7;
    const f7Params = Utils$1.extend({}, params, {
      root: rootEl,
    });
    if (routes && routes.length && !f7Params.routes) f7Params.routes = routes;

    const instance = new Framework7(f7Params);
    f7Instance = instance;
    if (instance.initialized) {
      f7.instance = instance;
      f7Instance = instance;
      events.emit('ready', f7.instance);
    } else {
      instance.on('init', () => {
        f7.instance = instance;
        f7Instance = instance;
        events.emit('ready', f7.instance);
      });
    }
  },
  ready(callback) {
    if (!callback) return;
    if (f7.instance) callback(f7.instance);
    else {
      f7.events.once('ready', callback);
    }
  },
  routers: {
    views: [],
    tabs: [],
    modals: null,
  },
};

function hasSlots (args, name) {
  return args && args[1] && args[1].$$slots && args[1].$$slots[name] && args[1].$$slots[name].length > 0;
}

const file = "node_modules/framework7-svelte/components/routable-modals.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (33:2) {#each modals as modal (modal.id)}
function create_each_block(key_1, ctx) {
	let first;
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*modal*/ ctx[5].props];
	var switch_value = /*modal*/ ctx[5].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty$1();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty$1();
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*modals*/ 1)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*modal*/ ctx[5].props)])
			: {};

			if (switch_value !== (switch_value = /*modal*/ ctx[5].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(33:2) {#each modals as modal (modal.id)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*modals*/ ctx[0];
	validate_each_argument(each_value);
	const get_key = ctx => /*modal*/ ctx[5].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "framework7-modals");
			add_location(div, file, 31, 0, 614);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding*/ ctx[2](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*modals*/ 1) {
				const each_value = /*modals*/ ctx[0];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div_binding*/ ctx[2](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let modals = [];
	let el;
	let routerData;

	onMount(() => {
		routerData = {
			el,
			modals,
			setModals(m) {
				tick().then(() => {
					$$invalidate(0, modals = m);
				});
			}
		};

		f7.routers.modals = routerData;
	});

	afterUpdate(() => {
		if (!routerData) return;
		f7.events.emit("modalsRouterDidUpdate", routerData);
	});

	onDestroy(() => {
		if (!routerData) return;
		f7.routers.modals = null;
		routerData = null;
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routable_modals> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Routable_modals", $$slots, []);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		afterUpdate,
		tick,
		f7,
		modals,
		el,
		routerData
	});

	$$self.$inject_state = $$props => {
		if ("modals" in $$props) $$invalidate(0, modals = $$props.modals);
		if ("el" in $$props) $$invalidate(1, el = $$props.el);
		if ("routerData" in $$props) routerData = $$props.routerData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [modals, el, div_binding];
}

class Routable_modals extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routable_modals",
			options,
			id: create_fragment.name
		});
	}
}

const file$1 = "node_modules/framework7-svelte/components/app.svelte";

function create_fragment$1(ctx) {
	let div;
	let t;
	let routablemodals;
	let current;
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	routablemodals = new Routable_modals({ $$inline: true });

	let div_levels = [
		{ id: /*id*/ ctx[0] },
		{ class: /*classes*/ ctx[2] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			create_component(routablemodals.$$.fragment);
			set_attributes(div, div_data);
			add_location(div, file$1, 34, 0, 804);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t);
			mount_component(routablemodals, div, null);
			/*div_binding*/ ctx[9](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*id*/ 1) && { id: /*id*/ ctx[0] },
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(routablemodals.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(routablemodals.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			destroy_component(routablemodals);
			/*div_binding*/ ctx[9](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	const omit_props_names = ["id","params","routes","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { id = "framework7-root" } = $$props;
	let { params = {} } = $$props;
	let { routes = [] } = $$props;
	let { class: className = undefined } = $$props;
	let el;

	onMount(() => {
		const parentEl = el.parentNode;

		if (parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
			parentEl.style.height = "100%";
		}

		if (f7.instance) return;
		f7.init(el, params, routes);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("App", $$slots, ['default']);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("params" in $$new_props) $$invalidate(4, params = $$new_props.params);
		if ("routes" in $$new_props) $$invalidate(5, routes = $$new_props.routes);
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		f7,
		RoutableModals: Routable_modals,
		Mixins,
		Utils: Utils$1,
		restProps,
		id,
		params,
		routes,
		className,
		el,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("params" in $$props) $$invalidate(4, params = $$new_props.params);
		if ("routes" in $$props) $$invalidate(5, routes = $$new_props.routes);
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("el" in $$props) $$invalidate(1, el = $$new_props.el);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classes = Utils$1.classNames(className, "framework7-root", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		el,
		classes,
		$$restProps,
		params,
		routes,
		className,
		$$scope,
		$$slots,
		div_binding
	];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { id: 0, params: 4, routes: 5, class: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: create_fragment$1.name
		});
	}

	get id() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get params() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set params(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get routes() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set routes(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$2 = "node_modules/framework7-svelte/components/badge.svelte";

function create_fragment$2(ctx) {
	let span;
	let current;
	const default_slot_template = /*$$slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let span_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			add_location(span, file$2, 64, 0, 1406);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","tooltip","tooltipTrigger"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { class: className = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;
	let f7Tooltip;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	onMount(() => {
		if (!tooltip) return;

		f7.ready(() => {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: tooltip,
				trigger: tooltipTrigger
			});
		});
	});

	onDestroy(() => {
		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Badge", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("tooltip" in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		className,
		tooltip,
		tooltipTrigger,
		el,
		f7Tooltip,
		tooltipText,
		watchTooltip,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("tooltip" in $$props) $$invalidate(3, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("el" in $$props) el = $$new_props.el;
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils$1.classNames(className, "badge", Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*tooltip*/ 8) {
			 watchTooltip(tooltip);
		}
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, tooltip, tooltipTrigger, $$scope, $$slots];
}

class Badge extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { class: 2, tooltip: 3, tooltipTrigger: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Badge",
			options,
			id: create_fragment$2.name
		});
	}

	get class() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$3 = "node_modules/framework7-svelte/components/block-title.svelte";

function create_fragment$3(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$3, 22, 0, 456);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	const omit_props_names = ["large","medium","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { large = false } = $$props;
	let { medium = false } = $$props;
	let { class: className = undefined } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Block_title", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("large" in $$new_props) $$invalidate(2, large = $$new_props.large);
		if ("medium" in $$new_props) $$invalidate(3, medium = $$new_props.medium);
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils: Utils$1,
		restProps,
		large,
		medium,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("large" in $$props) $$invalidate(2, large = $$new_props.large);
		if ("medium" in $$props) $$invalidate(3, medium = $$new_props.medium);
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils$1.classNames(
			className,
			"block-title",
			{
				"block-title-large": large,
				"block-title-medium": medium
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, large, medium, className, $$scope, $$slots];
}

class Block_title extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { large: 2, medium: 3, class: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Block_title",
			options,
			id: create_fragment$3.name
		});
	}

	get large() {
		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set large(value) {
		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get medium() {
		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set medium(value) {
		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$4 = "node_modules/framework7-svelte/components/block.svelte";

function create_fragment$4(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$4, 81, 0, 2150);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[22](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[22](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","strong","tabs","tab","tabActive","accordionList","accordionOpposite","noHairlines","noHairlinesMd","noHairlinesIos","noHairlinesAurora","class"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { inset = false } = $$props;
	let { xsmallInset = false } = $$props;
	let { smallInset = false } = $$props;
	let { mediumInset = false } = $$props;
	let { largeInset = false } = $$props;
	let { xlargeInset = false } = $$props;
	let { strong = false } = $$props;
	let { tabs = false } = $$props;
	let { tab = false } = $$props;
	let { tabActive = false } = $$props;
	let { accordionList = false } = $$props;
	let { accordionOpposite = false } = $$props;
	let { noHairlines = false } = $$props;
	let { noHairlinesMd = false } = $$props;
	let { noHairlinesIos = false } = $$props;
	let { noHairlinesAurora = false } = $$props;
	let { class: className = undefined } = $$props;
	let el;

	function onTabShow(tabEl) {
		if (el !== tabEl) return;
		dispatch("tabShow");
		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
	}

	function onTabHide(tabEl) {
		if (el !== tabEl) return;
		dispatch("tabHide");
		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
	}

	onMount(() => {
		f7.ready(() => {
			f7.instance.on("tabShow", onTabShow);
			f7.instance.on("tabHide", onTabHide);
		});
	});

	onDestroy(() => {
		if (f7.instance) {
			f7.instance.off("tabShow", onTabShow);
			f7.instance.off("tabHide", onTabHide);
		}
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Block", $$slots, ['default']);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("inset" in $$new_props) $$invalidate(3, inset = $$new_props.inset);
		if ("xsmallInset" in $$new_props) $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
		if ("smallInset" in $$new_props) $$invalidate(5, smallInset = $$new_props.smallInset);
		if ("mediumInset" in $$new_props) $$invalidate(6, mediumInset = $$new_props.mediumInset);
		if ("largeInset" in $$new_props) $$invalidate(7, largeInset = $$new_props.largeInset);
		if ("xlargeInset" in $$new_props) $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
		if ("strong" in $$new_props) $$invalidate(9, strong = $$new_props.strong);
		if ("tabs" in $$new_props) $$invalidate(10, tabs = $$new_props.tabs);
		if ("tab" in $$new_props) $$invalidate(11, tab = $$new_props.tab);
		if ("tabActive" in $$new_props) $$invalidate(12, tabActive = $$new_props.tabActive);
		if ("accordionList" in $$new_props) $$invalidate(13, accordionList = $$new_props.accordionList);
		if ("accordionOpposite" in $$new_props) $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
		if ("noHairlines" in $$new_props) $$invalidate(15, noHairlines = $$new_props.noHairlines);
		if ("noHairlinesMd" in $$new_props) $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
		if ("noHairlinesIos" in $$new_props) $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
		if ("noHairlinesAurora" in $$new_props) $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ("class" in $$new_props) $$invalidate(19, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		createEventDispatcher,
		f7,
		Mixins,
		Utils: Utils$1,
		restProps,
		dispatch,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		strong,
		tabs,
		tab,
		tabActive,
		accordionList,
		accordionOpposite,
		noHairlines,
		noHairlinesMd,
		noHairlinesIos,
		noHairlinesAurora,
		className,
		el,
		onTabShow,
		onTabHide,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
		if ("inset" in $$props) $$invalidate(3, inset = $$new_props.inset);
		if ("xsmallInset" in $$props) $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
		if ("smallInset" in $$props) $$invalidate(5, smallInset = $$new_props.smallInset);
		if ("mediumInset" in $$props) $$invalidate(6, mediumInset = $$new_props.mediumInset);
		if ("largeInset" in $$props) $$invalidate(7, largeInset = $$new_props.largeInset);
		if ("xlargeInset" in $$props) $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
		if ("strong" in $$props) $$invalidate(9, strong = $$new_props.strong);
		if ("tabs" in $$props) $$invalidate(10, tabs = $$new_props.tabs);
		if ("tab" in $$props) $$invalidate(11, tab = $$new_props.tab);
		if ("tabActive" in $$props) $$invalidate(12, tabActive = $$new_props.tabActive);
		if ("accordionList" in $$props) $$invalidate(13, accordionList = $$new_props.accordionList);
		if ("accordionOpposite" in $$props) $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
		if ("noHairlines" in $$props) $$invalidate(15, noHairlines = $$new_props.noHairlines);
		if ("noHairlinesMd" in $$props) $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
		if ("noHairlinesIos" in $$props) $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
		if ("noHairlinesAurora" in $$props) $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ("className" in $$props) $$invalidate(19, className = $$new_props.className);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils$1.classNames(
			className,
			"block",
			{
				inset,
				"xsmall-inset": xsmallInset,
				"small-inset": smallInset,
				"medium-inset": mediumInset,
				"large-inset": largeInset,
				"xlarge-inset": xlargeInset,
				"block-strong": strong,
				"accordion-list": accordionList,
				"accordion-opposite": accordionOpposite,
				tabs,
				tab,
				"tab-active": tabActive,
				"no-hairlines": noHairlines,
				"no-hairlines-md": noHairlinesMd,
				"no-hairlines-ios": noHairlinesIos,
				"no-hairlines-aurora": noHairlinesAurora
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		strong,
		tabs,
		tab,
		tabActive,
		accordionList,
		accordionOpposite,
		noHairlines,
		noHairlinesMd,
		noHairlinesIos,
		noHairlinesAurora,
		className,
		$$scope,
		$$slots,
		div_binding
	];
}

class Block extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			inset: 3,
			xsmallInset: 4,
			smallInset: 5,
			mediumInset: 6,
			largeInset: 7,
			xlargeInset: 8,
			strong: 9,
			tabs: 10,
			tab: 11,
			tabActive: 12,
			accordionList: 13,
			accordionOpposite: 14,
			noHairlines: 15,
			noHairlinesMd: 16,
			noHairlinesIos: 17,
			noHairlinesAurora: 18,
			class: 19
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Block",
			options,
			id: create_fragment$4.name
		});
	}

	get inset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xsmallInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xsmallInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediumInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediumInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xlargeInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xlargeInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strong() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strong(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabs() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabs(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tab() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabActive() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabActive(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionList() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionList(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionOpposite() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionOpposite(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlines() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlines(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesMd() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesMd(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesIos() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesIos(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesAurora() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesAurora(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

let routerComponentIdCounter = 0;

var componentsRouter = {
  proto: {
    pageComponentLoader(routerEl, component, componentUrl, options, resolve, reject) {
      const router = this;
      const el = routerEl;
      let viewRouter;
      f7.routers.views.forEach((data) => {
        if (data.el && data.el === routerEl) {
          viewRouter = data;
        }
      });

      if (!viewRouter) {
        reject();
        return;
      }

      const id = `${Utils$1.now()}_${(routerComponentIdCounter += 1)}`;
      const pageData = {
        component,
        id,
        props: Utils$1.extend(
          {
            f7route: options.route,
            $f7route: options.route,
            f7router: router,
            $f7router: router,
          },
          options.route.params,
          options.props || {},
        ),
      };
      if (viewRouter.component) {
        viewRouter.component.$f7router = router;
        viewRouter.component.$f7route = options.route;
      }

      let resolved;
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== viewRouter || resolved) return;
        f7.events.off('viewRouterDidUpdate', onDidUpdate);

        const pageEl = el.children[el.children.length - 1];
        pageData.el = pageEl;

        resolve(pageEl);
        resolved = true;
      }

      f7.events.on('viewRouterDidUpdate', onDidUpdate);

      viewRouter.pages.push(pageData);
      viewRouter.setPages(viewRouter.pages);
    },
    removePage($pageEl) {
      if (!$pageEl) return;
      const router = this;
      let f7Page;
      if ('length' in $pageEl && $pageEl[0]) f7Page = $pageEl[0].f7Page;
      else f7Page = $pageEl.f7Page;
      if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
        router.app.$($pageEl).remove();
        return;
      }
      let viewRouter;
      f7.routers.views.forEach((data) => {
        if (data.el && data.el === router.el) {
          viewRouter = data;
        }
      });

      let pageEl;
      if ('length' in $pageEl) {
        // Dom7
        if ($pageEl.length === 0) return;
        pageEl = $pageEl[0];
      } else {
        pageEl = $pageEl;
      }
      if (!pageEl) return;

      let pageComponentFound;
      viewRouter.pages.forEach((page, index) => {
        if (page.el === pageEl) {
          pageComponentFound = true;
          viewRouter.pages.splice(index, 1);
          viewRouter.setPages(viewRouter.pages);
        }
      });
      if (!pageComponentFound) {
        pageEl.parentNode.removeChild(pageEl);
      }
    },
    tabComponentLoader(tabEl, component, componentUrl, options, resolve, reject) {
      const router = this;
      if (!tabEl) reject();

      let tabRouter;
      f7.routers.tabs.forEach((tabData) => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      if (!tabRouter) {
        reject();
        return;
      }

      const id = `${Utils$1.now()}_${(routerComponentIdCounter += 1)}`;
      const tabContent = {
        id,
        component,
        props: Utils$1.extend(
          {
            f7route: options.route,
            $f7route: options.route,
            f7router: router,
            $f7router: router,
          },
          options.route.params,
          options.props || {},
        ),
      };

      if (tabRouter.component) {
        tabRouter.component.$f7router = router;
        tabRouter.component.$f7route = options.route;
      }

      let resolved;
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== tabRouter || resolved) return;
        f7.events.off('tabRouterDidUpdate', onDidUpdate);

        const tabContentEl = tabEl.children[0];
        resolve(tabContentEl);

        resolved = true;
      }

      f7.events.on('tabRouterDidUpdate', onDidUpdate);

      tabRouter.setTabContent(tabContent);
    },
    removeTabContent(tabEl) {
      if (!tabEl) return;

      let tabRouter;
      f7.routers.tabs.forEach((tabData) => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      const hasComponent = tabRouter && tabRouter.component;
      if (!tabRouter || !hasComponent) {
        tabEl.innerHTML = ''; // eslint-disable-line
        return;
      }
      tabRouter.setTabContent(null);
    },
    modalComponentLoader(rootEl, component, componentUrl, options, resolve, reject) {
      const router = this;
      const modalsRouter = f7.routers.modals;

      if (!modalsRouter) {
        reject();
        return;
      }

      const id = `${Utils$1.now()}_${(routerComponentIdCounter += 1)}`;
      const modalData = {
        component,
        id,
        props: Utils$1.extend(
          {
            f7route: options.route,
            $f7route: options.route,
            f7router: router,
            $f7router: router,
          },
          options.route.params,
          options.props || {},
        ),
      };
      if (modalsRouter.component) {
        modalsRouter.component.$f7router = router;
        modalsRouter.component.$f7route = options.route;
      }

      let resolved;
      function onDidUpdate() {
        if (resolved) return;
        f7.events.off('modalsRouterDidUpdate', onDidUpdate);

        const modalEl = modalsRouter.el.children[modalsRouter.el.children.length - 1];
        modalData.el = modalEl;

        resolve(modalEl);
        resolved = true;
      }

      f7.events.on('modalsRouterDidUpdate', onDidUpdate);

      modalsRouter.modals.push(modalData);
      modalsRouter.setModals(modalsRouter.modals);
    },
    removeModal(modalEl) {
      const modalsRouter = f7.routers.modals;
      if (!modalsRouter) return;

      let modalDataToRemove;
      modalsRouter.modals.forEach((modalData) => {
        if (modalData.el === modalEl) modalDataToRemove = modalData;
      });

      modalsRouter.modals.splice(modalsRouter.modals.indexOf(modalDataToRemove), 1);
      modalsRouter.setModals(modalsRouter.modals);
    },
  },
};

const f7Theme = {};
const Plugin = {
  name: 'phenomePlugin',
  installed: false,
  install(params = {}) {
    if (Plugin.installed) return;
    Plugin.installed = true;
    const Framework7 = this;
    f7.Framework7 = Framework7;
    f7.events = new Framework7.Events();
    // eslint-disable-next-line
    
    const { theme } = params;
    if (theme === 'md') f7Theme.md = true;
    if (theme === 'ios') f7Theme.ios = true;
    if (theme === 'aurora') f7Theme.aurora = true;
    if (!theme || theme === 'auto') {
      f7Theme.ios = !!Framework7.device.ios;
      f7Theme.aurora = Framework7.device.desktop && Framework7.device.electron;
      f7Theme.md = !f7Theme.ios && !f7Theme.aurora;
    }
    f7.ready(() => {
      f7Theme.ios = f7.instance.theme === 'ios';
      f7Theme.md = f7.instance.theme === 'md';
      f7Theme.aurora = f7.instance.theme === 'aurora';
    });
    
    // Extend F7 Router
    Framework7.Router.use(componentsRouter);
  },
};

const file$5 = "node_modules/framework7-svelte/components/icon.svelte";

function create_fragment$5(ctx) {
	let i;
	let t0_value = (/*iconText*/ ctx[2] || "") + "";
	let t0;
	let t1;
	let current;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	let i_levels = [
		{ style: /*iconStyle*/ ctx[3] },
		{ class: /*iconClasses*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let i_data = {};

	for (let i = 0; i < i_levels.length; i += 1) {
		i_data = assign(i_data, i_levels[i]);
	}

	const block = {
		c: function create() {
			i = element("i");
			t0 = text$1(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(i, i_data);
			add_location(i, file$5, 135, 0, 3344);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
			append_dev(i, t0);
			append_dev(i, t1);

			if (default_slot) {
				default_slot.m(i, null);
			}

			/*i_binding*/ ctx[18](i);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*iconText*/ 4) && t0_value !== (t0_value = (/*iconText*/ ctx[2] || "") + "")) set_data_dev(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			set_attributes(i, i_data = get_spread_update(i_levels, [
				(!current || dirty & /*iconStyle*/ 8) && { style: /*iconStyle*/ ctx[3] },
				(!current || dirty & /*iconClasses*/ 2) && { class: /*iconClasses*/ ctx[1] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
			if (default_slot) default_slot.d(detaching);
			/*i_binding*/ ctx[18](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"style","class","material","f7","icon","ios","aurora","md","tooltip","tooltipTrigger","size"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { material = undefined } = $$props;
	let { f7: f7$1 = undefined } = $$props;
	let { icon = undefined } = $$props;
	let { ios = undefined } = $$props;
	let { aurora = undefined } = $$props;
	let { md = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { size = undefined } = $$props;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	let el;
	let f7Tooltip;
	let classes = { icon: true };

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(19, _theme = f7Theme);
		});
	}

	let themeIcon;

	function iconTextComputed(t) {
		let textComputed = material || f7$1;

		if (md && t && t.md && (md.indexOf("material:") >= 0 || md.indexOf("f7:") >= 0)) {
			textComputed = md.split(":")[1];
		} else if (ios && t && t.ios && (ios.indexOf("material:") >= 0 || ios.indexOf("f7:") >= 0)) {
			textComputed = ios.split(":")[1];
		} else if (aurora && t && t.aurora && (aurora.indexOf("material:") >= 0 || aurora.indexOf("f7:") >= 0)) {
			textComputed = aurora.split(":")[1];
		}

		return textComputed;
	}

	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	onMount(() => {
		if (!tooltip) return;

		f7.ready(() => {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: tooltip,
				trigger: tooltipTrigger
			});
		});
	});

	onDestroy(() => {
		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Icon", $$slots, ['default']);

	function i_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("style" in $$new_props) $$invalidate(5, style = $$new_props.style);
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("material" in $$new_props) $$invalidate(7, material = $$new_props.material);
		if ("f7" in $$new_props) $$invalidate(8, f7$1 = $$new_props.f7);
		if ("icon" in $$new_props) $$invalidate(9, icon = $$new_props.icon);
		if ("ios" in $$new_props) $$invalidate(10, ios = $$new_props.ios);
		if ("aurora" in $$new_props) $$invalidate(11, aurora = $$new_props.aurora);
		if ("md" in $$new_props) $$invalidate(12, md = $$new_props.md);
		if ("tooltip" in $$new_props) $$invalidate(13, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(14, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("size" in $$new_props) $$invalidate(15, size = $$new_props.size);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		Mixins,
		Utils: Utils$1,
		restProps,
		theme: f7Theme,
		F7: f7,
		style,
		className,
		material,
		f7: f7$1,
		icon,
		ios,
		aurora,
		md,
		tooltip,
		tooltipTrigger,
		size,
		_theme,
		el,
		f7Tooltip,
		classes,
		themeIcon,
		iconTextComputed,
		tooltipText,
		watchTooltip,
		iconClasses,
		iconText,
		iconSize,
		iconStyle
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
		if ("style" in $$props) $$invalidate(5, style = $$new_props.style);
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("material" in $$props) $$invalidate(7, material = $$new_props.material);
		if ("f7" in $$props) $$invalidate(8, f7$1 = $$new_props.f7);
		if ("icon" in $$props) $$invalidate(9, icon = $$new_props.icon);
		if ("ios" in $$props) $$invalidate(10, ios = $$new_props.ios);
		if ("aurora" in $$props) $$invalidate(11, aurora = $$new_props.aurora);
		if ("md" in $$props) $$invalidate(12, md = $$new_props.md);
		if ("tooltip" in $$props) $$invalidate(13, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(14, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("size" in $$props) $$invalidate(15, size = $$new_props.size);
		if ("_theme" in $$props) $$invalidate(19, _theme = $$new_props._theme);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("classes" in $$props) $$invalidate(21, classes = $$new_props.classes);
		if ("themeIcon" in $$props) $$invalidate(22, themeIcon = $$new_props.themeIcon);
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("iconClasses" in $$props) $$invalidate(1, iconClasses = $$new_props.iconClasses);
		if ("iconText" in $$props) $$invalidate(2, iconText = $$new_props.iconText);
		if ("iconSize" in $$props) $$invalidate(24, iconSize = $$new_props.iconSize);
		if ("iconStyle" in $$props) $$invalidate(3, iconStyle = $$new_props.iconStyle);
	};

	let iconClasses;
	let iconText;
	let iconSize;
	let iconStyle;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*_theme, ios, md, aurora*/ 531456) {
			 if (_theme) {
				if (_theme.ios) $$invalidate(22, themeIcon = ios);
				if (_theme.md) $$invalidate(22, themeIcon = md);
				if (_theme.aurora) $$invalidate(22, themeIcon = aurora);
			}
		}

		if ($$self.$$.dirty & /*themeIcon, material, f7, icon*/ 4195200) {
			 if (themeIcon) {
				const parts = themeIcon.split(":");
				const prop = parts[0];
				const value = parts[1];

				if (prop === "material" || prop === "f7") {
					$$invalidate(21, classes["material-icons"] = prop === "material", classes);
					$$invalidate(21, classes["f7-icons"] = prop === "f7", classes);
				}

				if (prop === "icon") {
					$$invalidate(21, classes[value] = true, classes);
				}
			} else {
				$$invalidate(21, classes = {
					icon: true,
					"material-icons": material,
					"f7-icons": f7$1
				});

				if (icon) $$invalidate(21, classes[icon] = true, classes);
			}
		}

		 $$invalidate(1, iconClasses = Utils$1.classNames(className, classes, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*_theme*/ 524288) {
			 $$invalidate(2, iconText = iconTextComputed(_theme));
		}

		if ($$self.$$.dirty & /*size*/ 32768) {
			 $$invalidate(24, iconSize = typeof size === "number" || parseFloat(size) === size * 1
			? `${size}px`
			: size);
		}

		if ($$self.$$.dirty & /*style, iconSize*/ 16777248) {
			 $$invalidate(3, iconStyle = (style || "") + (iconSize
			? `;font-size: ${iconSize}; width: ${iconSize}; height: ${iconSize}`.replace(";;", "")
			: ""));
		}

		if ($$self.$$.dirty & /*tooltip*/ 8192) {
			 watchTooltip(tooltip);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		iconClasses,
		iconText,
		iconStyle,
		$$restProps,
		style,
		className,
		material,
		f7$1,
		icon,
		ios,
		aurora,
		md,
		tooltip,
		tooltipTrigger,
		size,
		$$scope,
		$$slots,
		i_binding
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			style: 5,
			class: 6,
			material: 7,
			f7: 8,
			icon: 9,
			ios: 10,
			aurora: 11,
			md: 12,
			tooltip: 13,
			tooltipTrigger: 14,
			size: 15
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$5.name
		});
	}

	get style() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get material() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set material(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ios() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ios(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get aurora() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set aurora(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get md() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set md(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$6 = "node_modules/framework7-svelte/components/button.svelte";

// (191:0) {:else}
function create_else_block(ctx) {
	let a;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*hasIcon*/ ctx[5] && create_if_block_4(ctx);
	let if_block1 = typeof /*text*/ ctx[0] !== "undefined" && create_if_block_3(ctx);
	const default_slot_template = /*$$slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);
	let a_levels = [{ class: /*classes*/ ctx[3] }, /*attrs*/ ctx[2]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$6, 191, 2, 5104);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			if (if_block0) if_block0.m(a, null);
			append_dev(a, t0);
			if (if_block1) if_block1.m(a, null);
			append_dev(a, t1);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*a_binding*/ ctx[45](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*hasIcon*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*hasIcon*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(a, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (typeof /*text*/ ctx[0] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					if_block1.m(a, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[0] & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty[0] & /*attrs*/ 4 && /*attrs*/ ctx[2]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*a_binding*/ ctx[45](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(191:0) {:else}",
		ctx
	});

	return block;
}

// (167:0) {#if tagName === 'button'}
function create_if_block(ctx) {
	let button;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*hasIcon*/ ctx[5] && create_if_block_2(ctx);
	let if_block1 = typeof /*text*/ ctx[0] !== "undefined" && create_if_block_1(ctx);
	const default_slot_template = /*$$slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);
	let button_levels = [{ class: /*classes*/ ctx[3] }, /*attrs*/ ctx[2]];
	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(button, button_data);
			add_location(button, file$6, 167, 2, 4589);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append_dev(button, t0);
			if (if_block1) if_block1.m(button, null);
			append_dev(button, t1);

			if (default_slot) {
				default_slot.m(button, null);
			}

			/*button_binding*/ ctx[44](button);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*onClick*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*hasIcon*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*hasIcon*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(button, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (typeof /*text*/ ctx[0] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				(!current || dirty[0] & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty[0] & /*attrs*/ 4 && /*attrs*/ ctx[2]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*button_binding*/ ctx[44](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(167:0) {#if tagName === 'button'}",
		ctx
	});

	return block;
}

// (198:4) {#if hasIcon}
function create_if_block_4(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[7].iconMaterial,
				f7: /*$$props*/ ctx[7].iconF7,
				icon: /*$$props*/ ctx[7].icon,
				md: /*$$props*/ ctx[7].iconMd,
				ios: /*$$props*/ ctx[7].iconIos,
				aurora: /*$$props*/ ctx[7].iconAurora,
				color: /*$$props*/ ctx[7].iconColor,
				size: /*$$props*/ ctx[7].iconSize
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty[0] & /*$$props*/ 128) icon_changes.material = /*$$props*/ ctx[7].iconMaterial;
			if (dirty[0] & /*$$props*/ 128) icon_changes.f7 = /*$$props*/ ctx[7].iconF7;
			if (dirty[0] & /*$$props*/ 128) icon_changes.icon = /*$$props*/ ctx[7].icon;
			if (dirty[0] & /*$$props*/ 128) icon_changes.md = /*$$props*/ ctx[7].iconMd;
			if (dirty[0] & /*$$props*/ 128) icon_changes.ios = /*$$props*/ ctx[7].iconIos;
			if (dirty[0] & /*$$props*/ 128) icon_changes.aurora = /*$$props*/ ctx[7].iconAurora;
			if (dirty[0] & /*$$props*/ 128) icon_changes.color = /*$$props*/ ctx[7].iconColor;
			if (dirty[0] & /*$$props*/ 128) icon_changes.size = /*$$props*/ ctx[7].iconSize;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(198:4) {#if hasIcon}",
		ctx
	});

	return block;
}

// (210:4) {#if typeof text !== 'undefined'}
function create_if_block_3(ctx) {
	let span;
	let t_value = Utils$1.text(/*text*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$6, 210, 6, 5537);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = Utils$1.text(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(210:4) {#if typeof text !== 'undefined'}",
		ctx
	});

	return block;
}

// (174:4) {#if hasIcon}
function create_if_block_2(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[7].iconMaterial,
				f7: /*$$props*/ ctx[7].iconF7,
				icon: /*$$props*/ ctx[7].icon,
				md: /*$$props*/ ctx[7].iconMd,
				ios: /*$$props*/ ctx[7].iconIos,
				aurora: /*$$props*/ ctx[7].iconAurora,
				color: /*$$props*/ ctx[7].iconColor,
				size: /*$$props*/ ctx[7].iconSize
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty[0] & /*$$props*/ 128) icon_changes.material = /*$$props*/ ctx[7].iconMaterial;
			if (dirty[0] & /*$$props*/ 128) icon_changes.f7 = /*$$props*/ ctx[7].iconF7;
			if (dirty[0] & /*$$props*/ 128) icon_changes.icon = /*$$props*/ ctx[7].icon;
			if (dirty[0] & /*$$props*/ 128) icon_changes.md = /*$$props*/ ctx[7].iconMd;
			if (dirty[0] & /*$$props*/ 128) icon_changes.ios = /*$$props*/ ctx[7].iconIos;
			if (dirty[0] & /*$$props*/ 128) icon_changes.aurora = /*$$props*/ ctx[7].iconAurora;
			if (dirty[0] & /*$$props*/ 128) icon_changes.color = /*$$props*/ ctx[7].iconColor;
			if (dirty[0] & /*$$props*/ 128) icon_changes.size = /*$$props*/ ctx[7].iconSize;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(174:4) {#if hasIcon}",
		ctx
	});

	return block;
}

// (186:4) {#if typeof text !== 'undefined'}
function create_if_block_1(ctx) {
	let span;
	let t_value = Utils$1.text(/*text*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$6, 186, 6, 5027);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = Utils$1.text(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(186:4) {#if typeof text !== 'undefined'}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tagName*/ ctx[4] === "button") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","text","tabLink","tabLinkActive","type","href","target","round","roundMd","roundIos","roundAurora","fill","fillMd","fillIos","fillAurora","large","largeMd","largeIos","largeAurora","small","smallMd","smallIos","smallAurora","raised","raisedMd","raisedIos","raisedAurora","outline","outlineMd","outlineIos","outlineAurora","active","disabled","tooltip","tooltipTrigger"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { type = undefined } = $$props;
	let { href = "#" } = $$props;
	let { target = undefined } = $$props;
	let { round = false } = $$props;
	let { roundMd = false } = $$props;
	let { roundIos = false } = $$props;
	let { roundAurora = false } = $$props;
	let { fill = false } = $$props;
	let { fillMd = false } = $$props;
	let { fillIos = false } = $$props;
	let { fillAurora = false } = $$props;
	let { large = false } = $$props;
	let { largeMd = false } = $$props;
	let { largeIos = false } = $$props;
	let { largeAurora = false } = $$props;
	let { small = false } = $$props;
	let { smallMd = false } = $$props;
	let { smallIos = false } = $$props;
	let { smallAurora = false } = $$props;
	let { raised = false } = $$props;
	let { raisedMd = false } = $$props;
	let { raisedIos = false } = $$props;
	let { raisedAurora = false } = $$props;
	let { outline = false } = $$props;
	let { outlineMd = false } = $$props;
	let { outlineIos = false } = $$props;
	let { outlineAurora = false } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;
	let f7Tooltip;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	onMount(() => {
		if ($$props.routeProps) {
			$$invalidate(1, el.f7RouteProps = $$props.routeProps, el);
		}

		if (!tooltip) return;

		f7.ready(() => {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: tooltip,
				trigger: tooltipTrigger
			});
		});
	});

	afterUpdate(() => {
		if ($$props.routeProps) {
			$$invalidate(1, el.f7RouteProps = $$props.routeProps, el);
		}
	});

	onDestroy(() => {
		if (el) delete el.f7RouteProps;

		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Button", $$slots, ['default']);

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(51, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("tabLink" in $$new_props) $$invalidate(9, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$new_props) $$invalidate(10, tabLinkActive = $$new_props.tabLinkActive);
		if ("type" in $$new_props) $$invalidate(11, type = $$new_props.type);
		if ("href" in $$new_props) $$invalidate(12, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(13, target = $$new_props.target);
		if ("round" in $$new_props) $$invalidate(14, round = $$new_props.round);
		if ("roundMd" in $$new_props) $$invalidate(15, roundMd = $$new_props.roundMd);
		if ("roundIos" in $$new_props) $$invalidate(16, roundIos = $$new_props.roundIos);
		if ("roundAurora" in $$new_props) $$invalidate(17, roundAurora = $$new_props.roundAurora);
		if ("fill" in $$new_props) $$invalidate(18, fill = $$new_props.fill);
		if ("fillMd" in $$new_props) $$invalidate(19, fillMd = $$new_props.fillMd);
		if ("fillIos" in $$new_props) $$invalidate(20, fillIos = $$new_props.fillIos);
		if ("fillAurora" in $$new_props) $$invalidate(21, fillAurora = $$new_props.fillAurora);
		if ("large" in $$new_props) $$invalidate(22, large = $$new_props.large);
		if ("largeMd" in $$new_props) $$invalidate(23, largeMd = $$new_props.largeMd);
		if ("largeIos" in $$new_props) $$invalidate(24, largeIos = $$new_props.largeIos);
		if ("largeAurora" in $$new_props) $$invalidate(25, largeAurora = $$new_props.largeAurora);
		if ("small" in $$new_props) $$invalidate(26, small = $$new_props.small);
		if ("smallMd" in $$new_props) $$invalidate(27, smallMd = $$new_props.smallMd);
		if ("smallIos" in $$new_props) $$invalidate(28, smallIos = $$new_props.smallIos);
		if ("smallAurora" in $$new_props) $$invalidate(29, smallAurora = $$new_props.smallAurora);
		if ("raised" in $$new_props) $$invalidate(30, raised = $$new_props.raised);
		if ("raisedMd" in $$new_props) $$invalidate(31, raisedMd = $$new_props.raisedMd);
		if ("raisedIos" in $$new_props) $$invalidate(32, raisedIos = $$new_props.raisedIos);
		if ("raisedAurora" in $$new_props) $$invalidate(33, raisedAurora = $$new_props.raisedAurora);
		if ("outline" in $$new_props) $$invalidate(34, outline = $$new_props.outline);
		if ("outlineMd" in $$new_props) $$invalidate(35, outlineMd = $$new_props.outlineMd);
		if ("outlineIos" in $$new_props) $$invalidate(36, outlineIos = $$new_props.outlineIos);
		if ("outlineAurora" in $$new_props) $$invalidate(37, outlineAurora = $$new_props.outlineAurora);
		if ("active" in $$new_props) $$invalidate(38, active = $$new_props.active);
		if ("disabled" in $$new_props) $$invalidate(39, disabled = $$new_props.disabled);
		if ("tooltip" in $$new_props) $$invalidate(40, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(41, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("$$scope" in $$new_props) $$invalidate(42, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		Icon,
		dispatch,
		className,
		text,
		tabLink,
		tabLinkActive,
		type,
		href,
		target,
		round,
		roundMd,
		roundIos,
		roundAurora,
		fill,
		fillMd,
		fillIos,
		fillAurora,
		large,
		largeMd,
		largeIos,
		largeAurora,
		small,
		smallMd,
		smallIos,
		smallAurora,
		raised,
		raisedMd,
		raisedIos,
		raisedAurora,
		outline,
		outlineMd,
		outlineIos,
		outlineAurora,
		active,
		disabled,
		tooltip,
		tooltipTrigger,
		el,
		f7Tooltip,
		tooltipText,
		watchTooltip,
		onClick,
		hrefComputed,
		attrs,
		classes,
		tagName,
		hasIcon
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
		if ("text" in $$props) $$invalidate(0, text = $$new_props.text);
		if ("tabLink" in $$props) $$invalidate(9, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$props) $$invalidate(10, tabLinkActive = $$new_props.tabLinkActive);
		if ("type" in $$props) $$invalidate(11, type = $$new_props.type);
		if ("href" in $$props) $$invalidate(12, href = $$new_props.href);
		if ("target" in $$props) $$invalidate(13, target = $$new_props.target);
		if ("round" in $$props) $$invalidate(14, round = $$new_props.round);
		if ("roundMd" in $$props) $$invalidate(15, roundMd = $$new_props.roundMd);
		if ("roundIos" in $$props) $$invalidate(16, roundIos = $$new_props.roundIos);
		if ("roundAurora" in $$props) $$invalidate(17, roundAurora = $$new_props.roundAurora);
		if ("fill" in $$props) $$invalidate(18, fill = $$new_props.fill);
		if ("fillMd" in $$props) $$invalidate(19, fillMd = $$new_props.fillMd);
		if ("fillIos" in $$props) $$invalidate(20, fillIos = $$new_props.fillIos);
		if ("fillAurora" in $$props) $$invalidate(21, fillAurora = $$new_props.fillAurora);
		if ("large" in $$props) $$invalidate(22, large = $$new_props.large);
		if ("largeMd" in $$props) $$invalidate(23, largeMd = $$new_props.largeMd);
		if ("largeIos" in $$props) $$invalidate(24, largeIos = $$new_props.largeIos);
		if ("largeAurora" in $$props) $$invalidate(25, largeAurora = $$new_props.largeAurora);
		if ("small" in $$props) $$invalidate(26, small = $$new_props.small);
		if ("smallMd" in $$props) $$invalidate(27, smallMd = $$new_props.smallMd);
		if ("smallIos" in $$props) $$invalidate(28, smallIos = $$new_props.smallIos);
		if ("smallAurora" in $$props) $$invalidate(29, smallAurora = $$new_props.smallAurora);
		if ("raised" in $$props) $$invalidate(30, raised = $$new_props.raised);
		if ("raisedMd" in $$props) $$invalidate(31, raisedMd = $$new_props.raisedMd);
		if ("raisedIos" in $$props) $$invalidate(32, raisedIos = $$new_props.raisedIos);
		if ("raisedAurora" in $$props) $$invalidate(33, raisedAurora = $$new_props.raisedAurora);
		if ("outline" in $$props) $$invalidate(34, outline = $$new_props.outline);
		if ("outlineMd" in $$props) $$invalidate(35, outlineMd = $$new_props.outlineMd);
		if ("outlineIos" in $$props) $$invalidate(36, outlineIos = $$new_props.outlineIos);
		if ("outlineAurora" in $$props) $$invalidate(37, outlineAurora = $$new_props.outlineAurora);
		if ("active" in $$props) $$invalidate(38, active = $$new_props.active);
		if ("disabled" in $$props) $$invalidate(39, disabled = $$new_props.disabled);
		if ("tooltip" in $$props) $$invalidate(40, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(41, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("el" in $$props) $$invalidate(1, el = $$new_props.el);
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("hrefComputed" in $$props) $$invalidate(48, hrefComputed = $$new_props.hrefComputed);
		if ("attrs" in $$props) $$invalidate(2, attrs = $$new_props.attrs);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
		if ("tagName" in $$props) $$invalidate(4, tagName = $$new_props.tagName);
		if ("hasIcon" in $$props) $$invalidate(5, hasIcon = $$new_props.hasIcon);
	};

	let hrefComputed;
	let attrs;
	let classes;
	let tagName;
	let hasIcon;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*href*/ 4096) {
			 $$invalidate(48, hrefComputed = href === true ? "#" : href || undefined);
		}

		 $$invalidate(2, attrs = Utils$1.extend(
			{
				href: hrefComputed,
				target,
				type,
				"data-tab": Utils$1.isStringProp(tabLink) && tabLink || undefined,
				...restProps($$restProps)
			},
			Mixins.linkRouterAttrs($$props),
			Mixins.linkActionsAttrs($$props)
		));

		 $$invalidate(3, classes = Utils$1.classNames(
			className,
			"button",
			{
				"tab-link": tabLink || tabLink === "",
				"tab-link-active": tabLinkActive,
				"button-round": round,
				"button-round-ios": roundIos,
				"button-round-aurora": roundAurora,
				"button-round-md": roundMd,
				"button-fill": fill,
				"button-fill-ios": fillIos,
				"button-fill-aurora": fillAurora,
				"button-fill-md": fillMd,
				"button-large": large,
				"button-large-ios": largeIos,
				"button-large-aurora": largeAurora,
				"button-large-md": largeMd,
				"button-small": small,
				"button-small-ios": smallIos,
				"button-small-aurora": smallAurora,
				"button-small-md": smallMd,
				"button-raised": raised,
				"button-raised-ios": raisedIos,
				"button-raised-aurora": raisedAurora,
				"button-raised-md": raisedMd,
				"button-active": active,
				"button-outline": outline,
				"button-outline-ios": outlineIos,
				"button-outline-aurora": outlineAurora,
				"button-outline-md": outlineMd,
				disabled
			},
			Mixins.colorClasses($$props),
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*type*/ 2048) {
			 $$invalidate(4, tagName = type === "submit" || type === "reset" || type === "button"
			? "button"
			: "a");
		}

		 $$invalidate(5, hasIcon = $$props.icon || $$props.iconMaterial || $$props.iconF7 || $$props.iconMd || $$props.iconIos || $$props.iconAurora);

		if ($$self.$$.dirty[1] & /*tooltip*/ 512) {
			 watchTooltip(tooltip);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		text,
		el,
		attrs,
		classes,
		tagName,
		hasIcon,
		onClick,
		$$props,
		className,
		tabLink,
		tabLinkActive,
		type,
		href,
		target,
		round,
		roundMd,
		roundIos,
		roundAurora,
		fill,
		fillMd,
		fillIos,
		fillAurora,
		large,
		largeMd,
		largeIos,
		largeAurora,
		small,
		smallMd,
		smallIos,
		smallAurora,
		raised,
		raisedMd,
		raisedIos,
		raisedAurora,
		outline,
		outlineMd,
		outlineIos,
		outlineAurora,
		active,
		disabled,
		tooltip,
		tooltipTrigger,
		$$scope,
		$$slots,
		button_binding,
		a_binding
	];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				class: 8,
				text: 0,
				tabLink: 9,
				tabLinkActive: 10,
				type: 11,
				href: 12,
				target: 13,
				round: 14,
				roundMd: 15,
				roundIos: 16,
				roundAurora: 17,
				fill: 18,
				fillMd: 19,
				fillIos: 20,
				fillAurora: 21,
				large: 22,
				largeMd: 23,
				largeIos: 24,
				largeAurora: 25,
				small: 26,
				smallMd: 27,
				smallIos: 28,
				smallAurora: 29,
				raised: 30,
				raisedMd: 31,
				raisedIos: 32,
				raisedAurora: 33,
				outline: 34,
				outlineMd: 35,
				outlineIos: 36,
				outlineAurora: 37,
				active: 38,
				disabled: 39,
				tooltip: 40,
				tooltipTrigger: 41
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$6.name
		});
	}

	get class() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLink() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLink(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLinkActive() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLinkActive(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get round() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set round(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fillMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fillMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fillIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fillIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fillAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fillAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get large() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set large(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get small() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set small(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raised() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raised(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlineMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlineMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlineIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlineIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlineAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlineAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$7 = "node_modules/framework7-svelte/components/text-editor.svelte";
const get_root_slot_changes = dirty => ({});
const get_root_slot_context = ctx => ({});
const get_root_end_slot_changes = dirty => ({});
const get_root_end_slot_context = ctx => ({});
const get_root_start_slot_changes = dirty => ({});
const get_root_start_slot_context = ctx => ({});

function create_fragment$7(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let t2;
	let current;
	const root_start_slot_template = /*$$slots*/ ctx[16]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[15], get_root_start_slot_context);
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	const root_end_slot_template = /*$$slots*/ ctx[16]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[15], get_root_end_slot_context);
	const root_slot_template = /*$$slots*/ ctx[16].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[15], get_root_slot_context);
	let div1_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (root_end_slot) root_end_slot.c();
			t2 = space();
			if (root_slot) root_slot.c();
			attr_dev(div0, "class", "text-editor-content");
			attr_dev(div0, "contenteditable", "");
			add_location(div0, file$7, 120, 2, 3480);
			set_attributes(div1, div1_data);
			add_location(div1, file$7, 118, 0, 3384);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (root_start_slot) {
				root_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div1, t1);

			if (root_end_slot) {
				root_end_slot.m(div1, null);
			}

			append_dev(div1, t2);

			if (root_slot) {
				root_slot.m(div1, null);
			}

			/*div1_binding*/ ctx[17](div1);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (root_start_slot) {
				if (root_start_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(root_start_slot, root_start_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_root_start_slot_changes, get_root_start_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(root_end_slot, root_end_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_root_end_slot_changes, get_root_end_slot_context);
				}
			}

			if (root_slot) {
				if (root_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(root_slot, root_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_root_slot_changes, get_root_slot_context);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(default_slot, local);
			transition_in(root_end_slot, local);
			transition_in(root_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(root_start_slot, local);
			transition_out(default_slot, local);
			transition_out(root_end_slot, local);
			transition_out(root_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (root_start_slot) root_start_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			if (root_slot) root_slot.d(detaching);
			/*div1_binding*/ ctx[17](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","mode","value","buttons","customButtons","dividers","imageUrlText","linkUrlText","placeholder","clearFormattingOnPaste","resizable","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { mode = undefined } = $$props;
	let { value = undefined } = $$props;
	let { buttons = undefined } = $$props;
	let { customButtons = undefined } = $$props;
	let { dividers = undefined } = $$props;
	let { imageUrlText = undefined } = $$props;
	let { linkUrlText = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { clearFormattingOnPaste = undefined } = $$props;
	let { resizable = false } = $$props;
	let el;
	let f7TextEditor;

	function instance() {
		return f7TextEditor;
	}

	function watchValue(newValue) {
		if (f7TextEditor) {
			f7TextEditor.setValue(newValue);
		}
	}

	function onChange(editor, editorValue) {
		dispatch("textEditorChange", [editorValue]);
		if (typeof $$props.onTextEditorChange === "function") $$props.onTextEditorChange(editorValue);
	}

	function onInput() {
		dispatch("textEditorChange");
		if (typeof $$props.onTextEditorChange === "function") $$props.onTextEditorChange();
	}

	function onFocus() {
		dispatch("textEditorFocus");
		if (typeof $$props.onTextEditorFocus === "function") $$props.onTextEditorFocus();
	}

	function onBlur() {
		dispatch("textEditorBlur");
		if (typeof $$props.onTextEditorBlur === "function") $$props.onTextEditorBlur();
	}

	function onButtonClick(editor, button) {
		dispatch("textEditorButtonClick", [button]);
		if (typeof $$props.onTextEditorButtonClick === "function") $$props.onTextEditorButtonClick(button);
	}

	function onKeyboardOpen() {
		dispatch("textEditorKeyboardOpen");
		if (typeof $$props.onTextEditorKeyboardOpen === "function") $$props.onTextEditorKeyboardOpen();
	}

	function onKeyboardClose() {
		dispatch("textEditorKeyboardClose");
		if (typeof $$props.onTextEditorKeyboardClose === "function") $$props.onTextEditorKeyboardClose();
	}

	function onPopoverOpen() {
		dispatch("textEditorPopoverOpen");
		if (typeof $$props.onTextEditorPopoverOpen === "function") $$props.onTextEditorPopoverOpen();
	}

	function onPopoverClose() {
		dispatch("textEditorPopoverClose");
		if (typeof $$props.onTextEditorPopoverClose === "function") $$props.onTextEditorPopoverClose();
	}

	onMount(() => {
		const params = Utils$1.noUndefinedProps({
			el,
			mode,
			value,
			buttons,
			customButtons,
			dividers,
			imageUrlText,
			linkUrlText,
			placeholder,
			clearFormattingOnPaste,
			on: {
				change: onChange,
				input: onInput,
				focus: onFocus,
				blur: onBlur,
				buttonClick: onButtonClick,
				keyboardOpen: onKeyboardOpen,
				keyboardClose: onKeyboardClose,
				popoverOpen: onPopoverOpen,
				popoverClose: onPopoverClose
			}
		});

		f7.ready(() => {
			f7TextEditor = f7.instance.textEditor.create(params);
		});
	});

	onDestroy(() => {
		if (f7TextEditor && f7TextEditor.destroy) {
			f7TextEditor.destroy();
		}
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Text_editor", $$slots, ['root-start','default','root-end','root']);

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("mode" in $$new_props) $$invalidate(4, mode = $$new_props.mode);
		if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
		if ("buttons" in $$new_props) $$invalidate(6, buttons = $$new_props.buttons);
		if ("customButtons" in $$new_props) $$invalidate(7, customButtons = $$new_props.customButtons);
		if ("dividers" in $$new_props) $$invalidate(8, dividers = $$new_props.dividers);
		if ("imageUrlText" in $$new_props) $$invalidate(9, imageUrlText = $$new_props.imageUrlText);
		if ("linkUrlText" in $$new_props) $$invalidate(10, linkUrlText = $$new_props.linkUrlText);
		if ("placeholder" in $$new_props) $$invalidate(11, placeholder = $$new_props.placeholder);
		if ("clearFormattingOnPaste" in $$new_props) $$invalidate(12, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
		if ("resizable" in $$new_props) $$invalidate(13, resizable = $$new_props.resizable);
		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		dispatch,
		className,
		mode,
		value,
		buttons,
		customButtons,
		dividers,
		imageUrlText,
		linkUrlText,
		placeholder,
		clearFormattingOnPaste,
		resizable,
		el,
		f7TextEditor,
		instance,
		watchValue,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onButtonClick,
		onKeyboardOpen,
		onKeyboardClose,
		onPopoverOpen,
		onPopoverClose,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(30, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("mode" in $$props) $$invalidate(4, mode = $$new_props.mode);
		if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
		if ("buttons" in $$props) $$invalidate(6, buttons = $$new_props.buttons);
		if ("customButtons" in $$props) $$invalidate(7, customButtons = $$new_props.customButtons);
		if ("dividers" in $$props) $$invalidate(8, dividers = $$new_props.dividers);
		if ("imageUrlText" in $$props) $$invalidate(9, imageUrlText = $$new_props.imageUrlText);
		if ("linkUrlText" in $$props) $$invalidate(10, linkUrlText = $$new_props.linkUrlText);
		if ("placeholder" in $$props) $$invalidate(11, placeholder = $$new_props.placeholder);
		if ("clearFormattingOnPaste" in $$props) $$invalidate(12, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
		if ("resizable" in $$props) $$invalidate(13, resizable = $$new_props.resizable);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("f7TextEditor" in $$props) f7TextEditor = $$new_props.f7TextEditor;
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils$1.classNames(className, "text-editor", resizable && "text-editor-resizable", Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*value*/ 32) {
			 watchValue(value);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		className,
		mode,
		value,
		buttons,
		customButtons,
		dividers,
		imageUrlText,
		linkUrlText,
		placeholder,
		clearFormattingOnPaste,
		resizable,
		instance,
		$$scope,
		$$slots,
		div1_binding
	];
}

class Text_editor extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1, create_fragment$7, safe_not_equal, {
			class: 3,
			mode: 4,
			value: 5,
			buttons: 6,
			customButtons: 7,
			dividers: 8,
			imageUrlText: 9,
			linkUrlText: 10,
			placeholder: 11,
			clearFormattingOnPaste: 12,
			resizable: 13,
			instance: 14
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Text_editor",
			options,
			id: create_fragment$7.name
		});
	}

	get class() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mode() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttons() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttons(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get customButtons() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set customButtons(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dividers() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dividers(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get imageUrlText() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set imageUrlText(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linkUrlText() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linkUrlText(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearFormattingOnPaste() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearFormattingOnPaste(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[14];
	}

	set instance(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$8 = "node_modules/framework7-svelte/components/link.svelte";

// (159:2) {#if hasIcon}
function create_if_block_2$1(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[10].iconMaterial,
				f7: /*$$props*/ ctx[10].iconF7,
				icon: /*$$props*/ ctx[10].icon,
				md: /*$$props*/ ctx[10].iconMd,
				ios: /*$$props*/ ctx[10].iconIos,
				aurora: /*$$props*/ ctx[10].iconAurora,
				color: /*$$props*/ ctx[10].iconColor,
				size: /*$$props*/ ctx[10].iconSize,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty[0] & /*$$props*/ 1024) icon_changes.material = /*$$props*/ ctx[10].iconMaterial;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.f7 = /*$$props*/ ctx[10].iconF7;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.icon = /*$$props*/ ctx[10].icon;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.md = /*$$props*/ ctx[10].iconMd;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.ios = /*$$props*/ ctx[10].iconIos;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.aurora = /*$$props*/ ctx[10].iconAurora;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.color = /*$$props*/ ctx[10].iconColor;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.size = /*$$props*/ ctx[10].iconSize;

			if (dirty[0] & /*$$scope, badgeColor, iconBadge*/ 33554444) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(159:2) {#if hasIcon}",
		ctx
	});

	return block;
}

// (169:5) {#if iconBadge}
function create_if_block_3$1(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[2],
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4) badge_1_changes.color = /*badgeColor*/ ctx[2];

			if (dirty[0] & /*$$scope, iconBadge*/ 33554440) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(169:5) {#if iconBadge}",
		ctx
	});

	return block;
}

// (169:20) <Badge color={badgeColor}>
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text$1(/*iconBadge*/ ctx[3]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*iconBadge*/ 8) set_data_dev(t, /*iconBadge*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(169:20) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (160:4) <Icon       material={$$props.iconMaterial}       f7={$$props.iconF7}       icon={$$props.icon}       md={$$props.iconMd}       ios={$$props.iconIos}       aurora={$$props.iconAurora}       color={$$props.iconColor}       size={$$props.iconSize}     >
function create_default_slot_1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*iconBadge*/ ctx[3] && create_if_block_3$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*iconBadge*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*iconBadge*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(160:4) <Icon       material={$$props.iconMaterial}       f7={$$props.iconF7}       icon={$$props.icon}       md={$$props.iconMd}       ios={$$props.iconIos}       aurora={$$props.iconAurora}       color={$$props.iconColor}       size={$$props.iconSize}     >",
		ctx
	});

	return block;
}

// (172:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}
function create_if_block$1(ctx) {
	let span;
	let t0_value = Utils$1.text(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	let if_block = typeof /*badge*/ ctx[1] !== "undefined" && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			span = element("span");
			t0 = text$1(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[5]);
			add_location(span, file$8, 172, 4, 4480);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, t1);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 1) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (typeof /*badge*/ ctx[1] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*isTabbarLabel*/ 32) {
				toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[5]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(172:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (175:6) {#if typeof badge !== 'undefined'}
function create_if_block_1$1(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[2],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4) badge_1_changes.color = /*badgeColor*/ ctx[2];

			if (dirty[0] & /*$$scope, badge*/ 33554434) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(175:6) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (175:40) <Badge color={badgeColor}>
function create_default_slot(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[1]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[1]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(175:40) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let a;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*hasIcon*/ ctx[8] && create_if_block_2$1(ctx);
	const default_slot_template = /*$$slots*/ ctx[23].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[25], null);
	let if_block1 = (typeof /*text*/ ctx[0] !== "undefined" || typeof /*badge*/ ctx[1] !== "undefined") && create_if_block$1(ctx);
	let a_levels = [{ class: /*classes*/ ctx[7] }, /*attrs*/ ctx[6]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (if_block0) if_block0.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			set_attributes(a, a_data);
			add_location(a, file$8, 152, 0, 3971);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			if (if_block0) if_block0.m(a, null);
			append_dev(a, t0);

			if (default_slot) {
				default_slot.m(a, null);
			}

			append_dev(a, t1);
			if (if_block1) if_block1.m(a, null);
			/*a_binding*/ ctx[24](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[9], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*hasIcon*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*hasIcon*/ 256) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(a, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 33554432) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[25], dirty, null, null);
				}
			}

			if (typeof /*text*/ ctx[0] !== "undefined" || typeof /*badge*/ ctx[1] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*text, badge*/ 3) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(a, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[0] & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				dirty[0] & /*attrs*/ 64 && /*attrs*/ ctx[6]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			/*a_binding*/ ctx[24](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","noLinkClass","text","tabLink","tabLinkActive","tabbarLabel","iconOnly","badge","badgeColor","iconBadge","href","target","tooltip","tooltipTrigger","smartSelect","smartSelectParams"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { noLinkClass = false } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { tabbarLabel = false } = $$props;
	let { iconOnly = false } = $$props;
	let { badge = undefined } = $$props;
	let { badgeColor = undefined } = $$props;
	let { iconBadge = undefined } = $$props;
	let { href = "#" } = $$props;
	let { target = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { smartSelect = false } = $$props;
	let { smartSelectParams = undefined } = $$props;
	let el;
	let f7Tooltip;
	let f7SmartSelect;
	let isTabbarLabel = tabbarLabel;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	onMount(() => {
		if ($$props.routeProps) {
			$$invalidate(4, el.f7RouteProps = $$props.routeProps, el);
		}

		f7.ready(() => {
			if (tabbarLabel || (tabLink || tabLink === "") && f7.instance.$(el).parents(".tabbar-labels").length) {
				$$invalidate(5, isTabbarLabel = true);
			}

			if (smartSelect) {
				const ssParams = Utils$1.extend({ el }, smartSelectParams || {});
				f7SmartSelect = f7.instance.smartSelect.create(ssParams);
			}

			if (tooltip) {
				f7Tooltip = f7.instance.tooltip.create({
					targetEl: el,
					text: tooltip,
					trigger: tooltipTrigger
				});
			}
		});
	});

	afterUpdate(() => {
		if ($$props.routeProps) {
			$$invalidate(4, el.f7RouteProps = $$props.routeProps, el);
		}
	});

	onDestroy(() => {
		if (el) delete el.f7RouteProps;

		if (f7SmartSelect && f7SmartSelect.destroy) {
			f7SmartSelect.destroy();
			f7SmartSelect = null;
		}

		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Link", $$slots, ['default']);

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(4, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(35, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(11, className = $$new_props.class);
		if ("noLinkClass" in $$new_props) $$invalidate(12, noLinkClass = $$new_props.noLinkClass);
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("tabLink" in $$new_props) $$invalidate(13, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$new_props) $$invalidate(14, tabLinkActive = $$new_props.tabLinkActive);
		if ("tabbarLabel" in $$new_props) $$invalidate(15, tabbarLabel = $$new_props.tabbarLabel);
		if ("iconOnly" in $$new_props) $$invalidate(16, iconOnly = $$new_props.iconOnly);
		if ("badge" in $$new_props) $$invalidate(1, badge = $$new_props.badge);
		if ("badgeColor" in $$new_props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
		if ("iconBadge" in $$new_props) $$invalidate(3, iconBadge = $$new_props.iconBadge);
		if ("href" in $$new_props) $$invalidate(17, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(18, target = $$new_props.target);
		if ("tooltip" in $$new_props) $$invalidate(19, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(20, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("smartSelect" in $$new_props) $$invalidate(21, smartSelect = $$new_props.smartSelect);
		if ("smartSelectParams" in $$new_props) $$invalidate(22, smartSelectParams = $$new_props.smartSelectParams);
		if ("$$scope" in $$new_props) $$invalidate(25, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		hasSlots,
		Badge,
		Icon,
		dispatch,
		className,
		noLinkClass,
		text,
		tabLink,
		tabLinkActive,
		tabbarLabel,
		iconOnly,
		badge,
		badgeColor,
		iconBadge,
		href,
		target,
		tooltip,
		tooltipTrigger,
		smartSelect,
		smartSelectParams,
		el,
		f7Tooltip,
		f7SmartSelect,
		isTabbarLabel,
		tooltipText,
		watchTooltip,
		onClick,
		hrefComputed,
		attrs,
		hasDefaultSlots,
		iconOnlyComputed,
		classes,
		hasIcon,
		hasIconBadge
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(11, className = $$new_props.className);
		if ("noLinkClass" in $$props) $$invalidate(12, noLinkClass = $$new_props.noLinkClass);
		if ("text" in $$props) $$invalidate(0, text = $$new_props.text);
		if ("tabLink" in $$props) $$invalidate(13, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$props) $$invalidate(14, tabLinkActive = $$new_props.tabLinkActive);
		if ("tabbarLabel" in $$props) $$invalidate(15, tabbarLabel = $$new_props.tabbarLabel);
		if ("iconOnly" in $$props) $$invalidate(16, iconOnly = $$new_props.iconOnly);
		if ("badge" in $$props) $$invalidate(1, badge = $$new_props.badge);
		if ("badgeColor" in $$props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
		if ("iconBadge" in $$props) $$invalidate(3, iconBadge = $$new_props.iconBadge);
		if ("href" in $$props) $$invalidate(17, href = $$new_props.href);
		if ("target" in $$props) $$invalidate(18, target = $$new_props.target);
		if ("tooltip" in $$props) $$invalidate(19, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(20, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("smartSelect" in $$props) $$invalidate(21, smartSelect = $$new_props.smartSelect);
		if ("smartSelectParams" in $$props) $$invalidate(22, smartSelectParams = $$new_props.smartSelectParams);
		if ("el" in $$props) $$invalidate(4, el = $$new_props.el);
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("f7SmartSelect" in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
		if ("isTabbarLabel" in $$props) $$invalidate(5, isTabbarLabel = $$new_props.isTabbarLabel);
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("hrefComputed" in $$props) $$invalidate(29, hrefComputed = $$new_props.hrefComputed);
		if ("attrs" in $$props) $$invalidate(6, attrs = $$new_props.attrs);
		if ("hasDefaultSlots" in $$props) $$invalidate(30, hasDefaultSlots = $$new_props.hasDefaultSlots);
		if ("iconOnlyComputed" in $$props) $$invalidate(31, iconOnlyComputed = $$new_props.iconOnlyComputed);
		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
		if ("hasIcon" in $$props) $$invalidate(8, hasIcon = $$new_props.hasIcon);
		if ("hasIconBadge" in $$props) hasIconBadge = $$new_props.hasIconBadge;
	};

	let hrefComputed;
	let attrs;
	let hasDefaultSlots;
	let iconOnlyComputed;
	let classes;
	let hasIcon;
	let hasIconBadge;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*href*/ 131072) {
			 $$invalidate(29, hrefComputed = href === true ? "#" : href || undefined);
		}

		 $$invalidate(6, attrs = Utils$1.extend(
			{
				href: hrefComputed,
				target,
				"data-tab": Utils$1.isStringProp(tabLink) && tabLink || undefined,
				...restProps($$restProps)
			},
			Mixins.linkRouterAttrs($$props),
			Mixins.linkActionsAttrs($$props)
		));

		if ($$self.$$.dirty[0] & /*iconOnly, text, hasDefaultSlots*/ 1073807361) {
			 $$invalidate(31, iconOnlyComputed = iconOnly || !text && !hasDefaultSlots);
		}

		 $$invalidate(7, classes = Utils$1.classNames(
			className,
			{
				link: !(noLinkClass || isTabbarLabel),
				"icon-only": iconOnlyComputed,
				"tab-link": tabLink || tabLink === "",
				"tab-link-active": tabLinkActive,
				"smart-select": smartSelect
			},
			Mixins.colorClasses($$props),
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props)
		));

		 $$invalidate(8, hasIcon = $$props.icon || $$props.iconMaterial || $$props.iconF7 || $$props.iconMd || $$props.iconIos || $$props.iconAurora);
		 hasIconBadge = $$props.hasIconBadge;

		if ($$self.$$.dirty[0] & /*tooltip*/ 524288) {
			 watchTooltip(tooltip);
		}
	};

	 $$invalidate(30, hasDefaultSlots = hasSlots(arguments, "default"));
	$$props = exclude_internal_props($$props);

	return [
		text,
		badge,
		badgeColor,
		iconBadge,
		el,
		isTabbarLabel,
		attrs,
		classes,
		hasIcon,
		onClick,
		$$props,
		className,
		noLinkClass,
		tabLink,
		tabLinkActive,
		tabbarLabel,
		iconOnly,
		href,
		target,
		tooltip,
		tooltipTrigger,
		smartSelect,
		smartSelectParams,
		$$slots,
		a_binding,
		$$scope
	];
}

class Link extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$7,
			create_fragment$8,
			safe_not_equal,
			{
				class: 11,
				noLinkClass: 12,
				text: 0,
				tabLink: 13,
				tabLinkActive: 14,
				tabbarLabel: 15,
				iconOnly: 16,
				badge: 1,
				badgeColor: 2,
				iconBadge: 3,
				href: 17,
				target: 18,
				tooltip: 19,
				tooltipTrigger: 20,
				smartSelect: 21,
				smartSelectParams: 22
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link",
			options,
			id: create_fragment$8.name
		});
	}

	get class() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noLinkClass() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noLinkClass(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLink() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLink(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLinkActive() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLinkActive(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabbarLabel() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabbarLabel(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconOnly() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconOnly(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get badge() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set badge(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get badgeColor() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set badgeColor(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconBadge() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconBadge(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelect() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smartSelect(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelectParams() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smartSelectParams(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$9 = "node_modules/framework7-svelte/components/list-input.svelte";
const get_content_end_slot_changes_1 = dirty => ({});
const get_content_end_slot_context_1 = ctx => ({});
const get_content_slot_changes_1 = dirty => ({});
const get_content_slot_context_1 = ctx => ({});
const get_inner_end_slot_changes_1 = dirty => ({});
const get_inner_end_slot_context_1 = ctx => ({});
const get_inner_slot_changes_1 = dirty => ({});
const get_inner_slot_context_1 = ctx => ({});
const get_info_slot_changes_1 = dirty => ({});
const get_info_slot_context_1 = ctx => ({});
const get_error_message_slot_changes_1 = dirty => ({});
const get_error_message_slot_context_1 = ctx => ({});
const get_input_slot_changes_1 = dirty => ({});
const get_input_slot_context_1 = ctx => ({});
const get_label_slot_changes_1 = dirty => ({});
const get_label_slot_context_1 = ctx => ({});
const get_inner_start_slot_changes_1 = dirty => ({});
const get_inner_start_slot_context_1 = ctx => ({});
const get_media_slot_changes_1 = dirty => ({});
const get_media_slot_context_1 = ctx => ({});
const get_content_start_slot_changes_1 = dirty => ({});
const get_content_start_slot_context_1 = ctx => ({});
const get_root_end_slot_changes$1 = dirty => ({});
const get_root_end_slot_context$1 = ctx => ({});
const get_root_slot_changes$1 = dirty => ({});
const get_root_slot_context$1 = ctx => ({});
const get_content_end_slot_changes = dirty => ({});
const get_content_end_slot_context = ctx => ({});
const get_content_slot_changes = dirty => ({});
const get_content_slot_context = ctx => ({});
const get_inner_end_slot_changes = dirty => ({});
const get_inner_end_slot_context = ctx => ({});
const get_inner_slot_changes = dirty => ({});
const get_inner_slot_context = ctx => ({});
const get_info_slot_changes = dirty => ({});
const get_info_slot_context = ctx => ({});
const get_error_message_slot_changes = dirty => ({});
const get_error_message_slot_context = ctx => ({});
const get_input_slot_changes = dirty => ({});
const get_input_slot_context = ctx => ({});
const get_label_slot_changes = dirty => ({});
const get_label_slot_context = ctx => ({});
const get_inner_start_slot_changes = dirty => ({});
const get_inner_start_slot_context = ctx => ({});
const get_media_slot_changes = dirty => ({});
const get_media_slot_context = ctx => ({});
const get_content_start_slot_changes = dirty => ({});
const get_content_start_slot_context = ctx => ({});
const get_root_start_slot_changes$1 = dirty => ({});
const get_root_start_slot_context$1 = ctx => ({});

// (562:0) {:else}
function create_else_block_1(ctx) {
	let div2;
	let t0;
	let t1;
	let t2;
	let div1;
	let t3;
	let t4;
	let div0;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let current;
	const content_start_slot_template = /*$$slots*/ ctx[73]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[72], get_content_start_slot_context_1);
	let if_block0 = /*isSortable*/ ctx[39] && /*isSortableOpposite*/ ctx[40] && create_if_block_23(ctx);
	let if_block1 = (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[44]) && create_if_block_21(ctx);
	const inner_start_slot_template = /*$$slots*/ ctx[73]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[72], get_inner_start_slot_context_1);
	let if_block2 = (typeof /*label*/ ctx[36] !== "undefined" || /*hasLabelSlots*/ ctx[45]) && create_if_block_20(ctx);
	let if_block3 = /*input*/ ctx[2] && create_if_block_16(ctx);
	const input_slot_template = /*$$slots*/ ctx[73].input;
	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[72], get_input_slot_context_1);
	let if_block4 = /*hasErrorMessage*/ ctx[46] && /*errorMessageForce*/ ctx[34] && create_if_block_15(ctx);
	let if_block5 = /*clearButton*/ ctx[32] && create_if_block_14(ctx);
	let if_block6 = (typeof /*info*/ ctx[35] !== "undefined" || /*hasInfoSlots*/ ctx[43]) && create_if_block_13(ctx);
	const inner_slot_template = /*$$slots*/ ctx[73].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[72], get_inner_slot_context_1);
	const inner_end_slot_template = /*$$slots*/ ctx[73]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[72], get_inner_end_slot_context_1);
	const content_slot_template = /*$$slots*/ ctx[73].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[72], get_content_slot_context_1);
	const content_end_slot_template = /*$$slots*/ ctx[73]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[72], get_content_end_slot_context_1);
	let div2_levels = [{ class: /*itemContentClasses*/ ctx[48] }, restProps(/*$$restProps*/ ctx[56])];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			div0 = element("div");
			if (if_block3) if_block3.c();
			t5 = space();
			if (input_slot) input_slot.c();
			t6 = space();
			if (if_block4) if_block4.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			t9 = space();
			if (inner_slot) inner_slot.c();
			t10 = space();
			if (inner_end_slot) inner_end_slot.c();
			t11 = space();
			if (content_slot) content_slot.c();
			t12 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", /*inputWrapClasses*/ ctx[50]);
			add_location(div0, file$9, 584, 6, 18775);
			attr_dev(div1, "class", "item-inner");
			add_location(div1, file$9, 576, 4, 18528);
			set_attributes(div2, div2_data);
			add_location(div2, file$9, 562, 2, 18131);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);

			if (content_start_slot) {
				content_start_slot.m(div2, null);
			}

			append_dev(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t1);
			if (if_block1) if_block1.m(div2, null);
			append_dev(div2, t2);
			append_dev(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_dev(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div1, t4);
			append_dev(div1, div0);
			if (if_block3) if_block3.m(div0, null);
			append_dev(div0, t5);

			if (input_slot) {
				input_slot.m(div0, null);
			}

			append_dev(div0, t6);
			if (if_block4) if_block4.m(div0, null);
			append_dev(div0, t7);
			if (if_block5) if_block5.m(div0, null);
			append_dev(div0, t8);
			if (if_block6) if_block6.m(div0, null);
			append_dev(div1, t9);

			if (inner_slot) {
				inner_slot.m(div1, null);
			}

			append_dev(div1, t10);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_dev(div2, t11);

			if (content_slot) {
				content_slot.m(div2, null);
			}

			append_dev(div2, t12);

			if (content_end_slot) {
				content_end_slot.m(div2, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_content_start_slot_changes_1, get_content_start_slot_context_1);
				}
			}

			if (/*isSortable*/ ctx[39] && /*isSortableOpposite*/ ctx[40]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_23(ctx);
					if_block0.c();
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[44]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*media*/ 1 | dirty[1] & /*hasMediaSlots*/ 8192) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_21(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div2, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_inner_start_slot_changes_1, get_inner_start_slot_context_1);
				}
			}

			if (typeof /*label*/ ctx[36] !== "undefined" || /*hasLabelSlots*/ ctx[45]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*label, hasLabelSlots*/ 16416) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_20(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*input*/ ctx[2]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*input*/ 4) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_16(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div0, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (input_slot) {
				if (input_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(input_slot, input_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_input_slot_changes_1, get_input_slot_context_1);
				}
			}

			if (/*hasErrorMessage*/ ctx[46] && /*errorMessageForce*/ ctx[34]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 32776) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_15(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div0, t7);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*clearButton*/ ctx[32]) {
				if (if_block5) ; else {
					if_block5 = create_if_block_14(ctx);
					if_block5.c();
					if_block5.m(div0, t8);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (typeof /*info*/ ctx[35] !== "undefined" || /*hasInfoSlots*/ ctx[43]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*info, hasInfoSlots*/ 4112) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_13(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(div0, null);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (!current || dirty[1] & /*inputWrapClasses*/ 524288) {
				attr_dev(div0, "class", /*inputWrapClasses*/ ctx[50]);
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_inner_slot_changes_1, get_inner_slot_context_1);
				}
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_inner_end_slot_changes_1, get_inner_end_slot_context_1);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_content_slot_changes_1, get_content_slot_context_1);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_content_end_slot_changes_1, get_content_end_slot_context_1);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[1] & /*itemContentClasses*/ 131072) && { class: /*itemContentClasses*/ ctx[48] },
				dirty[1] & /*$$restProps*/ 33554432 && restProps(/*$$restProps*/ ctx[56])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(input_slot, local);
			transition_in(if_block4);
			transition_in(if_block6);
			transition_in(inner_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(input_slot, local);
			transition_out(if_block4);
			transition_out(if_block6);
			transition_out(inner_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (input_slot) input_slot.d(detaching);
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (inner_slot) inner_slot.d(detaching);
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(562:0) {:else}",
		ctx
	});

	return block;
}

// (377:0) {#if wrap}
function create_if_block$2(ctx) {
	let li;
	let t0;
	let div2;
	let t1;
	let t2;
	let t3;
	let div1;
	let t4;
	let t5;
	let div0;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let t13;
	let t14;
	let t15;
	let t16;
	let current;
	const root_start_slot_template = /*$$slots*/ ctx[73]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[72], get_root_start_slot_context$1);
	const content_start_slot_template = /*$$slots*/ ctx[73]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[72], get_content_start_slot_context);
	let if_block0 = /*isSortable*/ ctx[39] && /*isSortableOpposite*/ ctx[40] && create_if_block_12(ctx);
	let if_block1 = (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[44]) && create_if_block_10(ctx);
	const inner_start_slot_template = /*$$slots*/ ctx[73]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[72], get_inner_start_slot_context);
	let if_block2 = (typeof /*label*/ ctx[36] !== "undefined" || /*hasLabelSlots*/ ctx[45]) && create_if_block_9(ctx);
	let if_block3 = /*input*/ ctx[2] && create_if_block_5(ctx);
	const input_slot_template = /*$$slots*/ ctx[73].input;
	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[72], get_input_slot_context);
	let if_block4 = /*hasErrorMessage*/ ctx[46] && /*errorMessageForce*/ ctx[34] && create_if_block_4$1(ctx);
	let if_block5 = /*clearButton*/ ctx[32] && create_if_block_3$2(ctx);
	let if_block6 = (typeof /*info*/ ctx[35] !== "undefined" || /*hasInfoSlots*/ ctx[43]) && create_if_block_2$2(ctx);
	const inner_slot_template = /*$$slots*/ ctx[73].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[72], get_inner_slot_context);
	const inner_end_slot_template = /*$$slots*/ ctx[73]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[72], get_inner_end_slot_context);
	const content_slot_template = /*$$slots*/ ctx[73].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[72], get_content_slot_context);
	const content_end_slot_template = /*$$slots*/ ctx[73]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[72], get_content_end_slot_context);
	let if_block7 = /*isSortable*/ ctx[39] && !/*isSortableOpposite*/ ctx[40] && create_if_block_1$2(ctx);
	const root_slot_template = /*$$slots*/ ctx[73].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[72], get_root_slot_context$1);
	const root_end_slot_template = /*$$slots*/ ctx[73]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[72], get_root_end_slot_context$1);
	let li_levels = [{ class: /*classes*/ ctx[51] }, restProps(/*$$restProps*/ ctx[56])];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			div2 = element("div");
			if (content_start_slot) content_start_slot.c();
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			div0 = element("div");
			if (if_block3) if_block3.c();
			t6 = space();
			if (input_slot) input_slot.c();
			t7 = space();
			if (if_block4) if_block4.c();
			t8 = space();
			if (if_block5) if_block5.c();
			t9 = space();
			if (if_block6) if_block6.c();
			t10 = space();
			if (inner_slot) inner_slot.c();
			t11 = space();
			if (inner_end_slot) inner_end_slot.c();
			t12 = space();
			if (content_slot) content_slot.c();
			t13 = space();
			if (content_end_slot) content_end_slot.c();
			t14 = space();
			if (if_block7) if_block7.c();
			t15 = space();
			if (root_slot) root_slot.c();
			t16 = space();
			if (root_end_slot) root_end_slot.c();
			attr_dev(div0, "class", /*inputWrapClasses*/ ctx[50]);
			add_location(div0, file$9, 401, 8, 11797);
			attr_dev(div1, "class", "item-inner");
			add_location(div1, file$9, 393, 6, 11534);
			attr_dev(div2, "class", /*itemContentClasses*/ ctx[48]);
			add_location(div2, file$9, 379, 4, 11139);
			set_attributes(li, li_data);
			add_location(li, file$9, 377, 2, 11055);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (root_start_slot) {
				root_start_slot.m(li, null);
			}

			append_dev(li, t0);
			append_dev(li, div2);

			if (content_start_slot) {
				content_start_slot.m(div2, null);
			}

			append_dev(div2, t1);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t2);
			if (if_block1) if_block1.m(div2, null);
			append_dev(div2, t3);
			append_dev(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_dev(div1, t4);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div1, t5);
			append_dev(div1, div0);
			if (if_block3) if_block3.m(div0, null);
			append_dev(div0, t6);

			if (input_slot) {
				input_slot.m(div0, null);
			}

			append_dev(div0, t7);
			if (if_block4) if_block4.m(div0, null);
			append_dev(div0, t8);
			if (if_block5) if_block5.m(div0, null);
			append_dev(div0, t9);
			if (if_block6) if_block6.m(div0, null);
			append_dev(div1, t10);

			if (inner_slot) {
				inner_slot.m(div1, null);
			}

			append_dev(div1, t11);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_dev(div2, t12);

			if (content_slot) {
				content_slot.m(div2, null);
			}

			append_dev(div2, t13);

			if (content_end_slot) {
				content_end_slot.m(div2, null);
			}

			append_dev(li, t14);
			if (if_block7) if_block7.m(li, null);
			append_dev(li, t15);

			if (root_slot) {
				root_slot.m(li, null);
			}

			append_dev(li, t16);

			if (root_end_slot) {
				root_end_slot.m(li, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(root_start_slot, root_start_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_root_start_slot_changes$1, get_root_start_slot_context$1);
				}
			}

			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_content_start_slot_changes, get_content_start_slot_context);
				}
			}

			if (/*isSortable*/ ctx[39] && /*isSortableOpposite*/ ctx[40]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_12(ctx);
					if_block0.c();
					if_block0.m(div2, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[44]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*media*/ 1 | dirty[1] & /*hasMediaSlots*/ 8192) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_10(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div2, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_inner_start_slot_changes, get_inner_start_slot_context);
				}
			}

			if (typeof /*label*/ ctx[36] !== "undefined" || /*hasLabelSlots*/ ctx[45]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*label, hasLabelSlots*/ 16416) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_9(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t5);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*input*/ ctx[2]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*input*/ 4) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_5(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div0, t6);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (input_slot) {
				if (input_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(input_slot, input_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_input_slot_changes, get_input_slot_context);
				}
			}

			if (/*hasErrorMessage*/ ctx[46] && /*errorMessageForce*/ ctx[34]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 32776) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_4$1(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div0, t8);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*clearButton*/ ctx[32]) {
				if (if_block5) ; else {
					if_block5 = create_if_block_3$2(ctx);
					if_block5.c();
					if_block5.m(div0, t9);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (typeof /*info*/ ctx[35] !== "undefined" || /*hasInfoSlots*/ ctx[43]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*info, hasInfoSlots*/ 4112) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_2$2(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(div0, null);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (!current || dirty[1] & /*inputWrapClasses*/ 524288) {
				attr_dev(div0, "class", /*inputWrapClasses*/ ctx[50]);
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_inner_slot_changes, get_inner_slot_context);
				}
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_inner_end_slot_changes, get_inner_end_slot_context);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_content_slot_changes, get_content_slot_context);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_content_end_slot_changes, get_content_end_slot_context);
				}
			}

			if (!current || dirty[1] & /*itemContentClasses*/ 131072) {
				attr_dev(div2, "class", /*itemContentClasses*/ ctx[48]);
			}

			if (/*isSortable*/ ctx[39] && !/*isSortableOpposite*/ ctx[40]) {
				if (if_block7) ; else {
					if_block7 = create_if_block_1$2(ctx);
					if_block7.c();
					if_block7.m(li, t15);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (root_slot) {
				if (root_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(root_slot, root_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_root_slot_changes$1, get_root_slot_context$1);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(root_end_slot, root_end_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_root_end_slot_changes$1, get_root_end_slot_context$1);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*classes*/ 1048576) && { class: /*classes*/ ctx[51] },
				dirty[1] & /*$$restProps*/ 33554432 && restProps(/*$$restProps*/ ctx[56])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(input_slot, local);
			transition_in(if_block4);
			transition_in(if_block6);
			transition_in(inner_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(root_start_slot, local);
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(input_slot, local);
			transition_out(if_block4);
			transition_out(if_block6);
			transition_out(inner_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (root_start_slot) root_start_slot.d(detaching);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (input_slot) input_slot.d(detaching);
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (inner_slot) inner_slot.d(detaching);
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			if (if_block7) if_block7.d();
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(377:0) {#if wrap}",
		ctx
	});

	return block;
}

// (565:4) {#if isSortable && isSortableOpposite}
function create_if_block_23(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$9, 565, 6, 18275);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_23.name,
		type: "if",
		source: "(565:4) {#if isSortable && isSortableOpposite}",
		ctx
	});

	return block;
}

// (569:4) {#if (media || hasMediaSlots)}
function create_if_block_21(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[0] !== "undefined" && create_if_block_22(ctx);
	const media_slot_template = /*$$slots*/ ctx[73].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[72], get_media_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$9, 569, 6, 18360);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[0] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_22(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_media_slot_changes_1, get_media_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_21.name,
		type: "if",
		source: "(569:4) {#if (media || hasMediaSlots)}",
		ctx
	});

	return block;
}

// (571:8) {#if typeof media !== 'undefined'}
function create_if_block_22(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[0])) attr_dev(img, "src", img_src_value);
			add_location(img, file$9, 571, 10, 18438);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 1 && img.src !== (img_src_value = /*media*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_22.name,
		type: "if",
		source: "(571:8) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (579:6) {#if (typeof label !== 'undefined' || hasLabelSlots)}
function create_if_block_20(ctx) {
	let div;
	let t0_value = Utils$1.text(/*label*/ ctx[36]) + "";
	let t0;
	let t1;
	let current;
	const label_slot_template = /*$$slots*/ ctx[73].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[72], get_label_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (label_slot) label_slot.c();
			attr_dev(div, "class", /*labelClasses*/ ctx[49]);
			add_location(div, file$9, 579, 8, 18654);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (label_slot) {
				label_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*label*/ 32) && t0_value !== (t0_value = Utils$1.text(/*label*/ ctx[36]) + "")) set_data_dev(t0, t0_value);

			if (label_slot) {
				if (label_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_label_slot_changes_1, get_label_slot_context_1);
				}
			}

			if (!current || dirty[1] & /*labelClasses*/ 262144) {
				attr_dev(div, "class", /*labelClasses*/ ctx[49]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (label_slot) label_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_20.name,
		type: "if",
		source: "(579:6) {#if (typeof label !== 'undefined' || hasLabelSlots)}",
		ctx
	});

	return block;
}

// (586:8) {#if input}
function create_if_block_16(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block_17,
		create_if_block_18,
		create_if_block_19,
		create_else_block_2
	];

	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*type*/ ctx[3] === "select") return 0;
		if (/*type*/ ctx[3] === "textarea") return 1;
		if (/*type*/ ctx[3] === "texteditor") return 2;
		return 3;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_16.name,
		type: "if",
		source: "(586:8) {#if input}",
		ctx
	});

	return block;
}

// (675:10) {:else}
function create_else_block_2(ctx) {
	let input_1;
	let input_1_validate_value;
	let input_1_data_validate_value;
	let input_1_data_validate_on_blur_value;
	let input_1_data_error_message_value;
	let input_1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input_1 = element("input");
			attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
			attr_dev(input_1, "name", /*name*/ ctx[4]);
			attr_dev(input_1, "type", /*inputType*/ ctx[41]);
			attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(input_1, "id", /*inputId*/ ctx[11]);
			attr_dev(input_1, "size", /*size*/ ctx[12]);
			attr_dev(input_1, "accept", /*accept*/ ctx[13]);
			attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
			input_1.autofocus = /*autofocus*/ ctx[18];
			attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
			input_1.disabled = /*disabled*/ ctx[9];
			attr_dev(input_1, "max", /*max*/ ctx[20]);
			attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(input_1, "min", /*min*/ ctx[21]);
			attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
			attr_dev(input_1, "step", /*step*/ ctx[22]);
			input_1.multiple = /*multiple*/ ctx[25];
			input_1.readOnly = /*readonly*/ ctx[7];
			input_1.required = /*required*/ ctx[8];
			attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);

			attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(input_1, "class", /*inputClasses*/ ctx[47]);

			input_1.value = input_1_value_value = /*type*/ ctx[3] === "datepicker" || /*type*/ ctx[3] === "colorpicker" || /*type*/ ctx[3] === "file"
			? ""
			: /*inputValue*/ ctx[42];

			add_location(input_1, file$9, 675, 12, 22353);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			/*input_1_binding_1*/ ctx[79](input_1);

			if (!mounted) {
				dispose = [
					listen_dev(input_1, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(input_1, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(input_1, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(input_1, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
			}

			if (dirty[0] & /*name*/ 16) {
				attr_dev(input_1, "name", /*name*/ ctx[4]);
			}

			if (dirty[1] & /*inputType*/ 1024) {
				attr_dev(input_1, "type", /*inputType*/ ctx[41]);
			}

			if (dirty[0] & /*inputmode*/ 64) {
				attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
			}

			if (dirty[0] & /*placeholder*/ 1024) {
				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (dirty[0] & /*inputId*/ 2048) {
				attr_dev(input_1, "id", /*inputId*/ ctx[11]);
			}

			if (dirty[0] & /*size*/ 4096) {
				attr_dev(input_1, "size", /*size*/ ctx[12]);
			}

			if (dirty[0] & /*accept*/ 8192) {
				attr_dev(input_1, "accept", /*accept*/ ctx[13]);
			}

			if (dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (dirty[0] & /*autofocus*/ 262144) {
				prop_dev(input_1, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (dirty[0] & /*autosave*/ 524288) {
				attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
			}

			if (dirty[0] & /*disabled*/ 512) {
				prop_dev(input_1, "disabled", /*disabled*/ ctx[9]);
			}

			if (dirty[0] & /*max*/ 1048576) {
				attr_dev(input_1, "max", /*max*/ ctx[20]);
			}

			if (dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (dirty[0] & /*min*/ 2097152) {
				attr_dev(input_1, "min", /*min*/ ctx[21]);
			}

			if (dirty[0] & /*minlength*/ 16777216) {
				attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
			}

			if (dirty[0] & /*step*/ 4194304) {
				attr_dev(input_1, "step", /*step*/ ctx[22]);
			}

			if (dirty[0] & /*multiple*/ 33554432) {
				prop_dev(input_1, "multiple", /*multiple*/ ctx[25]);
			}

			if (dirty[0] & /*readonly*/ 128) {
				prop_dev(input_1, "readOnly", /*readonly*/ ctx[7]);
			}

			if (dirty[0] & /*required*/ 256) {
				prop_dev(input_1, "required", /*required*/ ctx[8]);
			}

			if (dirty[0] & /*pattern*/ 134217728) {
				attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);
			}

			if (dirty[0] & /*validate*/ 268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(input_1, "validate", input_1_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(input_1, "data-validate", input_1_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(input_1, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[0] & /*type*/ 8 | dirty[1] & /*inputValue*/ 2048 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[3] === "datepicker" || /*type*/ ctx[3] === "colorpicker" || /*type*/ ctx[3] === "file"
			? ""
			: /*inputValue*/ ctx[42]) && input_1.value !== input_1_value_value) {
				prop_dev(input_1, "value", input_1_value_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			/*input_1_binding_1*/ ctx[79](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(675:10) {:else}",
		ctx
	});

	return block;
}

// (664:42) 
function create_if_block_19(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[5] === "undefined"
			? ""
			: /*value*/ ctx[5]
		},
		{ resizable: /*resizable*/ ctx[31] },
		{ placeholder: /*placeholder*/ ctx[10] },
		/*textEditorParams*/ ctx[37]
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });
	texteditor.$on("textEditorFocus", /*onFocus*/ ctx[53]);
	texteditor.$on("textEditorBlur", /*onBlur*/ ctx[54]);
	texteditor.$on("textEditorInput", /*onInput*/ ctx[52]);
	texteditor.$on("textEditorChange", /*onChange*/ ctx[55]);

	const block = {
		c: function create() {
			create_component(texteditor.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, placeholder*/ 1056 | dirty[1] & /*resizable, textEditorParams*/ 65)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 32 && {
						value: typeof /*value*/ ctx[5] === "undefined"
						? ""
						: /*value*/ ctx[5]
					},
					dirty[1] & /*resizable*/ 1 && { resizable: /*resizable*/ ctx[31] },
					dirty[0] & /*placeholder*/ 1024 && { placeholder: /*placeholder*/ ctx[10] },
					dirty[1] & /*textEditorParams*/ 64 && get_spread_object(/*textEditorParams*/ ctx[37])
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(texteditor, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_19.name,
		type: "if",
		source: "(664:42) ",
		ctx
	});

	return block;
}

// (626:40) 
function create_if_block_18(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
			attr_dev(textarea, "name", /*name*/ ctx[4]);
			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(textarea, "id", /*inputId*/ ctx[11]);
			attr_dev(textarea, "size", /*size*/ ctx[12]);
			attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
			attr_dev(textarea, "accept", /*accept*/ ctx[13]);
			attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
			textarea.autofocus = /*autofocus*/ ctx[18];
			attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
			textarea.disabled = /*disabled*/ ctx[9];
			attr_dev(textarea, "max", /*max*/ ctx[20]);
			attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(textarea, "min", /*min*/ ctx[21]);
			attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
			attr_dev(textarea, "step", /*step*/ ctx[22]);
			attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
			textarea.readOnly = /*readonly*/ ctx[7];
			textarea.required = /*required*/ ctx[8];
			attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);

			attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(textarea, "class", /*inputClasses*/ ctx[47]);
			textarea.value = /*inputValue*/ ctx[42];
			add_location(textarea, file$9, 626, 12, 20412);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			/*textarea_binding_1*/ ctx[78](textarea);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(textarea, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(textarea, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(textarea, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
			}

			if (dirty[0] & /*name*/ 16) {
				attr_dev(textarea, "name", /*name*/ ctx[4]);
			}

			if (dirty[0] & /*placeholder*/ 1024) {
				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (dirty[0] & /*inputId*/ 2048) {
				attr_dev(textarea, "id", /*inputId*/ ctx[11]);
			}

			if (dirty[0] & /*size*/ 4096) {
				attr_dev(textarea, "size", /*size*/ ctx[12]);
			}

			if (dirty[0] & /*inputmode*/ 64) {
				attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
			}

			if (dirty[0] & /*accept*/ 8192) {
				attr_dev(textarea, "accept", /*accept*/ ctx[13]);
			}

			if (dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (dirty[0] & /*autofocus*/ 262144) {
				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (dirty[0] & /*autosave*/ 524288) {
				attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
			}

			if (dirty[0] & /*disabled*/ 512) {
				prop_dev(textarea, "disabled", /*disabled*/ ctx[9]);
			}

			if (dirty[0] & /*max*/ 1048576) {
				attr_dev(textarea, "max", /*max*/ ctx[20]);
			}

			if (dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (dirty[0] & /*min*/ 2097152) {
				attr_dev(textarea, "min", /*min*/ ctx[21]);
			}

			if (dirty[0] & /*minlength*/ 16777216) {
				attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
			}

			if (dirty[0] & /*step*/ 4194304) {
				attr_dev(textarea, "step", /*step*/ ctx[22]);
			}

			if (dirty[0] & /*multiple*/ 33554432) {
				attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
			}

			if (dirty[0] & /*readonly*/ 128) {
				prop_dev(textarea, "readOnly", /*readonly*/ ctx[7]);
			}

			if (dirty[0] & /*required*/ 256) {
				prop_dev(textarea, "required", /*required*/ ctx[8]);
			}

			if (dirty[0] & /*pattern*/ 134217728) {
				attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);
			}

			if (dirty[0] & /*validate*/ 268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(textarea, "validate", textarea_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate", textarea_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(textarea, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[1] & /*inputValue*/ 2048) {
				prop_dev(textarea, "value", /*inputValue*/ ctx[42]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			/*textarea_binding_1*/ ctx[78](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_18.name,
		type: "if",
		source: "(626:40) ",
		ctx
	});

	return block;
}

// (587:10) {#if type === 'select'}
function create_if_block_17(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[73].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[72], null);

	const block = {
		c: function create() {
			select = element("select");
			if (default_slot) default_slot.c();
			attr_dev(select, "style", /*inputStyle*/ ctx[26]);
			attr_dev(select, "name", /*name*/ ctx[4]);
			attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(select, "id", /*inputId*/ ctx[11]);
			attr_dev(select, "size", /*size*/ ctx[12]);
			attr_dev(select, "accept", /*accept*/ ctx[13]);
			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
			select.autofocus = /*autofocus*/ ctx[18];
			attr_dev(select, "autosave", /*autosave*/ ctx[19]);
			select.disabled = /*disabled*/ ctx[9];
			attr_dev(select, "max", /*max*/ ctx[20]);
			attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(select, "min", /*min*/ ctx[21]);
			attr_dev(select, "minlength", /*minlength*/ ctx[24]);
			attr_dev(select, "step", /*step*/ ctx[22]);
			select.multiple = /*multiple*/ ctx[25];
			attr_dev(select, "readonly", /*readonly*/ ctx[7]);
			select.required = /*required*/ ctx[8];
			attr_dev(select, "pattern", /*pattern*/ ctx[27]);

			attr_dev(select, "validate", select_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(select, "data-validate", select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(select, "class", /*inputClasses*/ ctx[47]);
			add_location(select, file$9, 587, 12, 18872);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*inputValue*/ ctx[42]);
			/*select_binding_1*/ ctx[77](select);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(select, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(select, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(select, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[72], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(select, "style", /*inputStyle*/ ctx[26]);
			}

			if (!current || dirty[0] & /*name*/ 16) {
				attr_dev(select, "name", /*name*/ ctx[4]);
			}

			if (!current || dirty[0] & /*placeholder*/ 1024) {
				attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (!current || dirty[0] & /*inputId*/ 2048) {
				attr_dev(select, "id", /*inputId*/ ctx[11]);
			}

			if (!current || dirty[0] & /*size*/ 4096) {
				attr_dev(select, "size", /*size*/ ctx[12]);
			}

			if (!current || dirty[0] & /*accept*/ 8192) {
				attr_dev(select, "accept", /*accept*/ ctx[13]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (!current || dirty[0] & /*autofocus*/ 262144) {
				prop_dev(select, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (!current || dirty[0] & /*autosave*/ 524288) {
				attr_dev(select, "autosave", /*autosave*/ ctx[19]);
			}

			if (!current || dirty[0] & /*disabled*/ 512) {
				prop_dev(select, "disabled", /*disabled*/ ctx[9]);
			}

			if (!current || dirty[0] & /*max*/ 1048576) {
				attr_dev(select, "max", /*max*/ ctx[20]);
			}

			if (!current || dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (!current || dirty[0] & /*min*/ 2097152) {
				attr_dev(select, "min", /*min*/ ctx[21]);
			}

			if (!current || dirty[0] & /*minlength*/ 16777216) {
				attr_dev(select, "minlength", /*minlength*/ ctx[24]);
			}

			if (!current || dirty[0] & /*step*/ 4194304) {
				attr_dev(select, "step", /*step*/ ctx[22]);
			}

			if (!current || dirty[0] & /*multiple*/ 33554432) {
				prop_dev(select, "multiple", /*multiple*/ ctx[25]);
			}

			if (!current || dirty[0] & /*readonly*/ 128) {
				attr_dev(select, "readonly", /*readonly*/ ctx[7]);
			}

			if (!current || dirty[0] & /*required*/ 256) {
				prop_dev(select, "required", /*required*/ ctx[8]);
			}

			if (!current || dirty[0] & /*pattern*/ 134217728) {
				attr_dev(select, "pattern", /*pattern*/ ctx[27]);
			}

			if (!current || dirty[0] & /*validate*/ 268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(select, "validate", select_validate_value);
			}

			if (!current || dirty[0] & /*validate, validateOnBlur*/ 805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate", select_data_validate_value);
			}

			if (!current || dirty[0] & /*validateOnBlur*/ 536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
			}

			if (!current || dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(select, "data-error-message", select_data_error_message_value);
			}

			if (!current || dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(select, "class", /*inputClasses*/ ctx[47]);
			}

			if (!current || dirty[1] & /*inputValue*/ 2048) {
				select_option(select, /*inputValue*/ ctx[42]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding_1*/ ctx[77](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_17.name,
		type: "if",
		source: "(587:10) {#if type === 'select'}",
		ctx
	});

	return block;
}

// (717:8) {#if hasErrorMessage && errorMessageForce}
function create_if_block_15(ctx) {
	let div;
	let t0_value = Utils$1.text(/*errorMessage*/ ctx[33]) + "";
	let t0;
	let t1;
	let current;
	const error_message_slot_template = /*$$slots*/ ctx[73]["error-message"];
	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[72], get_error_message_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (error_message_slot) error_message_slot.c();
			attr_dev(div, "class", "item-input-error-message");
			add_location(div, file$9, 717, 10, 24057);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (error_message_slot) {
				error_message_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*errorMessage*/ 4) && t0_value !== (t0_value = Utils$1.text(/*errorMessage*/ ctx[33]) + "")) set_data_dev(t0, t0_value);

			if (error_message_slot) {
				if (error_message_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(error_message_slot, error_message_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_error_message_slot_changes_1, get_error_message_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error_message_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error_message_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (error_message_slot) error_message_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_15.name,
		type: "if",
		source: "(717:8) {#if hasErrorMessage && errorMessageForce}",
		ctx
	});

	return block;
}

// (723:8) {#if clearButton}
function create_if_block_14(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "input-clear-button");
			add_location(span, file$9, 723, 10, 24243);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_14.name,
		type: "if",
		source: "(723:8) {#if clearButton}",
		ctx
	});

	return block;
}

// (726:8) {#if (typeof info !== 'undefined' || hasInfoSlots)}
function create_if_block_13(ctx) {
	let div;
	let t0_value = Utils$1.text(/*info*/ ctx[35]) + "";
	let t0;
	let t1;
	let current;
	const info_slot_template = /*$$slots*/ ctx[73].info;
	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[72], get_info_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (info_slot) info_slot.c();
			attr_dev(div, "class", "item-input-info");
			add_location(div, file$9, 726, 10, 24363);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (info_slot) {
				info_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*info*/ 16) && t0_value !== (t0_value = Utils$1.text(/*info*/ ctx[35]) + "")) set_data_dev(t0, t0_value);

			if (info_slot) {
				if (info_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(info_slot, info_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_info_slot_changes_1, get_info_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(info_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(info_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (info_slot) info_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13.name,
		type: "if",
		source: "(726:8) {#if (typeof info !== 'undefined' || hasInfoSlots)}",
		ctx
	});

	return block;
}

// (382:6) {#if isSortable && isSortableOpposite}
function create_if_block_12(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$9, 382, 8, 11261);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12.name,
		type: "if",
		source: "(382:6) {#if isSortable && isSortableOpposite}",
		ctx
	});

	return block;
}

// (386:6) {#if (media || hasMediaSlots)}
function create_if_block_10(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[0] !== "undefined" && create_if_block_11(ctx);
	const media_slot_template = /*$$slots*/ ctx[73].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[72], get_media_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$9, 386, 8, 11352);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[0] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_11(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_media_slot_changes, get_media_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(386:6) {#if (media || hasMediaSlots)}",
		ctx
	});

	return block;
}

// (388:10) {#if typeof media !== 'undefined'}
function create_if_block_11(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[0])) attr_dev(img, "src", img_src_value);
			add_location(img, file$9, 388, 12, 11434);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 1 && img.src !== (img_src_value = /*media*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(388:10) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (396:8) {#if (typeof label !== 'undefined' || hasLabelSlots)}
function create_if_block_9(ctx) {
	let div;
	let t0_value = Utils$1.text(/*label*/ ctx[36]) + "";
	let t0;
	let t1;
	let current;
	const label_slot_template = /*$$slots*/ ctx[73].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[72], get_label_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (label_slot) label_slot.c();
			attr_dev(div, "class", /*labelClasses*/ ctx[49]);
			add_location(div, file$9, 396, 10, 11666);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (label_slot) {
				label_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*label*/ 32) && t0_value !== (t0_value = Utils$1.text(/*label*/ ctx[36]) + "")) set_data_dev(t0, t0_value);

			if (label_slot) {
				if (label_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_label_slot_changes, get_label_slot_context);
				}
			}

			if (!current || dirty[1] & /*labelClasses*/ 262144) {
				attr_dev(div, "class", /*labelClasses*/ ctx[49]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (label_slot) label_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(396:8) {#if (typeof label !== 'undefined' || hasLabelSlots)}",
		ctx
	});

	return block;
}

// (403:10) {#if input}
function create_if_block_5(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_6, create_if_block_7, create_if_block_8, create_else_block$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[3] === "select") return 0;
		if (/*type*/ ctx[3] === "textarea") return 1;
		if (/*type*/ ctx[3] === "texteditor") return 2;
		return 3;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(403:10) {#if input}",
		ctx
	});

	return block;
}

// (492:12) {:else}
function create_else_block$1(ctx) {
	let input_1;
	let input_1_validate_value;
	let input_1_data_validate_value;
	let input_1_data_validate_on_blur_value;
	let input_1_data_error_message_value;
	let input_1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input_1 = element("input");
			attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
			attr_dev(input_1, "name", /*name*/ ctx[4]);
			attr_dev(input_1, "type", /*inputType*/ ctx[41]);
			attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(input_1, "id", /*inputId*/ ctx[11]);
			attr_dev(input_1, "size", /*size*/ ctx[12]);
			attr_dev(input_1, "accept", /*accept*/ ctx[13]);
			attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
			input_1.autofocus = /*autofocus*/ ctx[18];
			attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
			input_1.disabled = /*disabled*/ ctx[9];
			attr_dev(input_1, "max", /*max*/ ctx[20]);
			attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(input_1, "min", /*min*/ ctx[21]);
			attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
			attr_dev(input_1, "step", /*step*/ ctx[22]);
			input_1.multiple = /*multiple*/ ctx[25];
			input_1.readOnly = /*readonly*/ ctx[7];
			input_1.required = /*required*/ ctx[8];
			attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);

			attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(input_1, "class", /*inputClasses*/ ctx[47]);

			input_1.value = input_1_value_value = /*type*/ ctx[3] === "datepicker" || /*type*/ ctx[3] === "colorpicker" || /*type*/ ctx[3] === "file"
			? ""
			: /*inputValue*/ ctx[42];

			add_location(input_1, file$9, 492, 14, 15557);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			/*input_1_binding*/ ctx[76](input_1);

			if (!mounted) {
				dispose = [
					listen_dev(input_1, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(input_1, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(input_1, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(input_1, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
			}

			if (dirty[0] & /*name*/ 16) {
				attr_dev(input_1, "name", /*name*/ ctx[4]);
			}

			if (dirty[1] & /*inputType*/ 1024) {
				attr_dev(input_1, "type", /*inputType*/ ctx[41]);
			}

			if (dirty[0] & /*inputmode*/ 64) {
				attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
			}

			if (dirty[0] & /*placeholder*/ 1024) {
				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (dirty[0] & /*inputId*/ 2048) {
				attr_dev(input_1, "id", /*inputId*/ ctx[11]);
			}

			if (dirty[0] & /*size*/ 4096) {
				attr_dev(input_1, "size", /*size*/ ctx[12]);
			}

			if (dirty[0] & /*accept*/ 8192) {
				attr_dev(input_1, "accept", /*accept*/ ctx[13]);
			}

			if (dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (dirty[0] & /*autofocus*/ 262144) {
				prop_dev(input_1, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (dirty[0] & /*autosave*/ 524288) {
				attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
			}

			if (dirty[0] & /*disabled*/ 512) {
				prop_dev(input_1, "disabled", /*disabled*/ ctx[9]);
			}

			if (dirty[0] & /*max*/ 1048576) {
				attr_dev(input_1, "max", /*max*/ ctx[20]);
			}

			if (dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (dirty[0] & /*min*/ 2097152) {
				attr_dev(input_1, "min", /*min*/ ctx[21]);
			}

			if (dirty[0] & /*minlength*/ 16777216) {
				attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
			}

			if (dirty[0] & /*step*/ 4194304) {
				attr_dev(input_1, "step", /*step*/ ctx[22]);
			}

			if (dirty[0] & /*multiple*/ 33554432) {
				prop_dev(input_1, "multiple", /*multiple*/ ctx[25]);
			}

			if (dirty[0] & /*readonly*/ 128) {
				prop_dev(input_1, "readOnly", /*readonly*/ ctx[7]);
			}

			if (dirty[0] & /*required*/ 256) {
				prop_dev(input_1, "required", /*required*/ ctx[8]);
			}

			if (dirty[0] & /*pattern*/ 134217728) {
				attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);
			}

			if (dirty[0] & /*validate*/ 268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(input_1, "validate", input_1_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(input_1, "data-validate", input_1_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(input_1, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[0] & /*type*/ 8 | dirty[1] & /*inputValue*/ 2048 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[3] === "datepicker" || /*type*/ ctx[3] === "colorpicker" || /*type*/ ctx[3] === "file"
			? ""
			: /*inputValue*/ ctx[42]) && input_1.value !== input_1_value_value) {
				prop_dev(input_1, "value", input_1_value_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			/*input_1_binding*/ ctx[76](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(492:12) {:else}",
		ctx
	});

	return block;
}

// (481:44) 
function create_if_block_8(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[5] === "undefined"
			? ""
			: /*value*/ ctx[5]
		},
		{ resizable: /*resizable*/ ctx[31] },
		{ placeholder: /*placeholder*/ ctx[10] },
		/*textEditorParams*/ ctx[37]
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });
	texteditor.$on("textEditorFocus", /*onFocus*/ ctx[53]);
	texteditor.$on("textEditorBlur", /*onBlur*/ ctx[54]);
	texteditor.$on("textEditorInput", /*onInput*/ ctx[52]);
	texteditor.$on("textEditorChange", /*onChange*/ ctx[55]);

	const block = {
		c: function create() {
			create_component(texteditor.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, placeholder*/ 1056 | dirty[1] & /*resizable, textEditorParams*/ 65)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 32 && {
						value: typeof /*value*/ ctx[5] === "undefined"
						? ""
						: /*value*/ ctx[5]
					},
					dirty[1] & /*resizable*/ 1 && { resizable: /*resizable*/ ctx[31] },
					dirty[0] & /*placeholder*/ 1024 && { placeholder: /*placeholder*/ ctx[10] },
					dirty[1] & /*textEditorParams*/ 64 && get_spread_object(/*textEditorParams*/ ctx[37])
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(texteditor, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(481:44) ",
		ctx
	});

	return block;
}

// (443:42) 
function create_if_block_7(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
			attr_dev(textarea, "name", /*name*/ ctx[4]);
			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(textarea, "id", /*inputId*/ ctx[11]);
			attr_dev(textarea, "size", /*size*/ ctx[12]);
			attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
			attr_dev(textarea, "accept", /*accept*/ ctx[13]);
			attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
			textarea.autofocus = /*autofocus*/ ctx[18];
			attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
			textarea.disabled = /*disabled*/ ctx[9];
			attr_dev(textarea, "max", /*max*/ ctx[20]);
			attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(textarea, "min", /*min*/ ctx[21]);
			attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
			attr_dev(textarea, "step", /*step*/ ctx[22]);
			attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
			textarea.readOnly = /*readonly*/ ctx[7];
			textarea.required = /*required*/ ctx[8];
			attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);

			attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(textarea, "class", /*inputClasses*/ ctx[47]);
			textarea.value = /*inputValue*/ ctx[42];
			add_location(textarea, file$9, 443, 14, 13518);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			/*textarea_binding*/ ctx[75](textarea);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(textarea, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(textarea, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(textarea, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
			}

			if (dirty[0] & /*name*/ 16) {
				attr_dev(textarea, "name", /*name*/ ctx[4]);
			}

			if (dirty[0] & /*placeholder*/ 1024) {
				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (dirty[0] & /*inputId*/ 2048) {
				attr_dev(textarea, "id", /*inputId*/ ctx[11]);
			}

			if (dirty[0] & /*size*/ 4096) {
				attr_dev(textarea, "size", /*size*/ ctx[12]);
			}

			if (dirty[0] & /*inputmode*/ 64) {
				attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
			}

			if (dirty[0] & /*accept*/ 8192) {
				attr_dev(textarea, "accept", /*accept*/ ctx[13]);
			}

			if (dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (dirty[0] & /*autofocus*/ 262144) {
				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (dirty[0] & /*autosave*/ 524288) {
				attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
			}

			if (dirty[0] & /*disabled*/ 512) {
				prop_dev(textarea, "disabled", /*disabled*/ ctx[9]);
			}

			if (dirty[0] & /*max*/ 1048576) {
				attr_dev(textarea, "max", /*max*/ ctx[20]);
			}

			if (dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (dirty[0] & /*min*/ 2097152) {
				attr_dev(textarea, "min", /*min*/ ctx[21]);
			}

			if (dirty[0] & /*minlength*/ 16777216) {
				attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
			}

			if (dirty[0] & /*step*/ 4194304) {
				attr_dev(textarea, "step", /*step*/ ctx[22]);
			}

			if (dirty[0] & /*multiple*/ 33554432) {
				attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
			}

			if (dirty[0] & /*readonly*/ 128) {
				prop_dev(textarea, "readOnly", /*readonly*/ ctx[7]);
			}

			if (dirty[0] & /*required*/ 256) {
				prop_dev(textarea, "required", /*required*/ ctx[8]);
			}

			if (dirty[0] & /*pattern*/ 134217728) {
				attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);
			}

			if (dirty[0] & /*validate*/ 268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(textarea, "validate", textarea_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate", textarea_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(textarea, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[1] & /*inputValue*/ 2048) {
				prop_dev(textarea, "value", /*inputValue*/ ctx[42]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			/*textarea_binding*/ ctx[75](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(443:42) ",
		ctx
	});

	return block;
}

// (404:12) {#if type === 'select'}
function create_if_block_6(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[73].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[72], null);

	const block = {
		c: function create() {
			select = element("select");
			if (default_slot) default_slot.c();
			attr_dev(select, "style", /*inputStyle*/ ctx[26]);
			attr_dev(select, "name", /*name*/ ctx[4]);
			attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(select, "id", /*inputId*/ ctx[11]);
			attr_dev(select, "size", /*size*/ ctx[12]);
			attr_dev(select, "accept", /*accept*/ ctx[13]);
			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
			select.autofocus = /*autofocus*/ ctx[18];
			attr_dev(select, "autosave", /*autosave*/ ctx[19]);
			select.disabled = /*disabled*/ ctx[9];
			attr_dev(select, "max", /*max*/ ctx[20]);
			attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(select, "min", /*min*/ ctx[21]);
			attr_dev(select, "minlength", /*minlength*/ ctx[24]);
			attr_dev(select, "step", /*step*/ ctx[22]);
			select.multiple = /*multiple*/ ctx[25];
			attr_dev(select, "readonly", /*readonly*/ ctx[7]);
			select.required = /*required*/ ctx[8];
			attr_dev(select, "pattern", /*pattern*/ ctx[27]);

			attr_dev(select, "validate", select_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(select, "data-validate", select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(select, "class", /*inputClasses*/ ctx[47]);
			add_location(select, file$9, 404, 14, 11900);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*inputValue*/ ctx[42]);
			/*select_binding*/ ctx[74](select);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(select, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(select, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(select, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[72], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(select, "style", /*inputStyle*/ ctx[26]);
			}

			if (!current || dirty[0] & /*name*/ 16) {
				attr_dev(select, "name", /*name*/ ctx[4]);
			}

			if (!current || dirty[0] & /*placeholder*/ 1024) {
				attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (!current || dirty[0] & /*inputId*/ 2048) {
				attr_dev(select, "id", /*inputId*/ ctx[11]);
			}

			if (!current || dirty[0] & /*size*/ 4096) {
				attr_dev(select, "size", /*size*/ ctx[12]);
			}

			if (!current || dirty[0] & /*accept*/ 8192) {
				attr_dev(select, "accept", /*accept*/ ctx[13]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (!current || dirty[0] & /*autofocus*/ 262144) {
				prop_dev(select, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (!current || dirty[0] & /*autosave*/ 524288) {
				attr_dev(select, "autosave", /*autosave*/ ctx[19]);
			}

			if (!current || dirty[0] & /*disabled*/ 512) {
				prop_dev(select, "disabled", /*disabled*/ ctx[9]);
			}

			if (!current || dirty[0] & /*max*/ 1048576) {
				attr_dev(select, "max", /*max*/ ctx[20]);
			}

			if (!current || dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (!current || dirty[0] & /*min*/ 2097152) {
				attr_dev(select, "min", /*min*/ ctx[21]);
			}

			if (!current || dirty[0] & /*minlength*/ 16777216) {
				attr_dev(select, "minlength", /*minlength*/ ctx[24]);
			}

			if (!current || dirty[0] & /*step*/ 4194304) {
				attr_dev(select, "step", /*step*/ ctx[22]);
			}

			if (!current || dirty[0] & /*multiple*/ 33554432) {
				prop_dev(select, "multiple", /*multiple*/ ctx[25]);
			}

			if (!current || dirty[0] & /*readonly*/ 128) {
				attr_dev(select, "readonly", /*readonly*/ ctx[7]);
			}

			if (!current || dirty[0] & /*required*/ 256) {
				prop_dev(select, "required", /*required*/ ctx[8]);
			}

			if (!current || dirty[0] & /*pattern*/ 134217728) {
				attr_dev(select, "pattern", /*pattern*/ ctx[27]);
			}

			if (!current || dirty[0] & /*validate*/ 268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(select, "validate", select_validate_value);
			}

			if (!current || dirty[0] & /*validate, validateOnBlur*/ 805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate", select_data_validate_value);
			}

			if (!current || dirty[0] & /*validateOnBlur*/ 536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
			}

			if (!current || dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(select, "data-error-message", select_data_error_message_value);
			}

			if (!current || dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(select, "class", /*inputClasses*/ ctx[47]);
			}

			if (!current || dirty[1] & /*inputValue*/ 2048) {
				select_option(select, /*inputValue*/ ctx[42]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding*/ ctx[74](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(404:12) {#if type === 'select'}",
		ctx
	});

	return block;
}

// (534:10) {#if hasErrorMessage && errorMessageForce}
function create_if_block_4$1(ctx) {
	let div;
	let t0_value = Utils$1.text(/*errorMessage*/ ctx[33]) + "";
	let t0;
	let t1;
	let current;
	const error_message_slot_template = /*$$slots*/ ctx[73]["error-message"];
	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[72], get_error_message_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (error_message_slot) error_message_slot.c();
			attr_dev(div, "class", "item-input-error-message");
			add_location(div, file$9, 534, 12, 17345);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (error_message_slot) {
				error_message_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*errorMessage*/ 4) && t0_value !== (t0_value = Utils$1.text(/*errorMessage*/ ctx[33]) + "")) set_data_dev(t0, t0_value);

			if (error_message_slot) {
				if (error_message_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(error_message_slot, error_message_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_error_message_slot_changes, get_error_message_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error_message_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error_message_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (error_message_slot) error_message_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(534:10) {#if hasErrorMessage && errorMessageForce}",
		ctx
	});

	return block;
}

// (540:10) {#if clearButton}
function create_if_block_3$2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "input-clear-button");
			add_location(span, file$9, 540, 12, 17543);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(540:10) {#if clearButton}",
		ctx
	});

	return block;
}

// (543:10) {#if (typeof info !== 'undefined' || hasInfoSlots)}
function create_if_block_2$2(ctx) {
	let div;
	let t0_value = Utils$1.text(/*info*/ ctx[35]) + "";
	let t0;
	let t1;
	let current;
	const info_slot_template = /*$$slots*/ ctx[73].info;
	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[72], get_info_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (info_slot) info_slot.c();
			attr_dev(div, "class", "item-input-info");
			add_location(div, file$9, 543, 12, 17669);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (info_slot) {
				info_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*info*/ 16) && t0_value !== (t0_value = Utils$1.text(/*info*/ ctx[35]) + "")) set_data_dev(t0, t0_value);

			if (info_slot) {
				if (info_slot.p && dirty[2] & /*$$scope*/ 1024) {
					update_slot(info_slot, info_slot_template, ctx, /*$$scope*/ ctx[72], dirty, get_info_slot_changes, get_info_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(info_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(info_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (info_slot) info_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(543:10) {#if (typeof info !== 'undefined' || hasInfoSlots)}",
		ctx
	});

	return block;
}

// (556:4) {#if isSortable && !isSortableOpposite}
function create_if_block_1$2(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$9, 556, 6, 18016);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(556:4) {#if isSortable && !isSortableOpposite}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$2, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*wrap*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","sortable","sortableOpposite","media","dropdown","wrap","input","type","name","value","inputmode","readonly","required","disabled","placeholder","inputId","size","accept","autocomplete","autocorrect","autocapitalize","spellcheck","autofocus","autosave","max","min","step","maxlength","minlength","multiple","inputStyle","pattern","validate","validateOnBlur","onValidate","tabindex","resizable","clearButton","noFormStoreData","noStoreData","ignoreStoreData","errorMessage","errorMessageForce","info","outline","label","inlineLabel","floatingLabel","calendarParams","colorPickerParams","textEditorParams","calendarInstance","colorPickerInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { sortable = undefined } = $$props;
	let { sortableOpposite = undefined } = $$props;
	let { media = undefined } = $$props;
	let { dropdown = "auto" } = $$props;
	let { wrap = true } = $$props;
	let { input = true } = $$props;
	let { type = "text" } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { inputmode = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { inputId = undefined } = $$props;
	let { size = undefined } = $$props;
	let { accept = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { autofocus = undefined } = $$props;
	let { autosave = undefined } = $$props;
	let { max = undefined } = $$props;
	let { min = undefined } = $$props;
	let { step = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { inputStyle = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { validate = undefined } = $$props;
	let { validateOnBlur = undefined } = $$props;
	let { onValidate = undefined } = $$props;
	let { tabindex = undefined } = $$props;
	let { resizable = undefined } = $$props;
	let { clearButton = undefined } = $$props;
	let { noFormStoreData = undefined } = $$props;
	let { noStoreData = undefined } = $$props;
	let { ignoreStoreData = undefined } = $$props;
	let { errorMessage = undefined } = $$props;
	let { errorMessageForce = undefined } = $$props;
	let { info = undefined } = $$props;
	let { outline = undefined } = $$props;
	let { label = undefined } = $$props;
	let { inlineLabel = undefined } = $$props;
	let { floatingLabel = undefined } = $$props;
	let { calendarParams = undefined } = $$props;
	let { colorPickerParams = undefined } = $$props;
	let { textEditorParams = undefined } = $$props;

	// State
	let inputEl;

	let inputFocused = false;
	let inputInvalid = false;
	let updateInputOnDidUpdate = false;
	let f7Calendar;
	let f7ColorPicker;

	function calendarInstance() {
		return f7Calendar;
	}

	function colorPickerInstance() {
		return f7ColorPicker;
	}

	function domValue() {
		if (!inputEl) return undefined;
		return inputEl.value;
	}

	function inputHasValue() {
		if (type === "datepicker" && Array.isArray(value) && value.length === 0) {
			return false;
		}

		const domV = domValue();

		return typeof value === "undefined"
		? domV || domV === 0
		: value || value === 0;
	}

	function validateInput() {
		if (!f7.instance || !inputEl) return;
		const validity = inputEl.validity;
		if (!validity) return;

		if (!validity.valid) {
			if (onValidate) onValidate(false);

			if (inputInvalid !== true) {
				$$invalidate(81, inputInvalid = true);
			}
		} else if (inputInvalid !== false) {
			if (onValidate) onValidate(true);
			$$invalidate(81, inputInvalid = false);
		}
	}

	let initialWatched = false;

	function watchValue() {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (type === "range" || type === "toggle") return;
		if (!f7.instance) return;
		updateInputOnDidUpdate = true;

		if (f7Calendar) {
			f7Calendar.setValue(value);
		}

		if (f7ColorPicker) {
			f7ColorPicker.setValue(value);
		}
	}

	function watchColorPickerParams() {
		if (!f7.instance || !f7ColorPicker) return;
		Utils$1.extend(f7ColorPicker.params, colorPickerParams || {});
	}

	function watchCalendarParams() {
		if (!f7.instance || !f7Calendar) return;
		Utils$1.extend(f7Calendar.params, calendarParams || {});
	}

	function onTextareaResize(event) {
		dispatch("textareaResize", [event]);
		if (typeof $$props.onTextareaResize === "function") $$props.onTextareaResize(event);
	}

	function onInputNotEmpty(event) {
		dispatch("inputNotEmpty", [event]);
		if (typeof $$props.onInputNotEmpty === "function") $$props.onInputNotEmpty(event);
	}

	function onInputEmpty(event) {
		dispatch("inputEmpty", [event]);
		if (typeof $$props.onInputEmpty === "function") $$props.onInputEmpty(event);
	}

	function onInputClear(event) {
		dispatch("inputClear", [event]);
		if (typeof $$props.onInputClear === "function") $$props.onInputClear(event);
	}

	function onInput(...args) {
		dispatch("input", [...args]);
		if (typeof $$props.onInput === "function") $$props.onInput(...args);

		if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && inputEl) {
			validateInput();
		}
	}

	function onFocus(...args) {
		dispatch("focus", [...args]);
		if (typeof $$props.onFocus === "function") $$props.onFocus(...args);
		$$invalidate(80, inputFocused = true);
	}

	function onBlur(...args) {
		dispatch("blur", [...args]);
		if (typeof $$props.onBlur === "function") $$props.onBlur(...args);

		if ((validate || validate === "" || validateOnBlur || validateOnBlur === "") && inputEl) {
			validateInput();
		}

		$$invalidate(80, inputFocused = false);
	}

	function onChange(...args) {
		dispatch("change", [...args]);
		if (typeof $$props.onChange === "function") $$props.onChange(...args);

		if (type === "texteditor") {
			dispatch("textEditorChange", [args[1]]);
		}
	}

	onMount(() => {
		f7.ready(() => {
			if (type === "range" || type === "toggle") return;
			if (!inputEl) return;
			inputEl.addEventListener("input:notempty", onInputNotEmpty, false);

			if (type === "textarea" && resizable) {
				inputEl.addEventListener("textarea:resize", onTextareaResize, false);
			}

			if (clearButton) {
				inputEl.addEventListener("input:empty", onInputEmpty, false);
				inputEl.addEventListener("input:clear", onInputClear, false);
			}

			if (type === "datepicker") {
				f7Calendar = f7.instance.calendar.create({
					inputEl,
					value,
					on: {
						change(calendar, calendarValue) {
							dispatch("calendarChange", [calendarValue]);
							if (typeof $$props.onCalendarChange === "function") $$props.onCalendarChange(calendarValue);
						}
					},
					...calendarParams || {}
				});
			}

			if (type === "colorpicker") {
				f7ColorPicker = f7.instance.colorPicker.create({
					inputEl,
					value,
					on: {
						change(colorPicker, colorPickerValue) {
							dispatch("colorPickerChange", [colorPickerValue]);
							if (typeof $$props.onColorPickerChange === "function") $$props.onColorPickerChange(colorPickerValue);
						}
					},
					...colorPickerParams || {}
				});
			}

			f7.instance.input.checkEmptyState(inputEl);

			if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && (typeof value !== "undefined" && value !== null && value !== "")) {
				setTimeout(
					() => {
						validateInput();
					},
					0
				);
			}

			if (resizable) {
				f7.instance.input.resizeTextarea(inputEl);
			}
		});
	});

	afterUpdate(() => {
		if (!f7.instance) return;

		if (updateInputOnDidUpdate) {
			if (!inputEl) return;
			updateInputOnDidUpdate = false;
			f7.instance.input.checkEmptyState(inputEl);

			if (validate && !validateOnBlur) {
				validateInput();
			}

			if (resizable) {
				f7.instance.input.resizeTextarea(inputEl);
			}
		}
	});

	onDestroy(() => {
		if (type === "range" || type === "toggle") return;
		if (!inputEl) return;
		inputEl.removeEventListener("input:notempty", onInputNotEmpty, false);

		if (type === "textarea" && resizable) {
			inputEl.removeEventListener("textarea:resize", onTextareaResize, false);
		}

		if (clearButton) {
			inputEl.removeEventListener("input:empty", onInputEmpty, false);
			inputEl.removeEventListener("input:clear", onInputClear, false);
		}

		if (f7Calendar && f7Calendar.destroy) {
			f7Calendar.destroy();
		}

		if (f7ColorPicker && f7ColorPicker.destroy) {
			f7ColorPicker.destroy();
		}

		f7Calendar = null;
		f7ColorPicker = null;
	});

	let { $$slots = {}, $$scope } = $$props;

	validate_slots("List_input", $$slots, [
		'root-start','content-start','media','inner-start','label','default','input','error-message','info','inner','inner-end','content','content-end','root','root-end'
	]);

	function select_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(38, inputEl);
		});
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(38, inputEl);
		});
	}

	function input_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(38, inputEl);
		});
	}

	function select_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(38, inputEl);
		});
	}

	function textarea_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(38, inputEl);
		});
	}

	function input_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(38, inputEl);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(99, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(56, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(57, className = $$new_props.class);
		if ("sortable" in $$new_props) $$invalidate(58, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$new_props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
		if ("media" in $$new_props) $$invalidate(0, media = $$new_props.media);
		if ("dropdown" in $$new_props) $$invalidate(60, dropdown = $$new_props.dropdown);
		if ("wrap" in $$new_props) $$invalidate(1, wrap = $$new_props.wrap);
		if ("input" in $$new_props) $$invalidate(2, input = $$new_props.input);
		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
		if ("name" in $$new_props) $$invalidate(4, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
		if ("inputmode" in $$new_props) $$invalidate(6, inputmode = $$new_props.inputmode);
		if ("readonly" in $$new_props) $$invalidate(7, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(8, required = $$new_props.required);
		if ("disabled" in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
		if ("placeholder" in $$new_props) $$invalidate(10, placeholder = $$new_props.placeholder);
		if ("inputId" in $$new_props) $$invalidate(11, inputId = $$new_props.inputId);
		if ("size" in $$new_props) $$invalidate(12, size = $$new_props.size);
		if ("accept" in $$new_props) $$invalidate(13, accept = $$new_props.accept);
		if ("autocomplete" in $$new_props) $$invalidate(14, autocomplete = $$new_props.autocomplete);
		if ("autocorrect" in $$new_props) $$invalidate(15, autocorrect = $$new_props.autocorrect);
		if ("autocapitalize" in $$new_props) $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
		if ("spellcheck" in $$new_props) $$invalidate(17, spellcheck = $$new_props.spellcheck);
		if ("autofocus" in $$new_props) $$invalidate(18, autofocus = $$new_props.autofocus);
		if ("autosave" in $$new_props) $$invalidate(19, autosave = $$new_props.autosave);
		if ("max" in $$new_props) $$invalidate(20, max = $$new_props.max);
		if ("min" in $$new_props) $$invalidate(21, min = $$new_props.min);
		if ("step" in $$new_props) $$invalidate(22, step = $$new_props.step);
		if ("maxlength" in $$new_props) $$invalidate(23, maxlength = $$new_props.maxlength);
		if ("minlength" in $$new_props) $$invalidate(24, minlength = $$new_props.minlength);
		if ("multiple" in $$new_props) $$invalidate(25, multiple = $$new_props.multiple);
		if ("inputStyle" in $$new_props) $$invalidate(26, inputStyle = $$new_props.inputStyle);
		if ("pattern" in $$new_props) $$invalidate(27, pattern = $$new_props.pattern);
		if ("validate" in $$new_props) $$invalidate(28, validate = $$new_props.validate);
		if ("validateOnBlur" in $$new_props) $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
		if ("onValidate" in $$new_props) $$invalidate(61, onValidate = $$new_props.onValidate);
		if ("tabindex" in $$new_props) $$invalidate(30, tabindex = $$new_props.tabindex);
		if ("resizable" in $$new_props) $$invalidate(31, resizable = $$new_props.resizable);
		if ("clearButton" in $$new_props) $$invalidate(32, clearButton = $$new_props.clearButton);
		if ("noFormStoreData" in $$new_props) $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
		if ("noStoreData" in $$new_props) $$invalidate(63, noStoreData = $$new_props.noStoreData);
		if ("ignoreStoreData" in $$new_props) $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
		if ("errorMessage" in $$new_props) $$invalidate(33, errorMessage = $$new_props.errorMessage);
		if ("errorMessageForce" in $$new_props) $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
		if ("info" in $$new_props) $$invalidate(35, info = $$new_props.info);
		if ("outline" in $$new_props) $$invalidate(65, outline = $$new_props.outline);
		if ("label" in $$new_props) $$invalidate(36, label = $$new_props.label);
		if ("inlineLabel" in $$new_props) $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
		if ("floatingLabel" in $$new_props) $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
		if ("calendarParams" in $$new_props) $$invalidate(68, calendarParams = $$new_props.calendarParams);
		if ("colorPickerParams" in $$new_props) $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
		if ("textEditorParams" in $$new_props) $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
		if ("$$scope" in $$new_props) $$invalidate(72, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		getContext,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		hasSlots,
		TextEditor: Text_editor,
		dispatch,
		className,
		sortable,
		sortableOpposite,
		media,
		dropdown,
		wrap,
		input,
		type,
		name,
		value,
		inputmode,
		readonly,
		required,
		disabled,
		placeholder,
		inputId,
		size,
		accept,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		autofocus,
		autosave,
		max,
		min,
		step,
		maxlength,
		minlength,
		multiple,
		inputStyle,
		pattern,
		validate,
		validateOnBlur,
		onValidate,
		tabindex,
		resizable,
		clearButton,
		noFormStoreData,
		noStoreData,
		ignoreStoreData,
		errorMessage,
		errorMessageForce,
		info,
		outline,
		label,
		inlineLabel,
		floatingLabel,
		calendarParams,
		colorPickerParams,
		textEditorParams,
		inputEl,
		inputFocused,
		inputInvalid,
		updateInputOnDidUpdate,
		f7Calendar,
		f7ColorPicker,
		calendarInstance,
		colorPickerInstance,
		domValue,
		inputHasValue,
		validateInput,
		initialWatched,
		watchValue,
		watchColorPickerParams,
		watchCalendarParams,
		onTextareaResize,
		onInputNotEmpty,
		onInputEmpty,
		onInputClear,
		onInput,
		onFocus,
		onBlur,
		onChange,
		isSortable,
		isSortableOpposite,
		inputType,
		needsValue,
		inputValue,
		hasInfoSlots,
		hasErrorSlots,
		hasMediaSlots,
		hasLabelSlots,
		hasErrorMessage,
		inputClasses,
		itemContentClasses,
		labelClasses,
		inputWrapClasses,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(99, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(57, className = $$new_props.className);
		if ("sortable" in $$props) $$invalidate(58, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
		if ("media" in $$props) $$invalidate(0, media = $$new_props.media);
		if ("dropdown" in $$props) $$invalidate(60, dropdown = $$new_props.dropdown);
		if ("wrap" in $$props) $$invalidate(1, wrap = $$new_props.wrap);
		if ("input" in $$props) $$invalidate(2, input = $$new_props.input);
		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
		if ("name" in $$props) $$invalidate(4, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
		if ("inputmode" in $$props) $$invalidate(6, inputmode = $$new_props.inputmode);
		if ("readonly" in $$props) $$invalidate(7, readonly = $$new_props.readonly);
		if ("required" in $$props) $$invalidate(8, required = $$new_props.required);
		if ("disabled" in $$props) $$invalidate(9, disabled = $$new_props.disabled);
		if ("placeholder" in $$props) $$invalidate(10, placeholder = $$new_props.placeholder);
		if ("inputId" in $$props) $$invalidate(11, inputId = $$new_props.inputId);
		if ("size" in $$props) $$invalidate(12, size = $$new_props.size);
		if ("accept" in $$props) $$invalidate(13, accept = $$new_props.accept);
		if ("autocomplete" in $$props) $$invalidate(14, autocomplete = $$new_props.autocomplete);
		if ("autocorrect" in $$props) $$invalidate(15, autocorrect = $$new_props.autocorrect);
		if ("autocapitalize" in $$props) $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
		if ("spellcheck" in $$props) $$invalidate(17, spellcheck = $$new_props.spellcheck);
		if ("autofocus" in $$props) $$invalidate(18, autofocus = $$new_props.autofocus);
		if ("autosave" in $$props) $$invalidate(19, autosave = $$new_props.autosave);
		if ("max" in $$props) $$invalidate(20, max = $$new_props.max);
		if ("min" in $$props) $$invalidate(21, min = $$new_props.min);
		if ("step" in $$props) $$invalidate(22, step = $$new_props.step);
		if ("maxlength" in $$props) $$invalidate(23, maxlength = $$new_props.maxlength);
		if ("minlength" in $$props) $$invalidate(24, minlength = $$new_props.minlength);
		if ("multiple" in $$props) $$invalidate(25, multiple = $$new_props.multiple);
		if ("inputStyle" in $$props) $$invalidate(26, inputStyle = $$new_props.inputStyle);
		if ("pattern" in $$props) $$invalidate(27, pattern = $$new_props.pattern);
		if ("validate" in $$props) $$invalidate(28, validate = $$new_props.validate);
		if ("validateOnBlur" in $$props) $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
		if ("onValidate" in $$props) $$invalidate(61, onValidate = $$new_props.onValidate);
		if ("tabindex" in $$props) $$invalidate(30, tabindex = $$new_props.tabindex);
		if ("resizable" in $$props) $$invalidate(31, resizable = $$new_props.resizable);
		if ("clearButton" in $$props) $$invalidate(32, clearButton = $$new_props.clearButton);
		if ("noFormStoreData" in $$props) $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
		if ("noStoreData" in $$props) $$invalidate(63, noStoreData = $$new_props.noStoreData);
		if ("ignoreStoreData" in $$props) $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
		if ("errorMessage" in $$props) $$invalidate(33, errorMessage = $$new_props.errorMessage);
		if ("errorMessageForce" in $$props) $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
		if ("info" in $$props) $$invalidate(35, info = $$new_props.info);
		if ("outline" in $$props) $$invalidate(65, outline = $$new_props.outline);
		if ("label" in $$props) $$invalidate(36, label = $$new_props.label);
		if ("inlineLabel" in $$props) $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
		if ("floatingLabel" in $$props) $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
		if ("calendarParams" in $$props) $$invalidate(68, calendarParams = $$new_props.calendarParams);
		if ("colorPickerParams" in $$props) $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
		if ("textEditorParams" in $$props) $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
		if ("inputEl" in $$props) $$invalidate(38, inputEl = $$new_props.inputEl);
		if ("inputFocused" in $$props) $$invalidate(80, inputFocused = $$new_props.inputFocused);
		if ("inputInvalid" in $$props) $$invalidate(81, inputInvalid = $$new_props.inputInvalid);
		if ("updateInputOnDidUpdate" in $$props) updateInputOnDidUpdate = $$new_props.updateInputOnDidUpdate;
		if ("f7Calendar" in $$props) f7Calendar = $$new_props.f7Calendar;
		if ("f7ColorPicker" in $$props) f7ColorPicker = $$new_props.f7ColorPicker;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("isSortable" in $$props) $$invalidate(39, isSortable = $$new_props.isSortable);
		if ("isSortableOpposite" in $$props) $$invalidate(40, isSortableOpposite = $$new_props.isSortableOpposite);
		if ("inputType" in $$props) $$invalidate(41, inputType = $$new_props.inputType);
		if ("needsValue" in $$props) needsValue = $$new_props.needsValue;
		if ("inputValue" in $$props) $$invalidate(42, inputValue = $$new_props.inputValue);
		if ("hasInfoSlots" in $$props) $$invalidate(43, hasInfoSlots = $$new_props.hasInfoSlots);
		if ("hasErrorSlots" in $$props) $$invalidate(87, hasErrorSlots = $$new_props.hasErrorSlots);
		if ("hasMediaSlots" in $$props) $$invalidate(44, hasMediaSlots = $$new_props.hasMediaSlots);
		if ("hasLabelSlots" in $$props) $$invalidate(45, hasLabelSlots = $$new_props.hasLabelSlots);
		if ("hasErrorMessage" in $$props) $$invalidate(46, hasErrorMessage = $$new_props.hasErrorMessage);
		if ("inputClasses" in $$props) $$invalidate(47, inputClasses = $$new_props.inputClasses);
		if ("itemContentClasses" in $$props) $$invalidate(48, itemContentClasses = $$new_props.itemContentClasses);
		if ("labelClasses" in $$props) $$invalidate(49, labelClasses = $$new_props.labelClasses);
		if ("inputWrapClasses" in $$props) $$invalidate(50, inputWrapClasses = $$new_props.inputWrapClasses);
		if ("classes" in $$props) $$invalidate(51, classes = $$new_props.classes);
	};

	let isSortable;
	let isSortableOpposite;
	let inputType;
	let needsValue;
	let inputValue;
	let hasInfoSlots;
	let hasErrorSlots;
	let hasMediaSlots;
	let hasLabelSlots;
	let hasErrorMessage;
	let inputClasses;
	let itemContentClasses;
	let labelClasses;
	let inputWrapClasses;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*sortable*/ 134217728) {
			 $$invalidate(39, isSortable = sortable || getContext("f7ListSortable"));
		}

		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 268435456) {
			 $$invalidate(40, isSortableOpposite = sortableOpposite || getContext("f7ListSortableOpposite"));
		}

		if ($$self.$$.dirty[0] & /*value*/ 32) {
			 watchValue();
		}

		if ($$self.$$.dirty[2] & /*colorPickerParams*/ 128) {
			 watchColorPickerParams();
		}

		if ($$self.$$.dirty[2] & /*calendarParams*/ 64) {
			 watchCalendarParams();
		}

		if ($$self.$$.dirty[0] & /*type*/ 8) {
			 $$invalidate(41, inputType = type === "datepicker" || type === "colorpicker"
			? "text"
			: type);
		}

		if ($$self.$$.dirty[0] & /*type*/ 8) {
			 needsValue = type !== "file" && type !== "datepicker" && type !== "colorpicker";
		}

		if ($$self.$$.dirty[0] & /*value*/ 32) {
			 $$invalidate(42, inputValue = (() => {
				let v;

				if (typeof value !== "undefined") {
					v = value;
				} else {
					v = domValue();
				}

				if (typeof v === "undefined" || v === null) return "";
				return v;
			})());
		}

		if ($$self.$$.dirty[1] & /*errorMessage*/ 4 | $$self.$$.dirty[2] & /*hasErrorSlots*/ 33554432) {
			 $$invalidate(46, hasErrorMessage = !!errorMessage || hasErrorSlots);
		}

		if ($$self.$$.dirty[1] & /*inputType, resizable, errorMessage, errorMessageForce*/ 1037 | $$self.$$.dirty[2] & /*noFormStoreData, noStoreData, ignoreStoreData, inputInvalid, inputFocused*/ 786439) {
			 $$invalidate(47, inputClasses = Utils$1.classNames({
				resizable: inputType === "textarea" && resizable,
				"no-store-data": noFormStoreData || noStoreData || ignoreStoreData,
				"input-invalid": errorMessage && errorMessageForce || inputInvalid,
				"input-with-value": inputHasValue(),
				"input-focused": inputFocused
			}));
		}

		 $$invalidate(48, itemContentClasses = Utils$1.classNames("item-content item-input", !wrap && className, !wrap && { disabled }, !wrap && Mixins.colorClasses($$props), {
			"inline-label": inlineLabel,
			"item-input-outline": outline,
			"item-input-focused": inputFocused,
			"item-input-with-info": !!info || hasInfoSlots,
			"item-input-with-value": inputHasValue(),
			"item-input-with-error-message": hasErrorMessage && errorMessageForce || inputInvalid,
			"item-input-invalid": hasErrorMessage && errorMessageForce || inputInvalid
		}));

		if ($$self.$$.dirty[2] & /*floatingLabel*/ 32) {
			 $$invalidate(49, labelClasses = Utils$1.classNames("item-title item-label", { "item-floating-label": floatingLabel }));
		}

		if ($$self.$$.dirty[0] & /*type*/ 8 | $$self.$$.dirty[1] & /*dropdown*/ 536870912) {
			 $$invalidate(50, inputWrapClasses = Utils$1.classNames("item-input-wrap", {
				"input-dropdown": dropdown === "auto" ? type === "select" : dropdown
			}));
		}

		 $$invalidate(51, classes = Utils$1.classNames(className, { disabled }, Mixins.colorClasses($$props)));
	};

	 $$invalidate(43, hasInfoSlots = hasSlots(arguments, "info"));

	// eslint-disable-next-line
	 $$invalidate(87, hasErrorSlots = hasSlots(arguments, "error-message"));

	// eslint-disable-next-line
	 $$invalidate(44, hasMediaSlots = hasSlots(arguments, "media"));

	// eslint-disable-next-line
	 $$invalidate(45, hasLabelSlots = hasSlots(arguments, "label"));

	$$props = exclude_internal_props($$props);

	return [
		media,
		wrap,
		input,
		type,
		name,
		value,
		inputmode,
		readonly,
		required,
		disabled,
		placeholder,
		inputId,
		size,
		accept,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		autofocus,
		autosave,
		max,
		min,
		step,
		maxlength,
		minlength,
		multiple,
		inputStyle,
		pattern,
		validate,
		validateOnBlur,
		tabindex,
		resizable,
		clearButton,
		errorMessage,
		errorMessageForce,
		info,
		label,
		textEditorParams,
		inputEl,
		isSortable,
		isSortableOpposite,
		inputType,
		inputValue,
		hasInfoSlots,
		hasMediaSlots,
		hasLabelSlots,
		hasErrorMessage,
		inputClasses,
		itemContentClasses,
		labelClasses,
		inputWrapClasses,
		classes,
		onInput,
		onFocus,
		onBlur,
		onChange,
		$$restProps,
		className,
		sortable,
		sortableOpposite,
		dropdown,
		onValidate,
		noFormStoreData,
		noStoreData,
		ignoreStoreData,
		outline,
		inlineLabel,
		floatingLabel,
		calendarParams,
		colorPickerParams,
		calendarInstance,
		colorPickerInstance,
		$$scope,
		$$slots,
		select_binding,
		textarea_binding,
		input_1_binding,
		select_binding_1,
		textarea_binding_1,
		input_1_binding_1
	];
}

class List_input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$8,
			create_fragment$9,
			safe_not_equal,
			{
				class: 57,
				sortable: 58,
				sortableOpposite: 59,
				media: 0,
				dropdown: 60,
				wrap: 1,
				input: 2,
				type: 3,
				name: 4,
				value: 5,
				inputmode: 6,
				readonly: 7,
				required: 8,
				disabled: 9,
				placeholder: 10,
				inputId: 11,
				size: 12,
				accept: 13,
				autocomplete: 14,
				autocorrect: 15,
				autocapitalize: 16,
				spellcheck: 17,
				autofocus: 18,
				autosave: 19,
				max: 20,
				min: 21,
				step: 22,
				maxlength: 23,
				minlength: 24,
				multiple: 25,
				inputStyle: 26,
				pattern: 27,
				validate: 28,
				validateOnBlur: 29,
				onValidate: 61,
				tabindex: 30,
				resizable: 31,
				clearButton: 32,
				noFormStoreData: 62,
				noStoreData: 63,
				ignoreStoreData: 64,
				errorMessage: 33,
				errorMessageForce: 34,
				info: 35,
				outline: 65,
				label: 36,
				inlineLabel: 66,
				floatingLabel: 67,
				calendarParams: 68,
				colorPickerParams: 69,
				textEditorParams: 37,
				calendarInstance: 70,
				colorPickerInstance: 71
			},
			[-1, -1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List_input",
			options,
			id: create_fragment$9.name
		});
	}

	get class() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortable() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortable(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableOpposite() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableOpposite(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get media() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set media(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dropdown() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dropdown(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrap() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrap(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputmode() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputmode(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputId() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputId(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accept() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accept(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocomplete() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocomplete(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocorrect() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocorrect(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocapitalize() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocapitalize(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get spellcheck() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set spellcheck(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autofocus() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autofocus(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autosave() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autosave(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get maxlength() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set maxlength(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get minlength() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set minlength(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputStyle() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputStyle(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pattern() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pattern(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validate() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validate(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validateOnBlur() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validateOnBlur(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onValidate() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onValidate(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabindex() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabindex(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearButton() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearButton(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noFormStoreData() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noFormStoreData(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noStoreData() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noStoreData(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ignoreStoreData() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ignoreStoreData(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorMessage() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessage(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorMessageForce() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessageForce(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get info() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set info(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inlineLabel() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inlineLabel(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get floatingLabel() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set floatingLabel(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get calendarParams() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set calendarParams(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get colorPickerParams() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set colorPickerParams(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get textEditorParams() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textEditorParams(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get calendarInstance() {
		return this.$$.ctx[70];
	}

	set calendarInstance(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get colorPickerInstance() {
		return this.$$.ctx[71];
	}

	set colorPickerInstance(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$a = "node_modules/framework7-svelte/components/list-item.svelte";
const get_root_end_slot_changes$2 = dirty => ({});
const get_root_end_slot_context$2 = ctx => ({});
const get_root_slot_changes$2 = dirty => ({});
const get_root_slot_context$2 = ctx => ({});
const get_content_end_slot_changes_5 = dirty => ({});
const get_content_end_slot_context_5 = ctx => ({});
const get_content_slot_changes_5 = dirty => ({});
const get_content_slot_context_5 = ctx => ({});
const get_inner_end_slot_changes_5 = dirty => ({});
const get_inner_end_slot_context_5 = ctx => ({});
const get_inner_slot_changes_11 = dirty => ({});
const get_inner_slot_context_11 = ctx => ({});
const get_after_end_slot_changes_11 = dirty => ({});
const get_after_end_slot_context_11 = ctx => ({});
const get_after_slot_changes_11 = dirty => ({});
const get_after_slot_context_11 = ctx => ({});
const get_after_start_slot_changes_11 = dirty => ({});
const get_after_start_slot_context_11 = ctx => ({});
const get_after_title_slot_changes_11 = dirty => ({});
const get_after_title_slot_context_11 = ctx => ({});
const get_footer_slot_changes_11 = dirty => ({});
const get_footer_slot_context_11 = ctx => ({});
const get_title_slot_changes_11 = dirty => ({});
const get_title_slot_context_11 = ctx => ({});
const get_header_slot_changes_11 = dirty => ({});
const get_header_slot_context_11 = ctx => ({});
const get_before_title_slot_changes_11 = dirty => ({});
const get_before_title_slot_context_11 = ctx => ({});
const get_footer_slot_changes_10 = dirty => ({});
const get_footer_slot_context_10 = ctx => ({});
const get_inner_slot_changes_10 = dirty => ({});
const get_inner_slot_context_10 = ctx => ({});
const get_text_slot_changes_5 = dirty => ({});
const get_text_slot_context_5 = ctx => ({});
const get_subtitle_slot_changes_5 = dirty => ({});
const get_subtitle_slot_context_5 = ctx => ({});
const get_after_end_slot_changes_10 = dirty => ({});
const get_after_end_slot_context_10 = ctx => ({});
const get_after_slot_changes_10 = dirty => ({});
const get_after_slot_context_10 = ctx => ({});
const get_after_start_slot_changes_10 = dirty => ({});
const get_after_start_slot_context_10 = ctx => ({});
const get_after_title_slot_changes_10 = dirty => ({});
const get_after_title_slot_context_10 = ctx => ({});
const get_title_slot_changes_10 = dirty => ({});
const get_title_slot_context_10 = ctx => ({});
const get_before_title_slot_changes_10 = dirty => ({});
const get_before_title_slot_context_10 = ctx => ({});
const get_header_slot_changes_10 = dirty => ({});
const get_header_slot_context_10 = ctx => ({});
const get_inner_start_slot_changes_5 = dirty => ({});
const get_inner_start_slot_context_5 = ctx => ({});
const get_media_slot_changes_5 = dirty => ({});
const get_media_slot_context_5 = ctx => ({});
const get_content_start_slot_changes_5 = dirty => ({});
const get_content_start_slot_context_5 = ctx => ({});
const get_content_end_slot_changes_4 = dirty => ({});
const get_content_end_slot_context_4 = ctx => ({});
const get_content_slot_changes_4 = dirty => ({});
const get_content_slot_context_4 = ctx => ({});
const get_inner_end_slot_changes_4 = dirty => ({});
const get_inner_end_slot_context_4 = ctx => ({});
const get_inner_slot_changes_9 = dirty => ({});
const get_inner_slot_context_9 = ctx => ({});
const get_after_end_slot_changes_9 = dirty => ({});
const get_after_end_slot_context_9 = ctx => ({});
const get_after_slot_changes_9 = dirty => ({});
const get_after_slot_context_9 = ctx => ({});
const get_after_start_slot_changes_9 = dirty => ({});
const get_after_start_slot_context_9 = ctx => ({});
const get_after_title_slot_changes_9 = dirty => ({});
const get_after_title_slot_context_9 = ctx => ({});
const get_footer_slot_changes_9 = dirty => ({});
const get_footer_slot_context_9 = ctx => ({});
const get_title_slot_changes_9 = dirty => ({});
const get_title_slot_context_9 = ctx => ({});
const get_header_slot_changes_9 = dirty => ({});
const get_header_slot_context_9 = ctx => ({});
const get_before_title_slot_changes_9 = dirty => ({});
const get_before_title_slot_context_9 = ctx => ({});
const get_footer_slot_changes_8 = dirty => ({});
const get_footer_slot_context_8 = ctx => ({});
const get_inner_slot_changes_8 = dirty => ({});
const get_inner_slot_context_8 = ctx => ({});
const get_text_slot_changes_4 = dirty => ({});
const get_text_slot_context_4 = ctx => ({});
const get_subtitle_slot_changes_4 = dirty => ({});
const get_subtitle_slot_context_4 = ctx => ({});
const get_after_end_slot_changes_8 = dirty => ({});
const get_after_end_slot_context_8 = ctx => ({});
const get_after_slot_changes_8 = dirty => ({});
const get_after_slot_context_8 = ctx => ({});
const get_after_start_slot_changes_8 = dirty => ({});
const get_after_start_slot_context_8 = ctx => ({});
const get_after_title_slot_changes_8 = dirty => ({});
const get_after_title_slot_context_8 = ctx => ({});
const get_title_slot_changes_8 = dirty => ({});
const get_title_slot_context_8 = ctx => ({});
const get_before_title_slot_changes_8 = dirty => ({});
const get_before_title_slot_context_8 = ctx => ({});
const get_header_slot_changes_8 = dirty => ({});
const get_header_slot_context_8 = ctx => ({});
const get_inner_start_slot_changes_4 = dirty => ({});
const get_inner_start_slot_context_4 = ctx => ({});
const get_media_slot_changes_4 = dirty => ({});
const get_media_slot_context_4 = ctx => ({});
const get_content_start_slot_changes_4 = dirty => ({});
const get_content_start_slot_context_4 = ctx => ({});
const get_content_end_slot_changes_3 = dirty => ({});
const get_content_end_slot_context_3 = ctx => ({});
const get_content_slot_changes_3 = dirty => ({});
const get_content_slot_context_3 = ctx => ({});
const get_inner_end_slot_changes_3 = dirty => ({});
const get_inner_end_slot_context_3 = ctx => ({});
const get_inner_slot_changes_7 = dirty => ({});
const get_inner_slot_context_7 = ctx => ({});
const get_after_end_slot_changes_7 = dirty => ({});
const get_after_end_slot_context_7 = ctx => ({});
const get_after_slot_changes_7 = dirty => ({});
const get_after_slot_context_7 = ctx => ({});
const get_after_start_slot_changes_7 = dirty => ({});
const get_after_start_slot_context_7 = ctx => ({});
const get_after_title_slot_changes_7 = dirty => ({});
const get_after_title_slot_context_7 = ctx => ({});
const get_footer_slot_changes_7 = dirty => ({});
const get_footer_slot_context_7 = ctx => ({});
const get_title_slot_changes_7 = dirty => ({});
const get_title_slot_context_7 = ctx => ({});
const get_header_slot_changes_7 = dirty => ({});
const get_header_slot_context_7 = ctx => ({});
const get_before_title_slot_changes_7 = dirty => ({});
const get_before_title_slot_context_7 = ctx => ({});
const get_footer_slot_changes_6 = dirty => ({});
const get_footer_slot_context_6 = ctx => ({});
const get_inner_slot_changes_6 = dirty => ({});
const get_inner_slot_context_6 = ctx => ({});
const get_text_slot_changes_3 = dirty => ({});
const get_text_slot_context_3 = ctx => ({});
const get_subtitle_slot_changes_3 = dirty => ({});
const get_subtitle_slot_context_3 = ctx => ({});
const get_after_end_slot_changes_6 = dirty => ({});
const get_after_end_slot_context_6 = ctx => ({});
const get_after_slot_changes_6 = dirty => ({});
const get_after_slot_context_6 = ctx => ({});
const get_after_start_slot_changes_6 = dirty => ({});
const get_after_start_slot_context_6 = ctx => ({});
const get_after_title_slot_changes_6 = dirty => ({});
const get_after_title_slot_context_6 = ctx => ({});
const get_title_slot_changes_6 = dirty => ({});
const get_title_slot_context_6 = ctx => ({});
const get_before_title_slot_changes_6 = dirty => ({});
const get_before_title_slot_context_6 = ctx => ({});
const get_header_slot_changes_6 = dirty => ({});
const get_header_slot_context_6 = ctx => ({});
const get_inner_start_slot_changes_3 = dirty => ({});
const get_inner_start_slot_context_3 = ctx => ({});
const get_media_slot_changes_3 = dirty => ({});
const get_media_slot_context_3 = ctx => ({});
const get_content_start_slot_changes_3 = dirty => ({});
const get_content_start_slot_context_3 = ctx => ({});
const get_content_end_slot_changes_2 = dirty => ({});
const get_content_end_slot_context_2 = ctx => ({});
const get_content_slot_changes_2 = dirty => ({});
const get_content_slot_context_2 = ctx => ({});
const get_inner_end_slot_changes_2 = dirty => ({});
const get_inner_end_slot_context_2 = ctx => ({});
const get_inner_slot_changes_5 = dirty => ({});
const get_inner_slot_context_5 = ctx => ({});
const get_after_end_slot_changes_5 = dirty => ({});
const get_after_end_slot_context_5 = ctx => ({});
const get_after_slot_changes_5 = dirty => ({});
const get_after_slot_context_5 = ctx => ({});
const get_after_start_slot_changes_5 = dirty => ({});
const get_after_start_slot_context_5 = ctx => ({});
const get_after_title_slot_changes_5 = dirty => ({});
const get_after_title_slot_context_5 = ctx => ({});
const get_footer_slot_changes_5 = dirty => ({});
const get_footer_slot_context_5 = ctx => ({});
const get_title_slot_changes_5 = dirty => ({});
const get_title_slot_context_5 = ctx => ({});
const get_header_slot_changes_5 = dirty => ({});
const get_header_slot_context_5 = ctx => ({});
const get_before_title_slot_changes_5 = dirty => ({});
const get_before_title_slot_context_5 = ctx => ({});
const get_footer_slot_changes_4 = dirty => ({});
const get_footer_slot_context_4 = ctx => ({});
const get_inner_slot_changes_4 = dirty => ({});
const get_inner_slot_context_4 = ctx => ({});
const get_text_slot_changes_2 = dirty => ({});
const get_text_slot_context_2 = ctx => ({});
const get_subtitle_slot_changes_2 = dirty => ({});
const get_subtitle_slot_context_2 = ctx => ({});
const get_after_end_slot_changes_4 = dirty => ({});
const get_after_end_slot_context_4 = ctx => ({});
const get_after_slot_changes_4 = dirty => ({});
const get_after_slot_context_4 = ctx => ({});
const get_after_start_slot_changes_4 = dirty => ({});
const get_after_start_slot_context_4 = ctx => ({});
const get_after_title_slot_changes_4 = dirty => ({});
const get_after_title_slot_context_4 = ctx => ({});
const get_title_slot_changes_4 = dirty => ({});
const get_title_slot_context_4 = ctx => ({});
const get_before_title_slot_changes_4 = dirty => ({});
const get_before_title_slot_context_4 = ctx => ({});
const get_header_slot_changes_4 = dirty => ({});
const get_header_slot_context_4 = ctx => ({});
const get_inner_start_slot_changes_2 = dirty => ({});
const get_inner_start_slot_context_2 = ctx => ({});
const get_media_slot_changes_2 = dirty => ({});
const get_media_slot_context_2 = ctx => ({});
const get_content_start_slot_changes_2 = dirty => ({});
const get_content_start_slot_context_2 = ctx => ({});
const get_content_end_slot_changes_1$1 = dirty => ({});
const get_content_end_slot_context_1$1 = ctx => ({});
const get_content_slot_changes_1$1 = dirty => ({});
const get_content_slot_context_1$1 = ctx => ({});
const get_inner_end_slot_changes_1$1 = dirty => ({});
const get_inner_end_slot_context_1$1 = ctx => ({});
const get_inner_slot_changes_3 = dirty => ({});
const get_inner_slot_context_3 = ctx => ({});
const get_after_end_slot_changes_3 = dirty => ({});
const get_after_end_slot_context_3 = ctx => ({});
const get_after_slot_changes_3 = dirty => ({});
const get_after_slot_context_3 = ctx => ({});
const get_after_start_slot_changes_3 = dirty => ({});
const get_after_start_slot_context_3 = ctx => ({});
const get_after_title_slot_changes_3 = dirty => ({});
const get_after_title_slot_context_3 = ctx => ({});
const get_footer_slot_changes_3 = dirty => ({});
const get_footer_slot_context_3 = ctx => ({});
const get_title_slot_changes_3 = dirty => ({});
const get_title_slot_context_3 = ctx => ({});
const get_header_slot_changes_3 = dirty => ({});
const get_header_slot_context_3 = ctx => ({});
const get_before_title_slot_changes_3 = dirty => ({});
const get_before_title_slot_context_3 = ctx => ({});
const get_footer_slot_changes_2 = dirty => ({});
const get_footer_slot_context_2 = ctx => ({});
const get_inner_slot_changes_2 = dirty => ({});
const get_inner_slot_context_2 = ctx => ({});
const get_text_slot_changes_1 = dirty => ({});
const get_text_slot_context_1 = ctx => ({});
const get_subtitle_slot_changes_1 = dirty => ({});
const get_subtitle_slot_context_1 = ctx => ({});
const get_after_end_slot_changes_2 = dirty => ({});
const get_after_end_slot_context_2 = ctx => ({});
const get_after_slot_changes_2 = dirty => ({});
const get_after_slot_context_2 = ctx => ({});
const get_after_start_slot_changes_2 = dirty => ({});
const get_after_start_slot_context_2 = ctx => ({});
const get_after_title_slot_changes_2 = dirty => ({});
const get_after_title_slot_context_2 = ctx => ({});
const get_title_slot_changes_2 = dirty => ({});
const get_title_slot_context_2 = ctx => ({});
const get_before_title_slot_changes_2 = dirty => ({});
const get_before_title_slot_context_2 = ctx => ({});
const get_header_slot_changes_2 = dirty => ({});
const get_header_slot_context_2 = ctx => ({});
const get_inner_start_slot_changes_1$1 = dirty => ({});
const get_inner_start_slot_context_1$1 = ctx => ({});
const get_media_slot_changes_1$1 = dirty => ({});
const get_media_slot_context_1$1 = ctx => ({});
const get_content_start_slot_changes_1$1 = dirty => ({});
const get_content_start_slot_context_1$1 = ctx => ({});
const get_content_end_slot_changes$1 = dirty => ({});
const get_content_end_slot_context$1 = ctx => ({});
const get_content_slot_changes$1 = dirty => ({});
const get_content_slot_context$1 = ctx => ({});
const get_inner_end_slot_changes$1 = dirty => ({});
const get_inner_end_slot_context$1 = ctx => ({});
const get_inner_slot_changes_1$1 = dirty => ({});
const get_inner_slot_context_1$1 = ctx => ({});
const get_after_end_slot_changes_1 = dirty => ({});
const get_after_end_slot_context_1 = ctx => ({});
const get_after_slot_changes_1 = dirty => ({});
const get_after_slot_context_1 = ctx => ({});
const get_after_start_slot_changes_1 = dirty => ({});
const get_after_start_slot_context_1 = ctx => ({});
const get_after_title_slot_changes_1 = dirty => ({});
const get_after_title_slot_context_1 = ctx => ({});
const get_footer_slot_changes_1 = dirty => ({});
const get_footer_slot_context_1 = ctx => ({});
const get_title_slot_changes_1 = dirty => ({});
const get_title_slot_context_1 = ctx => ({});
const get_header_slot_changes_1 = dirty => ({});
const get_header_slot_context_1 = ctx => ({});
const get_before_title_slot_changes_1 = dirty => ({});
const get_before_title_slot_context_1 = ctx => ({});
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_inner_slot_changes$1 = dirty => ({});
const get_inner_slot_context$1 = ctx => ({});
const get_text_slot_changes = dirty => ({});
const get_text_slot_context = ctx => ({});
const get_subtitle_slot_changes = dirty => ({});
const get_subtitle_slot_context = ctx => ({});
const get_after_end_slot_changes = dirty => ({});
const get_after_end_slot_context = ctx => ({});
const get_after_slot_changes = dirty => ({});
const get_after_slot_context = ctx => ({});
const get_after_start_slot_changes = dirty => ({});
const get_after_start_slot_context = ctx => ({});
const get_after_title_slot_changes = dirty => ({});
const get_after_title_slot_context = ctx => ({});
const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});
const get_before_title_slot_changes = dirty => ({});
const get_before_title_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});
const get_inner_start_slot_changes$1 = dirty => ({});
const get_inner_start_slot_context$1 = ctx => ({});
const get_media_slot_changes$1 = dirty => ({});
const get_media_slot_context$1 = ctx => ({});
const get_content_start_slot_changes$1 = dirty => ({});
const get_content_start_slot_context$1 = ctx => ({});
const get_root_start_slot_changes$2 = dirty => ({});
const get_root_start_slot_context$2 = ctx => ({});

// (370:0) {:else}
function create_else_block$2(ctx) {
	let li;
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let t2;
	let t3;
	let t4;
	let current;
	const root_start_slot_template = /*$$slots*/ ctx[66]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[80], get_root_start_slot_context$2);
	const if_block_creators = [create_if_block_4$2, create_if_block_67, create_else_block_7];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*swipeout*/ ctx[11]) return 0;
		if (/*isLink*/ ctx[35]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && !/*isSortableOpposite*/ ctx[29] && create_if_block_3$3(ctx);
	let if_block2 = (/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_2$3(ctx);
	const root_slot_template = /*$$slots*/ ctx[66].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[80], get_root_slot_context$2);
	const root_end_slot_template = /*$$slots*/ ctx[66]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[80], get_root_end_slot_context$2);

	let li_levels = [
		{ class: /*liClasses*/ ctx[31] },
		{
			"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
		},
		restProps(/*$$restProps*/ ctx[45])
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (root_slot) root_slot.c();
			t4 = space();
			if (root_end_slot) root_end_slot.c();
			set_attributes(li, li_data);
			add_location(li, file$a, 370, 2, 12202);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (root_start_slot) {
				root_start_slot.m(li, null);
			}

			append_dev(li, t0);
			if_blocks[current_block_type_index].m(li, null);
			append_dev(li, t1);
			if (if_block1) if_block1.m(li, null);
			append_dev(li, t2);
			if (if_block2) if_block2.m(li, null);
			append_dev(li, t3);

			if (root_slot) {
				root_slot.m(li, null);
			}

			append_dev(li, t4);

			if (root_end_slot) {
				root_end_slot.m(li, null);
			}

			/*li_binding_2*/ ctx[79](li);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(root_start_slot, root_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_root_start_slot_changes$2, get_root_start_slot_context$2);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(li, t1);
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && !/*isSortableOpposite*/ ctx[29]) {
				if (if_block1) ; else {
					if_block1 = create_if_block_3$3(ctx);
					if_block1.c();
					if_block1.m(li, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2$3(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(li, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (root_slot) {
				if (root_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(root_slot, root_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_root_slot_changes$2, get_root_slot_context$2);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(root_end_slot, root_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_root_end_slot_changes$2, get_root_end_slot_context$2);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*liClasses*/ 1) && { class: /*liClasses*/ ctx[31] },
				(!current || dirty[0] & /*virtualListIndex*/ 4194304) && {
					"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
				},
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(if_block0);
			transition_in(if_block2);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(root_start_slot, local);
			transition_out(if_block0);
			transition_out(if_block2);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (root_start_slot) root_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			/*li_binding_2*/ ctx[79](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(370:0) {:else}",
		ctx
	});

	return block;
}

// (365:19) 
function create_if_block_1$3(ctx) {
	let li;
	let t0_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	let li_levels = [
		{ class: /*liClasses*/ ctx[31] },
		{
			"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
		},
		restProps(/*$$restProps*/ ctx[45])
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			t0 = text$1(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(li, li_data);
			add_location(li, file$a, 365, 2, 12017);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, t0);
			append_dev(li, t1);

			if (default_slot) {
				default_slot.m(li, null);
			}

			/*li_binding_1*/ ctx[68](li);
			current = true;

			if (!mounted) {
				dispose = listen_dev(li, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*liClasses*/ 1) && { class: /*liClasses*/ ctx[31] },
				(!current || dirty[0] & /*virtualListIndex*/ 4194304) && {
					"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
				},
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
			/*li_binding_1*/ ctx[68](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(365:19) ",
		ctx
	});

	return block;
}

// (361:0) {#if (divider || groupTitle)}
function create_if_block$3(ctx) {
	let li;
	let span;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	let li_levels = [
		{ class: /*liClasses*/ ctx[31] },
		{
			"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
		},
		restProps(/*$$restProps*/ ctx[45])
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			add_location(span, file$a, 362, 4, 11941);
			set_attributes(li, li_data);
			add_location(li, file$a, 361, 2, 11807);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, span);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			/*li_binding*/ ctx[67](li);
			current = true;

			if (!mounted) {
				dispose = listen_dev(li, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty[0] & /*title*/ 1) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*liClasses*/ 1) && { class: /*liClasses*/ ctx[31] },
				(!current || dirty[0] & /*virtualListIndex*/ 4194304) && {
					"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
				},
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*li_binding*/ ctx[67](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(361:0) {#if (divider || groupTitle)}",
		ctx
	});

	return block;
}

// (850:6) {:else}
function create_else_block_7(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_88, create_else_block_9];
	const if_blocks = [];

	function select_block_type_8(ctx, dirty) {
		if (/*checkbox*/ ctx[14] || /*radio*/ ctx[15]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_8(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_8(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_7.name,
		type: "else",
		source: "(850:6) {:else}",
		ctx
	});

	return block;
}

// (734:6) {#if isLink}
function create_if_block_67(ctx) {
	let a;
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*$$slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_3);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_87(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_85(ctx);
	const inner_start_slot_template = /*$$slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_3);
	const if_block_creators = [create_if_block_68, create_else_block_6];
	const if_blocks = [];

	function select_block_type_7(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_7(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*$$slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_3);
	const content_slot_template = /*$$slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_3);
	const content_end_slot_template = /*$$slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_3);
	let a_levels = [{ class: /*linkClasses*/ ctx[33] }, /*linkAttrs*/ ctx[34]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", "item-inner");
			add_location(div0, file$a, 749, 12, 27154);
			attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			add_location(div1, file$a, 736, 10, 26679);
			set_attributes(a, a_data);
			add_location(a, file$a, 734, 8, 26554);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_dev(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding_2*/ ctx[74](div0);
			append_dev(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			/*a_binding_1*/ ctx[75](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_3, get_content_start_slot_context_3);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_87(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_85(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_3, get_inner_start_slot_context_3);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_7(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_3, get_inner_end_slot_context_3);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_3, get_content_slot_context_3);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_3, get_content_end_slot_context_3);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[1] & /*linkClasses*/ 4) && { class: /*linkClasses*/ ctx[33] },
				dirty[1] & /*linkAttrs*/ 8 && /*linkAttrs*/ ctx[34]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding_2*/ ctx[74](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			/*a_binding_1*/ ctx[75](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_67.name,
		type: "if",
		source: "(734:6) {#if isLink}",
		ctx
	});

	return block;
}

// (373:4) {#if swipeout}
function create_if_block_4$2(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_5$1, create_else_block_2$1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*isLink*/ ctx[35]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			attr_dev(div, "class", "swipeout-content");
			add_location(div, file$a, 373, 6, 12367);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(373:4) {#if swipeout}",
		ctx
	});

	return block;
}

// (976:8) {:else}
function create_else_block_9(ctx) {
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*$$slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_5);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_128(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_126(ctx);
	const inner_start_slot_template = /*$$slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_5);
	const if_block_creators = [create_if_block_109, create_else_block_10];
	const if_blocks = [];

	function select_block_type_10(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_10(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*$$slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_5);
	const content_slot_template = /*$$slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_5);
	const content_end_slot_template = /*$$slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_5);

	const block = {
		c: function create() {
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", "item-inner");
			add_location(div0, file$a, 989, 12, 36158);
			attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			add_location(div1, file$a, 976, 10, 35664);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_dev(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding_3*/ ctx[78](div0);
			append_dev(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div1, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_5, get_content_start_slot_context_5);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_128(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_126(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_5, get_inner_start_slot_context_5);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_10(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_5, get_inner_end_slot_context_5);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_5, get_content_slot_context_5);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_5, get_content_end_slot_context_5);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding_3*/ ctx[78](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_9.name,
		type: "else",
		source: "(976:8) {:else}",
		ctx
	});

	return block;
}

// (852:8) {#if checkbox || radio}
function create_if_block_88(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let input_value_value;
	let input_type_value;
	let t2;
	let i;
	let i_class_value;
	let t3;
	let t4;
	let div;
	let t5;
	let current_block_type_index;
	let if_block2;
	let t6;
	let t7;
	let t8;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*$$slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_4);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_108(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_106(ctx);
	const inner_start_slot_template = /*$$slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_4);
	const if_block_creators = [create_if_block_89, create_else_block_8];
	const if_blocks = [];

	function select_block_type_9(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_9(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*$$slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_4);
	const content_slot_template = /*$$slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_4);
	const content_end_slot_template = /*$$slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_4);

	const block = {
		c: function create() {
			label = element("label");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			i = element("i");
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			div = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t5 = space();
			if_block2.c();
			t6 = space();
			if (inner_end_slot) inner_end_slot.c();
			t7 = space();
			if (content_slot) content_slot.c();
			t8 = space();
			if (content_end_slot) content_end_slot.c();

			input.value = input_value_value = typeof /*value*/ ctx[18] === "undefined"
			? ""
			: /*value*/ ctx[18];

			attr_dev(input, "name", /*name*/ ctx[17]);
			input.checked = /*checked*/ ctx[16];
			input.readOnly = /*readonly*/ ctx[19];
			input.disabled = /*disabled*/ ctx[21];
			input.required = /*required*/ ctx[20];
			attr_dev(input, "type", input_type_value = /*radio*/ ctx[15] ? "radio" : "checkbox");
			add_location(input, file$a, 857, 12, 31236);
			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[15] ? "radio" : "checkbox"}`);
			add_location(i, file$a, 868, 12, 31613);
			attr_dev(div, "class", "item-inner");
			add_location(div, file$a, 877, 12, 31937);
			attr_dev(label, "class", /*contentClasses*/ ctx[32]);
			add_location(label, file$a, 852, 10, 30994);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (content_start_slot) {
				content_start_slot.m(label, null);
			}

			append_dev(label, t0);
			if (if_block0) if_block0.m(label, null);
			append_dev(label, t1);
			append_dev(label, input);
			/*input_binding_1*/ ctx[76](input);
			append_dev(label, t2);
			append_dev(label, i);
			append_dev(label, t3);
			if (if_block1) if_block1.m(label, null);
			append_dev(label, t4);
			append_dev(label, div);

			if (inner_start_slot) {
				inner_start_slot.m(div, null);
			}

			append_dev(div, t5);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t6);

			if (inner_end_slot) {
				inner_end_slot.m(div, null);
			}

			/*div_binding_1*/ ctx[77](div);
			append_dev(label, t7);

			if (content_slot) {
				content_slot.m(label, null);
			}

			append_dev(label, t8);

			if (content_end_slot) {
				content_end_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*onChange*/ ctx[44], false, false, false),
					listen_dev(label, "click", /*onClick*/ ctx[43], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_4, get_content_start_slot_context_4);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_108(ctx);
					if_block0.c();
					if_block0.m(label, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty[0] & /*value*/ 262144 && input_value_value !== (input_value_value = typeof /*value*/ ctx[18] === "undefined"
			? ""
			: /*value*/ ctx[18]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty[0] & /*name*/ 131072) {
				attr_dev(input, "name", /*name*/ ctx[17]);
			}

			if (!current || dirty[0] & /*checked*/ 65536) {
				prop_dev(input, "checked", /*checked*/ ctx[16]);
			}

			if (!current || dirty[0] & /*readonly*/ 524288) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[19]);
			}

			if (!current || dirty[0] & /*disabled*/ 2097152) {
				prop_dev(input, "disabled", /*disabled*/ ctx[21]);
			}

			if (!current || dirty[0] & /*required*/ 1048576) {
				prop_dev(input, "required", /*required*/ ctx[20]);
			}

			if (!current || dirty[0] & /*radio*/ 32768 && input_type_value !== (input_type_value = /*radio*/ ctx[15] ? "radio" : "checkbox")) {
				attr_dev(input, "type", input_type_value);
			}

			if (!current || dirty[0] & /*radio*/ 32768 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[15] ? "radio" : "checkbox"}`)) {
				attr_dev(i, "class", i_class_value);
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_106(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(label, t4);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_4, get_inner_start_slot_context_4);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_9(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(div, t6);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_4, get_inner_end_slot_context_4);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_4, get_content_slot_context_4);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_4, get_content_end_slot_context_4);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(label, "class", /*contentClasses*/ ctx[32]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			/*input_binding_1*/ ctx[76](null);
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div_binding_1*/ ctx[77](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_88.name,
		type: "if",
		source: "(852:8) {#if checkbox || radio}",
		ctx
	});

	return block;
}

// (979:12) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_128(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$a, 979, 14, 35841);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_128.name,
		type: "if",
		source: "(979:12) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (982:12) {#if hasMedia}
function create_if_block_126(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_127(ctx);
	const media_slot_template = /*$$slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$a, 982, 14, 35933);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_127(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_5, get_media_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_126.name,
		type: "if",
		source: "(982:12) {#if hasMedia}",
		ctx
	});

	return block;
}

// (984:16) {#if typeof media !== 'undefined'}
function create_if_block_127(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$a, 984, 18, 36027);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_127.name,
		type: "if",
		source: "(984:16) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (1044:14) {:else}
function create_else_block_10(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_11);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_123(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_11);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_120(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_11);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_119(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_11, get_before_title_slot_context_11);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_123(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_11, get_after_title_slot_context_11);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_120(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_11, get_inner_slot_context_11);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_119(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_10.name,
		type: "else",
		source: "(1044:14) {:else}",
		ctx
	});

	return block;
}

// (992:14) {#if isMedia}
function create_if_block_109(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_118(ctx);
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_10);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_117(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_10);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_114(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_113(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_112(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_10);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_111(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_110(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty$1();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$a, 998, 16, 36496);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_118(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_10, get_before_title_slot_context_10);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_117(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_10, get_after_title_slot_context_10);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_114(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_113(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_112(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_10, get_inner_slot_context_10);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_111(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_110(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_109.name,
		type: "if",
		source: "(992:14) {#if isMedia}",
		ctx
	});

	return block;
}

// (1046:16) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_123(ctx) {
	let div;
	let t0;
	let t1_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_125(ctx);
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_11);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_124(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text$1(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 1046, 18, 38337);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_125(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_11, get_title_slot_context_11);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_124(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_123.name,
		type: "if",
		source: "(1046:16) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (1048:20) {#if hasHeader}
function create_if_block_125(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_11);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 1048, 22, 38420);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_11, get_header_slot_context_11);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_125.name,
		type: "if",
		source: "(1048:20) {#if hasHeader}",
		ctx
	});

	return block;
}

// (1056:20) {#if hasFooter}
function create_if_block_124(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_11);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 1056, 22, 38733);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_11, get_footer_slot_context_11);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_124.name,
		type: "if",
		source: "(1056:20) {#if hasFooter}",
		ctx
	});

	return block;
}

// (1065:16) {#if hasAfter}
function create_if_block_120(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_11);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_122(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_121(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_11);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_11);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 1065, 18, 39046);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_11, get_after_start_slot_context_11);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_122(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_121(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_11, get_after_slot_context_11);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_11, get_after_end_slot_context_11);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_120.name,
		type: "if",
		source: "(1065:16) {#if hasAfter}",
		ctx
	});

	return block;
}

// (1068:20) {#if typeof after !== 'undefined'}
function create_if_block_122(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 1068, 22, 39196);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_122.name,
		type: "if",
		source: "(1068:20) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (1071:20) {#if typeof badge !== 'undefined'}
function create_if_block_121(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_121.name,
		type: "if",
		source: "(1071:20) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (1072:22) <Badge color={badgeColor}>
function create_default_slot_11(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(1072:22) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (1079:16) {#if !(swipeout || accordionItem)}
function create_if_block_119(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_119.name,
		type: "if",
		source: "(1079:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (993:16) {#if hasHeader}
function create_if_block_118(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_10);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 993, 18, 36323);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_10, get_header_slot_context_10);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_118.name,
		type: "if",
		source: "(993:16) {#if hasHeader}",
		ctx
	});

	return block;
}

// (1001:18) {#if (hasTitle)}
function create_if_block_117(ctx) {
	let div;
	let t0_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_10);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 1001, 20, 36627);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_10, get_title_slot_context_10);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_117.name,
		type: "if",
		source: "(1001:18) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (1008:18) {#if hasAfter}
function create_if_block_114(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_10);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_116(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_115(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_10);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_10);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 1008, 20, 36888);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_10, get_after_start_slot_context_10);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_116(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_115(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_10, get_after_slot_context_10);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_10, get_after_end_slot_context_10);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_114.name,
		type: "if",
		source: "(1008:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (1011:22) {#if typeof after !== 'undefined'}
function create_if_block_116(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 1011, 24, 37044);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_116.name,
		type: "if",
		source: "(1011:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (1014:22) {#if typeof badge !== 'undefined'}
function create_if_block_115(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_115.name,
		type: "if",
		source: "(1014:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (1015:24) <Badge color={badgeColor}>
function create_default_slot_10(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(1015:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (1022:16) {#if hasSubtitle}
function create_if_block_113(ctx) {
	let div;
	let t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*$$slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$a, 1022, 18, 37486);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_5, get_subtitle_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_113.name,
		type: "if",
		source: "(1022:16) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (1028:16) {#if hasText}
function create_if_block_112(ctx) {
	let div;
	let t0_value = Utils$1.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*$$slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$a, 1028, 18, 37697);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_5, get_text_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_112.name,
		type: "if",
		source: "(1028:16) {#if hasText}",
		ctx
	});

	return block;
}

// (1035:16) {#if !(swipeout || accordionItem)}
function create_if_block_111(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_111.name,
		type: "if",
		source: "(1035:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (1038:16) {#if hasFooter}
function create_if_block_110(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_10);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 1038, 18, 38036);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_10, get_footer_slot_context_10);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_110.name,
		type: "if",
		source: "(1038:16) {#if hasFooter}",
		ctx
	});

	return block;
}

// (855:12) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_108(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$a, 855, 14, 31173);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_108.name,
		type: "if",
		source: "(855:12) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (870:12) {#if hasMedia}
function create_if_block_106(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_107(ctx);
	const media_slot_template = /*$$slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$a, 870, 14, 31712);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_107(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_4, get_media_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_106.name,
		type: "if",
		source: "(870:12) {#if hasMedia}",
		ctx
	});

	return block;
}

// (872:16) {#if typeof media !== 'undefined'}
function create_if_block_107(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$a, 872, 18, 31806);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_107.name,
		type: "if",
		source: "(872:16) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (932:14) {:else}
function create_else_block_8(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_9);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_103(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_9);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_100(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_9);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_99(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_9, get_before_title_slot_context_9);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_103(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_9, get_after_title_slot_context_9);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_100(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_9, get_inner_slot_context_9);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_99(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_8.name,
		type: "else",
		source: "(932:14) {:else}",
		ctx
	});

	return block;
}

// (880:14) {#if isMedia}
function create_if_block_89(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_98(ctx);
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_8);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_97(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_8);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_94(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_93(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_92(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_8);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_91(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_90(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty$1();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$a, 886, 16, 32275);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_98(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_8, get_before_title_slot_context_8);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_97(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_8, get_after_title_slot_context_8);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_94(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_93(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_92(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_8, get_inner_slot_context_8);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_91(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_90(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_89.name,
		type: "if",
		source: "(880:14) {#if isMedia}",
		ctx
	});

	return block;
}

// (934:16) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_103(ctx) {
	let div;
	let t0;
	let t1_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_105(ctx);
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_9);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_104(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text$1(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 934, 18, 34116);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_105(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_9, get_title_slot_context_9);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_104(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_103.name,
		type: "if",
		source: "(934:16) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (936:20) {#if hasHeader}
function create_if_block_105(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_9);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 936, 22, 34199);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_9, get_header_slot_context_9);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_105.name,
		type: "if",
		source: "(936:20) {#if hasHeader}",
		ctx
	});

	return block;
}

// (944:20) {#if hasFooter}
function create_if_block_104(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_9);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 944, 22, 34512);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_9, get_footer_slot_context_9);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_104.name,
		type: "if",
		source: "(944:20) {#if hasFooter}",
		ctx
	});

	return block;
}

// (953:16) {#if hasAfter}
function create_if_block_100(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_9);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_102(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_101(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_9);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_9);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 953, 18, 34825);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_9, get_after_start_slot_context_9);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_102(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_101(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_9, get_after_slot_context_9);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_9, get_after_end_slot_context_9);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_100.name,
		type: "if",
		source: "(953:16) {#if hasAfter}",
		ctx
	});

	return block;
}

// (956:20) {#if typeof after !== 'undefined'}
function create_if_block_102(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 956, 22, 34975);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_102.name,
		type: "if",
		source: "(956:20) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (959:20) {#if typeof badge !== 'undefined'}
function create_if_block_101(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_101.name,
		type: "if",
		source: "(959:20) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (960:22) <Badge color={badgeColor}>
function create_default_slot_9(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(960:22) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (967:16) {#if !(swipeout || accordionItem)}
function create_if_block_99(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_99.name,
		type: "if",
		source: "(967:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (881:16) {#if hasHeader}
function create_if_block_98(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_8);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 881, 18, 32102);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_8, get_header_slot_context_8);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_98.name,
		type: "if",
		source: "(881:16) {#if hasHeader}",
		ctx
	});

	return block;
}

// (889:18) {#if (hasTitle)}
function create_if_block_97(ctx) {
	let div;
	let t0_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_8);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 889, 20, 32406);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_8, get_title_slot_context_8);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_97.name,
		type: "if",
		source: "(889:18) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (896:18) {#if hasAfter}
function create_if_block_94(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_8);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_96(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_95(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_8);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_8);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 896, 20, 32667);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_8, get_after_start_slot_context_8);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_96(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_95(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_8, get_after_slot_context_8);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_8, get_after_end_slot_context_8);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_94.name,
		type: "if",
		source: "(896:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (899:22) {#if typeof after !== 'undefined'}
function create_if_block_96(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 899, 24, 32823);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_96.name,
		type: "if",
		source: "(899:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (902:22) {#if typeof badge !== 'undefined'}
function create_if_block_95(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_95.name,
		type: "if",
		source: "(902:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (903:24) <Badge color={badgeColor}>
function create_default_slot_8(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(903:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (910:16) {#if hasSubtitle}
function create_if_block_93(ctx) {
	let div;
	let t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*$$slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$a, 910, 18, 33265);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_4, get_subtitle_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_93.name,
		type: "if",
		source: "(910:16) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (916:16) {#if hasText}
function create_if_block_92(ctx) {
	let div;
	let t0_value = Utils$1.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*$$slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$a, 916, 18, 33476);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_4, get_text_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_92.name,
		type: "if",
		source: "(916:16) {#if hasText}",
		ctx
	});

	return block;
}

// (923:16) {#if !(swipeout || accordionItem)}
function create_if_block_91(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_91.name,
		type: "if",
		source: "(923:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (926:16) {#if hasFooter}
function create_if_block_90(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_8);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 926, 18, 33815);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_8, get_footer_slot_context_8);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_90.name,
		type: "if",
		source: "(926:16) {#if hasFooter}",
		ctx
	});

	return block;
}

// (739:12) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_87(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$a, 739, 14, 26837);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_87.name,
		type: "if",
		source: "(739:12) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (742:12) {#if hasMedia}
function create_if_block_85(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_86(ctx);
	const media_slot_template = /*$$slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$a, 742, 14, 26929);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_86(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_3, get_media_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_85.name,
		type: "if",
		source: "(742:12) {#if hasMedia}",
		ctx
	});

	return block;
}

// (744:16) {#if typeof media !== 'undefined'}
function create_if_block_86(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$a, 744, 18, 27023);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_86.name,
		type: "if",
		source: "(744:16) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (804:14) {:else}
function create_else_block_6(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_7);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_82(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_7);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_79(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_7);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_78(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_7, get_before_title_slot_context_7);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_82(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_7, get_after_title_slot_context_7);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_79(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_7, get_inner_slot_context_7);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_78(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_6.name,
		type: "else",
		source: "(804:14) {:else}",
		ctx
	});

	return block;
}

// (752:14) {#if isMedia}
function create_if_block_68(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_77(ctx);
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_6);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_76(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_6);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_73(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_72(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_71(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_6);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_70(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_69(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty$1();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$a, 758, 16, 27492);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_77(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_6, get_before_title_slot_context_6);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_76(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_6, get_after_title_slot_context_6);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_73(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_72(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_71(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_6, get_inner_slot_context_6);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_70(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_69(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_68.name,
		type: "if",
		source: "(752:14) {#if isMedia}",
		ctx
	});

	return block;
}

// (806:16) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_82(ctx) {
	let div;
	let t0;
	let t1_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_84(ctx);
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_7);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_83(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text$1(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 806, 18, 29333);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_84(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_7, get_title_slot_context_7);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_83(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_82.name,
		type: "if",
		source: "(806:16) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (808:20) {#if hasHeader}
function create_if_block_84(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_7);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 808, 22, 29416);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_7, get_header_slot_context_7);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_84.name,
		type: "if",
		source: "(808:20) {#if hasHeader}",
		ctx
	});

	return block;
}

// (816:20) {#if hasFooter}
function create_if_block_83(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_7);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 816, 22, 29729);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_7, get_footer_slot_context_7);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_83.name,
		type: "if",
		source: "(816:20) {#if hasFooter}",
		ctx
	});

	return block;
}

// (825:16) {#if hasAfter}
function create_if_block_79(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_7);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_81(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_80(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_7);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_7);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 825, 18, 30042);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_7, get_after_start_slot_context_7);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_81(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_80(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_7, get_after_slot_context_7);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_7, get_after_end_slot_context_7);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_79.name,
		type: "if",
		source: "(825:16) {#if hasAfter}",
		ctx
	});

	return block;
}

// (828:20) {#if typeof after !== 'undefined'}
function create_if_block_81(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 828, 22, 30192);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_81.name,
		type: "if",
		source: "(828:20) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (831:20) {#if typeof badge !== 'undefined'}
function create_if_block_80(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_80.name,
		type: "if",
		source: "(831:20) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (832:22) <Badge color={badgeColor}>
function create_default_slot_7(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(832:22) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (839:16) {#if !(swipeout || accordionItem)}
function create_if_block_78(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_78.name,
		type: "if",
		source: "(839:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (753:16) {#if hasHeader}
function create_if_block_77(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_6);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 753, 18, 27319);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_6, get_header_slot_context_6);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_77.name,
		type: "if",
		source: "(753:16) {#if hasHeader}",
		ctx
	});

	return block;
}

// (761:18) {#if (hasTitle)}
function create_if_block_76(ctx) {
	let div;
	let t0_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_6);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 761, 20, 27623);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_6, get_title_slot_context_6);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_76.name,
		type: "if",
		source: "(761:18) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (768:18) {#if hasAfter}
function create_if_block_73(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_6);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_75(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_74(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_6);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_6);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 768, 20, 27884);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_6, get_after_start_slot_context_6);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_75(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_74(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_6, get_after_slot_context_6);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_6, get_after_end_slot_context_6);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_73.name,
		type: "if",
		source: "(768:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (771:22) {#if typeof after !== 'undefined'}
function create_if_block_75(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 771, 24, 28040);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_75.name,
		type: "if",
		source: "(771:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (774:22) {#if typeof badge !== 'undefined'}
function create_if_block_74(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_74.name,
		type: "if",
		source: "(774:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (775:24) <Badge color={badgeColor}>
function create_default_slot_6(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(775:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (782:16) {#if hasSubtitle}
function create_if_block_72(ctx) {
	let div;
	let t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*$$slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$a, 782, 18, 28482);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_3, get_subtitle_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_72.name,
		type: "if",
		source: "(782:16) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (788:16) {#if hasText}
function create_if_block_71(ctx) {
	let div;
	let t0_value = Utils$1.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*$$slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$a, 788, 18, 28693);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_3, get_text_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_71.name,
		type: "if",
		source: "(788:16) {#if hasText}",
		ctx
	});

	return block;
}

// (795:16) {#if !(swipeout || accordionItem)}
function create_if_block_70(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_70.name,
		type: "if",
		source: "(795:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (798:16) {#if hasFooter}
function create_if_block_69(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_6);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 798, 18, 29032);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_6, get_footer_slot_context_6);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_69.name,
		type: "if",
		source: "(798:16) {#if hasFooter}",
		ctx
	});

	return block;
}

// (491:8) {:else}
function create_else_block_2$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_26, create_else_block_4];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (/*checkbox*/ ctx[14] || /*radio*/ ctx[15]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_4(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$1.name,
		type: "else",
		source: "(491:8) {:else}",
		ctx
	});

	return block;
}

// (375:8) {#if isLink}
function create_if_block_5$1(ctx) {
	let a;
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*$$slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context$1);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_25(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_23$1(ctx);
	const inner_start_slot_template = /*$$slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context$1);
	const if_block_creators = [create_if_block_6$1, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*$$slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context$1);
	const content_slot_template = /*$$slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context$1);
	const content_end_slot_template = /*$$slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context$1);
	let a_levels = [{ class: /*linkClasses*/ ctx[33] }, /*linkAttrs*/ ctx[34]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", "item-inner");
			add_location(div0, file$a, 390, 14, 13059);
			attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			add_location(div1, file$a, 377, 12, 12558);
			set_attributes(a, a_data);
			add_location(a, file$a, 375, 10, 12429);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_dev(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[69](div0);
			append_dev(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			/*a_binding*/ ctx[70](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes$1, get_content_start_slot_context$1);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_25(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_23$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes$1, get_inner_start_slot_context$1);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes$1, get_inner_end_slot_context$1);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes$1, get_content_slot_context$1);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes$1, get_content_end_slot_context$1);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[1] & /*linkClasses*/ 4) && { class: /*linkClasses*/ ctx[33] },
				dirty[1] & /*linkAttrs*/ 8 && /*linkAttrs*/ ctx[34]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding*/ ctx[69](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			/*a_binding*/ ctx[70](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$1.name,
		type: "if",
		source: "(375:8) {#if isLink}",
		ctx
	});

	return block;
}

// (617:10) {:else}
function create_else_block_4(ctx) {
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*$$slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_2);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_66(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_64(ctx);
	const inner_start_slot_template = /*$$slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_2);
	const if_block_creators = [create_if_block_47, create_else_block_5];
	const if_blocks = [];

	function select_block_type_6(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_6(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*$$slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_2);
	const content_slot_template = /*$$slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_2);
	const content_end_slot_template = /*$$slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_2);

	const block = {
		c: function create() {
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", "item-inner");
			add_location(div0, file$a, 630, 14, 22543);
			attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			add_location(div1, file$a, 617, 12, 22023);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_dev(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding_1*/ ctx[73](div0);
			append_dev(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div1, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_2, get_content_start_slot_context_2);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_66(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_64(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_2, get_inner_start_slot_context_2);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_6(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_2, get_inner_end_slot_context_2);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_2, get_content_slot_context_2);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_2, get_content_end_slot_context_2);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding_1*/ ctx[73](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_4.name,
		type: "else",
		source: "(617:10) {:else}",
		ctx
	});

	return block;
}

// (493:10) {#if checkbox || radio}
function create_if_block_26(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let input_value_value;
	let input_type_value;
	let t2;
	let i;
	let i_class_value;
	let t3;
	let t4;
	let div;
	let t5;
	let current_block_type_index;
	let if_block2;
	let t6;
	let t7;
	let t8;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*$$slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_1$1);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_46(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_44(ctx);
	const inner_start_slot_template = /*$$slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_1$1);
	const if_block_creators = [create_if_block_27, create_else_block_3];
	const if_blocks = [];

	function select_block_type_5(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_5(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*$$slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_1$1);
	const content_slot_template = /*$$slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_1$1);
	const content_end_slot_template = /*$$slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_1$1);

	const block = {
		c: function create() {
			label = element("label");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			i = element("i");
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			div = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t5 = space();
			if_block2.c();
			t6 = space();
			if (inner_end_slot) inner_end_slot.c();
			t7 = space();
			if (content_slot) content_slot.c();
			t8 = space();
			if (content_end_slot) content_end_slot.c();

			input.value = input_value_value = typeof /*value*/ ctx[18] === "undefined"
			? ""
			: /*value*/ ctx[18];

			attr_dev(input, "name", /*name*/ ctx[17]);
			input.checked = /*checked*/ ctx[16];
			input.readOnly = /*readonly*/ ctx[19];
			input.disabled = /*disabled*/ ctx[21];
			input.required = /*required*/ ctx[20];
			attr_dev(input, "type", input_type_value = /*radio*/ ctx[15] ? "radio" : "checkbox");
			add_location(input, file$a, 498, 14, 17357);
			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[15] ? "radio" : "checkbox"}`);
			add_location(i, file$a, 509, 14, 17756);
			attr_dev(div, "class", "item-inner");
			add_location(div, file$a, 518, 14, 18098);
			attr_dev(label, "class", /*contentClasses*/ ctx[32]);
			add_location(label, file$a, 493, 12, 17105);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (content_start_slot) {
				content_start_slot.m(label, null);
			}

			append_dev(label, t0);
			if (if_block0) if_block0.m(label, null);
			append_dev(label, t1);
			append_dev(label, input);
			/*input_binding*/ ctx[71](input);
			append_dev(label, t2);
			append_dev(label, i);
			append_dev(label, t3);
			if (if_block1) if_block1.m(label, null);
			append_dev(label, t4);
			append_dev(label, div);

			if (inner_start_slot) {
				inner_start_slot.m(div, null);
			}

			append_dev(div, t5);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t6);

			if (inner_end_slot) {
				inner_end_slot.m(div, null);
			}

			/*div_binding*/ ctx[72](div);
			append_dev(label, t7);

			if (content_slot) {
				content_slot.m(label, null);
			}

			append_dev(label, t8);

			if (content_end_slot) {
				content_end_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*onChange*/ ctx[44], false, false, false),
					listen_dev(label, "click", /*onClick*/ ctx[43], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_1$1, get_content_start_slot_context_1$1);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_46(ctx);
					if_block0.c();
					if_block0.m(label, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty[0] & /*value*/ 262144 && input_value_value !== (input_value_value = typeof /*value*/ ctx[18] === "undefined"
			? ""
			: /*value*/ ctx[18]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty[0] & /*name*/ 131072) {
				attr_dev(input, "name", /*name*/ ctx[17]);
			}

			if (!current || dirty[0] & /*checked*/ 65536) {
				prop_dev(input, "checked", /*checked*/ ctx[16]);
			}

			if (!current || dirty[0] & /*readonly*/ 524288) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[19]);
			}

			if (!current || dirty[0] & /*disabled*/ 2097152) {
				prop_dev(input, "disabled", /*disabled*/ ctx[21]);
			}

			if (!current || dirty[0] & /*required*/ 1048576) {
				prop_dev(input, "required", /*required*/ ctx[20]);
			}

			if (!current || dirty[0] & /*radio*/ 32768 && input_type_value !== (input_type_value = /*radio*/ ctx[15] ? "radio" : "checkbox")) {
				attr_dev(input, "type", input_type_value);
			}

			if (!current || dirty[0] & /*radio*/ 32768 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[15] ? "radio" : "checkbox"}`)) {
				attr_dev(i, "class", i_class_value);
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_44(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(label, t4);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_1$1, get_inner_start_slot_context_1$1);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_5(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(div, t6);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_1$1, get_inner_end_slot_context_1$1);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_1$1, get_content_slot_context_1$1);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_1$1, get_content_end_slot_context_1$1);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(label, "class", /*contentClasses*/ ctx[32]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			/*input_binding*/ ctx[71](null);
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div_binding*/ ctx[72](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_26.name,
		type: "if",
		source: "(493:10) {#if checkbox || radio}",
		ctx
	});

	return block;
}

// (620:14) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_66(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$a, 620, 16, 22206);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_66.name,
		type: "if",
		source: "(620:14) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (623:14) {#if hasMedia}
function create_if_block_64(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_65(ctx);
	const media_slot_template = /*$$slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$a, 623, 16, 22304);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_65(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_2, get_media_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_64.name,
		type: "if",
		source: "(623:14) {#if hasMedia}",
		ctx
	});

	return block;
}

// (625:18) {#if typeof media !== 'undefined'}
function create_if_block_65(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$a, 625, 20, 22402);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_65.name,
		type: "if",
		source: "(625:18) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (685:16) {:else}
function create_else_block_5(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_5);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_61(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_5);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_58(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_5);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_57(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_5, get_before_title_slot_context_5);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_61(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_5, get_after_title_slot_context_5);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_58(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_5, get_inner_slot_context_5);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_57(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_5.name,
		type: "else",
		source: "(685:16) {:else}",
		ctx
	});

	return block;
}

// (633:16) {#if isMedia}
function create_if_block_47(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_56(ctx);
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_4);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_55(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_4);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_52(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_51(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_50(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_4);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_49(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_48(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty$1();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$a, 639, 18, 22899);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_56(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_4, get_before_title_slot_context_4);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_55(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_4, get_after_title_slot_context_4);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_52(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_51(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_50(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_4, get_inner_slot_context_4);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_49(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_48(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_47.name,
		type: "if",
		source: "(633:16) {#if isMedia}",
		ctx
	});

	return block;
}

// (687:18) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_61(ctx) {
	let div;
	let t0;
	let t1_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_63(ctx);
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_5);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_62(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text$1(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 687, 20, 24836);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_63(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_5, get_title_slot_context_5);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_62(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_61.name,
		type: "if",
		source: "(687:18) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (689:22) {#if hasHeader}
function create_if_block_63(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 689, 24, 24923);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_5, get_header_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_63.name,
		type: "if",
		source: "(689:22) {#if hasHeader}",
		ctx
	});

	return block;
}

// (697:22) {#if hasFooter}
function create_if_block_62(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 697, 24, 25252);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_5, get_footer_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_62.name,
		type: "if",
		source: "(697:22) {#if hasFooter}",
		ctx
	});

	return block;
}

// (706:18) {#if hasAfter}
function create_if_block_58(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_5);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_60(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_59(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_5);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 706, 20, 25583);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_5, get_after_start_slot_context_5);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_60(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_59(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_5, get_after_slot_context_5);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_5, get_after_end_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_58.name,
		type: "if",
		source: "(706:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (709:22) {#if typeof after !== 'undefined'}
function create_if_block_60(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 709, 24, 25739);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_60.name,
		type: "if",
		source: "(709:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (712:22) {#if typeof badge !== 'undefined'}
function create_if_block_59(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_59.name,
		type: "if",
		source: "(712:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (713:24) <Badge color={badgeColor}>
function create_default_slot_5(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(713:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (720:18) {#if !(swipeout || accordionItem)}
function create_if_block_57(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_57.name,
		type: "if",
		source: "(720:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (634:18) {#if hasHeader}
function create_if_block_56(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 634, 20, 22716);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_4, get_header_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_56.name,
		type: "if",
		source: "(634:18) {#if hasHeader}",
		ctx
	});

	return block;
}

// (642:20) {#if (hasTitle)}
function create_if_block_55(ctx) {
	let div;
	let t0_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 642, 22, 23036);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_4, get_title_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_55.name,
		type: "if",
		source: "(642:20) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (649:20) {#if hasAfter}
function create_if_block_52(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_4);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_54(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_53(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_4);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 649, 22, 23311);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_4, get_after_start_slot_context_4);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_54(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_53(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_4, get_after_slot_context_4);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_4, get_after_end_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_52.name,
		type: "if",
		source: "(649:20) {#if hasAfter}",
		ctx
	});

	return block;
}

// (652:24) {#if typeof after !== 'undefined'}
function create_if_block_54(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 652, 26, 23473);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_54.name,
		type: "if",
		source: "(652:24) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (655:24) {#if typeof badge !== 'undefined'}
function create_if_block_53(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_53.name,
		type: "if",
		source: "(655:24) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (656:26) <Badge color={badgeColor}>
function create_default_slot_4(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(656:26) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (663:18) {#if hasSubtitle}
function create_if_block_51(ctx) {
	let div;
	let t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*$$slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$a, 663, 20, 23937);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_2, get_subtitle_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_51.name,
		type: "if",
		source: "(663:18) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (669:18) {#if hasText}
function create_if_block_50(ctx) {
	let div;
	let t0_value = Utils$1.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*$$slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$a, 669, 20, 24160);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_2, get_text_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_50.name,
		type: "if",
		source: "(669:18) {#if hasText}",
		ctx
	});

	return block;
}

// (676:18) {#if !(swipeout || accordionItem)}
function create_if_block_49(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_49.name,
		type: "if",
		source: "(676:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (679:18) {#if hasFooter}
function create_if_block_48(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 679, 20, 24519);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_4, get_footer_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_48.name,
		type: "if",
		source: "(679:18) {#if hasFooter}",
		ctx
	});

	return block;
}

// (496:14) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_46(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$a, 496, 16, 17290);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_46.name,
		type: "if",
		source: "(496:14) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (511:14) {#if hasMedia}
function create_if_block_44(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_45(ctx);
	const media_slot_template = /*$$slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_1$1);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$a, 511, 16, 17859);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_45(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_1$1, get_media_slot_context_1$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_44.name,
		type: "if",
		source: "(511:14) {#if hasMedia}",
		ctx
	});

	return block;
}

// (513:18) {#if typeof media !== 'undefined'}
function create_if_block_45(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$a, 513, 20, 17957);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_45.name,
		type: "if",
		source: "(513:18) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (573:16) {:else}
function create_else_block_3(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_3);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_41(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_3);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_38(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_3);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_37(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_3, get_before_title_slot_context_3);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_41(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_3, get_after_title_slot_context_3);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_38(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_3, get_inner_slot_context_3);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_37(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3.name,
		type: "else",
		source: "(573:16) {:else}",
		ctx
	});

	return block;
}

// (521:16) {#if isMedia}
function create_if_block_27(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_36(ctx);
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_2);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_35(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_2);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_32(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_31(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_30(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_2);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_29(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_28(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty$1();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$a, 527, 18, 18454);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_36(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_2, get_before_title_slot_context_2);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_35(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_2, get_after_title_slot_context_2);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_32(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_31(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_30(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_2, get_inner_slot_context_2);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_29(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_28(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_27.name,
		type: "if",
		source: "(521:16) {#if isMedia}",
		ctx
	});

	return block;
}

// (575:18) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_41(ctx) {
	let div;
	let t0;
	let t1_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_43(ctx);
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_3);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_42(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text$1(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 575, 20, 20391);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_43(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_3, get_title_slot_context_3);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_42(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_41.name,
		type: "if",
		source: "(575:18) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (577:22) {#if hasHeader}
function create_if_block_43(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 577, 24, 20478);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_3, get_header_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_43.name,
		type: "if",
		source: "(577:22) {#if hasHeader}",
		ctx
	});

	return block;
}

// (585:22) {#if hasFooter}
function create_if_block_42(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 585, 24, 20807);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_3, get_footer_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_42.name,
		type: "if",
		source: "(585:22) {#if hasFooter}",
		ctx
	});

	return block;
}

// (594:18) {#if hasAfter}
function create_if_block_38(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_3);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_40(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_39(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_3);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 594, 20, 21138);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_3, get_after_start_slot_context_3);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_40(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_39(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_3, get_after_slot_context_3);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_3, get_after_end_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_38.name,
		type: "if",
		source: "(594:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (597:22) {#if typeof after !== 'undefined'}
function create_if_block_40(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 597, 24, 21294);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_40.name,
		type: "if",
		source: "(597:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (600:22) {#if typeof badge !== 'undefined'}
function create_if_block_39(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_39.name,
		type: "if",
		source: "(600:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (601:24) <Badge color={badgeColor}>
function create_default_slot_3(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(601:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (608:18) {#if !(swipeout || accordionItem)}
function create_if_block_37(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_37.name,
		type: "if",
		source: "(608:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (522:18) {#if hasHeader}
function create_if_block_36(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 522, 20, 18271);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_2, get_header_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_36.name,
		type: "if",
		source: "(522:18) {#if hasHeader}",
		ctx
	});

	return block;
}

// (530:20) {#if (hasTitle)}
function create_if_block_35(ctx) {
	let div;
	let t0_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 530, 22, 18591);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_2, get_title_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_35.name,
		type: "if",
		source: "(530:20) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (537:20) {#if hasAfter}
function create_if_block_32(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_2);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_34(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_33(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_2);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 537, 22, 18866);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_2, get_after_start_slot_context_2);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_34(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_33(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_2, get_after_slot_context_2);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_2, get_after_end_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_32.name,
		type: "if",
		source: "(537:20) {#if hasAfter}",
		ctx
	});

	return block;
}

// (540:24) {#if typeof after !== 'undefined'}
function create_if_block_34(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 540, 26, 19028);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_34.name,
		type: "if",
		source: "(540:24) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (543:24) {#if typeof badge !== 'undefined'}
function create_if_block_33(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_33.name,
		type: "if",
		source: "(543:24) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (544:26) <Badge color={badgeColor}>
function create_default_slot_2$1(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(544:26) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (551:18) {#if hasSubtitle}
function create_if_block_31(ctx) {
	let div;
	let t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*$$slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$a, 551, 20, 19492);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_1, get_subtitle_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_31.name,
		type: "if",
		source: "(551:18) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (557:18) {#if hasText}
function create_if_block_30(ctx) {
	let div;
	let t0_value = Utils$1.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*$$slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$a, 557, 20, 19715);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_1, get_text_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_30.name,
		type: "if",
		source: "(557:18) {#if hasText}",
		ctx
	});

	return block;
}

// (564:18) {#if !(swipeout || accordionItem)}
function create_if_block_29(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_29.name,
		type: "if",
		source: "(564:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (567:18) {#if hasFooter}
function create_if_block_28(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 567, 20, 20074);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_2, get_footer_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_28.name,
		type: "if",
		source: "(567:18) {#if hasFooter}",
		ctx
	});

	return block;
}

// (380:14) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_25(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$a, 380, 16, 12722);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_25.name,
		type: "if",
		source: "(380:14) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (383:14) {#if hasMedia}
function create_if_block_23$1(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_24(ctx);
	const media_slot_template = /*$$slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context$1);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$a, 383, 16, 12820);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_24(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes$1, get_media_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_23$1.name,
		type: "if",
		source: "(383:14) {#if hasMedia}",
		ctx
	});

	return block;
}

// (385:18) {#if typeof media !== 'undefined'}
function create_if_block_24(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$a, 385, 20, 12918);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_24.name,
		type: "if",
		source: "(385:18) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (445:16) {:else}
function create_else_block_1$1(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_1);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_20$1(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_1);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_17$1(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_1$1);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_16$1(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_1, get_before_title_slot_context_1);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_20$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_1, get_after_title_slot_context_1);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_17$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_1$1, get_inner_slot_context_1$1);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_16$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(445:16) {:else}",
		ctx
	});

	return block;
}

// (393:16) {#if isMedia}
function create_if_block_6$1(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_15$1(ctx);
	const before_title_slot_template = /*$$slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_14$1(ctx);
	const after_title_slot_template = /*$$slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_11$1(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_10$1(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_9$1(ctx);
	const inner_slot_template = /*$$slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context$1);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_8$1(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_7$1(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty$1();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$a, 399, 18, 13415);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_15$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes, get_before_title_slot_context);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_14$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes, get_after_title_slot_context);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_11$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_10$1(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_9$1(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes$1, get_inner_slot_context$1);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_8$1(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_7$1(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$1.name,
		type: "if",
		source: "(393:16) {#if isMedia}",
		ctx
	});

	return block;
}

// (447:18) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_20$1(ctx) {
	let div;
	let t0;
	let t1_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_22$1(ctx);
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_1);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_21$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text$1(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 447, 20, 15352);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_22$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_1, get_title_slot_context_1);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_21$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_20$1.name,
		type: "if",
		source: "(447:18) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (449:22) {#if hasHeader}
function create_if_block_22$1(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 449, 24, 15439);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_1, get_header_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_22$1.name,
		type: "if",
		source: "(449:22) {#if hasHeader}",
		ctx
	});

	return block;
}

// (457:22) {#if hasFooter}
function create_if_block_21$1(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 457, 24, 15768);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_1, get_footer_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_21$1.name,
		type: "if",
		source: "(457:22) {#if hasFooter}",
		ctx
	});

	return block;
}

// (466:18) {#if hasAfter}
function create_if_block_17$1(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_1);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_19$1(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_18$1(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_1);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 466, 20, 16099);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_1, get_after_start_slot_context_1);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_19$1(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_18$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_1, get_after_slot_context_1);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_1, get_after_end_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_17$1.name,
		type: "if",
		source: "(466:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (469:22) {#if typeof after !== 'undefined'}
function create_if_block_19$1(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 469, 24, 16255);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_19$1.name,
		type: "if",
		source: "(469:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (472:22) {#if typeof badge !== 'undefined'}
function create_if_block_18$1(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_18$1.name,
		type: "if",
		source: "(472:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (473:24) <Badge color={badgeColor}>
function create_default_slot_1$1(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(473:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (480:18) {#if !(swipeout || accordionItem)}
function create_if_block_16$1(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_16$1.name,
		type: "if",
		source: "(480:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (394:18) {#if hasHeader}
function create_if_block_15$1(ctx) {
	let div;
	let t0_value = Utils$1.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*$$slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$a, 394, 20, 13232);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes, get_header_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_15$1.name,
		type: "if",
		source: "(394:18) {#if hasHeader}",
		ctx
	});

	return block;
}

// (402:20) {#if (hasTitle)}
function create_if_block_14$1(ctx) {
	let div;
	let t0_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*$$slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$a, 402, 22, 13552);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes, get_title_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_14$1.name,
		type: "if",
		source: "(402:20) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (409:20) {#if hasAfter}
function create_if_block_11$1(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*$$slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_13$1(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_12$1(ctx);
	const after_slot_template = /*$$slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context);
	const after_end_slot_template = /*$$slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$a, 409, 22, 13827);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes, get_after_start_slot_context);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_13$1(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_12$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes, get_after_slot_context);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes, get_after_end_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11$1.name,
		type: "if",
		source: "(409:20) {#if hasAfter}",
		ctx
	});

	return block;
}

// (412:24) {#if typeof after !== 'undefined'}
function create_if_block_13$1(ctx) {
	let span;
	let t_value = Utils$1.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			add_location(span, file$a, 412, 26, 13989);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13$1.name,
		type: "if",
		source: "(412:24) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (415:24) {#if typeof badge !== 'undefined'}
function create_if_block_12$1(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12$1.name,
		type: "if",
		source: "(415:24) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (416:26) <Badge color={badgeColor}>
function create_default_slot$1(ctx) {
	let t_value = Utils$1.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(416:26) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (423:18) {#if hasSubtitle}
function create_if_block_10$1(ctx) {
	let div;
	let t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*$$slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$a, 423, 20, 14453);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes, get_subtitle_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10$1.name,
		type: "if",
		source: "(423:18) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (429:18) {#if hasText}
function create_if_block_9$1(ctx) {
	let div;
	let t0_value = Utils$1.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*$$slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$a, 429, 20, 14676);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes, get_text_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9$1.name,
		type: "if",
		source: "(429:18) {#if hasText}",
		ctx
	});

	return block;
}

// (436:18) {#if !(swipeout || accordionItem)}
function create_if_block_8$1(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8$1.name,
		type: "if",
		source: "(436:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (439:18) {#if hasFooter}
function create_if_block_7$1(ctx) {
	let div;
	let t0_value = Utils$1.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*$$slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$a, 439, 20, 15035);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes, get_footer_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7$1.name,
		type: "if",
		source: "(439:18) {#if hasFooter}",
		ctx
	});

	return block;
}

// (1092:4) {#if (isSortable && sortable !== false && !isSortableOpposite)}
function create_if_block_3$3(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$a, 1092, 6, 40001);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$3.name,
		type: "if",
		source: "(1092:4) {#if (isSortable && sortable !== false && !isSortableOpposite)}",
		ctx
	});

	return block;
}

// (1095:4) {#if (swipeout || accordionItem)}
function create_if_block_2$3(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(1095:4) {#if (swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (363:16) {Utils.text(title)}
function fallback_block(ctx) {
	let t_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*title*/ 1 && t_value !== (t_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(363:16) {Utils.text(title)}",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$3, create_if_block_1$3, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*divider*/ ctx[9] || /*groupTitle*/ ctx[10]) return 0;
		if (/*isSimple*/ ctx[30]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","title","text","media","subtitle","header","footer","tooltip","tooltipTrigger","link","tabLink","tabLinkActive","href","target","after","badge","badgeColor","mediaItem","mediaList","divider","groupTitle","swipeout","swipeoutOpened","sortable","sortableOpposite","accordionItem","accordionItemOpened","smartSelect","smartSelectParams","noChevron","chevronCenter","checkbox","radio","radioIcon","checked","indeterminate","name","value","readonly","required","disabled","virtualListIndex","smartSelectInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { text = undefined } = $$props;
	let { media = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	let { header = undefined } = $$props;
	let { footer = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { link = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { href = undefined } = $$props;
	let { target = undefined } = $$props;
	let { after = undefined } = $$props;
	let { badge = undefined } = $$props;
	let { badgeColor = undefined } = $$props;
	let { mediaItem = false } = $$props;
	let { mediaList = false } = $$props;
	let { divider = false } = $$props;
	let { groupTitle = false } = $$props;
	let { swipeout = false } = $$props;
	let { swipeoutOpened = false } = $$props;
	let { sortable = undefined } = $$props;
	let { sortableOpposite = undefined } = $$props;
	let { accordionItem = false } = $$props;
	let { accordionItemOpened = false } = $$props;
	let { smartSelect = false } = $$props;
	let { smartSelectParams = undefined } = $$props;
	let { noChevron = undefined } = $$props;
	let { chevronCenter = undefined } = $$props;
	let { checkbox = undefined } = $$props;
	let { radio = undefined } = $$props;
	let { radioIcon = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { indeterminate = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { virtualListIndex = undefined } = $$props;
	let el;
	let linkEl;
	let innerEl;
	let inputEl;
	let f7SmartSelect;
	let f7Tooltip;

	function smartSelectInstance() {
		return f7SmartSelect;
	}

	/* eslint-enable no-undef */
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	let initialWatchedOpened = false;

	function watchSwipeoutOpened(opened) {
		if (!initialWatchedOpened) {
			initialWatchedOpened = true;
			return;
		}

		if (!swipeout) return;

		if (opened) {
			f7.instance.swipeout.open(el);
		} else {
			f7.instance.swipeout.close(el);
		}
	}

	function onClick(event) {
		if (event.target.tagName.toLowerCase() !== "input") {
			dispatch("click", event);
			if (typeof $$props.onClick === "function") $$props.onClick(event);
		}
	}

	function onSwipeoutOverswipeEnter(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutOverswipeEnter");
		if (typeof $$props.onSwipeoutOverswipeEnter === "function") $$props.onSwipeoutOverswipeEnter();
	}

	function onSwipeoutOverswipeExit(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutOverswipeExit");
		if (typeof $$props.onSwipeoutOverswipeExit === "function") $$props.onSwipeoutOverswipeExit();
	}

	function onSwipeoutDeleted(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutDeleted");
		if (typeof $$props.onSwipeoutDeleted === "function") $$props.onSwipeoutDeleted();
	}

	function onSwipeoutDelete(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutDelete");
		if (typeof $$props.onSwipeoutDelete === "function") $$props.onSwipeoutDelete();
	}

	function onSwipeoutClose(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutClose");
		if (typeof $$props.onSwipeoutClose === "function") $$props.onSwipeoutClose();
	}

	function onSwipeoutClosed(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutClosed");
		if (typeof $$props.onSwipeoutClosed === "function") $$props.onSwipeoutClosed();
	}

	function onSwipeoutOpen(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutOpen");
		if (typeof $$props.onSwipeoutOpen === "function") $$props.onSwipeoutOpen();
	}

	function onSwipeoutOpened(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutOpened");
		if (typeof $$props.onSwipeoutOpened === "function") $$props.onSwipeoutOpened();
	}

	function onSwipeout(eventEl, progress) {
		if (eventEl !== el) return;
		dispatch("swipeout", progress);
	}

	function onAccBeforeClose(eventEl, prevent) {
		if (eventEl !== el) return;
		dispatch("accordionBeforeClose", [prevent]);
		if (typeof $$props.onAccordionBeforeClose === "function") $$props.onAccordionBeforeClose(prevent);
	}

	function onAccClose(eventEl) {
		if (eventEl !== el) return;
		dispatch("accordionClose");
		if (typeof $$props.onAccordionClose === "function") $$props.onAccordionClose();
	}

	function onAccClosed(eventEl) {
		if (eventEl !== el) return;
		dispatch("accordionClosed");
		if (typeof $$props.onAccordionClosed === "function") $$props.onAccordionClosed();
	}

	function onAccBeforeOpen(eventEl, prevent) {
		if (eventEl !== el) return;
		dispatch("accordionBeforeOpen", [prevent]);
		if (typeof $$props.onAccordionBeforeOpen === "function") $$props.onAccordionBeforeOpen(prevent);
	}

	function onAccOpen(eventEl) {
		if (eventEl !== el) return;
		dispatch("accordionOpen");
		if (typeof $$props.onAccordionOpen === "function") $$props.onAccordionOpen();
	}

	function onAccOpened(eventEl) {
		if (eventEl !== el) return;
		dispatch("accordionOpened");
		if (typeof $$props.onAccordionOpened === "function") $$props.onAccordionOpened();
	}

	function onChange(event) {
		dispatch("change", [event]);
		if (typeof $$props.onChange === "function") $$props.onChange(event);
	}

	onMount(() => {
		if (linkEl && $$props.routeProps) {
			$$invalidate(24, linkEl.f7RouteProps = $$props.routeProps, linkEl);
		}

		if (indeterminate && inputEl) {
			$$invalidate(26, inputEl.indeterminate = true, inputEl);
		}

		f7.ready(() => {
			if (swipeout) {
				f7.instance.on("swipeoutOpen", onSwipeoutOpen);
				f7.instance.on("swipeoutOpened", onSwipeoutOpened);
				f7.instance.on("swipeoutClose", onSwipeoutClose);
				f7.instance.on("swipeoutClosed", onSwipeoutClosed);
				f7.instance.on("swipeoutDelete", onSwipeoutDelete);
				f7.instance.on("swipeoutDeleted", onSwipeoutDeleted);
				f7.instance.on("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
				f7.instance.on("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
				f7.instance.on("swipeout", onSwipeout);
			}

			if (accordionItem) {
				f7.instance.on("accordionBeforeOpen", onAccBeforeOpen);
				f7.instance.on("accordionOpen", onAccOpen);
				f7.instance.on("accordionOpened", onAccOpened);
				f7.instance.on("accordionBeforeClose", onAccBeforeClose);
				f7.instance.on("accordionClose", onAccClose);
				f7.instance.on("accordionClosed", onAccClosed);
			}

			if (linkEl && smartSelect) {
				const ssParams = Utils$1.extend({ el: linkEl }, smartSelectParams || {});
				f7SmartSelect = f7.instance.smartSelect.create(ssParams);
			}

			if (swipeoutOpened) {
				f7.instance.swipeout.open(el);
			}

			if (tooltip) {
				f7Tooltip = f7.instance.tooltip.create({
					targetEl: el,
					text: tooltip,
					trigger: tooltipTrigger
				});
			}
		});
	});

	afterUpdate(() => {
		if (linkEl && $$props.routeProps) {
			$$invalidate(24, linkEl.f7RouteProps = $$props.routeProps, linkEl);
		}

		if (inputEl) {
			$$invalidate(26, inputEl.indeterminate = indeterminate, inputEl);
		}
	});

	onDestroy(() => {
		if (linkEl) {
			delete linkEl.f7RouteProps;
		}

		if (!f7.instance) return;

		if (swipeout) {
			f7.instance.off("swipeoutOpen", onSwipeoutOpen);
			f7.instance.off("swipeoutOpened", onSwipeoutOpened);
			f7.instance.off("swipeoutClose", onSwipeoutClose);
			f7.instance.off("swipeoutClosed", onSwipeoutClosed);
			f7.instance.off("swipeoutDelete", onSwipeoutDelete);
			f7.instance.off("swipeoutDeleted", onSwipeoutDeleted);
			f7.instance.off("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
			f7.instance.off("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
			f7.instance.off("swipeout", onSwipeout);
		}

		if (accordionItem) {
			f7.instance.off("accordionBeforeOpen", onAccBeforeOpen);
			f7.instance.off("accordionOpen", onAccOpen);
			f7.instance.off("accordionOpened", onAccOpened);
			f7.instance.off("accordionBeforeClose", onAccBeforeClose);
			f7.instance.off("accordionClose", onAccClose);
			f7.instance.off("accordionClosed", onAccClosed);
		}

		if (f7SmartSelect && f7SmartSelect.destroy) {
			f7SmartSelect.destroy();
			f7SmartSelect = null;
		}

		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	validate_slots("List_item", $$slots, [
		'default','root-start','content-start','media','inner-start','header','before-title','title','after-title','after-start','after','after-end','subtitle','text','inner','footer','inner-end','content','content-end','root','root-end'
	]);

	function li_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(23, el);
		});
	}

	function li_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(23, el);
		});
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(25, innerEl);
		});
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			linkEl = $$value;
			$$invalidate(24, linkEl);
		});
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(26, inputEl);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(25, innerEl);
		});
	}

	function div0_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(25, innerEl);
		});
	}

	function div0_binding_2($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(25, innerEl);
		});
	}

	function a_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			linkEl = $$value;
			$$invalidate(24, linkEl);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(26, inputEl);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(25, innerEl);
		});
	}

	function div0_binding_3($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(25, innerEl);
		});
	}

	function li_binding_2($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(23, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(103, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(45, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(46, className = $$new_props.class);
		if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
		if ("text" in $$new_props) $$invalidate(1, text = $$new_props.text);
		if ("media" in $$new_props) $$invalidate(2, media = $$new_props.media);
		if ("subtitle" in $$new_props) $$invalidate(3, subtitle = $$new_props.subtitle);
		if ("header" in $$new_props) $$invalidate(4, header = $$new_props.header);
		if ("footer" in $$new_props) $$invalidate(5, footer = $$new_props.footer);
		if ("tooltip" in $$new_props) $$invalidate(47, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(48, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("link" in $$new_props) $$invalidate(49, link = $$new_props.link);
		if ("tabLink" in $$new_props) $$invalidate(50, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$new_props) $$invalidate(51, tabLinkActive = $$new_props.tabLinkActive);
		if ("href" in $$new_props) $$invalidate(52, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(53, target = $$new_props.target);
		if ("after" in $$new_props) $$invalidate(6, after = $$new_props.after);
		if ("badge" in $$new_props) $$invalidate(7, badge = $$new_props.badge);
		if ("badgeColor" in $$new_props) $$invalidate(8, badgeColor = $$new_props.badgeColor);
		if ("mediaItem" in $$new_props) $$invalidate(54, mediaItem = $$new_props.mediaItem);
		if ("mediaList" in $$new_props) $$invalidate(55, mediaList = $$new_props.mediaList);
		if ("divider" in $$new_props) $$invalidate(9, divider = $$new_props.divider);
		if ("groupTitle" in $$new_props) $$invalidate(10, groupTitle = $$new_props.groupTitle);
		if ("swipeout" in $$new_props) $$invalidate(11, swipeout = $$new_props.swipeout);
		if ("swipeoutOpened" in $$new_props) $$invalidate(56, swipeoutOpened = $$new_props.swipeoutOpened);
		if ("sortable" in $$new_props) $$invalidate(12, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$new_props) $$invalidate(57, sortableOpposite = $$new_props.sortableOpposite);
		if ("accordionItem" in $$new_props) $$invalidate(13, accordionItem = $$new_props.accordionItem);
		if ("accordionItemOpened" in $$new_props) $$invalidate(58, accordionItemOpened = $$new_props.accordionItemOpened);
		if ("smartSelect" in $$new_props) $$invalidate(59, smartSelect = $$new_props.smartSelect);
		if ("smartSelectParams" in $$new_props) $$invalidate(60, smartSelectParams = $$new_props.smartSelectParams);
		if ("noChevron" in $$new_props) $$invalidate(61, noChevron = $$new_props.noChevron);
		if ("chevronCenter" in $$new_props) $$invalidate(62, chevronCenter = $$new_props.chevronCenter);
		if ("checkbox" in $$new_props) $$invalidate(14, checkbox = $$new_props.checkbox);
		if ("radio" in $$new_props) $$invalidate(15, radio = $$new_props.radio);
		if ("radioIcon" in $$new_props) $$invalidate(63, radioIcon = $$new_props.radioIcon);
		if ("checked" in $$new_props) $$invalidate(16, checked = $$new_props.checked);
		if ("indeterminate" in $$new_props) $$invalidate(64, indeterminate = $$new_props.indeterminate);
		if ("name" in $$new_props) $$invalidate(17, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(18, value = $$new_props.value);
		if ("readonly" in $$new_props) $$invalidate(19, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(20, required = $$new_props.required);
		if ("disabled" in $$new_props) $$invalidate(21, disabled = $$new_props.disabled);
		if ("virtualListIndex" in $$new_props) $$invalidate(22, virtualListIndex = $$new_props.virtualListIndex);
		if ("$$scope" in $$new_props) $$invalidate(80, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		afterUpdate,
		getContext,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		hasSlots,
		Badge,
		dispatch,
		className,
		title,
		text,
		media,
		subtitle,
		header,
		footer,
		tooltip,
		tooltipTrigger,
		link,
		tabLink,
		tabLinkActive,
		href,
		target,
		after,
		badge,
		badgeColor,
		mediaItem,
		mediaList,
		divider,
		groupTitle,
		swipeout,
		swipeoutOpened,
		sortable,
		sortableOpposite,
		accordionItem,
		accordionItemOpened,
		smartSelect,
		smartSelectParams,
		noChevron,
		chevronCenter,
		checkbox,
		radio,
		radioIcon,
		checked,
		indeterminate,
		name,
		value,
		readonly,
		required,
		disabled,
		virtualListIndex,
		el,
		linkEl,
		innerEl,
		inputEl,
		f7SmartSelect,
		f7Tooltip,
		smartSelectInstance,
		tooltipText,
		watchTooltip,
		initialWatchedOpened,
		watchSwipeoutOpened,
		onClick,
		onSwipeoutOverswipeEnter,
		onSwipeoutOverswipeExit,
		onSwipeoutDeleted,
		onSwipeoutDelete,
		onSwipeoutClose,
		onSwipeoutClosed,
		onSwipeoutOpen,
		onSwipeoutOpened,
		onSwipeout,
		onAccBeforeClose,
		onAccClose,
		onAccClosed,
		onAccBeforeOpen,
		onAccOpen,
		onAccOpened,
		onChange,
		isMedia,
		isSortable,
		isSortableOpposite,
		isSimple,
		liClasses,
		contentClasses,
		linkClasses,
		linkAttrs,
		isLink,
		hasMedia,
		hasTitle,
		hasHeader,
		hasFooter,
		hasSubtitle,
		hasText,
		hasAfter
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(103, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(46, className = $$new_props.className);
		if ("title" in $$props) $$invalidate(0, title = $$new_props.title);
		if ("text" in $$props) $$invalidate(1, text = $$new_props.text);
		if ("media" in $$props) $$invalidate(2, media = $$new_props.media);
		if ("subtitle" in $$props) $$invalidate(3, subtitle = $$new_props.subtitle);
		if ("header" in $$props) $$invalidate(4, header = $$new_props.header);
		if ("footer" in $$props) $$invalidate(5, footer = $$new_props.footer);
		if ("tooltip" in $$props) $$invalidate(47, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(48, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("link" in $$props) $$invalidate(49, link = $$new_props.link);
		if ("tabLink" in $$props) $$invalidate(50, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$props) $$invalidate(51, tabLinkActive = $$new_props.tabLinkActive);
		if ("href" in $$props) $$invalidate(52, href = $$new_props.href);
		if ("target" in $$props) $$invalidate(53, target = $$new_props.target);
		if ("after" in $$props) $$invalidate(6, after = $$new_props.after);
		if ("badge" in $$props) $$invalidate(7, badge = $$new_props.badge);
		if ("badgeColor" in $$props) $$invalidate(8, badgeColor = $$new_props.badgeColor);
		if ("mediaItem" in $$props) $$invalidate(54, mediaItem = $$new_props.mediaItem);
		if ("mediaList" in $$props) $$invalidate(55, mediaList = $$new_props.mediaList);
		if ("divider" in $$props) $$invalidate(9, divider = $$new_props.divider);
		if ("groupTitle" in $$props) $$invalidate(10, groupTitle = $$new_props.groupTitle);
		if ("swipeout" in $$props) $$invalidate(11, swipeout = $$new_props.swipeout);
		if ("swipeoutOpened" in $$props) $$invalidate(56, swipeoutOpened = $$new_props.swipeoutOpened);
		if ("sortable" in $$props) $$invalidate(12, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$props) $$invalidate(57, sortableOpposite = $$new_props.sortableOpposite);
		if ("accordionItem" in $$props) $$invalidate(13, accordionItem = $$new_props.accordionItem);
		if ("accordionItemOpened" in $$props) $$invalidate(58, accordionItemOpened = $$new_props.accordionItemOpened);
		if ("smartSelect" in $$props) $$invalidate(59, smartSelect = $$new_props.smartSelect);
		if ("smartSelectParams" in $$props) $$invalidate(60, smartSelectParams = $$new_props.smartSelectParams);
		if ("noChevron" in $$props) $$invalidate(61, noChevron = $$new_props.noChevron);
		if ("chevronCenter" in $$props) $$invalidate(62, chevronCenter = $$new_props.chevronCenter);
		if ("checkbox" in $$props) $$invalidate(14, checkbox = $$new_props.checkbox);
		if ("radio" in $$props) $$invalidate(15, radio = $$new_props.radio);
		if ("radioIcon" in $$props) $$invalidate(63, radioIcon = $$new_props.radioIcon);
		if ("checked" in $$props) $$invalidate(16, checked = $$new_props.checked);
		if ("indeterminate" in $$props) $$invalidate(64, indeterminate = $$new_props.indeterminate);
		if ("name" in $$props) $$invalidate(17, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(18, value = $$new_props.value);
		if ("readonly" in $$props) $$invalidate(19, readonly = $$new_props.readonly);
		if ("required" in $$props) $$invalidate(20, required = $$new_props.required);
		if ("disabled" in $$props) $$invalidate(21, disabled = $$new_props.disabled);
		if ("virtualListIndex" in $$props) $$invalidate(22, virtualListIndex = $$new_props.virtualListIndex);
		if ("el" in $$props) $$invalidate(23, el = $$new_props.el);
		if ("linkEl" in $$props) $$invalidate(24, linkEl = $$new_props.linkEl);
		if ("innerEl" in $$props) $$invalidate(25, innerEl = $$new_props.innerEl);
		if ("inputEl" in $$props) $$invalidate(26, inputEl = $$new_props.inputEl);
		if ("f7SmartSelect" in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("initialWatchedOpened" in $$props) initialWatchedOpened = $$new_props.initialWatchedOpened;
		if ("isMedia" in $$props) $$invalidate(27, isMedia = $$new_props.isMedia);
		if ("isSortable" in $$props) $$invalidate(28, isSortable = $$new_props.isSortable);
		if ("isSortableOpposite" in $$props) $$invalidate(29, isSortableOpposite = $$new_props.isSortableOpposite);
		if ("isSimple" in $$props) $$invalidate(30, isSimple = $$new_props.isSimple);
		if ("liClasses" in $$props) $$invalidate(31, liClasses = $$new_props.liClasses);
		if ("contentClasses" in $$props) $$invalidate(32, contentClasses = $$new_props.contentClasses);
		if ("linkClasses" in $$props) $$invalidate(33, linkClasses = $$new_props.linkClasses);
		if ("linkAttrs" in $$props) $$invalidate(34, linkAttrs = $$new_props.linkAttrs);
		if ("isLink" in $$props) $$invalidate(35, isLink = $$new_props.isLink);
		if ("hasMedia" in $$props) $$invalidate(36, hasMedia = $$new_props.hasMedia);
		if ("hasTitle" in $$props) $$invalidate(37, hasTitle = $$new_props.hasTitle);
		if ("hasHeader" in $$props) $$invalidate(38, hasHeader = $$new_props.hasHeader);
		if ("hasFooter" in $$props) $$invalidate(39, hasFooter = $$new_props.hasFooter);
		if ("hasSubtitle" in $$props) $$invalidate(40, hasSubtitle = $$new_props.hasSubtitle);
		if ("hasText" in $$props) $$invalidate(41, hasText = $$new_props.hasText);
		if ("hasAfter" in $$props) $$invalidate(42, hasAfter = $$new_props.hasAfter);
	};

	let isMedia;
	let isSortable;
	let isSortableOpposite;
	let isSimple;
	let liClasses;
	let contentClasses;
	let linkClasses;
	let linkAttrs;
	let isLink;
	let hasMedia;
	let hasTitle;
	let hasHeader;
	let hasFooter;
	let hasSubtitle;
	let hasText;
	let hasAfter;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*mediaList, mediaItem*/ 25165824) {
			 $$invalidate(27, isMedia = mediaList || mediaItem || getContext("f7ListMedia"));
		}

		if ($$self.$$.dirty[0] & /*sortable*/ 4096) {
			 $$invalidate(28, isSortable = sortable || getContext("f7ListSortable"));
		}

		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 67108864) {
			 $$invalidate(29, isSortableOpposite = sortableOpposite || getContext("f7ListSortableOpposite"));
		}

		 $$invalidate(31, liClasses = Utils$1.classNames(
			className,
			{
				"item-divider": divider,
				"list-group-title": groupTitle,
				"media-item": isMedia,
				swipeout,
				"accordion-item": accordionItem,
				"accordion-item-opened": accordionItemOpened,
				disabled: disabled && !(radio || checkbox),
				"no-chevron": noChevron,
				"chevron-center": chevronCenter,
				"disallow-sorting": sortable === false
			},
			Mixins.colorClasses($$props)
		));

		 $$invalidate(32, contentClasses = Utils$1.classNames(
			className,
			"item-content",
			{
				"item-checkbox": checkbox,
				"item-radio": radio,
				"item-radio-icon-start": radio && radioIcon === "start",
				"item-radio-icon-end": radio && radioIcon === "end"
			},
			Mixins.colorClasses($$props)
		));

		 $$invalidate(33, linkClasses = Utils$1.classNames(
			{
				"item-link": true,
				"smart-select": smartSelect,
				"tab-link": tabLink || tabLink === "",
				"tab-link-active": tabLinkActive
			},
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props)
		));

		 $$invalidate(34, linkAttrs = {
			href: link === true ? "" : link || href,
			target,
			"data-tab": Utils$1.isStringProp(tabLink) && tabLink || undefined,
			...Mixins.linkRouterAttrs($$props),
			...Mixins.linkActionsAttrs($$props)
		});

		if ($$self.$$.dirty[0] & /*accordionItem*/ 8192 | $$self.$$.dirty[1] & /*link, href, smartSelect*/ 270794752) {
			 $$invalidate(35, isLink = link || href || smartSelect || accordionItem);
		}

		if ($$self.$$.dirty[0] & /*media*/ 4) {
			/* eslint-disable no-undef */
			 $$invalidate(36, hasMedia = typeof media !== "undefined" || hasSlots(arguments, "media"));
		}

		if ($$self.$$.dirty[0] & /*title*/ 1) {
			 $$invalidate(37, hasTitle = typeof title !== "undefined" || hasSlots(arguments, "title"));
		}

		if ($$self.$$.dirty[0] & /*header*/ 16) {
			 $$invalidate(38, hasHeader = typeof header !== "undefined" || hasSlots(arguments, "header"));
		}

		if ($$self.$$.dirty[0] & /*footer*/ 32) {
			 $$invalidate(39, hasFooter = typeof footer !== "undefined" || hasSlots(arguments, "footer"));
		}

		if ($$self.$$.dirty[0] & /*subtitle*/ 8) {
			 $$invalidate(40, hasSubtitle = typeof subtitle !== "undefined" || hasSlots(arguments, "subtitle"));
		}

		if ($$self.$$.dirty[0] & /*text*/ 2) {
			 $$invalidate(41, hasText = typeof text !== "undefined" || hasSlots(arguments, "text"));
		}

		if ($$self.$$.dirty[0] & /*after, badge*/ 192) {
			 $$invalidate(42, hasAfter = typeof after !== "undefined" || typeof badge !== "undefined" || hasSlots(arguments, "after"));
		}

		if ($$self.$$.dirty[1] & /*tooltip*/ 65536) {
			 watchTooltip(tooltip);
		}

		if ($$self.$$.dirty[1] & /*swipeoutOpened*/ 33554432) {
			 watchSwipeoutOpened(swipeoutOpened);
		}
	};

	 $$invalidate(30, isSimple = getContext("f7ListSimple"));
	$$props = exclude_internal_props($$props);

	return [
		title,
		text,
		media,
		subtitle,
		header,
		footer,
		after,
		badge,
		badgeColor,
		divider,
		groupTitle,
		swipeout,
		sortable,
		accordionItem,
		checkbox,
		radio,
		checked,
		name,
		value,
		readonly,
		required,
		disabled,
		virtualListIndex,
		el,
		linkEl,
		innerEl,
		inputEl,
		isMedia,
		isSortable,
		isSortableOpposite,
		isSimple,
		liClasses,
		contentClasses,
		linkClasses,
		linkAttrs,
		isLink,
		hasMedia,
		hasTitle,
		hasHeader,
		hasFooter,
		hasSubtitle,
		hasText,
		hasAfter,
		onClick,
		onChange,
		$$restProps,
		className,
		tooltip,
		tooltipTrigger,
		link,
		tabLink,
		tabLinkActive,
		href,
		target,
		mediaItem,
		mediaList,
		swipeoutOpened,
		sortableOpposite,
		accordionItemOpened,
		smartSelect,
		smartSelectParams,
		noChevron,
		chevronCenter,
		radioIcon,
		indeterminate,
		smartSelectInstance,
		$$slots,
		li_binding,
		li_binding_1,
		div0_binding,
		a_binding,
		input_binding,
		div_binding,
		div0_binding_1,
		div0_binding_2,
		a_binding_1,
		input_binding_1,
		div_binding_1,
		div0_binding_3,
		li_binding_2,
		$$scope
	];
}

class List_item extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$9,
			create_fragment$a,
			safe_not_equal,
			{
				class: 46,
				title: 0,
				text: 1,
				media: 2,
				subtitle: 3,
				header: 4,
				footer: 5,
				tooltip: 47,
				tooltipTrigger: 48,
				link: 49,
				tabLink: 50,
				tabLinkActive: 51,
				href: 52,
				target: 53,
				after: 6,
				badge: 7,
				badgeColor: 8,
				mediaItem: 54,
				mediaList: 55,
				divider: 9,
				groupTitle: 10,
				swipeout: 11,
				swipeoutOpened: 56,
				sortable: 12,
				sortableOpposite: 57,
				accordionItem: 13,
				accordionItemOpened: 58,
				smartSelect: 59,
				smartSelectParams: 60,
				noChevron: 61,
				chevronCenter: 62,
				checkbox: 14,
				radio: 15,
				radioIcon: 63,
				checked: 16,
				indeterminate: 64,
				name: 17,
				value: 18,
				readonly: 19,
				required: 20,
				disabled: 21,
				virtualListIndex: 22,
				smartSelectInstance: 65
			},
			[-1, -1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List_item",
			options,
			id: create_fragment$a.name
		});
	}

	get class() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get media() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set media(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get header() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set header(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get footer() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set footer(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLink() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLink(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLinkActive() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLinkActive(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get after() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set after(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get badge() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set badge(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get badgeColor() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set badgeColor(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediaItem() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediaItem(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediaList() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediaList(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get divider() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set divider(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get groupTitle() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set groupTitle(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeout() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeout(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeoutOpened() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeoutOpened(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortable() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortable(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableOpposite() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableOpposite(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionItem() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionItem(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionItemOpened() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionItemOpened(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelect() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smartSelect(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelectParams() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smartSelectParams(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noChevron() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noChevron(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get chevronCenter() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set chevronCenter(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checkbox() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checkbox(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get radio() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set radio(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get radioIcon() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set radioIcon(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indeterminate() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indeterminate(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get virtualListIndex() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set virtualListIndex(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelectInstance() {
		return this.$$.ctx[65];
	}

	set smartSelectInstance(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$b = "node_modules/framework7-svelte/components/list.svelte";
const get_after_list_slot_changes_1 = dirty => ({});
const get_after_list_slot_context_1 = ctx => ({});
const get_list_slot_changes_1 = dirty => ({});
const get_list_slot_context_1 = ctx => ({});
const get_before_list_slot_changes_1 = dirty => ({});
const get_before_list_slot_context_1 = ctx => ({});
const get_after_list_slot_changes = dirty => ({});
const get_after_list_slot_context = ctx => ({});
const get_list_slot_changes = dirty => ({});
const get_list_slot_context = ctx => ({});
const get_before_list_slot_changes = dirty => ({});
const get_before_list_slot_context = ctx => ({});

// (219:0) {:else}
function create_else_block_1$2(ctx) {
	let div;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let div_data_sortable_move_elements_value;
	let current;
	const before_list_slot_template = /*$$slots*/ ctx[43]["before-list"];
	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[42], get_before_list_slot_context_1);
	const if_block_creators = [create_if_block_2$4, create_else_block_2$2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*hasUlSlots*/ ctx[4] && /*ul*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_list_slot_template = /*$$slots*/ ctx[43]["after-list"];
	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[42], get_after_list_slot_context_1);

	let div_levels = [
		{ class: /*classes*/ ctx[5] },
		{
			"data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== "undefined"
			? /*sortableMoveElements*/ ctx[1].toString()
			: undefined
		},
		restProps(/*$$restProps*/ ctx[7])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (before_list_slot) before_list_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_list_slot) after_list_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$b, 219, 2, 7145);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (before_list_slot) {
				before_list_slot.m(div, null);
			}

			append_dev(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t1);

			if (after_list_slot) {
				after_list_slot.m(div, null);
			}

			/*div_binding*/ ctx[45](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_list_slot) {
				if (before_list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(before_list_slot, before_list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_before_list_slot_changes_1, get_before_list_slot_context_1);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, t1);
			}

			if (after_list_slot) {
				if (after_list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(after_list_slot, after_list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_after_list_slot_changes_1, get_after_list_slot_context_1);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				(!current || dirty[0] & /*sortableMoveElements*/ 2 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== "undefined"
				? /*sortableMoveElements*/ ctx[1].toString()
				: undefined)) && {
					"data-sortable-move-elements": div_data_sortable_move_elements_value
				},
				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_list_slot, local);
			transition_in(if_block);
			transition_in(after_list_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_list_slot, local);
			transition_out(if_block);
			transition_out(after_list_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (before_list_slot) before_list_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_list_slot) after_list_slot.d(detaching);
			/*div_binding*/ ctx[45](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$2.name,
		type: "else",
		source: "(219:0) {:else}",
		ctx
	});

	return block;
}

// (200:0) {#if form}
function create_if_block$4(ctx) {
	let form_1;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let form_1_data_sortable_move_elements_value;
	let current;
	let mounted;
	let dispose;
	const before_list_slot_template = /*$$slots*/ ctx[43]["before-list"];
	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[42], get_before_list_slot_context);
	const if_block_creators = [create_if_block_1$4, create_else_block$3];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*hasUlSlots*/ ctx[4] && /*ul*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_list_slot_template = /*$$slots*/ ctx[43]["after-list"];
	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[42], get_after_list_slot_context);

	let form_1_levels = [
		{ class: /*classes*/ ctx[5] },
		{
			"data-sortable-move-elements": form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== "undefined"
			? /*sortableMoveElements*/ ctx[1].toString()
			: undefined
		},
		restProps(/*$$restProps*/ ctx[7])
	];

	let form_1_data = {};

	for (let i = 0; i < form_1_levels.length; i += 1) {
		form_1_data = assign(form_1_data, form_1_levels[i]);
	}

	const block = {
		c: function create() {
			form_1 = element("form");
			if (before_list_slot) before_list_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_list_slot) after_list_slot.c();
			set_attributes(form_1, form_1_data);
			add_location(form_1, file$b, 200, 2, 6709);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form_1, anchor);

			if (before_list_slot) {
				before_list_slot.m(form_1, null);
			}

			append_dev(form_1, t0);
			if_blocks[current_block_type_index].m(form_1, null);
			append_dev(form_1, t1);

			if (after_list_slot) {
				after_list_slot.m(form_1, null);
			}

			/*form_1_binding*/ ctx[44](form_1);
			current = true;

			if (!mounted) {
				dispose = listen_dev(form_1, "submit", /*onSubmit*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (before_list_slot) {
				if (before_list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(before_list_slot, before_list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_before_list_slot_changes, get_before_list_slot_context);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(form_1, t1);
			}

			if (after_list_slot) {
				if (after_list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(after_list_slot, after_list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_after_list_slot_changes, get_after_list_slot_context);
				}
			}

			set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
				(!current || dirty[0] & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				(!current || dirty[0] & /*sortableMoveElements*/ 2 && form_1_data_sortable_move_elements_value !== (form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== "undefined"
				? /*sortableMoveElements*/ ctx[1].toString()
				: undefined)) && {
					"data-sortable-move-elements": form_1_data_sortable_move_elements_value
				},
				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_list_slot, local);
			transition_in(if_block);
			transition_in(after_list_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_list_slot, local);
			transition_out(if_block);
			transition_out(after_list_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form_1);
			if (before_list_slot) before_list_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_list_slot) after_list_slot.d(detaching);
			/*form_1_binding*/ ctx[44](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(200:0) {#if form}",
		ctx
	});

	return block;
}

// (232:4) {:else}
function create_else_block_2$2(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$2.name,
		type: "else",
		source: "(232:4) {:else}",
		ctx
	});

	return block;
}

// (227:4) {#if hasUlSlots && ul}
function create_if_block_2$4(ctx) {
	let ul_1;
	let t;
	let current;
	const list_slot_template = /*$$slots*/ ctx[43].list;
	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[42], get_list_slot_context_1);
	const default_slot_template = /*$$slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);

	const block = {
		c: function create() {
			ul_1 = element("ul");
			if (list_slot) list_slot.c();
			t = space();
			if (default_slot) default_slot.c();
			add_location(ul_1, file$b, 227, 4, 7412);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul_1, anchor);

			if (list_slot) {
				list_slot.m(ul_1, null);
			}

			append_dev(ul_1, t);

			if (default_slot) {
				default_slot.m(ul_1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (list_slot) {
				if (list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(list_slot, list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_list_slot_changes_1, get_list_slot_context_1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul_1);
			if (list_slot) list_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(227:4) {#if hasUlSlots && ul}",
		ctx
	});

	return block;
}

// (214:4) {:else}
function create_else_block$3(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(214:4) {:else}",
		ctx
	});

	return block;
}

// (209:4) {#if hasUlSlots && ul}
function create_if_block_1$4(ctx) {
	let ul_1;
	let t;
	let current;
	const list_slot_template = /*$$slots*/ ctx[43].list;
	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[42], get_list_slot_context);
	const default_slot_template = /*$$slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);

	const block = {
		c: function create() {
			ul_1 = element("ul");
			if (list_slot) list_slot.c();
			t = space();
			if (default_slot) default_slot.c();
			add_location(ul_1, file$b, 209, 4, 7002);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul_1, anchor);

			if (list_slot) {
				list_slot.m(ul_1, null);
			}

			append_dev(ul_1, t);

			if (default_slot) {
				default_slot.m(ul_1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (list_slot) {
				if (list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(list_slot, list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_list_slot_changes, get_list_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul_1);
			if (list_slot) list_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(209:4) {#if hasUlSlots && ul}",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$4, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*form*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","ul","inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","mediaList","sortable","sortableTapHold","sortableEnabled","sortableMoveElements","sortableOpposite","accordionList","accordionOpposite","contactsList","simpleList","linksList","noHairlines","noHairlinesBetween","noHairlinesMd","noHairlinesBetweenMd","noHairlinesIos","noHairlinesBetweenIos","noHairlinesAurora","noHairlinesBetweenAurora","noChevron","chevronCenter","tab","tabActive","form","formStoreData","inlineLabels","virtualList","virtualListParams","virtualListInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { ul = true } = $$props;
	let { inset = false } = $$props;
	let { xsmallInset = false } = $$props;
	let { smallInset = false } = $$props;
	let { mediumInset = false } = $$props;
	let { largeInset = false } = $$props;
	let { xlargeInset = false } = $$props;
	let { mediaList = false } = $$props;
	let { sortable = false } = $$props;
	let { sortableTapHold = false } = $$props;
	let { sortableEnabled = false } = $$props;
	let { sortableMoveElements = undefined } = $$props;
	let { sortableOpposite = false } = $$props;
	let { accordionList = false } = $$props;
	let { accordionOpposite = false } = $$props;
	let { contactsList = false } = $$props;
	let { simpleList = false } = $$props;
	let { linksList = false } = $$props;
	let { noHairlines = false } = $$props;
	let { noHairlinesBetween = false } = $$props;
	let { noHairlinesMd = false } = $$props;
	let { noHairlinesBetweenMd = false } = $$props;
	let { noHairlinesIos = false } = $$props;
	let { noHairlinesBetweenIos = false } = $$props;
	let { noHairlinesAurora = false } = $$props;
	let { noHairlinesBetweenAurora = false } = $$props;
	let { noChevron = false } = $$props;
	let { chevronCenter = false } = $$props;
	let { tab = false } = $$props;
	let { tabActive = false } = $$props;
	let { form = false } = $$props;
	let { formStoreData = false } = $$props;
	let { inlineLabels = false } = $$props;
	let { virtualList = false } = $$props;
	let { virtualListParams = undefined } = $$props;
	let el;
	let f7VirtualList;

	function virtualListInstance() {
		return f7VirtualList;
	}

	setContext("f7ListMedia", mediaList);
	setContext("f7ListSortable", sortable);
	setContext("f7ListSortableOpposite", sortableOpposite);
	setContext("f7ListSimple", simpleList);

	function onSubmit(event) {
		dispatch("submit", [event]);
		if (typeof $$props.onSubmit === "function") $$props.onSubmit(event);
	}

	function onSortableEnable(sortableEl) {
		if (sortableEl !== el) return;
		dispatch("sortableEnable");
		if (typeof $$props.onSortableEnable === "function") $$props.onSortableEnable();
	}

	function onSortableDisable(sortableEl) {
		if (sortableEl !== el) return;
		dispatch("sortableDisable");
		if (typeof $$props.onSortableDisable === "function") $$props.onSortableDisable();
	}

	function onSortableSort(sortableEl, sortData, listEl) {
		if (sortableEl !== listEl) return;
		dispatch("sortableSort", [sortData]);
		if (typeof $$props.onSortableSort === "function") $$props.onSortableSort(sortData);
	}

	function onTabShow(tabEl) {
		if (tabEl !== el) return;
		dispatch("tabShow");
		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
	}

	function onTabHide(tabEl) {
		if (tabEl !== el) return;
		dispatch("tabHide");
		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
	}

	onMount(() => {
		f7.ready(() => {
			f7.instance.on("sortableEnable", onSortableEnable);
			f7.instance.on("sortableDisable", onSortableDisable);
			f7.instance.on("sortableSort", onSortableSort);
			f7.instance.on("tabShow", onTabShow);
			f7.instance.on("tabHide", onTabHide);
			if (!virtualList) return;
			const vlParams = virtualListParams || {};
			if (!vlParams.renderItem && !vlParams.itemTemplate && !vlParams.renderExternal) return;

			f7VirtualList = f7.instance.virtualList.create(Utils$1.extend(
				{
					el,
					on: {
						itemBeforeInsert(itemEl, item) {
							const vl = this;
							dispatch("virtualItemBeforeInsert", [vl, itemEl, item]);
							if (typeof $$props.onVirtualItemBeforeInsert === "function") $$props.onVirtualItemBeforeInsert(vl, itemEl, item);
						},
						beforeClear(fragment) {
							const vl = this;
							dispatch("virtualBeforeClear", [vl, fragment]);
							if (typeof $$props.onVirtualBeforeClear === "function") $$props.onVirtualBeforeClear(vl, fragment);
						},
						itemsBeforeInsert(fragment) {
							const vl = this;
							dispatch("virtualItemsBeforeInsert", [vl, fragment]);
							if (typeof $$props.onVirtualItemsBeforeInsert === "function") $$props.onVirtualItemsBeforeInsert(vl, fragment);
						},
						itemsAfterInsert(fragment) {
							const vl = this;
							dispatch("virtualItemsAfterInsert", [vl, fragment]);
							if (typeof $$props.onVirtualItemsAfterInsert === "function") $$props.onVirtualItemsAfterInsert(vl, fragment);
						}
					}
				},
				vlParams
			));
		});
	});

	onDestroy(() => {
		if (!f7.instance) return;
		f7.instance.off("sortableEnable", onSortableEnable);
		f7.instance.off("sortableDisable", onSortableDisable);
		f7.instance.off("sortableSort", onSortableSort);
		f7.instance.off("tabShow", onTabShow);
		f7.instance.off("tabHide", onTabHide);
		if (f7VirtualList && f7VirtualList.destroy) f7VirtualList.destroy();
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("List", $$slots, ['before-list','list','default','after-list']);

	function form_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(53, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ("ul" in $$new_props) $$invalidate(0, ul = $$new_props.ul);
		if ("inset" in $$new_props) $$invalidate(9, inset = $$new_props.inset);
		if ("xsmallInset" in $$new_props) $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
		if ("smallInset" in $$new_props) $$invalidate(11, smallInset = $$new_props.smallInset);
		if ("mediumInset" in $$new_props) $$invalidate(12, mediumInset = $$new_props.mediumInset);
		if ("largeInset" in $$new_props) $$invalidate(13, largeInset = $$new_props.largeInset);
		if ("xlargeInset" in $$new_props) $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
		if ("mediaList" in $$new_props) $$invalidate(15, mediaList = $$new_props.mediaList);
		if ("sortable" in $$new_props) $$invalidate(16, sortable = $$new_props.sortable);
		if ("sortableTapHold" in $$new_props) $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
		if ("sortableEnabled" in $$new_props) $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
		if ("sortableMoveElements" in $$new_props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
		if ("sortableOpposite" in $$new_props) $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
		if ("accordionList" in $$new_props) $$invalidate(20, accordionList = $$new_props.accordionList);
		if ("accordionOpposite" in $$new_props) $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
		if ("contactsList" in $$new_props) $$invalidate(22, contactsList = $$new_props.contactsList);
		if ("simpleList" in $$new_props) $$invalidate(23, simpleList = $$new_props.simpleList);
		if ("linksList" in $$new_props) $$invalidate(24, linksList = $$new_props.linksList);
		if ("noHairlines" in $$new_props) $$invalidate(25, noHairlines = $$new_props.noHairlines);
		if ("noHairlinesBetween" in $$new_props) $$invalidate(26, noHairlinesBetween = $$new_props.noHairlinesBetween);
		if ("noHairlinesMd" in $$new_props) $$invalidate(27, noHairlinesMd = $$new_props.noHairlinesMd);
		if ("noHairlinesBetweenMd" in $$new_props) $$invalidate(28, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
		if ("noHairlinesIos" in $$new_props) $$invalidate(29, noHairlinesIos = $$new_props.noHairlinesIos);
		if ("noHairlinesBetweenIos" in $$new_props) $$invalidate(30, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
		if ("noHairlinesAurora" in $$new_props) $$invalidate(31, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ("noHairlinesBetweenAurora" in $$new_props) $$invalidate(32, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
		if ("noChevron" in $$new_props) $$invalidate(33, noChevron = $$new_props.noChevron);
		if ("chevronCenter" in $$new_props) $$invalidate(34, chevronCenter = $$new_props.chevronCenter);
		if ("tab" in $$new_props) $$invalidate(35, tab = $$new_props.tab);
		if ("tabActive" in $$new_props) $$invalidate(36, tabActive = $$new_props.tabActive);
		if ("form" in $$new_props) $$invalidate(2, form = $$new_props.form);
		if ("formStoreData" in $$new_props) $$invalidate(37, formStoreData = $$new_props.formStoreData);
		if ("inlineLabels" in $$new_props) $$invalidate(38, inlineLabels = $$new_props.inlineLabels);
		if ("virtualList" in $$new_props) $$invalidate(39, virtualList = $$new_props.virtualList);
		if ("virtualListParams" in $$new_props) $$invalidate(40, virtualListParams = $$new_props.virtualListParams);
		if ("$$scope" in $$new_props) $$invalidate(42, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		setContext,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		hasSlots,
		dispatch,
		className,
		ul,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		mediaList,
		sortable,
		sortableTapHold,
		sortableEnabled,
		sortableMoveElements,
		sortableOpposite,
		accordionList,
		accordionOpposite,
		contactsList,
		simpleList,
		linksList,
		noHairlines,
		noHairlinesBetween,
		noHairlinesMd,
		noHairlinesBetweenMd,
		noHairlinesIos,
		noHairlinesBetweenIos,
		noHairlinesAurora,
		noHairlinesBetweenAurora,
		noChevron,
		chevronCenter,
		tab,
		tabActive,
		form,
		formStoreData,
		inlineLabels,
		virtualList,
		virtualListParams,
		el,
		f7VirtualList,
		virtualListInstance,
		onSubmit,
		onSortableEnable,
		onSortableDisable,
		onSortableSort,
		onTabShow,
		onTabHide,
		hasUlSlots,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(53, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
		if ("ul" in $$props) $$invalidate(0, ul = $$new_props.ul);
		if ("inset" in $$props) $$invalidate(9, inset = $$new_props.inset);
		if ("xsmallInset" in $$props) $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
		if ("smallInset" in $$props) $$invalidate(11, smallInset = $$new_props.smallInset);
		if ("mediumInset" in $$props) $$invalidate(12, mediumInset = $$new_props.mediumInset);
		if ("largeInset" in $$props) $$invalidate(13, largeInset = $$new_props.largeInset);
		if ("xlargeInset" in $$props) $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
		if ("mediaList" in $$props) $$invalidate(15, mediaList = $$new_props.mediaList);
		if ("sortable" in $$props) $$invalidate(16, sortable = $$new_props.sortable);
		if ("sortableTapHold" in $$props) $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
		if ("sortableEnabled" in $$props) $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
		if ("sortableMoveElements" in $$props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
		if ("sortableOpposite" in $$props) $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
		if ("accordionList" in $$props) $$invalidate(20, accordionList = $$new_props.accordionList);
		if ("accordionOpposite" in $$props) $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
		if ("contactsList" in $$props) $$invalidate(22, contactsList = $$new_props.contactsList);
		if ("simpleList" in $$props) $$invalidate(23, simpleList = $$new_props.simpleList);
		if ("linksList" in $$props) $$invalidate(24, linksList = $$new_props.linksList);
		if ("noHairlines" in $$props) $$invalidate(25, noHairlines = $$new_props.noHairlines);
		if ("noHairlinesBetween" in $$props) $$invalidate(26, noHairlinesBetween = $$new_props.noHairlinesBetween);
		if ("noHairlinesMd" in $$props) $$invalidate(27, noHairlinesMd = $$new_props.noHairlinesMd);
		if ("noHairlinesBetweenMd" in $$props) $$invalidate(28, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
		if ("noHairlinesIos" in $$props) $$invalidate(29, noHairlinesIos = $$new_props.noHairlinesIos);
		if ("noHairlinesBetweenIos" in $$props) $$invalidate(30, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
		if ("noHairlinesAurora" in $$props) $$invalidate(31, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ("noHairlinesBetweenAurora" in $$props) $$invalidate(32, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
		if ("noChevron" in $$props) $$invalidate(33, noChevron = $$new_props.noChevron);
		if ("chevronCenter" in $$props) $$invalidate(34, chevronCenter = $$new_props.chevronCenter);
		if ("tab" in $$props) $$invalidate(35, tab = $$new_props.tab);
		if ("tabActive" in $$props) $$invalidate(36, tabActive = $$new_props.tabActive);
		if ("form" in $$props) $$invalidate(2, form = $$new_props.form);
		if ("formStoreData" in $$props) $$invalidate(37, formStoreData = $$new_props.formStoreData);
		if ("inlineLabels" in $$props) $$invalidate(38, inlineLabels = $$new_props.inlineLabels);
		if ("virtualList" in $$props) $$invalidate(39, virtualList = $$new_props.virtualList);
		if ("virtualListParams" in $$props) $$invalidate(40, virtualListParams = $$new_props.virtualListParams);
		if ("el" in $$props) $$invalidate(3, el = $$new_props.el);
		if ("f7VirtualList" in $$props) f7VirtualList = $$new_props.f7VirtualList;
		if ("hasUlSlots" in $$props) $$invalidate(4, hasUlSlots = $$new_props.hasUlSlots);
		if ("classes" in $$props) $$invalidate(5, classes = $$new_props.classes);
	};

	let hasUlSlots;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(5, classes = Utils$1.classNames(
			className,
			"list",
			{
				inset,
				"xsmall-inset": xsmallInset,
				"small-inset": smallInset,
				"medium-inset": mediumInset,
				"large-inset": largeInset,
				"xlarge-inset": xlargeInset,
				"media-list": mediaList,
				"simple-list": simpleList,
				"links-list": linksList,
				sortable,
				"sortable-tap-hold": sortableTapHold,
				"sortable-enabled": sortableEnabled,
				"sortable-opposite": sortableOpposite,
				"accordion-list": accordionList,
				"accordion-opposite": accordionOpposite,
				"contacts-list": contactsList,
				"virtual-list": virtualList,
				tab,
				"tab-active": tabActive,
				"no-hairlines": noHairlines,
				"no-hairlines-md": noHairlinesMd,
				"no-hairlines-ios": noHairlinesIos,
				"no-hairlines-aurora": noHairlinesAurora,
				"no-hairlines-between": noHairlinesBetween,
				"no-hairlines-between-md": noHairlinesBetweenMd,
				"no-hairlines-between-ios": noHairlinesBetweenIos,
				"no-hairlines-between-aurora": noHairlinesBetweenAurora,
				"form-store-data": formStoreData,
				"inline-labels": inlineLabels,
				"no-chevron": noChevron,
				"chevron-center": chevronCenter
			},
			Mixins.colorClasses($$props)
		));
	};

	 $$invalidate(4, hasUlSlots = hasSlots(arguments, "default") || hasSlots(arguments, "list"));
	$$props = exclude_internal_props($$props);

	return [
		ul,
		sortableMoveElements,
		form,
		el,
		hasUlSlots,
		classes,
		onSubmit,
		$$restProps,
		className,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		mediaList,
		sortable,
		sortableTapHold,
		sortableEnabled,
		sortableOpposite,
		accordionList,
		accordionOpposite,
		contactsList,
		simpleList,
		linksList,
		noHairlines,
		noHairlinesBetween,
		noHairlinesMd,
		noHairlinesBetweenMd,
		noHairlinesIos,
		noHairlinesBetweenIos,
		noHairlinesAurora,
		noHairlinesBetweenAurora,
		noChevron,
		chevronCenter,
		tab,
		tabActive,
		formStoreData,
		inlineLabels,
		virtualList,
		virtualListParams,
		virtualListInstance,
		$$scope,
		$$slots,
		form_1_binding,
		div_binding
	];
}

class List extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$a,
			create_fragment$b,
			safe_not_equal,
			{
				class: 8,
				ul: 0,
				inset: 9,
				xsmallInset: 10,
				smallInset: 11,
				mediumInset: 12,
				largeInset: 13,
				xlargeInset: 14,
				mediaList: 15,
				sortable: 16,
				sortableTapHold: 17,
				sortableEnabled: 18,
				sortableMoveElements: 1,
				sortableOpposite: 19,
				accordionList: 20,
				accordionOpposite: 21,
				contactsList: 22,
				simpleList: 23,
				linksList: 24,
				noHairlines: 25,
				noHairlinesBetween: 26,
				noHairlinesMd: 27,
				noHairlinesBetweenMd: 28,
				noHairlinesIos: 29,
				noHairlinesBetweenIos: 30,
				noHairlinesAurora: 31,
				noHairlinesBetweenAurora: 32,
				noChevron: 33,
				chevronCenter: 34,
				tab: 35,
				tabActive: 36,
				form: 2,
				formStoreData: 37,
				inlineLabels: 38,
				virtualList: 39,
				virtualListParams: 40,
				virtualListInstance: 41
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List",
			options,
			id: create_fragment$b.name
		});
	}

	get class() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ul() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ul(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xsmallInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xsmallInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediumInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediumInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xlargeInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xlargeInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediaList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediaList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortable() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortable(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableTapHold() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableTapHold(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableEnabled() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableEnabled(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableMoveElements() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableMoveElements(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableOpposite() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableOpposite(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionOpposite() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionOpposite(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contactsList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contactsList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get simpleList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set simpleList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linksList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linksList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlines() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlines(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesBetween() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesBetween(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesMd() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesMd(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesBetweenMd() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesBetweenMd(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesIos() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesIos(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesBetweenIos() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesBetweenIos(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesAurora() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesAurora(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesBetweenAurora() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesBetweenAurora(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noChevron() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noChevron(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get chevronCenter() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set chevronCenter(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tab() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabActive() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabActive(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formStoreData() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formStoreData(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inlineLabels() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inlineLabels(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get virtualList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set virtualList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get virtualListParams() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set virtualListParams(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get virtualListInstance() {
		return this.$$.ctx[41];
	}

	set virtualListInstance(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$c = "node_modules/framework7-svelte/components/nav-left.svelte";

// (55:2) {#if backLink}
function create_if_block$5(ctx) {
	let link;
	let current;

	link = new Link({
			props: {
				href: /*backLinkUrl*/ ctx[1] || "#",
				back: true,
				icon: "icon-back",
				force: /*backLinkForce*/ ctx[2] || undefined,
				class: !/*backLinkText*/ ctx[4] ? "icon-only" : undefined,
				text: /*backLinkText*/ ctx[4],
				onClick: /*onBackClick*/ ctx[5]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(link.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(link, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const link_changes = {};
			if (dirty & /*backLinkUrl*/ 2) link_changes.href = /*backLinkUrl*/ ctx[1] || "#";
			if (dirty & /*backLinkForce*/ 4) link_changes.force = /*backLinkForce*/ ctx[2] || undefined;
			if (dirty & /*backLinkText*/ 16) link_changes.class = !/*backLinkText*/ ctx[4] ? "icon-only" : undefined;
			if (dirty & /*backLinkText*/ 16) link_changes.text = /*backLinkText*/ ctx[4];
			link.$set(link_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(link, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(55:2) {#if backLink}",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*backLink*/ ctx[0] && create_if_block$5(ctx);
	const default_slot_template = /*$$slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	let div_levels = [{ class: /*classes*/ ctx[3] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$c, 50, 0, 1335);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*backLink*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*backLink*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { backLink = undefined } = $$props;
	let { backLinkUrl = undefined } = $$props;
	let { backLinkForce = undefined } = $$props;
	let { backLinkShowText = undefined } = $$props;
	let { sliding = undefined } = $$props;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(12, _theme = f7Theme);
		});
	}

	function onBackClick() {
		dispatch("clickBack");
		if (typeof $$props.onClickBack === "function") $$props.onClickBack();
		dispatch("backClick");
		if (typeof $$props.onBackClick === "function") $$props.onBackClick();
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Nav_left", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("backLink" in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
		if ("backLinkUrl" in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
		if ("backLinkForce" in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
		if ("backLinkShowText" in $$new_props) $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
		if ("sliding" in $$new_props) $$invalidate(9, sliding = $$new_props.sliding);
		if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		theme: f7Theme,
		Link,
		dispatch,
		className,
		backLink,
		backLinkUrl,
		backLinkForce,
		backLinkShowText,
		sliding,
		_theme,
		onBackClick,
		classes,
		needBackLinkText,
		backLinkText
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("backLink" in $$props) $$invalidate(0, backLink = $$new_props.backLink);
		if ("backLinkUrl" in $$props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
		if ("backLinkForce" in $$props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
		if ("backLinkShowText" in $$props) $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
		if ("sliding" in $$props) $$invalidate(9, sliding = $$new_props.sliding);
		if ("_theme" in $$props) $$invalidate(12, _theme = $$new_props._theme);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
		if ("needBackLinkText" in $$props) $$invalidate(13, needBackLinkText = $$new_props.needBackLinkText);
		if ("backLinkText" in $$props) $$invalidate(4, backLinkText = $$new_props.backLinkText);
	};

	let classes;
	let needBackLinkText;
	let backLinkText;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, classes = Utils$1.classNames(className, "left", { sliding }, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*backLinkShowText*/ 256) {
			 $$invalidate(13, needBackLinkText = backLinkShowText);
		}

		if ($$self.$$.dirty & /*needBackLinkText, _theme*/ 12288) {
			 if (typeof needBackLinkText === "undefined") $$invalidate(13, needBackLinkText = _theme && !_theme.md);
		}

		if ($$self.$$.dirty & /*backLink, needBackLinkText*/ 8193) {
			 $$invalidate(4, backLinkText = backLink !== true && needBackLinkText
			? backLink
			: undefined);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		backLink,
		backLinkUrl,
		backLinkForce,
		classes,
		backLinkText,
		onBackClick,
		$$restProps,
		className,
		backLinkShowText,
		sliding,
		$$scope,
		$$slots
	];
}

class Nav_left extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$b, create_fragment$c, safe_not_equal, {
			class: 7,
			backLink: 0,
			backLinkUrl: 1,
			backLinkForce: 2,
			backLinkShowText: 8,
			sliding: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Nav_left",
			options,
			id: create_fragment$c.name
		});
	}

	get class() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLink() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLink(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkUrl() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkUrl(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkForce() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkForce(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkShowText() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkShowText(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliding() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliding(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$d = "node_modules/framework7-svelte/components/nav-right.svelte";

function create_fragment$d(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$d, 19, 0, 371);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","sliding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { class: className = undefined } = $$props;
	let { sliding = undefined } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Nav_right", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("sliding" in $$new_props) $$invalidate(3, sliding = $$new_props.sliding);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils: Utils$1,
		restProps,
		className,
		sliding,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("sliding" in $$props) $$invalidate(3, sliding = $$new_props.sliding);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils$1.classNames(className, "right", { sliding }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, sliding, $$scope, $$slots];
}

class Nav_right extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$d, safe_not_equal, { class: 2, sliding: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Nav_right",
			options,
			id: create_fragment$d.name
		});
	}

	get class() {
		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliding() {
		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliding(value) {
		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$e = "node_modules/framework7-svelte/components/nav-title.svelte";

// (26:2) {#if typeof title !== 'undefined'}
function create_if_block_1$5(ctx) {
	let t_value = Utils$1.text(/*title*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1 && t_value !== (t_value = Utils$1.text(/*title*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(26:2) {#if typeof title !== 'undefined'}",
		ctx
	});

	return block;
}

// (27:2) {#if typeof subtitle !== 'undefined'}
function create_if_block$6(ctx) {
	let span;
	let t_value = Utils$1.text(/*subtitle*/ ctx[1]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(t_value);
			attr_dev(span, "class", "subtitle");
			add_location(span, file$e, 27, 4, 598);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*subtitle*/ 2 && t_value !== (t_value = Utils$1.text(/*subtitle*/ ctx[1]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(27:2) {#if typeof subtitle !== 'undefined'}",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let if_block0 = typeof /*title*/ ctx[0] !== "undefined" && create_if_block_1$5(ctx);
	let if_block1 = typeof /*subtitle*/ ctx[1] !== "undefined" && create_if_block$6(ctx);
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$e, 21, 0, 438);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (typeof /*title*/ ctx[0] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$5(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*subtitle*/ ctx[1] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","title","subtitle","sliding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	let { sliding = undefined } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Nav_title", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
		if ("subtitle" in $$new_props) $$invalidate(1, subtitle = $$new_props.subtitle);
		if ("sliding" in $$new_props) $$invalidate(5, sliding = $$new_props.sliding);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils: Utils$1,
		restProps,
		className,
		title,
		subtitle,
		sliding,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("title" in $$props) $$invalidate(0, title = $$new_props.title);
		if ("subtitle" in $$props) $$invalidate(1, subtitle = $$new_props.subtitle);
		if ("sliding" in $$props) $$invalidate(5, sliding = $$new_props.sliding);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classes = Utils$1.classNames(className, "title", { sliding }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [title, subtitle, classes, $$restProps, className, sliding, $$scope, $$slots];
}

class Nav_title extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$d, create_fragment$e, safe_not_equal, {
			class: 4,
			title: 0,
			subtitle: 1,
			sliding: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Nav_title",
			options,
			id: create_fragment$e.name
		});
	}

	get class() {
		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliding() {
		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliding(value) {
		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$f = "node_modules/framework7-svelte/components/navbar.svelte";
const get_after_inner_slot_changes = dirty => ({});
const get_after_inner_slot_context = ctx => ({});
const get_title_large_slot_changes = dirty => ({});
const get_title_large_slot_context = ctx => ({});
const get_right_slot_changes = dirty => ({});
const get_right_slot_context = ctx => ({});
const get_nav_right_slot_changes = dirty => ({});
const get_nav_right_slot_context = ctx => ({});
const get_title_slot_changes$1 = dirty => ({});
const get_title_slot_context$1 = ctx => ({});
const get_left_slot_changes = dirty => ({});
const get_left_slot_context = ctx => ({});
const get_nav_left_slot_changes = dirty => ({});
const get_nav_left_slot_context = ctx => ({});
const get_before_inner_slot_changes = dirty => ({});
const get_before_inner_slot_context = ctx => ({});

// (218:4) {#if backLink || hasLeftSlots}
function create_if_block_3$4(ctx) {
	let navleft;
	let current;

	navleft = new Nav_left({
			props: {
				backLink: /*backLink*/ ctx[0],
				backLinkUrl: /*backLinkUrl*/ ctx[1],
				backLinkForce: /*backLinkForce*/ ctx[2],
				backLinkShowText: /*backLinkShowText*/ ctx[3],
				onBackClick: /*onBackClick*/ ctx[15],
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(navleft.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(navleft, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const navleft_changes = {};
			if (dirty[0] & /*backLink*/ 1) navleft_changes.backLink = /*backLink*/ ctx[0];
			if (dirty[0] & /*backLinkUrl*/ 2) navleft_changes.backLinkUrl = /*backLinkUrl*/ ctx[1];
			if (dirty[0] & /*backLinkForce*/ 4) navleft_changes.backLinkForce = /*backLinkForce*/ ctx[2];
			if (dirty[0] & /*backLinkShowText*/ 8) navleft_changes.backLinkShowText = /*backLinkShowText*/ ctx[3];

			if (dirty[1] & /*$$scope*/ 4) {
				navleft_changes.$$scope = { dirty, ctx };
			}

			navleft.$set(navleft_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navleft.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navleft.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navleft, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$4.name,
		type: "if",
		source: "(218:4) {#if backLink || hasLeftSlots}",
		ctx
	});

	return block;
}

// (219:6) <NavLeft         backLink={backLink}         backLinkUrl={backLinkUrl}         backLinkForce={backLinkForce}         backLinkShowText={backLinkShowText}         onBackClick={onBackClick}       >
function create_default_slot_2$2(ctx) {
	let t;
	let current;
	const nav_left_slot_template = /*$$slots*/ ctx[31]["nav-left"];
	const nav_left_slot = create_slot(nav_left_slot_template, ctx, /*$$scope*/ ctx[33], get_nav_left_slot_context);
	const left_slot_template = /*$$slots*/ ctx[31].left;
	const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[33], get_left_slot_context);

	const block = {
		c: function create() {
			if (nav_left_slot) nav_left_slot.c();
			t = space();
			if (left_slot) left_slot.c();
		},
		m: function mount(target, anchor) {
			if (nav_left_slot) {
				nav_left_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);

			if (left_slot) {
				left_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (nav_left_slot) {
				if (nav_left_slot.p && dirty[1] & /*$$scope*/ 4) {
					update_slot(nav_left_slot, nav_left_slot_template, ctx, /*$$scope*/ ctx[33], dirty, get_nav_left_slot_changes, get_nav_left_slot_context);
				}
			}

			if (left_slot) {
				if (left_slot.p && dirty[1] & /*$$scope*/ 4) {
					update_slot(left_slot, left_slot_template, ctx, /*$$scope*/ ctx[33], dirty, get_left_slot_changes, get_left_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(nav_left_slot, local);
			transition_in(left_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(nav_left_slot, local);
			transition_out(left_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (nav_left_slot) nav_left_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (left_slot) left_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(219:6) <NavLeft         backLink={backLink}         backLinkUrl={backLinkUrl}         backLinkForce={backLinkForce}         backLinkShowText={backLinkShowText}         onBackClick={onBackClick}       >",
		ctx
	});

	return block;
}

// (230:4) {#if title || subtitle || hasTitleSlots}
function create_if_block_2$5(ctx) {
	let navtitle;
	let current;

	navtitle = new Nav_title({
			props: {
				title: /*title*/ ctx[4],
				subtitle: /*subtitle*/ ctx[5],
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(navtitle.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(navtitle, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const navtitle_changes = {};
			if (dirty[0] & /*title*/ 16) navtitle_changes.title = /*title*/ ctx[4];
			if (dirty[0] & /*subtitle*/ 32) navtitle_changes.subtitle = /*subtitle*/ ctx[5];

			if (dirty[1] & /*$$scope*/ 4) {
				navtitle_changes.$$scope = { dirty, ctx };
			}

			navtitle.$set(navtitle_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navtitle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navtitle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navtitle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$5.name,
		type: "if",
		source: "(230:4) {#if title || subtitle || hasTitleSlots}",
		ctx
	});

	return block;
}

// (231:6) <NavTitle         title={title}         subtitle={subtitle}       >
function create_default_slot_1$2(ctx) {
	let current;
	const title_slot_template = /*$$slots*/ ctx[31].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[33], get_title_slot_context$1);

	const block = {
		c: function create() {
			if (title_slot) title_slot.c();
		},
		m: function mount(target, anchor) {
			if (title_slot) {
				title_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (title_slot) {
				if (title_slot.p && dirty[1] & /*$$scope*/ 4) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[33], dirty, get_title_slot_changes$1, get_title_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(231:6) <NavTitle         title={title}         subtitle={subtitle}       >",
		ctx
	});

	return block;
}

// (238:4) {#if hasRightSlots}
function create_if_block_1$6(ctx) {
	let navright;
	let current;

	navright = new Nav_right({
			props: {
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(navright.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(navright, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const navright_changes = {};

			if (dirty[1] & /*$$scope*/ 4) {
				navright_changes.$$scope = { dirty, ctx };
			}

			navright.$set(navright_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navright.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navright.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navright, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(238:4) {#if hasRightSlots}",
		ctx
	});

	return block;
}

// (239:6) <NavRight>
function create_default_slot$2(ctx) {
	let t;
	let current;
	const nav_right_slot_template = /*$$slots*/ ctx[31]["nav-right"];
	const nav_right_slot = create_slot(nav_right_slot_template, ctx, /*$$scope*/ ctx[33], get_nav_right_slot_context);
	const right_slot_template = /*$$slots*/ ctx[31].right;
	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[33], get_right_slot_context);

	const block = {
		c: function create() {
			if (nav_right_slot) nav_right_slot.c();
			t = space();
			if (right_slot) right_slot.c();
		},
		m: function mount(target, anchor) {
			if (nav_right_slot) {
				nav_right_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);

			if (right_slot) {
				right_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (nav_right_slot) {
				if (nav_right_slot.p && dirty[1] & /*$$scope*/ 4) {
					update_slot(nav_right_slot, nav_right_slot_template, ctx, /*$$scope*/ ctx[33], dirty, get_nav_right_slot_changes, get_nav_right_slot_context);
				}
			}

			if (right_slot) {
				if (right_slot.p && dirty[1] & /*$$scope*/ 4) {
					update_slot(right_slot, right_slot_template, ctx, /*$$scope*/ ctx[33], dirty, get_right_slot_changes, get_right_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(nav_right_slot, local);
			transition_in(right_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(nav_right_slot, local);
			transition_out(right_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (nav_right_slot) nav_right_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (right_slot) right_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(239:6) <NavRight>",
		ctx
	});

	return block;
}

// (244:4) {#if largeTitle || hasTitleLargeSlots}
function create_if_block$7(ctx) {
	let div1;
	let div0;
	let t0_value = Utils$1.text(/*largeTitle*/ ctx[11]) + "";
	let t0;
	let t1;
	let current;
	const title_large_slot_template = /*$$slots*/ ctx[31]["title-large"];
	const title_large_slot = create_slot(title_large_slot_template, ctx, /*$$scope*/ ctx[33], get_title_large_slot_context);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			if (title_large_slot) title_large_slot.c();
			attr_dev(div0, "class", "title-large-text");
			add_location(div0, file$f, 245, 8, 7906);
			attr_dev(div1, "class", "title-large");
			add_location(div1, file$f, 244, 6, 7872);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t0);
			append_dev(div0, t1);

			if (title_large_slot) {
				title_large_slot.m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*largeTitle*/ 2048) && t0_value !== (t0_value = Utils$1.text(/*largeTitle*/ ctx[11]) + "")) set_data_dev(t0, t0_value);

			if (title_large_slot) {
				if (title_large_slot.p && dirty[1] & /*$$scope*/ 4) {
					update_slot(title_large_slot, title_large_slot_template, ctx, /*$$scope*/ ctx[33], dirty, get_title_large_slot_changes, get_title_large_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_large_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_large_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (title_large_slot) title_large_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(244:4) {#if largeTitle || hasTitleLargeSlots}",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let current;
	const before_inner_slot_template = /*$$slots*/ ctx[31]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[33], get_before_inner_slot_context);
	let if_block0 = (/*backLink*/ ctx[0] || /*hasLeftSlots*/ ctx[8]) && create_if_block_3$4(ctx);
	let if_block1 = (/*title*/ ctx[4] || /*subtitle*/ ctx[5] || /*hasTitleSlots*/ ctx[10]) && create_if_block_2$5(ctx);
	let if_block2 = /*hasRightSlots*/ ctx[9] && create_if_block_1$6(ctx);
	let if_block3 = (/*largeTitle*/ ctx[11] || /*hasTitleLargeSlots*/ ctx[12]) && create_if_block$7(ctx);
	const default_slot_template = /*$$slots*/ ctx[31].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[33], null);
	const after_inner_slot_template = /*$$slots*/ ctx[31]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[33], get_after_inner_slot_context);

	let div2_levels = [
		{ class: /*classes*/ ctx[13] },
		{ "data-f7-slot": /*f7Slot*/ ctx[6] },
		restProps(/*$$restProps*/ ctx[16])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			if (before_inner_slot) before_inner_slot.c();
			t1 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (default_slot) default_slot.c();
			t6 = space();
			if (after_inner_slot) after_inner_slot.c();
			attr_dev(div0, "class", "navbar-bg");
			add_location(div0, file$f, 214, 2, 7093);
			attr_dev(div1, "class", /*innerClasses*/ ctx[14]);
			add_location(div1, file$f, 216, 2, 7161);
			set_attributes(div2, div2_data);
			add_location(div2, file$f, 208, 0, 6995);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t0);

			if (before_inner_slot) {
				before_inner_slot.m(div2, null);
			}

			append_dev(div2, t1);
			append_dev(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div1, t4);
			if (if_block3) if_block3.m(div1, null);
			append_dev(div1, t5);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div2, t6);

			if (after_inner_slot) {
				after_inner_slot.m(div2, null);
			}

			/*div2_binding*/ ctx[32](div2);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty[1] & /*$$scope*/ 4) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[33], dirty, get_before_inner_slot_changes, get_before_inner_slot_context);
				}
			}

			if (/*backLink*/ ctx[0] || /*hasLeftSlots*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*backLink, hasLeftSlots*/ 257) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*title*/ ctx[4] || /*subtitle*/ ctx[5] || /*hasTitleSlots*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*title, subtitle, hasTitleSlots*/ 1072) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*hasRightSlots*/ ctx[9]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*hasRightSlots*/ 512) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$6(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*largeTitle*/ ctx[11] || /*hasTitleLargeSlots*/ ctx[12]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*largeTitle, hasTitleLargeSlots*/ 6144) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$7(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div1, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[33], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*innerClasses*/ 16384) {
				attr_dev(div1, "class", /*innerClasses*/ ctx[14]);
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty[1] & /*$$scope*/ 4) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[33], dirty, get_after_inner_slot_changes, get_after_inner_slot_context);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 8192) && { class: /*classes*/ ctx[13] },
				(!current || dirty[0] & /*f7Slot*/ 64) && { "data-f7-slot": /*f7Slot*/ ctx[6] },
				dirty[0] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[16])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(default_slot, local);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(default_slot, local);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*div2_binding*/ ctx[32](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding","title","subtitle","hidden","noShadow","noHairline","innerClass","innerClassName","large","largeTransparent","transparent","titleLarge","f7Slot","hide","show","size"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { backLink = undefined } = $$props;
	let { backLinkUrl = undefined } = $$props;
	let { backLinkForce = false } = $$props;
	let { backLinkShowText = undefined } = $$props;
	let { sliding = true } = $$props;
	let { title = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	let { hidden = false } = $$props;
	let { noShadow = false } = $$props;
	let { noHairline = false } = $$props;
	let { innerClass = undefined } = $$props;
	let { innerClassName = undefined } = $$props;
	let { large = false } = $$props;
	let { largeTransparent = false } = $$props;
	let { transparent = false } = $$props;
	let { titleLarge = undefined } = $$props;
	let { f7Slot = "fixed" } = $$props;
	let el;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	let routerPositionClass = "";
	let largeCollapsed = false;
	let routerNavbarRole = null;
	let routerNavbarRoleDetailRoot = false;
	let routerNavbarMasterStack = false;
	let transparentVisible = false;

	function hide(animate) {
		f7.navbar.hide(el, animate);
	}

	function show(animate) {
		f7.navbar.show(el, animate);
	}

	function size() {
		f7.navbar.size(el);
	}

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(34, _theme = f7Theme);
		});
	}

	function onHide(navbarEl) {
		if (el !== navbarEl) return;
		dispatch("navbarHide");
		if (typeof $$props.onNavbarHide === "function") $$props.onNavbarHide();
	}

	function onShow(navbarEl) {
		if (el !== navbarEl) return;
		dispatch("navbarShow");
		if (typeof $$props.onNavbarShow === "function") $$props.onNavbarShow();
	}

	function onNavbarTransparentShow(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(40, transparentVisible = true);
		dispatch("navbarTransparentShow");
		if (typeof $$props.onNavbarTransparentShow === "function") $$props.onNavbarTransparentShow();
	}

	function onNavbarTransparentHide(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(40, transparentVisible = false);
		dispatch("navbarTransparentHide");
		if (typeof $$props.onNavbarTransparentHide === "function") $$props.onNavbarTransparentHide();
	}

	function onExpand(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(36, largeCollapsed = false);
		dispatch("navbarExpand");
		if (typeof $$props.onNavbarExpand === "function") $$props.onNavbarExpand();
	}

	function onCollapse(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(36, largeCollapsed = true);
		dispatch("navbarCollapse");
		if (typeof $$props.onNavbarCollapse === "function") $$props.onNavbarCollapse();
	}

	function onNavbarPosition(navbarEl, position) {
		if (el !== navbarEl) return;
		$$invalidate(35, routerPositionClass = position ? `navbar-${position}` : position);
	}

	function onNavbarRole(navbarEl, rolesData) {
		if (el !== navbarEl) return;
		$$invalidate(37, routerNavbarRole = rolesData.role);
		$$invalidate(38, routerNavbarRoleDetailRoot = rolesData.detailRoot);
	}

	function onNavbarMasterStack(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(39, routerNavbarMasterStack = true);
	}

	function onNavbarMasterUnstack(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(39, routerNavbarMasterStack = false);
	}

	function onBackClick() {
		dispatch("clickBack");
		if (typeof $$props.onClickBack === "function") $$props.onClickBack();
	}

	function mountNavbar() {
		f7.instance.on("navbarShow", onShow);
		f7.instance.on("navbarHide", onHide);
		f7.instance.on("navbarCollapse", onCollapse);
		f7.instance.on("navbarExpand", onExpand);
		f7.instance.on("navbarPosition", onNavbarPosition);
		f7.instance.on("navbarRole", onNavbarRole);
		f7.instance.on("navbarMasterStack", onNavbarMasterStack);
		f7.instance.on("navbarMasterUnstack", onNavbarMasterUnstack);
		f7.instance.on("navbarTransparentShow", onNavbarTransparentShow);
		f7.instance.on("navbarTransparentHide", onNavbarTransparentHide);
	}

	function destroyNavbar() {
		f7.instance.off("navbarShow", onShow);
		f7.instance.off("navbarHide", onHide);
		f7.instance.off("navbarCollapse", onCollapse);
		f7.instance.off("navbarExpand", onExpand);
		f7.instance.off("navbarPosition", onNavbarPosition);
		f7.instance.off("navbarRole", onNavbarRole);
		f7.instance.off("navbarMasterStack", onNavbarMasterStack);
		f7.instance.off("navbarMasterUnstack", onNavbarMasterUnstack);
		f7.instance.off("navbarTransparentShow", onNavbarTransparentShow);
		f7.instance.off("navbarTransparentHide", onNavbarTransparentHide);
	}

	onMount(() => {
		f7.ready(() => {
			mountNavbar();
		});
	});

	afterUpdate(() => {
		if (!f7.instance) return;
		f7.instance.navbar.size(el);
	});

	onDestroy(() => {
		if (!f7.instance) return;
		destroyNavbar();
	});

	let { $$slots = {}, $$scope } = $$props;

	validate_slots("Navbar", $$slots, [
		'before-inner','nav-left','left','title','nav-right','right','title-large','default','after-inner'
	]);

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(7, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(59, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(17, className = $$new_props.class);
		if ("backLink" in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
		if ("backLinkUrl" in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
		if ("backLinkForce" in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
		if ("backLinkShowText" in $$new_props) $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
		if ("sliding" in $$new_props) $$invalidate(18, sliding = $$new_props.sliding);
		if ("title" in $$new_props) $$invalidate(4, title = $$new_props.title);
		if ("subtitle" in $$new_props) $$invalidate(5, subtitle = $$new_props.subtitle);
		if ("hidden" in $$new_props) $$invalidate(19, hidden = $$new_props.hidden);
		if ("noShadow" in $$new_props) $$invalidate(20, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$new_props) $$invalidate(21, noHairline = $$new_props.noHairline);
		if ("innerClass" in $$new_props) $$invalidate(22, innerClass = $$new_props.innerClass);
		if ("innerClassName" in $$new_props) $$invalidate(23, innerClassName = $$new_props.innerClassName);
		if ("large" in $$new_props) $$invalidate(24, large = $$new_props.large);
		if ("largeTransparent" in $$new_props) $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
		if ("transparent" in $$new_props) $$invalidate(26, transparent = $$new_props.transparent);
		if ("titleLarge" in $$new_props) $$invalidate(27, titleLarge = $$new_props.titleLarge);
		if ("f7Slot" in $$new_props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(33, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		afterUpdate,
		Mixins,
		Utils: Utils$1,
		restProps,
		theme: f7Theme,
		f7,
		hasSlots,
		NavLeft: Nav_left,
		NavTitle: Nav_title,
		NavRight: Nav_right,
		dispatch,
		className,
		backLink,
		backLinkUrl,
		backLinkForce,
		backLinkShowText,
		sliding,
		title,
		subtitle,
		hidden,
		noShadow,
		noHairline,
		innerClass,
		innerClassName,
		large,
		largeTransparent,
		transparent,
		titleLarge,
		f7Slot,
		el,
		_theme,
		routerPositionClass,
		largeCollapsed,
		routerNavbarRole,
		routerNavbarRoleDetailRoot,
		routerNavbarMasterStack,
		transparentVisible,
		hide,
		show,
		size,
		onHide,
		onShow,
		onNavbarTransparentShow,
		onNavbarTransparentHide,
		onExpand,
		onCollapse,
		onNavbarPosition,
		onNavbarRole,
		onNavbarMasterStack,
		onNavbarMasterUnstack,
		onBackClick,
		mountNavbar,
		destroyNavbar,
		hasLeftSlots,
		hasRightSlots,
		hasTitleSlots,
		largeTitle,
		hasTitleLargeSlots,
		addLeftTitleClass,
		addCenterTitleClass,
		isLarge,
		isTransparent,
		isTransparentVisible,
		classes,
		innerClasses
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(59, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(17, className = $$new_props.className);
		if ("backLink" in $$props) $$invalidate(0, backLink = $$new_props.backLink);
		if ("backLinkUrl" in $$props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
		if ("backLinkForce" in $$props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
		if ("backLinkShowText" in $$props) $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
		if ("sliding" in $$props) $$invalidate(18, sliding = $$new_props.sliding);
		if ("title" in $$props) $$invalidate(4, title = $$new_props.title);
		if ("subtitle" in $$props) $$invalidate(5, subtitle = $$new_props.subtitle);
		if ("hidden" in $$props) $$invalidate(19, hidden = $$new_props.hidden);
		if ("noShadow" in $$props) $$invalidate(20, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$props) $$invalidate(21, noHairline = $$new_props.noHairline);
		if ("innerClass" in $$props) $$invalidate(22, innerClass = $$new_props.innerClass);
		if ("innerClassName" in $$props) $$invalidate(23, innerClassName = $$new_props.innerClassName);
		if ("large" in $$props) $$invalidate(24, large = $$new_props.large);
		if ("largeTransparent" in $$props) $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
		if ("transparent" in $$props) $$invalidate(26, transparent = $$new_props.transparent);
		if ("titleLarge" in $$props) $$invalidate(27, titleLarge = $$new_props.titleLarge);
		if ("f7Slot" in $$props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
		if ("el" in $$props) $$invalidate(7, el = $$new_props.el);
		if ("_theme" in $$props) $$invalidate(34, _theme = $$new_props._theme);
		if ("routerPositionClass" in $$props) $$invalidate(35, routerPositionClass = $$new_props.routerPositionClass);
		if ("largeCollapsed" in $$props) $$invalidate(36, largeCollapsed = $$new_props.largeCollapsed);
		if ("routerNavbarRole" in $$props) $$invalidate(37, routerNavbarRole = $$new_props.routerNavbarRole);
		if ("routerNavbarRoleDetailRoot" in $$props) $$invalidate(38, routerNavbarRoleDetailRoot = $$new_props.routerNavbarRoleDetailRoot);
		if ("routerNavbarMasterStack" in $$props) $$invalidate(39, routerNavbarMasterStack = $$new_props.routerNavbarMasterStack);
		if ("transparentVisible" in $$props) $$invalidate(40, transparentVisible = $$new_props.transparentVisible);
		if ("hasLeftSlots" in $$props) $$invalidate(8, hasLeftSlots = $$new_props.hasLeftSlots);
		if ("hasRightSlots" in $$props) $$invalidate(9, hasRightSlots = $$new_props.hasRightSlots);
		if ("hasTitleSlots" in $$props) $$invalidate(10, hasTitleSlots = $$new_props.hasTitleSlots);
		if ("largeTitle" in $$props) $$invalidate(11, largeTitle = $$new_props.largeTitle);
		if ("hasTitleLargeSlots" in $$props) $$invalidate(12, hasTitleLargeSlots = $$new_props.hasTitleLargeSlots);
		if ("addLeftTitleClass" in $$props) $$invalidate(41, addLeftTitleClass = $$new_props.addLeftTitleClass);
		if ("addCenterTitleClass" in $$props) $$invalidate(42, addCenterTitleClass = $$new_props.addCenterTitleClass);
		if ("isLarge" in $$props) $$invalidate(43, isLarge = $$new_props.isLarge);
		if ("isTransparent" in $$props) $$invalidate(44, isTransparent = $$new_props.isTransparent);
		if ("isTransparentVisible" in $$props) $$invalidate(45, isTransparentVisible = $$new_props.isTransparentVisible);
		if ("classes" in $$props) $$invalidate(13, classes = $$new_props.classes);
		if ("innerClasses" in $$props) $$invalidate(14, innerClasses = $$new_props.innerClasses);
	};

	let hasLeftSlots;
	let hasRightSlots;
	let hasTitleSlots;
	let largeTitle;
	let hasTitleLargeSlots;
	let addLeftTitleClass;
	let addCenterTitleClass;
	let isLarge;
	let isTransparent;
	let isTransparentVisible;
	let classes;
	let innerClasses;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*titleLarge, large, title*/ 150994960) {
			 $$invalidate(11, largeTitle = titleLarge || large && title);
		}

		if ($$self.$$.dirty[1] & /*_theme*/ 8) {
			 $$invalidate(41, addLeftTitleClass = _theme && _theme.ios && f7.instance && !f7.instance.params.navbar.iosCenterTitle);
		}

		if ($$self.$$.dirty[1] & /*_theme*/ 8) {
			 $$invalidate(42, addCenterTitleClass = _theme && _theme.md && f7.instance && f7.instance.params.navbar.mdCenterTitle || _theme && _theme.aurora && f7.instance && f7.instance.params.navbar.auroraCenterTitle);
		}

		if ($$self.$$.dirty[0] & /*large, largeTransparent*/ 50331648) {
			 $$invalidate(43, isLarge = large || largeTransparent);
		}

		if ($$self.$$.dirty[0] & /*transparent, largeTransparent*/ 100663296 | $$self.$$.dirty[1] & /*isLarge*/ 4096) {
			 $$invalidate(44, isTransparent = transparent || isLarge && largeTransparent);
		}

		if ($$self.$$.dirty[1] & /*isTransparent, transparentVisible*/ 8704) {
			 $$invalidate(45, isTransparentVisible = isTransparent && transparentVisible);
		}

		 $$invalidate(13, classes = Utils$1.classNames(
			className,
			"navbar",
			routerPositionClass,
			{
				"navbar-hidden": hidden,
				"navbar-large": isLarge,
				"navbar-large-collapsed": isLarge && largeCollapsed,
				"navbar-transparent": isTransparent,
				"navbar-transparent-visible": isTransparentVisible,
				"navbar-master": routerNavbarRole === "master",
				"navbar-master-detail": routerNavbarRole === "detail",
				"navbar-master-detail-root": routerNavbarRoleDetailRoot === true,
				"navbar-master-stacked": routerNavbarMasterStack === true,
				"no-shadow": noShadow,
				"no-hairline": noHairline
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*innerClass, innerClassName, sliding*/ 12845056 | $$self.$$.dirty[1] & /*addLeftTitleClass, addCenterTitleClass*/ 3072) {
			 $$invalidate(14, innerClasses = Utils$1.classNames("navbar-inner", innerClass, innerClassName, {
				sliding,
				"navbar-inner-left-title": addLeftTitleClass,
				"navbar-inner-centered-title": addCenterTitleClass
			}));
		}
	};

	 $$invalidate(8, hasLeftSlots = hasSlots(arguments, "nav-left") || hasSlots(arguments, "left"));

	// eslint-disable-next-line
	 $$invalidate(9, hasRightSlots = hasSlots(arguments, "nav-right") || hasSlots(arguments, "right"));

	// eslint-disable-next-line
	 $$invalidate(10, hasTitleSlots = hasSlots(arguments, "title"));

	// eslint-disable-next-line
	 $$invalidate(12, hasTitleLargeSlots = hasSlots(arguments, "title-large"));

	$$props = exclude_internal_props($$props);

	return [
		backLink,
		backLinkUrl,
		backLinkForce,
		backLinkShowText,
		title,
		subtitle,
		f7Slot,
		el,
		hasLeftSlots,
		hasRightSlots,
		hasTitleSlots,
		largeTitle,
		hasTitleLargeSlots,
		classes,
		innerClasses,
		onBackClick,
		$$restProps,
		className,
		sliding,
		hidden,
		noShadow,
		noHairline,
		innerClass,
		innerClassName,
		large,
		largeTransparent,
		transparent,
		titleLarge,
		hide,
		show,
		size,
		$$slots,
		div2_binding,
		$$scope
	];
}

class Navbar$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$e,
			create_fragment$f,
			safe_not_equal,
			{
				class: 17,
				backLink: 0,
				backLinkUrl: 1,
				backLinkForce: 2,
				backLinkShowText: 3,
				sliding: 18,
				title: 4,
				subtitle: 5,
				hidden: 19,
				noShadow: 20,
				noHairline: 21,
				innerClass: 22,
				innerClassName: 23,
				large: 24,
				largeTransparent: 25,
				transparent: 26,
				titleLarge: 27,
				f7Slot: 6,
				hide: 28,
				show: 29,
				size: 30
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Navbar",
			options,
			id: create_fragment$f.name
		});
	}

	get class() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLink() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLink(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkUrl() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkUrl(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkForce() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkForce(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkShowText() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkShowText(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliding() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliding(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hidden() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hidden(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noShadow() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noShadow(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairline() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairline(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get innerClass() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set innerClass(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get innerClassName() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set innerClassName(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get large() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set large(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeTransparent() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeTransparent(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transparent() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transparent(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get titleLarge() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set titleLarge(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hide() {
		return this.$$.ctx[28];
	}

	set hide(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show() {
		return this.$$.ctx[29];
	}

	set show(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		return this.$$.ctx[30];
	}

	set size(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$g = "node_modules/framework7-svelte/components/preloader.svelte";

// (67:2) {:else}
function create_else_block$4(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "preloader-inner");
			add_location(span, file$g, 67, 2, 2080);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(67:2) {:else}",
		ctx
	});

	return block;
}

// (63:36) 
function create_if_block_2$6(ctx) {
	let span1;
	let span0;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			attr_dev(span0, "class", "preloader-inner-circle");
			add_location(span0, file$g, 64, 4, 2013);
			attr_dev(span1, "class", "preloader-inner");
			add_location(span1, file$g, 63, 2, 1978);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$6.name,
		type: "if",
		source: "(63:36) ",
		ctx
	});

	return block;
}

// (48:33) 
function create_if_block_1$7(ctx) {
	let span12;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let t2;
	let span3;
	let t3;
	let span4;
	let t4;
	let span5;
	let t5;
	let span6;
	let t6;
	let span7;
	let t7;
	let span8;
	let t8;
	let span9;
	let t9;
	let span10;
	let t10;
	let span11;

	const block = {
		c: function create() {
			span12 = element("span");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			t2 = space();
			span3 = element("span");
			t3 = space();
			span4 = element("span");
			t4 = space();
			span5 = element("span");
			t5 = space();
			span6 = element("span");
			t6 = space();
			span7 = element("span");
			t7 = space();
			span8 = element("span");
			t8 = space();
			span9 = element("span");
			t9 = space();
			span10 = element("span");
			t10 = space();
			span11 = element("span");
			attr_dev(span0, "class", "preloader-inner-line");
			add_location(span0, file$g, 49, 4, 1369);
			attr_dev(span1, "class", "preloader-inner-line");
			add_location(span1, file$g, 50, 4, 1416);
			attr_dev(span2, "class", "preloader-inner-line");
			add_location(span2, file$g, 51, 4, 1463);
			attr_dev(span3, "class", "preloader-inner-line");
			add_location(span3, file$g, 52, 4, 1510);
			attr_dev(span4, "class", "preloader-inner-line");
			add_location(span4, file$g, 53, 4, 1557);
			attr_dev(span5, "class", "preloader-inner-line");
			add_location(span5, file$g, 54, 4, 1604);
			attr_dev(span6, "class", "preloader-inner-line");
			add_location(span6, file$g, 55, 4, 1651);
			attr_dev(span7, "class", "preloader-inner-line");
			add_location(span7, file$g, 56, 4, 1698);
			attr_dev(span8, "class", "preloader-inner-line");
			add_location(span8, file$g, 57, 4, 1745);
			attr_dev(span9, "class", "preloader-inner-line");
			add_location(span9, file$g, 58, 4, 1792);
			attr_dev(span10, "class", "preloader-inner-line");
			add_location(span10, file$g, 59, 4, 1839);
			attr_dev(span11, "class", "preloader-inner-line");
			add_location(span11, file$g, 60, 4, 1886);
			attr_dev(span12, "class", "preloader-inner");
			add_location(span12, file$g, 48, 2, 1334);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span12, anchor);
			append_dev(span12, span0);
			append_dev(span12, t0);
			append_dev(span12, span1);
			append_dev(span12, t1);
			append_dev(span12, span2);
			append_dev(span12, t2);
			append_dev(span12, span3);
			append_dev(span12, t3);
			append_dev(span12, span4);
			append_dev(span12, t4);
			append_dev(span12, span5);
			append_dev(span12, t5);
			append_dev(span12, span6);
			append_dev(span12, t6);
			append_dev(span12, span7);
			append_dev(span12, t7);
			append_dev(span12, span8);
			append_dev(span12, t8);
			append_dev(span12, span9);
			append_dev(span12, t9);
			append_dev(span12, span10);
			append_dev(span12, t10);
			append_dev(span12, span11);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span12);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(48:33) ",
		ctx
	});

	return block;
}

// (38:2) {#if _theme && _theme.md}
function create_if_block$8(ctx) {
	let span5;
	let span0;
	let t0;
	let span2;
	let span1;
	let t1;
	let span4;
	let span3;

	const block = {
		c: function create() {
			span5 = element("span");
			span0 = element("span");
			t0 = space();
			span2 = element("span");
			span1 = element("span");
			t1 = space();
			span4 = element("span");
			span3 = element("span");
			attr_dev(span0, "class", "preloader-inner-gap");
			add_location(span0, file$g, 39, 4, 1044);
			attr_dev(span1, "class", "preloader-inner-half-circle");
			add_location(span1, file$g, 41, 6, 1127);
			attr_dev(span2, "class", "preloader-inner-left");
			add_location(span2, file$g, 40, 4, 1085);
			attr_dev(span3, "class", "preloader-inner-half-circle");
			add_location(span3, file$g, 44, 6, 1231);
			attr_dev(span4, "class", "preloader-inner-right");
			add_location(span4, file$g, 43, 4, 1188);
			attr_dev(span5, "class", "preloader-inner");
			add_location(span5, file$g, 38, 2, 1009);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span5, anchor);
			append_dev(span5, span0);
			append_dev(span5, t0);
			append_dev(span5, span2);
			append_dev(span2, span1);
			append_dev(span5, t1);
			append_dev(span5, span4);
			append_dev(span4, span3);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(38:2) {#if _theme && _theme.md}",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let span;

	function select_block_type(ctx, dirty) {
		if (/*_theme*/ ctx[0] && /*_theme*/ ctx[0].md) return create_if_block$8;
		if (/*_theme*/ ctx[0] && /*_theme*/ ctx[0].ios) return create_if_block_1$7;
		if (/*_theme*/ ctx[0] && /*_theme*/ ctx[0].aurora) return create_if_block_2$6;
		return create_else_block$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	let span_levels = [
		{ style: /*preloaderStyle*/ ctx[1] },
		{ class: /*classes*/ ctx[2] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if_block.c();
			set_attributes(span, span_data);
			add_location(span, file$g, 36, 0, 905);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if_block.m(span, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(span, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				dirty & /*preloaderStyle*/ 2 && { style: /*preloaderStyle*/ ctx[1] },
				dirty & /*classes*/ 4 && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	const omit_props_names = ["style","class","size"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { size = undefined } = $$props;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(0, _theme = f7Theme);
		});
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Preloader", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("style" in $$new_props) $$invalidate(4, style = $$new_props.style);
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("size" in $$new_props) $$invalidate(6, size = $$new_props.size);
	};

	$$self.$capture_state = () => ({
		theme: f7Theme,
		Utils: Utils$1,
		restProps,
		Mixins,
		f7,
		style,
		className,
		size,
		_theme,
		sizeComputed,
		preloaderStyle,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("style" in $$props) $$invalidate(4, style = $$new_props.style);
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("size" in $$props) $$invalidate(6, size = $$new_props.size);
		if ("_theme" in $$props) $$invalidate(0, _theme = $$new_props._theme);
		if ("sizeComputed" in $$props) $$invalidate(7, sizeComputed = $$new_props.sizeComputed);
		if ("preloaderStyle" in $$props) $$invalidate(1, preloaderStyle = $$new_props.preloaderStyle);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let sizeComputed;
	let preloaderStyle;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 64) {
			 $$invalidate(7, sizeComputed = size && typeof size === "string" && size.indexOf("px") >= 0
			? size.replace("px", "")
			: size);
		}

		if ($$self.$$.dirty & /*style, sizeComputed*/ 144) {
			 $$invalidate(1, preloaderStyle = ((style || "") + (sizeComputed
			? `;width: ${sizeComputed}px; height: ${sizeComputed}px; --f7-preloader-size: ${sizeComputed}px`
			: "")).replace(";;", ";"));
		}

		 $$invalidate(2, classes = Utils$1.classNames(className, "preloader", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [_theme, preloaderStyle, classes, $$restProps, style, className, size];
}

class Preloader$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$g, safe_not_equal, { style: 4, class: 5, size: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Preloader",
			options,
			id: create_fragment$g.name
		});
	}

	get style() {
		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$h = "node_modules/framework7-svelte/components/page-content.svelte";

// (147:2) {#if ptr && ptrPreloader && !ptrBottom}
function create_if_block_3$5(ctx) {
	let div1;
	let preloader;
	let t;
	let div0;
	let current;
	preloader = new Preloader$2({ $$inline: true });

	const block = {
		c: function create() {
			div1 = element("div");
			create_component(preloader.$$.fragment);
			t = space();
			div0 = element("div");
			attr_dev(div0, "class", "ptr-arrow");
			add_location(div0, file$h, 149, 6, 4501);
			attr_dev(div1, "class", "ptr-preloader");
			add_location(div1, file$h, 147, 4, 4447);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(preloader, div1, null);
			append_dev(div1, t);
			append_dev(div1, div0);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(preloader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$5.name,
		type: "if",
		source: "(147:2) {#if ptr && ptrPreloader && !ptrBottom}",
		ctx
	});

	return block;
}

// (153:2) {#if infinite && infiniteTop && infinitePreloader}
function create_if_block_2$7(ctx) {
	let preloader;
	let current;

	preloader = new Preloader$2({
			props: { class: "infinite-scroll-preloader" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(preloader.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(preloader, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(preloader, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$7.name,
		type: "if",
		source: "(153:2) {#if infinite && infiniteTop && infinitePreloader}",
		ctx
	});

	return block;
}

// (157:2) {#if infinite && !infiniteTop && infinitePreloader}
function create_if_block_1$8(ctx) {
	let preloader;
	let current;

	preloader = new Preloader$2({
			props: { class: "infinite-scroll-preloader" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(preloader.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(preloader, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(preloader, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(157:2) {#if infinite && !infiniteTop && infinitePreloader}",
		ctx
	});

	return block;
}

// (160:2) {#if ptr && ptrPreloader && ptrBottom}
function create_if_block$9(ctx) {
	let div1;
	let preloader;
	let t;
	let div0;
	let current;
	preloader = new Preloader$2({ $$inline: true });

	const block = {
		c: function create() {
			div1 = element("div");
			create_component(preloader.$$.fragment);
			t = space();
			div0 = element("div");
			attr_dev(div0, "class", "ptr-arrow");
			add_location(div0, file$h, 162, 6, 4881);
			attr_dev(div1, "class", "ptr-preloader");
			add_location(div1, file$h, 160, 4, 4827);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(preloader, div1, null);
			append_dev(div1, t);
			append_dev(div1, div0);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(preloader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(160:2) {#if ptr && ptrPreloader && ptrBottom}",
		ctx
	});

	return block;
}

function create_fragment$h(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let div_data_ptr_mousewheel_value;
	let div_data_infinite_distance_value;
	let current;
	let if_block0 = /*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && !/*ptrBottom*/ ctx[3] && create_if_block_3$5(ctx);
	let if_block1 = /*infinite*/ ctx[5] && /*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8] && create_if_block_2$7(ctx);
	const default_slot_template = /*$$slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	let if_block2 = /*infinite*/ ctx[5] && !/*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8] && create_if_block_1$8(ctx);
	let if_block3 = /*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && /*ptrBottom*/ ctx[3] && create_if_block$9(ctx);

	let div_levels = [
		{ class: /*pageContentClasses*/ ctx[10] },
		{
			"data-ptr-distance": /*ptrDistance*/ ctx[1]
		},
		{
			"data-ptr-mousewheel": div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[4] || undefined
		},
		{
			"data-infinite-distance": div_data_infinite_distance_value = /*infiniteDistance*/ ctx[7] || undefined
		},
		restProps(/*$$restProps*/ ctx[11])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();
			set_attributes(div, div_data);
			add_location(div, file$h, 138, 0, 4165);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t2);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t3);
			if (if_block3) if_block3.m(div, null);
			/*div_binding*/ ctx[22](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && !/*ptrBottom*/ ctx[3]) {
				if (if_block0) {
					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 13) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*infinite*/ ctx[5] && /*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8]) {
				if (if_block1) {
					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 352) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			if (/*infinite*/ ctx[5] && !/*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8]) {
				if (if_block2) {
					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 352) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$8(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && /*ptrBottom*/ ctx[3]) {
				if (if_block3) {
					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 13) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$9(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*pageContentClasses*/ 1024) && { class: /*pageContentClasses*/ ctx[10] },
				(!current || dirty[0] & /*ptrDistance*/ 2) && {
					"data-ptr-distance": /*ptrDistance*/ ctx[1]
				},
				(!current || dirty[0] & /*ptrMousewheel*/ 16 && div_data_ptr_mousewheel_value !== (div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[4] || undefined)) && {
					"data-ptr-mousewheel": div_data_ptr_mousewheel_value
				},
				(!current || dirty[0] & /*infiniteDistance*/ 128 && div_data_infinite_distance_value !== (div_data_infinite_distance_value = /*infiniteDistance*/ ctx[7] || undefined)) && {
					"data-infinite-distance": div_data_infinite_distance_value
				},
				dirty[0] & /*$$restProps*/ 2048 && restProps(/*$$restProps*/ ctx[11])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			/*div_binding*/ ctx[22](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"tab","tabActive","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { tab = false } = $$props;
	let { tabActive = false } = $$props;
	let { ptr = false } = $$props;
	let { ptrDistance = undefined } = $$props;
	let { ptrPreloader = true } = $$props;
	let { ptrBottom = false } = $$props;
	let { ptrMousewheel = false } = $$props;
	let { infinite = false } = $$props;
	let { infiniteTop = false } = $$props;
	let { infiniteDistance = undefined } = $$props;
	let { infinitePreloader = true } = $$props;
	let { hideBarsOnScroll = false } = $$props;
	let { hideNavbarOnScroll = false } = $$props;
	let { hideToolbarOnScroll = false } = $$props;
	let { messagesContent = false } = $$props;
	let { loginScreen = false } = $$props;
	let { class: className = undefined } = $$props;
	let pageContentEl;

	// Event handlers
	function onPtrPullStart(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrPullStart");
		if (typeof $$props.onPtrPullStart === "function") $$props.onPtrPullStart();
	}

	function onPtrPullMove(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrPullMove");
		if (typeof $$props.onPtrPullMove === "function") $$props.onPtrPullMove();
	}

	function onPtrPullEnd(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrPullEnd");
		if (typeof $$props.onPtrPullEnd === "function") $$props.onPtrPullEnd();
	}

	function onPtrRefresh(ptrEl, done) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrRefresh", [done]);
		if (typeof $$props.onPtrRefresh === "function") $$props.onPtrRefresh(done);
	}

	function onPtrDone(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrDone");
		if (typeof $$props.onPtrDone === "function") $$props.onPtrDone();
	}

	function onInfinite(infEl) {
		if (infEl !== pageContentEl) return;
		dispatch("infinite");
		if (typeof $$props.onInfinite === "function") $$props.onInfinite();
	}

	function onTabShow(tabEl) {
		if (pageContentEl !== tabEl) return;
		dispatch("tabShow");
		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
	}

	function onTabHide(tabEl) {
		if (pageContentEl !== tabEl) return;
		dispatch("tabHide");
		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
	}

	function mountPageContent() {
		if (ptr) {
			f7.instance.on("ptrPullStart", onPtrPullStart);
			f7.instance.on("ptrPullMove", onPtrPullMove);
			f7.instance.on("ptrPullEnd", onPtrPullEnd);
			f7.instance.on("ptrRefresh", onPtrRefresh);
			f7.instance.on("ptrDone", onPtrDone);
		}

		if (infinite) {
			f7.instance.on("infinite", onInfinite);
		}

		if (tab) {
			f7.instance.on("tabShow", onTabShow);
			f7.instance.on("tabHide", onTabHide);
		}
	}

	function destroyPageContent() {
		if (ptr) {
			f7.instance.off("ptrPullStart", onPtrPullStart);
			f7.instance.off("ptrPullMove", onPtrPullMove);
			f7.instance.off("ptrPullEnd", onPtrPullEnd);
			f7.instance.off("ptrRefresh", onPtrRefresh);
			f7.instance.off("ptrDone", onPtrDone);
		}

		if (infinite) {
			f7.instance.off("infinite", onInfinite);
		}

		if (tab) {
			f7.instance.off("tabShow", onTabShow);
			f7.instance.off("tabHide", onTabHide);
		}
	}

	onMount(() => {
		f7.ready(() => {
			mountPageContent();
		});
	});

	onDestroy(() => {
		if (!f7.instance) return;
		destroyPageContent();
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Page_content", $$slots, ['default']);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			pageContentEl = $$value;
			$$invalidate(9, pageContentEl);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(34, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("tab" in $$new_props) $$invalidate(12, tab = $$new_props.tab);
		if ("tabActive" in $$new_props) $$invalidate(13, tabActive = $$new_props.tabActive);
		if ("ptr" in $$new_props) $$invalidate(0, ptr = $$new_props.ptr);
		if ("ptrDistance" in $$new_props) $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
		if ("ptrPreloader" in $$new_props) $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
		if ("ptrBottom" in $$new_props) $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
		if ("ptrMousewheel" in $$new_props) $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
		if ("infinite" in $$new_props) $$invalidate(5, infinite = $$new_props.infinite);
		if ("infiniteTop" in $$new_props) $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
		if ("infiniteDistance" in $$new_props) $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
		if ("infinitePreloader" in $$new_props) $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
		if ("hideBarsOnScroll" in $$new_props) $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ("hideNavbarOnScroll" in $$new_props) $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ("hideToolbarOnScroll" in $$new_props) $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ("messagesContent" in $$new_props) $$invalidate(17, messagesContent = $$new_props.messagesContent);
		if ("loginScreen" in $$new_props) $$invalidate(18, loginScreen = $$new_props.loginScreen);
		if ("class" in $$new_props) $$invalidate(19, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		createEventDispatcher,
		Utils: Utils$1,
		restProps,
		Mixins,
		f7,
		Preloader: Preloader$2,
		dispatch,
		tab,
		tabActive,
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		className,
		pageContentEl,
		onPtrPullStart,
		onPtrPullMove,
		onPtrPullEnd,
		onPtrRefresh,
		onPtrDone,
		onInfinite,
		onTabShow,
		onTabHide,
		mountPageContent,
		destroyPageContent,
		pageContentClasses
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(34, $$props = assign(assign({}, $$props), $$new_props));
		if ("tab" in $$props) $$invalidate(12, tab = $$new_props.tab);
		if ("tabActive" in $$props) $$invalidate(13, tabActive = $$new_props.tabActive);
		if ("ptr" in $$props) $$invalidate(0, ptr = $$new_props.ptr);
		if ("ptrDistance" in $$props) $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
		if ("ptrPreloader" in $$props) $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
		if ("ptrBottom" in $$props) $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
		if ("ptrMousewheel" in $$props) $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
		if ("infinite" in $$props) $$invalidate(5, infinite = $$new_props.infinite);
		if ("infiniteTop" in $$props) $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
		if ("infiniteDistance" in $$props) $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
		if ("infinitePreloader" in $$props) $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
		if ("hideBarsOnScroll" in $$props) $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ("hideNavbarOnScroll" in $$props) $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ("hideToolbarOnScroll" in $$props) $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ("messagesContent" in $$props) $$invalidate(17, messagesContent = $$new_props.messagesContent);
		if ("loginScreen" in $$props) $$invalidate(18, loginScreen = $$new_props.loginScreen);
		if ("className" in $$props) $$invalidate(19, className = $$new_props.className);
		if ("pageContentEl" in $$props) $$invalidate(9, pageContentEl = $$new_props.pageContentEl);
		if ("pageContentClasses" in $$props) $$invalidate(10, pageContentClasses = $$new_props.pageContentClasses);
	};

	let pageContentClasses;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(10, pageContentClasses = Utils$1.classNames(
			className,
			"page-content",
			{
				tab,
				"tab-active": tabActive,
				"ptr-content": ptr,
				"ptr-bottom": ptrBottom,
				"infinite-scroll-content": infinite,
				"infinite-scroll-top": infiniteTop,
				"hide-bars-on-scroll": hideBarsOnScroll,
				"hide-navbar-on-scroll": hideNavbarOnScroll,
				"hide-toolbar-on-scroll": hideToolbarOnScroll,
				"messages-content": messagesContent,
				"login-screen-content": loginScreen
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		pageContentEl,
		pageContentClasses,
		$$restProps,
		tab,
		tabActive,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		className,
		$$scope,
		$$slots,
		div_binding
	];
}

class Page_content extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$g,
			create_fragment$h,
			safe_not_equal,
			{
				tab: 12,
				tabActive: 13,
				ptr: 0,
				ptrDistance: 1,
				ptrPreloader: 2,
				ptrBottom: 3,
				ptrMousewheel: 4,
				infinite: 5,
				infiniteTop: 6,
				infiniteDistance: 7,
				infinitePreloader: 8,
				hideBarsOnScroll: 14,
				hideNavbarOnScroll: 15,
				hideToolbarOnScroll: 16,
				messagesContent: 17,
				loginScreen: 18,
				class: 19
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Page_content",
			options,
			id: create_fragment$h.name
		});
	}

	get tab() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabActive() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabActive(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptr() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptr(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrDistance() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrDistance(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrPreloader() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrPreloader(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrBottom() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrBottom(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrMousewheel() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrMousewheel(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infinite() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infinite(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infiniteTop() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infiniteTop(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infiniteDistance() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infiniteDistance(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infinitePreloader() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infinitePreloader(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideBarsOnScroll() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideBarsOnScroll(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideNavbarOnScroll() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideNavbarOnScroll(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideToolbarOnScroll() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideToolbarOnScroll(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get messagesContent() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set messagesContent(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loginScreen() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loginScreen(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$i = "node_modules/framework7-svelte/components/page.svelte";
const get_static_slot_changes_1 = dirty => ({});
const get_static_slot_context_1 = ctx => ({});
const get_static_slot_changes = dirty => ({});
const get_static_slot_context = ctx => ({});
const get_fixed_slot_changes = dirty => ({});
const get_fixed_slot_context = ctx => ({});

// (353:2) {:else}
function create_else_block$5(ctx) {
	let t;
	let current;
	const static_slot_template = /*$$slots*/ ctx[35].static;
	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[37], get_static_slot_context_1);
	const default_slot_template = /*$$slots*/ ctx[35].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[37], null);

	const block = {
		c: function create() {
			if (static_slot) static_slot.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (static_slot) {
				static_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (static_slot) {
				if (static_slot.p && dirty[1] & /*$$scope*/ 64) {
					update_slot(static_slot, static_slot_template, ctx, /*$$scope*/ ctx[37], dirty, get_static_slot_changes_1, get_static_slot_context_1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[37], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(static_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(static_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (static_slot) static_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(353:2) {:else}",
		ctx
	});

	return block;
}

// (327:2) {#if pageContent}
function create_if_block$a(ctx) {
	let pagecontent;
	let current;

	pagecontent = new Page_content({
			props: {
				ptr: /*ptr*/ ctx[2],
				ptrDistance: /*ptrDistance*/ ctx[3],
				ptrPreloader: /*ptrPreloader*/ ctx[4],
				ptrBottom: /*ptrBottom*/ ctx[5],
				ptrMousewheel: /*ptrMousewheel*/ ctx[6],
				infinite: /*infinite*/ ctx[7],
				infiniteTop: /*infiniteTop*/ ctx[8],
				infiniteDistance: /*infiniteDistance*/ ctx[9],
				infinitePreloader: /*infinitePreloader*/ ctx[10],
				hideBarsOnScroll: /*hideBarsOnScroll*/ ctx[11],
				hideNavbarOnScroll: /*hideNavbarOnScroll*/ ctx[12],
				hideToolbarOnScroll: /*hideToolbarOnScroll*/ ctx[13],
				messagesContent: /*messagesContent*/ ctx[14],
				loginScreen: /*loginScreen*/ ctx[15],
				onPtrPullStart: /*onPtrPullStart*/ ctx[18],
				onPtrPullMove: /*onPtrPullMove*/ ctx[19],
				onPtrPullEnd: /*onPtrPullEnd*/ ctx[20],
				onPtrRefresh: /*onPtrRefresh*/ ctx[21],
				onPtrDone: /*onPtrDone*/ ctx[22],
				onInfinite: /*onInfinite*/ ctx[23],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(pagecontent.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(pagecontent, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const pagecontent_changes = {};
			if (dirty[0] & /*ptr*/ 4) pagecontent_changes.ptr = /*ptr*/ ctx[2];
			if (dirty[0] & /*ptrDistance*/ 8) pagecontent_changes.ptrDistance = /*ptrDistance*/ ctx[3];
			if (dirty[0] & /*ptrPreloader*/ 16) pagecontent_changes.ptrPreloader = /*ptrPreloader*/ ctx[4];
			if (dirty[0] & /*ptrBottom*/ 32) pagecontent_changes.ptrBottom = /*ptrBottom*/ ctx[5];
			if (dirty[0] & /*ptrMousewheel*/ 64) pagecontent_changes.ptrMousewheel = /*ptrMousewheel*/ ctx[6];
			if (dirty[0] & /*infinite*/ 128) pagecontent_changes.infinite = /*infinite*/ ctx[7];
			if (dirty[0] & /*infiniteTop*/ 256) pagecontent_changes.infiniteTop = /*infiniteTop*/ ctx[8];
			if (dirty[0] & /*infiniteDistance*/ 512) pagecontent_changes.infiniteDistance = /*infiniteDistance*/ ctx[9];
			if (dirty[0] & /*infinitePreloader*/ 1024) pagecontent_changes.infinitePreloader = /*infinitePreloader*/ ctx[10];
			if (dirty[0] & /*hideBarsOnScroll*/ 2048) pagecontent_changes.hideBarsOnScroll = /*hideBarsOnScroll*/ ctx[11];
			if (dirty[0] & /*hideNavbarOnScroll*/ 4096) pagecontent_changes.hideNavbarOnScroll = /*hideNavbarOnScroll*/ ctx[12];
			if (dirty[0] & /*hideToolbarOnScroll*/ 8192) pagecontent_changes.hideToolbarOnScroll = /*hideToolbarOnScroll*/ ctx[13];
			if (dirty[0] & /*messagesContent*/ 16384) pagecontent_changes.messagesContent = /*messagesContent*/ ctx[14];
			if (dirty[0] & /*loginScreen*/ 32768) pagecontent_changes.loginScreen = /*loginScreen*/ ctx[15];

			if (dirty[1] & /*$$scope*/ 64) {
				pagecontent_changes.$$scope = { dirty, ctx };
			}

			pagecontent.$set(pagecontent_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pagecontent.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pagecontent.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(pagecontent, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(327:2) {#if pageContent}",
		ctx
	});

	return block;
}

// (328:2) <PageContent     ptr={ptr}     ptrDistance={ptrDistance}     ptrPreloader={ptrPreloader}     ptrBottom={ptrBottom}     ptrMousewheel={ptrMousewheel}     infinite={infinite}     infiniteTop={infiniteTop}     infiniteDistance={infiniteDistance}     infinitePreloader={infinitePreloader}     hideBarsOnScroll={hideBarsOnScroll}     hideNavbarOnScroll={hideNavbarOnScroll}     hideToolbarOnScroll={hideToolbarOnScroll}     messagesContent={messagesContent}     loginScreen={loginScreen}     onPtrPullStart={onPtrPullStart}     onPtrPullMove={onPtrPullMove}     onPtrPullEnd={onPtrPullEnd}     onPtrRefresh={onPtrRefresh}     onPtrDone={onPtrDone}     onInfinite={onInfinite}   >
function create_default_slot$3(ctx) {
	let t;
	let current;
	const static_slot_template = /*$$slots*/ ctx[35].static;
	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[37], get_static_slot_context);
	const default_slot_template = /*$$slots*/ ctx[35].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[37], null);

	const block = {
		c: function create() {
			if (static_slot) static_slot.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (static_slot) {
				static_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (static_slot) {
				if (static_slot.p && dirty[1] & /*$$scope*/ 64) {
					update_slot(static_slot, static_slot_template, ctx, /*$$scope*/ ctx[37], dirty, get_static_slot_changes, get_static_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[37], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(static_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(static_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (static_slot) static_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(328:2) <PageContent     ptr={ptr}     ptrDistance={ptrDistance}     ptrPreloader={ptrPreloader}     ptrBottom={ptrBottom}     ptrMousewheel={ptrMousewheel}     infinite={infinite}     infiniteTop={infiniteTop}     infiniteDistance={infiniteDistance}     infinitePreloader={infinitePreloader}     hideBarsOnScroll={hideBarsOnScroll}     hideNavbarOnScroll={hideNavbarOnScroll}     hideToolbarOnScroll={hideToolbarOnScroll}     messagesContent={messagesContent}     loginScreen={loginScreen}     onPtrPullStart={onPtrPullStart}     onPtrPullMove={onPtrPullMove}     onPtrPullEnd={onPtrPullEnd}     onPtrRefresh={onPtrRefresh}     onPtrDone={onPtrDone}     onInfinite={onInfinite}   >",
		ctx
	});

	return block;
}

function create_fragment$i(ctx) {
	let div;
	let t;
	let current_block_type_index;
	let if_block;
	let current;
	const fixed_slot_template = /*$$slots*/ ctx[35].fixed;
	const fixed_slot = create_slot(fixed_slot_template, ctx, /*$$scope*/ ctx[37], get_fixed_slot_context);
	const if_block_creators = [create_if_block$a, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*pageContent*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div_levels = [
		{ class: /*classes*/ ctx[17] },
		{ "data-name": /*name*/ ctx[0] },
		restProps(/*$$restProps*/ ctx[24])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (fixed_slot) fixed_slot.c();
			t = space();
			if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$i, 324, 0, 11332);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (fixed_slot) {
				fixed_slot.m(div, null);
			}

			append_dev(div, t);
			if_blocks[current_block_type_index].m(div, null);
			/*div_binding*/ ctx[36](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (fixed_slot) {
				if (fixed_slot.p && dirty[1] & /*$$scope*/ 64) {
					update_slot(fixed_slot, fixed_slot_template, ctx, /*$$scope*/ ctx[37], dirty, get_fixed_slot_changes, get_fixed_slot_context);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 131072) && { class: /*classes*/ ctx[17] },
				(!current || dirty[0] & /*name*/ 1) && { "data-name": /*name*/ ctx[0] },
				dirty[0] & /*$$restProps*/ 16777216 && restProps(/*$$restProps*/ ctx[24])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fixed_slot, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(fixed_slot, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (fixed_slot) fixed_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			/*div_binding*/ ctx[36](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"name","stacked","withSubnavbar","subnavbar","withNavbarLarge","navbarLarge","noNavbar","noToolbar","tabs","pageContent","noSwipeback","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { name = undefined } = $$props;
	let { stacked = undefined } = $$props;
	let { withSubnavbar = undefined } = $$props;
	let { subnavbar = undefined } = $$props;
	let { withNavbarLarge = undefined } = $$props;
	let { navbarLarge = undefined } = $$props;
	let { noNavbar = undefined } = $$props;
	let { noToolbar = undefined } = $$props;
	let { tabs = undefined } = $$props;
	let { pageContent = true } = $$props;
	let { noSwipeback = undefined } = $$props;
	let { ptr = undefined } = $$props;
	let { ptrDistance = undefined } = $$props;
	let { ptrPreloader = true } = $$props;
	let { ptrBottom = undefined } = $$props;
	let { ptrMousewheel = undefined } = $$props;
	let { infinite = undefined } = $$props;
	let { infiniteTop = undefined } = $$props;
	let { infiniteDistance = undefined } = $$props;
	let { infinitePreloader = true } = $$props;
	let { hideBarsOnScroll = undefined } = $$props;
	let { hideNavbarOnScroll = undefined } = $$props;
	let { hideToolbarOnScroll = undefined } = $$props;
	let { messagesContent = undefined } = $$props;
	let { loginScreen = undefined } = $$props;
	let { class: className = undefined } = $$props;

	// State
	let el;

	let hasSubnavbar = false;
	let hasNavbarLarge = false;
	let hasNavbarLargeCollapsed = false;
	let hasCardExpandableOpened = false;
	let routerPositionClass = "";
	let routerForceUnstack = false;
	let routerPageRole = null;
	let routerPageRoleDetailRoot = false;
	let routerPageMasterStack = false;

	// Handlers
	function onPtrPullStart() {
		dispatch("ptrPullStart");
		if (typeof $$props.onPtrPullStart === "function") $$props.onPtrPullStart();
	}

	function onPtrPullMove() {
		dispatch("ptrPullMove");
		if (typeof $$props.onPtrPullMove === "function") $$props.onPtrPullMove();
	}

	function onPtrPullEnd() {
		dispatch("ptrPullEnd");
		if (typeof $$props.onPtrPullEnd === "function") $$props.onPtrPullEnd();
	}

	function onPtrRefresh(done) {
		dispatch("ptrRefresh", [done]);
		if (typeof $$props.onPtrRefresh === "function") $$props.onPtrRefresh(done);
	}

	function onPtrDone() {
		dispatch("ptrDone");
		if (typeof $$props.onPtrDone === "function") $$props.onPtrDone();
	}

	function onInfinite() {
		dispatch("infinite");
		if (typeof $$props.onInfinite === "function") $$props.onInfinite();
	}

	// Main Page Events
	function onPageMounted(page) {
		if (el !== page.el) return;
		dispatch("pageMounted", [page]);
		if (typeof $$props.onPageMounted === "function") $$props.onPageMounted(page);
	}

	function onPageInit(page) {
		if (el !== page.el) return;

		if (typeof withSubnavbar === "undefined" && typeof subnavbar === "undefined") {
			if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find(".subnavbar").length || page.$el.children(".navbar").find(".subnavbar").length) {
				$$invalidate(38, hasSubnavbar = true);
			}
		}

		if (typeof withNavbarLarge === "undefined" && typeof navbarLarge === "undefined") {
			if (page.$navbarEl && page.$navbarEl.hasClass("navbar-large") || page.$el.children(".navbar-large").length) {
				$$invalidate(39, hasNavbarLarge = true);
			}
		}

		dispatch("pageInit", [page]);
		if (typeof $$props.onPageInit === "function") $$props.onPageInit(page);
	}

	function onPageReinit(page) {
		if (el !== page.el) return;
		dispatch("pageReinit", [page]);
		if (typeof $$props.onPageReinit === "function") $$props.onPageReinit(page);
	}

	function onPageBeforeIn(page) {
		if (el !== page.el) return;

		if (!page.swipeBack) {
			if (page.from === "next") {
				$$invalidate(42, routerPositionClass = "page-next");
			}

			if (page.from === "previous") {
				$$invalidate(42, routerPositionClass = "page-previous");
			}
		}

		dispatch("pageBeforeIn", [page]);
		if (typeof $$props.onPageBeforeIn === "function") $$props.onPageBeforeIn(page);
	}

	function onPageBeforeOut(page) {
		if (el !== page.el) return;
		dispatch("pageBeforeOut", [page]);
		if (typeof $$props.onPageBeforeOut === "function") $$props.onPageBeforeOut(page);
	}

	function onPageAfterOut(page) {
		if (el !== page.el) return;

		if (page.to === "next") {
			$$invalidate(42, routerPositionClass = "page-next");
		}

		if (page.to === "previous") {
			$$invalidate(42, routerPositionClass = "page-previous");
		}

		dispatch("pageAfterOut", [page]);
		if (typeof $$props.onPageAfterOut === "function") $$props.onPageAfterOut(page);
	}

	function onPageAfterIn(page) {
		if (el !== page.el) return;
		$$invalidate(42, routerPositionClass = "page-current");
		dispatch("pageAfterIn", [page]);
		if (typeof $$props.onPageAfterIn === "function") $$props.onPageAfterIn(page);
	}

	function onPageBeforeRemove(page) {
		if (el !== page.el) return;

		if (page.$navbarEl && page.$navbarEl[0] && page.$navbarEl.parent()[0] && page.$navbarEl.parent()[0] !== el) {
			page.$el.prepend(page.$navbarEl);
		}

		dispatch("pageBeforeRemove", [page]);
		if (typeof $$props.onPageBeforeRemove === "function") $$props.onPageBeforeRemove(page);
	}

	function onPageBeforeUnmount(page) {
		if (el !== page.el) return;
		dispatch("pageBeforeUnmount", [page]);
		if (typeof $$props.onPageBeforeUnmount === "function") $$props.onPageBeforeUnmount(page);
	}

	// Helper events
	function onPageStack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(43, routerForceUnstack = false);
	}

	function onPageUnstack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(43, routerForceUnstack = true);
	}

	function onPagePosition(pageEl, position) {
		if (el !== pageEl) return;
		$$invalidate(42, routerPositionClass = `page-${position}`);
	}

	function onPageRole(pageEl, rolesData) {
		if (el !== pageEl) return;
		$$invalidate(44, routerPageRole = rolesData.role);
		$$invalidate(45, routerPageRoleDetailRoot = rolesData.detailRoot);
	}

	function onPageMasterStack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(46, routerPageMasterStack = true);
	}

	function onPageMasterUnstack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(46, routerPageMasterStack = false);
	}

	function onPageNavbarLargeCollapsed(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(40, hasNavbarLargeCollapsed = true);
	}

	function onPageNavbarLargeExpanded(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(40, hasNavbarLargeCollapsed = false);
	}

	function onCardOpened(cardEl, pageEl) {
		if (el !== pageEl) return;
		$$invalidate(41, hasCardExpandableOpened = true);
	}

	function onCardClose(cardEl, pageEl) {
		if (el !== pageEl) return;
		$$invalidate(41, hasCardExpandableOpened = false);
	}

	function onPageTabShow(pageEl) {
		if (el !== pageEl) return;
		dispatch("pageTabShow");
		if (typeof $$props.onPageTabShow === "function") $$props.onPageTabShow();
	}

	function onPageTabHide(pageEl) {
		if (el !== pageEl) return;
		dispatch("pageTabHide");
		if (typeof $$props.onPageTabHide === "function") $$props.onPageTabHide();
	}

	// Mount/destroy
	function mountPage() {
		f7.instance.on("pageMounted", onPageMounted);
		f7.instance.on("pageInit", onPageInit);
		f7.instance.on("pageReinit", onPageReinit);
		f7.instance.on("pageBeforeIn", onPageBeforeIn);
		f7.instance.on("pageBeforeOut", onPageBeforeOut);
		f7.instance.on("pageAfterOut", onPageAfterOut);
		f7.instance.on("pageAfterIn", onPageAfterIn);
		f7.instance.on("pageBeforeRemove", onPageBeforeRemove);
		f7.instance.on("pageBeforeUnmount", onPageBeforeUnmount);
		f7.instance.on("pageStack", onPageStack);
		f7.instance.on("pageUnstack", onPageUnstack);
		f7.instance.on("pagePosition", onPagePosition);
		f7.instance.on("pageRole", onPageRole);
		f7.instance.on("pageMasterStack", onPageMasterStack);
		f7.instance.on("pageMasterUnstack", onPageMasterUnstack);
		f7.instance.on("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
		f7.instance.on("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
		f7.instance.on("cardOpened", onCardOpened);
		f7.instance.on("cardClose", onCardClose);
		f7.instance.on("pageTabShow", onPageTabShow);
		f7.instance.on("pageTabHide", onPageTabHide);
	}

	function destroyPage() {
		f7.instance.off("pageMounted", onPageMounted);
		f7.instance.off("pageInit", onPageInit);
		f7.instance.off("pageReinit", onPageReinit);
		f7.instance.off("pageBeforeIn", onPageBeforeIn);
		f7.instance.off("pageBeforeOut", onPageBeforeOut);
		f7.instance.off("pageAfterOut", onPageAfterOut);
		f7.instance.off("pageAfterIn", onPageAfterIn);
		f7.instance.off("pageBeforeRemove", onPageBeforeRemove);
		f7.instance.off("pageBeforeUnmount", onPageBeforeUnmount);
		f7.instance.off("pageStack", onPageStack);
		f7.instance.off("pageUnstack", onPageUnstack);
		f7.instance.off("pagePosition", onPagePosition);
		f7.instance.off("pageRole", onPageRole);
		f7.instance.off("pageMasterStack", onPageMasterStack);
		f7.instance.off("pageMasterUnstack", onPageMasterUnstack);
		f7.instance.off("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
		f7.instance.off("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
		f7.instance.off("cardOpened", onCardOpened);
		f7.instance.off("cardClose", onCardClose);
		f7.instance.off("pageTabShow", onPageTabShow);
		f7.instance.off("pageTabHide", onPageTabHide);
	}

	onMount(() => {
		f7.ready(() => {
			if (el) {
				const dom7 = f7.instance.$;
				const fixedEls = dom7(el).children(".page-content").children("[data-f7-slot=\"fixed\"]");

				if (fixedEls.length) {
					for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
						dom7(el).prepend(fixedEls[i]);
					}
				}
			}

			mountPage();
		});
	});

	afterUpdate(() => {
		if (el && f7.instance) {
			const dom7 = f7.instance.$;
			const fixedEls = dom7(el).children(".page-content").children("[data-f7-slot=\"fixed\"]");

			if (fixedEls.length) {
				for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
					dom7(el).prepend(fixedEls[i]);
				}
			}
		}
	});

	onDestroy(() => {
		if (!f7.instance) return;
		destroyPage();
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Page", $$slots, ['fixed','static','default']);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(16, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(73, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("name" in $$new_props) $$invalidate(0, name = $$new_props.name);
		if ("stacked" in $$new_props) $$invalidate(25, stacked = $$new_props.stacked);
		if ("withSubnavbar" in $$new_props) $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
		if ("subnavbar" in $$new_props) $$invalidate(27, subnavbar = $$new_props.subnavbar);
		if ("withNavbarLarge" in $$new_props) $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
		if ("navbarLarge" in $$new_props) $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
		if ("noNavbar" in $$new_props) $$invalidate(30, noNavbar = $$new_props.noNavbar);
		if ("noToolbar" in $$new_props) $$invalidate(31, noToolbar = $$new_props.noToolbar);
		if ("tabs" in $$new_props) $$invalidate(32, tabs = $$new_props.tabs);
		if ("pageContent" in $$new_props) $$invalidate(1, pageContent = $$new_props.pageContent);
		if ("noSwipeback" in $$new_props) $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
		if ("ptr" in $$new_props) $$invalidate(2, ptr = $$new_props.ptr);
		if ("ptrDistance" in $$new_props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
		if ("ptrPreloader" in $$new_props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
		if ("ptrBottom" in $$new_props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
		if ("ptrMousewheel" in $$new_props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
		if ("infinite" in $$new_props) $$invalidate(7, infinite = $$new_props.infinite);
		if ("infiniteTop" in $$new_props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
		if ("infiniteDistance" in $$new_props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
		if ("infinitePreloader" in $$new_props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
		if ("hideBarsOnScroll" in $$new_props) $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ("hideNavbarOnScroll" in $$new_props) $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ("hideToolbarOnScroll" in $$new_props) $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ("messagesContent" in $$new_props) $$invalidate(14, messagesContent = $$new_props.messagesContent);
		if ("loginScreen" in $$new_props) $$invalidate(15, loginScreen = $$new_props.loginScreen);
		if ("class" in $$new_props) $$invalidate(34, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(37, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		onDestroy,
		createEventDispatcher,
		Utils: Utils$1,
		restProps,
		Mixins,
		f7,
		PageContent: Page_content,
		dispatch,
		name,
		stacked,
		withSubnavbar,
		subnavbar,
		withNavbarLarge,
		navbarLarge,
		noNavbar,
		noToolbar,
		tabs,
		pageContent,
		noSwipeback,
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		className,
		el,
		hasSubnavbar,
		hasNavbarLarge,
		hasNavbarLargeCollapsed,
		hasCardExpandableOpened,
		routerPositionClass,
		routerForceUnstack,
		routerPageRole,
		routerPageRoleDetailRoot,
		routerPageMasterStack,
		onPtrPullStart,
		onPtrPullMove,
		onPtrPullEnd,
		onPtrRefresh,
		onPtrDone,
		onInfinite,
		onPageMounted,
		onPageInit,
		onPageReinit,
		onPageBeforeIn,
		onPageBeforeOut,
		onPageAfterOut,
		onPageAfterIn,
		onPageBeforeRemove,
		onPageBeforeUnmount,
		onPageStack,
		onPageUnstack,
		onPagePosition,
		onPageRole,
		onPageMasterStack,
		onPageMasterUnstack,
		onPageNavbarLargeCollapsed,
		onPageNavbarLargeExpanded,
		onCardOpened,
		onCardClose,
		onPageTabShow,
		onPageTabHide,
		mountPage,
		destroyPage,
		forceSubnavbar,
		forceNavbarLarge,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(73, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(0, name = $$new_props.name);
		if ("stacked" in $$props) $$invalidate(25, stacked = $$new_props.stacked);
		if ("withSubnavbar" in $$props) $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
		if ("subnavbar" in $$props) $$invalidate(27, subnavbar = $$new_props.subnavbar);
		if ("withNavbarLarge" in $$props) $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
		if ("navbarLarge" in $$props) $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
		if ("noNavbar" in $$props) $$invalidate(30, noNavbar = $$new_props.noNavbar);
		if ("noToolbar" in $$props) $$invalidate(31, noToolbar = $$new_props.noToolbar);
		if ("tabs" in $$props) $$invalidate(32, tabs = $$new_props.tabs);
		if ("pageContent" in $$props) $$invalidate(1, pageContent = $$new_props.pageContent);
		if ("noSwipeback" in $$props) $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
		if ("ptr" in $$props) $$invalidate(2, ptr = $$new_props.ptr);
		if ("ptrDistance" in $$props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
		if ("ptrPreloader" in $$props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
		if ("ptrBottom" in $$props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
		if ("ptrMousewheel" in $$props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
		if ("infinite" in $$props) $$invalidate(7, infinite = $$new_props.infinite);
		if ("infiniteTop" in $$props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
		if ("infiniteDistance" in $$props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
		if ("infinitePreloader" in $$props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
		if ("hideBarsOnScroll" in $$props) $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ("hideNavbarOnScroll" in $$props) $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ("hideToolbarOnScroll" in $$props) $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ("messagesContent" in $$props) $$invalidate(14, messagesContent = $$new_props.messagesContent);
		if ("loginScreen" in $$props) $$invalidate(15, loginScreen = $$new_props.loginScreen);
		if ("className" in $$props) $$invalidate(34, className = $$new_props.className);
		if ("el" in $$props) $$invalidate(16, el = $$new_props.el);
		if ("hasSubnavbar" in $$props) $$invalidate(38, hasSubnavbar = $$new_props.hasSubnavbar);
		if ("hasNavbarLarge" in $$props) $$invalidate(39, hasNavbarLarge = $$new_props.hasNavbarLarge);
		if ("hasNavbarLargeCollapsed" in $$props) $$invalidate(40, hasNavbarLargeCollapsed = $$new_props.hasNavbarLargeCollapsed);
		if ("hasCardExpandableOpened" in $$props) $$invalidate(41, hasCardExpandableOpened = $$new_props.hasCardExpandableOpened);
		if ("routerPositionClass" in $$props) $$invalidate(42, routerPositionClass = $$new_props.routerPositionClass);
		if ("routerForceUnstack" in $$props) $$invalidate(43, routerForceUnstack = $$new_props.routerForceUnstack);
		if ("routerPageRole" in $$props) $$invalidate(44, routerPageRole = $$new_props.routerPageRole);
		if ("routerPageRoleDetailRoot" in $$props) $$invalidate(45, routerPageRoleDetailRoot = $$new_props.routerPageRoleDetailRoot);
		if ("routerPageMasterStack" in $$props) $$invalidate(46, routerPageMasterStack = $$new_props.routerPageMasterStack);
		if ("forceSubnavbar" in $$props) $$invalidate(47, forceSubnavbar = $$new_props.forceSubnavbar);
		if ("forceNavbarLarge" in $$props) $$invalidate(48, forceNavbarLarge = $$new_props.forceNavbarLarge);
		if ("classes" in $$props) $$invalidate(17, classes = $$new_props.classes);
	};

	let forceSubnavbar;
	let forceNavbarLarge;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*subnavbar, withSubnavbar*/ 201326592 | $$self.$$.dirty[1] & /*hasSubnavbar*/ 128) {
			 $$invalidate(47, forceSubnavbar = typeof subnavbar === "undefined" && typeof withSubnavbar === "undefined"
			? hasSubnavbar
			: false);
		}

		if ($$self.$$.dirty[0] & /*navbarLarge, withNavbarLarge*/ 805306368 | $$self.$$.dirty[1] & /*hasNavbarLarge*/ 256) {
			 $$invalidate(48, forceNavbarLarge = typeof navbarLarge === "undefined" && typeof withNavbarLarge === "undefined"
			? hasNavbarLarge
			: false);
		}

		 $$invalidate(17, classes = Utils$1.classNames(
			className,
			"page",
			routerPositionClass,
			{
				stacked: stacked && !routerForceUnstack,
				tabs,
				"page-with-subnavbar": subnavbar || withSubnavbar || forceSubnavbar,
				"page-with-navbar-large": navbarLarge || withNavbarLarge || forceNavbarLarge,
				"no-navbar": noNavbar,
				"no-toolbar": noToolbar,
				"no-swipeback": noSwipeback,
				"page-master": routerPageRole === "master",
				"page-master-detail": routerPageRole === "detail",
				"page-master-detail-root": routerPageRoleDetailRoot === true,
				"page-master-stacked": routerPageMasterStack === true,
				"page-with-navbar-large-collapsed": hasNavbarLargeCollapsed === true,
				"page-with-card-opened": hasCardExpandableOpened === true,
				"login-screen-page": loginScreen
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		name,
		pageContent,
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		el,
		classes,
		onPtrPullStart,
		onPtrPullMove,
		onPtrPullEnd,
		onPtrRefresh,
		onPtrDone,
		onInfinite,
		$$restProps,
		stacked,
		withSubnavbar,
		subnavbar,
		withNavbarLarge,
		navbarLarge,
		noNavbar,
		noToolbar,
		tabs,
		noSwipeback,
		className,
		$$slots,
		div_binding,
		$$scope
	];
}

class Page extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$h,
			create_fragment$i,
			safe_not_equal,
			{
				name: 0,
				stacked: 25,
				withSubnavbar: 26,
				subnavbar: 27,
				withNavbarLarge: 28,
				navbarLarge: 29,
				noNavbar: 30,
				noToolbar: 31,
				tabs: 32,
				pageContent: 1,
				noSwipeback: 33,
				ptr: 2,
				ptrDistance: 3,
				ptrPreloader: 4,
				ptrBottom: 5,
				ptrMousewheel: 6,
				infinite: 7,
				infiniteTop: 8,
				infiniteDistance: 9,
				infinitePreloader: 10,
				hideBarsOnScroll: 11,
				hideNavbarOnScroll: 12,
				hideToolbarOnScroll: 13,
				messagesContent: 14,
				loginScreen: 15,
				class: 34
			},
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Page",
			options,
			id: create_fragment$i.name
		});
	}

	get name() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stacked() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stacked(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get withSubnavbar() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set withSubnavbar(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subnavbar() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subnavbar(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get withNavbarLarge() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set withNavbarLarge(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get navbarLarge() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set navbarLarge(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noNavbar() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noNavbar(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noToolbar() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noToolbar(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabs() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabs(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pageContent() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pageContent(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noSwipeback() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noSwipeback(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptr() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptr(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrDistance() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrDistance(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrPreloader() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrPreloader(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrBottom() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrBottom(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrMousewheel() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrMousewheel(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infinite() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infinite(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infiniteTop() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infiniteTop(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infiniteDistance() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infiniteDistance(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infinitePreloader() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infinitePreloader(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideBarsOnScroll() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideBarsOnScroll(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideNavbarOnScroll() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideNavbarOnScroll(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideToolbarOnScroll() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideToolbarOnScroll(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get messagesContent() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set messagesContent(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loginScreen() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loginScreen(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$j = "node_modules/framework7-svelte/components/searchbar.svelte";
const get_after_inner_slot_changes_1 = dirty => ({});
const get_after_inner_slot_context_1 = ctx => ({});
const get_inner_end_slot_changes_1$2 = dirty => ({});
const get_inner_end_slot_context_1$2 = ctx => ({});
const get_input_wrap_end_slot_changes_1 = dirty => ({});
const get_input_wrap_end_slot_context_1 = ctx => ({});
const get_input_wrap_start_slot_changes_1 = dirty => ({});
const get_input_wrap_start_slot_context_1 = ctx => ({});
const get_inner_start_slot_changes_1$2 = dirty => ({});
const get_inner_start_slot_context_1$2 = ctx => ({});
const get_before_inner_slot_changes_1 = dirty => ({});
const get_before_inner_slot_context_1 = ctx => ({});
const get_after_inner_slot_changes$1 = dirty => ({});
const get_after_inner_slot_context$1 = ctx => ({});
const get_inner_end_slot_changes$2 = dirty => ({});
const get_inner_end_slot_context$2 = ctx => ({});
const get_input_wrap_end_slot_changes = dirty => ({});
const get_input_wrap_end_slot_context = ctx => ({});
const get_input_wrap_start_slot_changes = dirty => ({});
const get_input_wrap_start_slot_context = ctx => ({});
const get_inner_start_slot_changes$2 = dirty => ({});
const get_inner_start_slot_context$2 = ctx => ({});
const get_before_inner_slot_changes$1 = dirty => ({});
const get_before_inner_slot_context$1 = ctx => ({});

// (208:0) {:else}
function create_else_block$6(ctx) {
	let div2;
	let t0;
	let div1;
	let t1;
	let div0;
	let t2;
	let input;
	let input_value_value;
	let t3;
	let i;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let current;
	let mounted;
	let dispose;
	const before_inner_slot_template = /*$$slots*/ ctx[47]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[46], get_before_inner_slot_context_1);
	const inner_start_slot_template = /*$$slots*/ ctx[47]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[46], get_inner_start_slot_context_1$2);
	const input_wrap_start_slot_template = /*$$slots*/ ctx[47]["input-wrap-start"];
	const input_wrap_start_slot = create_slot(input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[46], get_input_wrap_start_slot_context_1);
	let if_block0 = /*clearButton*/ ctx[4] && create_if_block_4$3(ctx);
	const input_wrap_end_slot_template = /*$$slots*/ ctx[47]["input-wrap-end"];
	const input_wrap_end_slot = create_slot(input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[46], get_input_wrap_end_slot_context_1);
	let if_block1 = /*disableButton*/ ctx[2] && create_if_block_3$6(ctx);
	const inner_end_slot_template = /*$$slots*/ ctx[47]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[46], get_inner_end_slot_context_1$2);
	const default_slot_template = /*$$slots*/ ctx[47].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[46], null);
	const after_inner_slot_template = /*$$slots*/ ctx[47]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[46], get_after_inner_slot_context_1);

	let div2_levels = [
		{ class: /*classes*/ ctx[8] },
		{ "data-f7-slot": /*f7Slot*/ ctx[6] },
		restProps(/*$$restProps*/ ctx[16])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t1 = space();
			div0 = element("div");
			if (input_wrap_start_slot) input_wrap_start_slot.c();
			t2 = space();
			input = element("input");
			t3 = space();
			i = element("i");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			if (input_wrap_end_slot) input_wrap_end_slot.c();
			t6 = space();
			if (if_block1) if_block1.c();
			t7 = space();
			if (inner_end_slot) inner_end_slot.c();
			t8 = space();
			if (default_slot) default_slot.c();
			t9 = space();
			if (after_inner_slot) after_inner_slot.c();

			input.value = input_value_value = typeof /*value*/ ctx[5] === "undefined"
			? ""
			: /*value*/ ctx[5];

			attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
			attr_dev(input, "type", "search");
			add_location(input, file$j, 214, 8, 6362);
			attr_dev(i, "class", "searchbar-icon");
			add_location(i, file$j, 223, 8, 6624);
			attr_dev(div0, "class", "searchbar-input-wrap");
			add_location(div0, file$j, 212, 6, 6278);
			attr_dev(div1, "class", "searchbar-inner");
			add_location(div1, file$j, 210, 4, 6208);
			set_attributes(div2, div2_data);
			add_location(div2, file$j, 208, 2, 6084);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div2, null);
			}

			append_dev(div2, t0);
			append_dev(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_dev(div1, t1);
			append_dev(div1, div0);

			if (input_wrap_start_slot) {
				input_wrap_start_slot.m(div0, null);
			}

			append_dev(div0, t2);
			append_dev(div0, input);
			append_dev(div0, t3);
			append_dev(div0, i);
			append_dev(div0, t4);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div0, t5);

			if (input_wrap_end_slot) {
				input_wrap_end_slot.m(div0, null);
			}

			append_dev(div1, t6);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t7);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_dev(div1, t8);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div2, t9);

			if (after_inner_slot) {
				after_inner_slot.m(div2, null);
			}

			/*div2_binding*/ ctx[49](div2);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*onInput*/ ctx[10], false, false, false),
					listen_dev(input, "change", /*onChange*/ ctx[9], false, false, false),
					listen_dev(input, "focus", /*onFocus*/ ctx[11], false, false, false),
					listen_dev(input, "blur", /*onBlur*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_before_inner_slot_changes_1, get_before_inner_slot_context_1);
				}
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_inner_start_slot_changes_1$2, get_inner_start_slot_context_1$2);
				}
			}

			if (input_wrap_start_slot) {
				if (input_wrap_start_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(input_wrap_start_slot, input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_input_wrap_start_slot_changes_1, get_input_wrap_start_slot_context_1);
				}
			}

			if (!current || dirty[0] & /*value*/ 32 && input_value_value !== (input_value_value = typeof /*value*/ ctx[5] === "undefined"
			? ""
			: /*value*/ ctx[5])) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty[0] & /*placeholder*/ 2) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (/*clearButton*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$3(ctx);
					if_block0.c();
					if_block0.m(div0, t5);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (input_wrap_end_slot) {
				if (input_wrap_end_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(input_wrap_end_slot, input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_input_wrap_end_slot_changes_1, get_input_wrap_end_slot_context_1);
				}
			}

			if (/*disableButton*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$6(ctx);
					if_block1.c();
					if_block1.m(div1, t7);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_inner_end_slot_changes_1$2, get_inner_end_slot_context_1$2);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[46], dirty, null, null);
				}
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_after_inner_slot_changes_1, get_after_inner_slot_context_1);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 256) && { class: /*classes*/ ctx[8] },
				(!current || dirty[0] & /*f7Slot*/ 64) && { "data-f7-slot": /*f7Slot*/ ctx[6] },
				dirty[0] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[16])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(inner_start_slot, local);
			transition_in(input_wrap_start_slot, local);
			transition_in(input_wrap_end_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(default_slot, local);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(inner_start_slot, local);
			transition_out(input_wrap_start_slot, local);
			transition_out(input_wrap_end_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(default_slot, local);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (input_wrap_start_slot) input_wrap_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (input_wrap_end_slot) input_wrap_end_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*div2_binding*/ ctx[49](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$6.name,
		type: "else",
		source: "(208:0) {:else}",
		ctx
	});

	return block;
}

// (178:0) {#if form}
function create_if_block$b(ctx) {
	let form_1;
	let t0;
	let div1;
	let t1;
	let div0;
	let t2;
	let input;
	let input_value_value;
	let t3;
	let i;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let current;
	let mounted;
	let dispose;
	const before_inner_slot_template = /*$$slots*/ ctx[47]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[46], get_before_inner_slot_context$1);
	const inner_start_slot_template = /*$$slots*/ ctx[47]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[46], get_inner_start_slot_context$2);
	const input_wrap_start_slot_template = /*$$slots*/ ctx[47]["input-wrap-start"];
	const input_wrap_start_slot = create_slot(input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[46], get_input_wrap_start_slot_context);
	let if_block0 = /*clearButton*/ ctx[4] && create_if_block_2$8(ctx);
	const input_wrap_end_slot_template = /*$$slots*/ ctx[47]["input-wrap-end"];
	const input_wrap_end_slot = create_slot(input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[46], get_input_wrap_end_slot_context);
	let if_block1 = /*disableButton*/ ctx[2] && create_if_block_1$9(ctx);
	const inner_end_slot_template = /*$$slots*/ ctx[47]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[46], get_inner_end_slot_context$2);
	const default_slot_template = /*$$slots*/ ctx[47].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[46], null);
	const after_inner_slot_template = /*$$slots*/ ctx[47]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[46], get_after_inner_slot_context$1);

	let form_1_levels = [
		{ class: /*classes*/ ctx[8] },
		{ "data-f7-slot": /*f7Slot*/ ctx[6] },
		restProps(/*$$restProps*/ ctx[16])
	];

	let form_1_data = {};

	for (let i = 0; i < form_1_levels.length; i += 1) {
		form_1_data = assign(form_1_data, form_1_levels[i]);
	}

	const block = {
		c: function create() {
			form_1 = element("form");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t1 = space();
			div0 = element("div");
			if (input_wrap_start_slot) input_wrap_start_slot.c();
			t2 = space();
			input = element("input");
			t3 = space();
			i = element("i");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			if (input_wrap_end_slot) input_wrap_end_slot.c();
			t6 = space();
			if (if_block1) if_block1.c();
			t7 = space();
			if (inner_end_slot) inner_end_slot.c();
			t8 = space();
			if (default_slot) default_slot.c();
			t9 = space();
			if (after_inner_slot) after_inner_slot.c();

			input.value = input_value_value = typeof /*value*/ ctx[5] === "undefined"
			? ""
			: /*value*/ ctx[5];

			attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
			attr_dev(input, "type", "search");
			add_location(input, file$j, 184, 8, 5371);
			attr_dev(i, "class", "searchbar-icon");
			add_location(i, file$j, 193, 8, 5633);
			attr_dev(div0, "class", "searchbar-input-wrap");
			add_location(div0, file$j, 182, 6, 5287);
			attr_dev(div1, "class", "searchbar-inner");
			add_location(div1, file$j, 180, 4, 5217);
			set_attributes(form_1, form_1_data);
			add_location(form_1, file$j, 178, 2, 5071);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form_1, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(form_1, null);
			}

			append_dev(form_1, t0);
			append_dev(form_1, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_dev(div1, t1);
			append_dev(div1, div0);

			if (input_wrap_start_slot) {
				input_wrap_start_slot.m(div0, null);
			}

			append_dev(div0, t2);
			append_dev(div0, input);
			append_dev(div0, t3);
			append_dev(div0, i);
			append_dev(div0, t4);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div0, t5);

			if (input_wrap_end_slot) {
				input_wrap_end_slot.m(div0, null);
			}

			append_dev(div1, t6);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t7);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_dev(div1, t8);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(form_1, t9);

			if (after_inner_slot) {
				after_inner_slot.m(form_1, null);
			}

			/*form_1_binding*/ ctx[48](form_1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*onInput*/ ctx[10], false, false, false),
					listen_dev(input, "change", /*onChange*/ ctx[9], false, false, false),
					listen_dev(input, "focus", /*onFocus*/ ctx[11], false, false, false),
					listen_dev(input, "blur", /*onBlur*/ ctx[12], false, false, false),
					listen_dev(form_1, "submit", /*onSubmit*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_before_inner_slot_changes$1, get_before_inner_slot_context$1);
				}
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_inner_start_slot_changes$2, get_inner_start_slot_context$2);
				}
			}

			if (input_wrap_start_slot) {
				if (input_wrap_start_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(input_wrap_start_slot, input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_input_wrap_start_slot_changes, get_input_wrap_start_slot_context);
				}
			}

			if (!current || dirty[0] & /*value*/ 32 && input_value_value !== (input_value_value = typeof /*value*/ ctx[5] === "undefined"
			? ""
			: /*value*/ ctx[5])) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty[0] & /*placeholder*/ 2) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (/*clearButton*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$8(ctx);
					if_block0.c();
					if_block0.m(div0, t5);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (input_wrap_end_slot) {
				if (input_wrap_end_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(input_wrap_end_slot, input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_input_wrap_end_slot_changes, get_input_wrap_end_slot_context);
				}
			}

			if (/*disableButton*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$9(ctx);
					if_block1.c();
					if_block1.m(div1, t7);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_inner_end_slot_changes$2, get_inner_end_slot_context$2);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[46], dirty, null, null);
				}
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty[1] & /*$$scope*/ 32768) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[46], dirty, get_after_inner_slot_changes$1, get_after_inner_slot_context$1);
				}
			}

			set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
				(!current || dirty[0] & /*classes*/ 256) && { class: /*classes*/ ctx[8] },
				(!current || dirty[0] & /*f7Slot*/ 64) && { "data-f7-slot": /*f7Slot*/ ctx[6] },
				dirty[0] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[16])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(inner_start_slot, local);
			transition_in(input_wrap_start_slot, local);
			transition_in(input_wrap_end_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(default_slot, local);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(inner_start_slot, local);
			transition_out(input_wrap_start_slot, local);
			transition_out(input_wrap_end_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(default_slot, local);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form_1);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (input_wrap_start_slot) input_wrap_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (input_wrap_end_slot) input_wrap_end_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*form_1_binding*/ ctx[48](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$b.name,
		type: "if",
		source: "(178:0) {#if form}",
		ctx
	});

	return block;
}

// (225:8) {#if clearButton}
function create_if_block_4$3(ctx) {
	let span;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "input-clear-button");
			add_location(span, file$j, 225, 10, 6689);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onClearButtonClick*/ ctx[14], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$3.name,
		type: "if",
		source: "(225:8) {#if clearButton}",
		ctx
	});

	return block;
}

// (230:6) {#if disableButton}
function create_if_block_3$6(ctx) {
	let span;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(/*disableButtonText*/ ctx[3]);
			attr_dev(span, "class", "searchbar-disable-button");
			add_location(span, file$j, 230, 8, 6855);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onDisableButtonClick*/ ctx[15], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*disableButtonText*/ 8) set_data_dev(t, /*disableButtonText*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$6.name,
		type: "if",
		source: "(230:6) {#if disableButton}",
		ctx
	});

	return block;
}

// (195:8) {#if clearButton}
function create_if_block_2$8(ctx) {
	let span;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "input-clear-button");
			add_location(span, file$j, 195, 10, 5698);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onClearButtonClick*/ ctx[14], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$8.name,
		type: "if",
		source: "(195:8) {#if clearButton}",
		ctx
	});

	return block;
}

// (200:6) {#if disableButton}
function create_if_block_1$9(ctx) {
	let span;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			t = text$1(/*disableButtonText*/ ctx[3]);
			attr_dev(span, "class", "searchbar-disable-button");
			add_location(span, file$j, 200, 8, 5864);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onDisableButtonClick*/ ctx[15], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*disableButtonText*/ 8) set_data_dev(t, /*disableButtonText*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$9.name,
		type: "if",
		source: "(200:6) {#if disableButton}",
		ctx
	});

	return block;
}

function create_fragment$j(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$b, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*form*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$1($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","noShadow","noHairline","form","placeholder","disableButton","disableButtonText","clearButton","value","inputEvents","expandable","inline","searchContainer","searchIn","searchItem","searchGroup","searchGroupTitle","foundEl","notFoundEl","backdrop","backdropEl","hideOnEnableEl","hideOnSearchEl","ignore","customSearch","removeDiacritics","hideDividers","hideGroups","init","f7Slot","instance","search","enable","disable","toggle","clear"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { noShadow = false } = $$props;
	let { noHairline = false } = $$props;
	let { form = true } = $$props;
	let { placeholder = "Search" } = $$props;
	let { disableButton = true } = $$props;
	let { disableButtonText = "Cancel" } = $$props;
	let { clearButton = true } = $$props;
	let { value = undefined } = $$props;
	let { inputEvents = "change input compositionend" } = $$props;
	let { expandable = false } = $$props;
	let { inline = false } = $$props;
	let { searchContainer = undefined } = $$props;
	let { searchIn = ".item-title" } = $$props;
	let { searchItem = "li" } = $$props;
	let { searchGroup = ".list-group" } = $$props;
	let { searchGroupTitle = ".item-divider, .list-group-title" } = $$props;
	let { foundEl = ".searchbar-found" } = $$props;
	let { notFoundEl = ".searchbar-not-found" } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { hideOnEnableEl = ".searchbar-hide-on-enable" } = $$props;
	let { hideOnSearchEl = ".searchbar-hide-on-search" } = $$props;
	let { ignore = ".searchbar-ignore" } = $$props;
	let { customSearch = false } = $$props;
	let { removeDiacritics = false } = $$props;
	let { hideDividers = true } = $$props;
	let { hideGroups = true } = $$props;
	let { init = true } = $$props;
	let { f7Slot = "fixed" } = $$props;
	let el;
	let f7Searchbar;

	function instance() {
		return f7Searchbar;
	}

	function search(query) {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.search(query);
	}

	function enable() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.enable();
	}

	function disable() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.disable();
	}

	function toggle() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.toggle();
	}

	function clear() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.clear();
	}

	function onChange(event) {
		dispatch("change", [event]);
		if (typeof $$props.onChange === "function") $$props.onChange(event);
	}

	function onInput(event) {
		dispatch("input", [event]);
		if (typeof $$props.onInput === "function") $$props.onInput(event);
	}

	function onFocus(event) {
		dispatch("focus", [event]);
		if (typeof $$props.onFocus === "function") $$props.onFocus(event);
	}

	function onBlur(event) {
		dispatch("blur", [event]);
		if (typeof $$props.onBlur === "function") $$props.onBlur(event);
	}

	function onSubmit(event) {
		dispatch("submit", [event]);
		if (typeof $$props.onSubmit === "function") $$props.onSubmit(event);
	}

	function onClearButtonClick(event) {
		dispatch("click:clear", [event]);
	}

	function onDisableButtonClick(event) {
		dispatch("click:disable", [event]);
	}

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			const params = Utils$1.noUndefinedProps({
				el,
				inputEvents,
				searchContainer,
				searchIn,
				searchItem,
				searchGroup,
				searchGroupTitle,
				hideOnEnableEl,
				hideOnSearchEl,
				foundEl,
				notFoundEl,
				backdrop,
				backdropEl,
				disableButton,
				ignore,
				customSearch,
				removeDiacritics,
				hideDividers,
				hideGroups,
				expandable,
				inline,
				on: {
					search(searchbar, query, previousQuery) {
						dispatch("searchbarSearch", [searchbar, query, previousQuery]);
						if (typeof $$props.onSearchbarSearch === "function") $$props.onSearchbarSearch(searchbar, query, previousQuery);
					},
					clear(searchbar, previousQuery) {
						dispatch("searchbarClear", [searchbar, previousQuery]);
						if (typeof $$props.onSearchbarClear === "function") $$props.onSearchbarClear(searchbar, previousQuery);
					},
					enable(searchbar) {
						dispatch("searchbarEnable", [searchbar]);
						if (typeof $$props.onSearchbarEnable === "function") $$props.onSearchbarEnable(searchbar);
					},
					disable(searchbar) {
						dispatch("searchbarDisable", [searchbar]);
						if (typeof $$props.onSearchbarDisable === "function") $$props.onSearchbarDisable(searchbar);
					}
				}
			});

			Object.keys(params).forEach(key => {
				if (params[key] === "") {
					delete params[key];
				}
			});

			f7Searchbar = f7.instance.searchbar.create(params);
		});
	});

	onDestroy(() => {
		if (f7Searchbar && f7Searchbar.destroy) {
			f7Searchbar.destroy();
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	validate_slots("Searchbar", $$slots, [
		'before-inner','inner-start','input-wrap-start','input-wrap-end','inner-end','default','after-inner'
	]);

	function form_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(7, el);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(7, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(52, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(17, className = $$new_props.class);
		if ("noShadow" in $$new_props) $$invalidate(18, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$new_props) $$invalidate(19, noHairline = $$new_props.noHairline);
		if ("form" in $$new_props) $$invalidate(0, form = $$new_props.form);
		if ("placeholder" in $$new_props) $$invalidate(1, placeholder = $$new_props.placeholder);
		if ("disableButton" in $$new_props) $$invalidate(2, disableButton = $$new_props.disableButton);
		if ("disableButtonText" in $$new_props) $$invalidate(3, disableButtonText = $$new_props.disableButtonText);
		if ("clearButton" in $$new_props) $$invalidate(4, clearButton = $$new_props.clearButton);
		if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
		if ("inputEvents" in $$new_props) $$invalidate(20, inputEvents = $$new_props.inputEvents);
		if ("expandable" in $$new_props) $$invalidate(21, expandable = $$new_props.expandable);
		if ("inline" in $$new_props) $$invalidate(22, inline = $$new_props.inline);
		if ("searchContainer" in $$new_props) $$invalidate(23, searchContainer = $$new_props.searchContainer);
		if ("searchIn" in $$new_props) $$invalidate(24, searchIn = $$new_props.searchIn);
		if ("searchItem" in $$new_props) $$invalidate(25, searchItem = $$new_props.searchItem);
		if ("searchGroup" in $$new_props) $$invalidate(26, searchGroup = $$new_props.searchGroup);
		if ("searchGroupTitle" in $$new_props) $$invalidate(27, searchGroupTitle = $$new_props.searchGroupTitle);
		if ("foundEl" in $$new_props) $$invalidate(28, foundEl = $$new_props.foundEl);
		if ("notFoundEl" in $$new_props) $$invalidate(29, notFoundEl = $$new_props.notFoundEl);
		if ("backdrop" in $$new_props) $$invalidate(30, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(31, backdropEl = $$new_props.backdropEl);
		if ("hideOnEnableEl" in $$new_props) $$invalidate(32, hideOnEnableEl = $$new_props.hideOnEnableEl);
		if ("hideOnSearchEl" in $$new_props) $$invalidate(33, hideOnSearchEl = $$new_props.hideOnSearchEl);
		if ("ignore" in $$new_props) $$invalidate(34, ignore = $$new_props.ignore);
		if ("customSearch" in $$new_props) $$invalidate(35, customSearch = $$new_props.customSearch);
		if ("removeDiacritics" in $$new_props) $$invalidate(36, removeDiacritics = $$new_props.removeDiacritics);
		if ("hideDividers" in $$new_props) $$invalidate(37, hideDividers = $$new_props.hideDividers);
		if ("hideGroups" in $$new_props) $$invalidate(38, hideGroups = $$new_props.hideGroups);
		if ("init" in $$new_props) $$invalidate(39, init = $$new_props.init);
		if ("f7Slot" in $$new_props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(46, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		dispatch,
		className,
		noShadow,
		noHairline,
		form,
		placeholder,
		disableButton,
		disableButtonText,
		clearButton,
		value,
		inputEvents,
		expandable,
		inline,
		searchContainer,
		searchIn,
		searchItem,
		searchGroup,
		searchGroupTitle,
		foundEl,
		notFoundEl,
		backdrop,
		backdropEl,
		hideOnEnableEl,
		hideOnSearchEl,
		ignore,
		customSearch,
		removeDiacritics,
		hideDividers,
		hideGroups,
		init,
		f7Slot,
		el,
		f7Searchbar,
		instance,
		search,
		enable,
		disable,
		toggle,
		clear,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onSubmit,
		onClearButtonClick,
		onDisableButtonClick,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(52, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(17, className = $$new_props.className);
		if ("noShadow" in $$props) $$invalidate(18, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$props) $$invalidate(19, noHairline = $$new_props.noHairline);
		if ("form" in $$props) $$invalidate(0, form = $$new_props.form);
		if ("placeholder" in $$props) $$invalidate(1, placeholder = $$new_props.placeholder);
		if ("disableButton" in $$props) $$invalidate(2, disableButton = $$new_props.disableButton);
		if ("disableButtonText" in $$props) $$invalidate(3, disableButtonText = $$new_props.disableButtonText);
		if ("clearButton" in $$props) $$invalidate(4, clearButton = $$new_props.clearButton);
		if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
		if ("inputEvents" in $$props) $$invalidate(20, inputEvents = $$new_props.inputEvents);
		if ("expandable" in $$props) $$invalidate(21, expandable = $$new_props.expandable);
		if ("inline" in $$props) $$invalidate(22, inline = $$new_props.inline);
		if ("searchContainer" in $$props) $$invalidate(23, searchContainer = $$new_props.searchContainer);
		if ("searchIn" in $$props) $$invalidate(24, searchIn = $$new_props.searchIn);
		if ("searchItem" in $$props) $$invalidate(25, searchItem = $$new_props.searchItem);
		if ("searchGroup" in $$props) $$invalidate(26, searchGroup = $$new_props.searchGroup);
		if ("searchGroupTitle" in $$props) $$invalidate(27, searchGroupTitle = $$new_props.searchGroupTitle);
		if ("foundEl" in $$props) $$invalidate(28, foundEl = $$new_props.foundEl);
		if ("notFoundEl" in $$props) $$invalidate(29, notFoundEl = $$new_props.notFoundEl);
		if ("backdrop" in $$props) $$invalidate(30, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$props) $$invalidate(31, backdropEl = $$new_props.backdropEl);
		if ("hideOnEnableEl" in $$props) $$invalidate(32, hideOnEnableEl = $$new_props.hideOnEnableEl);
		if ("hideOnSearchEl" in $$props) $$invalidate(33, hideOnSearchEl = $$new_props.hideOnSearchEl);
		if ("ignore" in $$props) $$invalidate(34, ignore = $$new_props.ignore);
		if ("customSearch" in $$props) $$invalidate(35, customSearch = $$new_props.customSearch);
		if ("removeDiacritics" in $$props) $$invalidate(36, removeDiacritics = $$new_props.removeDiacritics);
		if ("hideDividers" in $$props) $$invalidate(37, hideDividers = $$new_props.hideDividers);
		if ("hideGroups" in $$props) $$invalidate(38, hideGroups = $$new_props.hideGroups);
		if ("init" in $$props) $$invalidate(39, init = $$new_props.init);
		if ("f7Slot" in $$props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
		if ("el" in $$props) $$invalidate(7, el = $$new_props.el);
		if ("f7Searchbar" in $$props) f7Searchbar = $$new_props.f7Searchbar;
		if ("classes" in $$props) $$invalidate(8, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(8, classes = Utils$1.classNames(
			className,
			"searchbar",
			{
				"searchbar-inline": inline,
				"no-shadow": noShadow,
				"no-hairline": noHairline,
				"searchbar-expandable": expandable
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		form,
		placeholder,
		disableButton,
		disableButtonText,
		clearButton,
		value,
		f7Slot,
		el,
		classes,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onSubmit,
		onClearButtonClick,
		onDisableButtonClick,
		$$restProps,
		className,
		noShadow,
		noHairline,
		inputEvents,
		expandable,
		inline,
		searchContainer,
		searchIn,
		searchItem,
		searchGroup,
		searchGroupTitle,
		foundEl,
		notFoundEl,
		backdrop,
		backdropEl,
		hideOnEnableEl,
		hideOnSearchEl,
		ignore,
		customSearch,
		removeDiacritics,
		hideDividers,
		hideGroups,
		init,
		instance,
		search,
		enable,
		disable,
		toggle,
		clear,
		$$scope,
		$$slots,
		form_1_binding,
		div2_binding
	];
}

class Searchbar$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$1,
			create_fragment$j,
			safe_not_equal,
			{
				class: 17,
				noShadow: 18,
				noHairline: 19,
				form: 0,
				placeholder: 1,
				disableButton: 2,
				disableButtonText: 3,
				clearButton: 4,
				value: 5,
				inputEvents: 20,
				expandable: 21,
				inline: 22,
				searchContainer: 23,
				searchIn: 24,
				searchItem: 25,
				searchGroup: 26,
				searchGroupTitle: 27,
				foundEl: 28,
				notFoundEl: 29,
				backdrop: 30,
				backdropEl: 31,
				hideOnEnableEl: 32,
				hideOnSearchEl: 33,
				ignore: 34,
				customSearch: 35,
				removeDiacritics: 36,
				hideDividers: 37,
				hideGroups: 38,
				init: 39,
				f7Slot: 6,
				instance: 40,
				search: 41,
				enable: 42,
				disable: 43,
				toggle: 44,
				clear: 45
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Searchbar",
			options,
			id: create_fragment$j.name
		});
	}

	get class() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noShadow() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noShadow(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairline() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairline(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disableButton() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disableButton(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disableButtonText() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disableButtonText(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearButton() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearButton(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputEvents() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputEvents(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expandable() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expandable(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inline() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inline(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchContainer() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchContainer(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchIn() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchIn(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchItem() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchItem(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchGroup() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchGroup(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchGroupTitle() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchGroupTitle(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get foundEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set foundEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get notFoundEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set notFoundEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideOnEnableEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideOnEnableEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideOnSearchEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideOnSearchEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ignore() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ignore(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get customSearch() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set customSearch(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get removeDiacritics() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set removeDiacritics(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideDividers() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideDividers(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideGroups() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideGroups(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[40];
	}

	set instance(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get search() {
		return this.$$.ctx[41];
	}

	set search(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get enable() {
		return this.$$.ctx[42];
	}

	set enable(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disable() {
		return this.$$.ctx[43];
	}

	set disable(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		return this.$$.ctx[44];
	}

	set toggle(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clear() {
		return this.$$.ctx[45];
	}

	set clear(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$k = "node_modules/framework7-svelte/components/sheet.svelte";
const get_fixed_slot_changes$1 = dirty => ({});
const get_fixed_slot_context$1 = ctx => ({});

function create_fragment$k(ctx) {
	let div1;
	let t;
	let div0;
	let current;
	const fixed_slot_template = /*$$slots*/ ctx[22].fixed;
	const fixed_slot = create_slot(fixed_slot_template, ctx, /*$$scope*/ ctx[21], get_fixed_slot_context$1);
	const default_slot_template = /*$$slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
	let div1_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			if (fixed_slot) fixed_slot.c();
			t = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div0, "class", "sheet-modal-inner");
			add_location(div0, file$k, 150, 2, 4483);
			set_attributes(div1, div1_data);
			add_location(div1, file$k, 144, 0, 4385);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (fixed_slot) {
				fixed_slot.m(div1, null);
			}

			append_dev(div1, t);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[23](div0);
			/*div1_binding*/ ctx[24](div1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (fixed_slot) {
				if (fixed_slot.p && dirty[0] & /*$$scope*/ 2097152) {
					update_slot(fixed_slot, fixed_slot_template, ctx, /*$$scope*/ ctx[21], dirty, get_fixed_slot_changes$1, get_fixed_slot_context$1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 2097152) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, null, null);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty[0] & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty[0] & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fixed_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fixed_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (fixed_slot) fixed_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding*/ ctx[23](null);
			/*div1_binding*/ ctx[24](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$2($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","opened","top","bottom","position","backdrop","backdropEl","closeByBackdropClick","closeByOutsideClick","closeOnEscape","push","swipeToClose","swipeToStep","swipeHandler","instance","open","close"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { top = undefined } = $$props;
	let { bottom = undefined } = $$props;
	let { position = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { closeByOutsideClick = undefined } = $$props;
	let { closeOnEscape = undefined } = $$props;
	let { push = undefined } = $$props;
	let { swipeToClose = undefined } = $$props;
	let { swipeToStep = undefined } = $$props;
	let { swipeHandler = undefined } = $$props;
	let el;
	let innerEl;
	let f7Sheet;

	function instance() {
		return f7Sheet;
	}

	function open(anim) {
		if (!f7Sheet) return undefined;
		return f7Sheet.open(anim);
	}

	function close(anim) {
		if (!f7Sheet) return undefined;
		return f7Sheet.close(anim);
	}

	function onOpen(instance) {
		dispatch("sheetOpen", [instance]);
		if (typeof $$props.onSheetOpen === "function") $$props.onSheetOpen(instance);
	}

	function onOpened(instance) {
		dispatch("sheetOpened", [instance]);
		if (typeof $$props.onSheetOpened === "function") $$props.onSheetOpened(instance);
	}

	function onClose(instance) {
		dispatch("sheetClose", [instance]);
		if (typeof $$props.onSheetClose === "function") $$props.onSheetClose(instance);
	}

	function onClosed(instance) {
		dispatch("sheetClosed", [instance]);
		if (typeof $$props.onSheetClosed === "function") $$props.onSheetClosed(instance);
	}

	function onStepProgress(instance, progress) {
		dispatch("sheetStepProgress", [instance, progress]);
		if (typeof $$props.onSheetStepProgress === "function") $$props.onSheetStepProgress(instance, progress);
	}

	function onStepOpen(instance) {
		dispatch("sheetStepOpen", [instance]);
		if (typeof $$props.onSheetStepOpen === "function") $$props.onSheetStepOpen(instance);
	}

	function onStepClose(instance) {
		dispatch("sheetStepClose", [instance]);
		if (typeof $$props.onSheetStepClose === "function") $$props.onSheetStepClose(instance);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Sheet) return;
		if (openedPassed) f7Sheet.open(); else f7Sheet.close();
	}

	onMount(() => {
		const params = {
			el,
			on: {
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed,
				stepOpen: onStepOpen,
				stepClose: onStepClose,
				stepProgress: onStepProgress
			}
		};

		if (typeof backdrop !== "undefined") params.backdrop = backdrop;
		if (typeof backdropEl !== "undefined") params.backdropEl = backdropEl;
		if (typeof closeByBackdropClick !== "undefined") params.closeByBackdropClick = closeByBackdropClick;
		if (typeof closeByOutsideClick !== "undefined") params.closeByOutsideClick = closeByOutsideClick;
		if (typeof closeOnEscape !== "undefined") params.closeOnEscape = closeOnEscape;
		if (typeof swipeToClose !== "undefined") params.swipeToClose = swipeToClose;
		if (typeof swipeToStep !== "undefined") params.swipeToStep = swipeToStep;
		if (typeof swipeHandler !== "undefined") params.swipeHandler = swipeHandler;

		f7.ready(() => {
			if (el && innerEl) {
				const dom7 = f7.instance.$;
				const fixedEls = dom7(innerEl).children(".navbar, .toolbar, .tabbar, .searchbar");

				if (fixedEls.length) {
					dom7(el).prepend(fixedEls);
				}
			}

			f7Sheet = f7.instance.sheet.create(params);

			if (opened) {
				f7Sheet.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Sheet) f7Sheet.destroy();
		f7Sheet = undefined;
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Sheet", $$slots, ['fixed','default']);

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(1, innerEl);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(37, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("opened" in $$new_props) $$invalidate(5, opened = $$new_props.opened);
		if ("top" in $$new_props) $$invalidate(6, top = $$new_props.top);
		if ("bottom" in $$new_props) $$invalidate(7, bottom = $$new_props.bottom);
		if ("position" in $$new_props) $$invalidate(8, position = $$new_props.position);
		if ("backdrop" in $$new_props) $$invalidate(9, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(10, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$new_props) $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeByOutsideClick" in $$new_props) $$invalidate(12, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ("closeOnEscape" in $$new_props) $$invalidate(13, closeOnEscape = $$new_props.closeOnEscape);
		if ("push" in $$new_props) $$invalidate(14, push = $$new_props.push);
		if ("swipeToClose" in $$new_props) $$invalidate(15, swipeToClose = $$new_props.swipeToClose);
		if ("swipeToStep" in $$new_props) $$invalidate(16, swipeToStep = $$new_props.swipeToStep);
		if ("swipeHandler" in $$new_props) $$invalidate(17, swipeHandler = $$new_props.swipeHandler);
		if ("$$scope" in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils: Utils$1,
		restProps,
		f7,
		dispatch,
		className,
		opened,
		top,
		bottom,
		position,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		push,
		swipeToClose,
		swipeToStep,
		swipeHandler,
		el,
		innerEl,
		f7Sheet,
		instance,
		open,
		close,
		onOpen,
		onOpened,
		onClose,
		onClosed,
		onStepProgress,
		onStepOpen,
		onStepClose,
		initialWatched,
		watchOpened,
		positionComputed,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(37, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("opened" in $$props) $$invalidate(5, opened = $$new_props.opened);
		if ("top" in $$props) $$invalidate(6, top = $$new_props.top);
		if ("bottom" in $$props) $$invalidate(7, bottom = $$new_props.bottom);
		if ("position" in $$props) $$invalidate(8, position = $$new_props.position);
		if ("backdrop" in $$props) $$invalidate(9, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$props) $$invalidate(10, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$props) $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeByOutsideClick" in $$props) $$invalidate(12, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ("closeOnEscape" in $$props) $$invalidate(13, closeOnEscape = $$new_props.closeOnEscape);
		if ("push" in $$props) $$invalidate(14, push = $$new_props.push);
		if ("swipeToClose" in $$props) $$invalidate(15, swipeToClose = $$new_props.swipeToClose);
		if ("swipeToStep" in $$props) $$invalidate(16, swipeToStep = $$new_props.swipeToStep);
		if ("swipeHandler" in $$props) $$invalidate(17, swipeHandler = $$new_props.swipeHandler);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("innerEl" in $$props) $$invalidate(1, innerEl = $$new_props.innerEl);
		if ("f7Sheet" in $$props) f7Sheet = $$new_props.f7Sheet;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("positionComputed" in $$props) $$invalidate(27, positionComputed = $$new_props.positionComputed);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let positionComputed;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*position, top, bottom*/ 448) {
			 $$invalidate(27, positionComputed = (() => {
				if (position) return position;
				if (top) return "top";
				if (bottom) return "bottom";
				return "botton";
			})());
		}

		 $$invalidate(2, classes = Utils$1.classNames(className, "sheet-modal", `sheet-modal-${positionComputed}`, { "sheet-modal-push": push }, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty[0] & /*opened*/ 32) {
			 watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		innerEl,
		classes,
		$$restProps,
		className,
		opened,
		top,
		bottom,
		position,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		push,
		swipeToClose,
		swipeToStep,
		swipeHandler,
		instance,
		open,
		close,
		$$scope,
		$$slots,
		div0_binding,
		div1_binding
	];
}

class Sheet$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$2,
			create_fragment$k,
			safe_not_equal,
			{
				class: 4,
				opened: 5,
				top: 6,
				bottom: 7,
				position: 8,
				backdrop: 9,
				backdropEl: 10,
				closeByBackdropClick: 11,
				closeByOutsideClick: 12,
				closeOnEscape: 13,
				push: 14,
				swipeToClose: 15,
				swipeToStep: 16,
				swipeHandler: 17,
				instance: 18,
				open: 19,
				close: 20
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sheet",
			options,
			id: create_fragment$k.name
		});
	}

	get class() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opened() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opened(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get top() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set top(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottom() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottom(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropEl() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropEl(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByBackdropClick() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByBackdropClick(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByOutsideClick() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByOutsideClick(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeOnEscape() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeOnEscape(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get push() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set push(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeToClose() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeToClose(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeToStep() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeToStep(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeHandler() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeHandler(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[18];
	}

	set instance(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		return this.$$.ctx[19];
	}

	set open(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[20];
	}

	set close(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$l = "node_modules/framework7-svelte/components/toolbar.svelte";
const get_after_inner_slot_changes$2 = dirty => ({});
const get_after_inner_slot_context$2 = ctx => ({});
const get_before_inner_slot_changes$2 = dirty => ({});
const get_before_inner_slot_context$2 = ctx => ({});

// (98:2) {:else}
function create_else_block$7(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[23].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[22], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4194304) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[22], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$7.name,
		type: "else",
		source: "(98:2) {:else}",
		ctx
	});

	return block;
}

// (94:2) {#if inner}
function create_if_block$c(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[23].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[22], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "toolbar-inner");
			add_location(div, file$l, 94, 4, 2753);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4194304) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[22], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$c.name,
		type: "if",
		source: "(94:2) {#if inner}",
		ctx
	});

	return block;
}

function create_fragment$l(ctx) {
	let div;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let current;
	const before_inner_slot_template = /*$$slots*/ ctx[23]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[22], get_before_inner_slot_context$2);
	const if_block_creators = [create_if_block$c, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*inner*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_inner_slot_template = /*$$slots*/ ctx[23]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[22], get_after_inner_slot_context$2);

	let div_levels = [
		{ class: /*classes*/ ctx[3] },
		{ "data-f7-slot": /*f7Slot*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_inner_slot) after_inner_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$l, 91, 0, 2617);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div, null);
			}

			append_dev(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t1);

			if (after_inner_slot) {
				after_inner_slot.m(div, null);
			}

			/*div_binding*/ ctx[24](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty & /*$$scope*/ 4194304) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[22], dirty, get_before_inner_slot_changes$2, get_before_inner_slot_context$2);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, t1);
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty & /*$$scope*/ 4194304) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[22], dirty, get_after_inner_slot_changes$2, get_after_inner_slot_context$2);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				(!current || dirty & /*f7Slot*/ 2) && { "data-f7-slot": /*f7Slot*/ ctx[1] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(if_block);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(if_block);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*div_binding*/ ctx[24](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","tabbar","labels","scrollable","hidden","noShadow","noHairline","noBorder","position","topMd","topIos","topAurora","top","bottomMd","bottomIos","bottomAurora","bottom","inner","f7Slot"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { tabbar = false } = $$props;
	let { labels = false } = $$props;
	let { scrollable = false } = $$props;
	let { hidden = false } = $$props;
	let { noShadow = false } = $$props;
	let { noHairline = false } = $$props;
	let { noBorder = false } = $$props;
	let { position = undefined } = $$props;
	let { topMd = undefined } = $$props;
	let { topIos = undefined } = $$props;
	let { topAurora = undefined } = $$props;
	let { top = undefined } = $$props;
	let { bottomMd = undefined } = $$props;
	let { bottomIos = undefined } = $$props;
	let { bottomAurora = undefined } = $$props;
	let { bottom = undefined } = $$props;
	let { inner = true } = $$props;
	let { f7Slot = "fixed" } = $$props;
	let el;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(25, _theme = f7Theme);
		});
	}

	function onShow(toolbarEl) {
		if (el !== toolbarEl) return;
		dispatch("toolbarShow");
		if (typeof $$props.onToolbarShow === "function") $$props.onToolbarShow();
	}

	function onHide(toolbarEl) {
		if (el !== toolbarEl) return;
		dispatch("toolbarHide");
		if (typeof $$props.onToolbarHide === "function") $$props.onToolbarHide();
	}

	onMount(() => {
		f7.ready(() => {
			if (tabbar) f7.instance.toolbar.setHighlight(el);
			f7.instance.on("toolbarShow", onShow);
			f7.instance.on("toolbarHide", onHide);
		});
	});

	afterUpdate(() => {
		if (tabbar && f7.instance && el) {
			f7.instance.toolbar.setHighlight(el);
		}
	});

	onDestroy(() => {
		if (!f7.instance) return;
		f7.instance.off("toolbarShow", onShow);
		f7.instance.off("toolbarHide", onHide);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Toolbar", $$slots, ['before-inner','default','after-inner']);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("tabbar" in $$new_props) $$invalidate(6, tabbar = $$new_props.tabbar);
		if ("labels" in $$new_props) $$invalidate(7, labels = $$new_props.labels);
		if ("scrollable" in $$new_props) $$invalidate(8, scrollable = $$new_props.scrollable);
		if ("hidden" in $$new_props) $$invalidate(9, hidden = $$new_props.hidden);
		if ("noShadow" in $$new_props) $$invalidate(10, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$new_props) $$invalidate(11, noHairline = $$new_props.noHairline);
		if ("noBorder" in $$new_props) $$invalidate(12, noBorder = $$new_props.noBorder);
		if ("position" in $$new_props) $$invalidate(13, position = $$new_props.position);
		if ("topMd" in $$new_props) $$invalidate(14, topMd = $$new_props.topMd);
		if ("topIos" in $$new_props) $$invalidate(15, topIos = $$new_props.topIos);
		if ("topAurora" in $$new_props) $$invalidate(16, topAurora = $$new_props.topAurora);
		if ("top" in $$new_props) $$invalidate(17, top = $$new_props.top);
		if ("bottomMd" in $$new_props) $$invalidate(18, bottomMd = $$new_props.bottomMd);
		if ("bottomIos" in $$new_props) $$invalidate(19, bottomIos = $$new_props.bottomIos);
		if ("bottomAurora" in $$new_props) $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
		if ("bottom" in $$new_props) $$invalidate(21, bottom = $$new_props.bottom);
		if ("inner" in $$new_props) $$invalidate(0, inner = $$new_props.inner);
		if ("f7Slot" in $$new_props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(22, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		afterUpdate,
		Mixins,
		Utils: Utils$1,
		restProps,
		theme: f7Theme,
		f7,
		dispatch,
		className,
		tabbar,
		labels,
		scrollable,
		hidden,
		noShadow,
		noHairline,
		noBorder,
		position,
		topMd,
		topIos,
		topAurora,
		top,
		bottomMd,
		bottomIos,
		bottomAurora,
		bottom,
		inner,
		f7Slot,
		el,
		_theme,
		onShow,
		onHide,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("tabbar" in $$props) $$invalidate(6, tabbar = $$new_props.tabbar);
		if ("labels" in $$props) $$invalidate(7, labels = $$new_props.labels);
		if ("scrollable" in $$props) $$invalidate(8, scrollable = $$new_props.scrollable);
		if ("hidden" in $$props) $$invalidate(9, hidden = $$new_props.hidden);
		if ("noShadow" in $$props) $$invalidate(10, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$props) $$invalidate(11, noHairline = $$new_props.noHairline);
		if ("noBorder" in $$props) $$invalidate(12, noBorder = $$new_props.noBorder);
		if ("position" in $$props) $$invalidate(13, position = $$new_props.position);
		if ("topMd" in $$props) $$invalidate(14, topMd = $$new_props.topMd);
		if ("topIos" in $$props) $$invalidate(15, topIos = $$new_props.topIos);
		if ("topAurora" in $$props) $$invalidate(16, topAurora = $$new_props.topAurora);
		if ("top" in $$props) $$invalidate(17, top = $$new_props.top);
		if ("bottomMd" in $$props) $$invalidate(18, bottomMd = $$new_props.bottomMd);
		if ("bottomIos" in $$props) $$invalidate(19, bottomIos = $$new_props.bottomIos);
		if ("bottomAurora" in $$props) $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
		if ("bottom" in $$props) $$invalidate(21, bottom = $$new_props.bottom);
		if ("inner" in $$props) $$invalidate(0, inner = $$new_props.inner);
		if ("f7Slot" in $$props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
		if ("_theme" in $$props) $$invalidate(25, _theme = $$new_props._theme);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, classes = Utils$1.classNames(
			className,
			"toolbar",
			{
				tabbar,
				"toolbar-bottom": _theme && _theme.md && bottomMd || _theme && _theme.ios && bottomIos || _theme && _theme.aurora && bottomAurora || bottom || position === "bottom",
				"toolbar-top": _theme && _theme.md && topMd || _theme && _theme.ios && topIos || _theme && _theme.aurora && topAurora || top || position === "top",
				"tabbar-labels": labels,
				"tabbar-scrollable": scrollable,
				"toolbar-hidden": hidden,
				"no-shadow": noShadow,
				"no-hairline": noHairline || noBorder
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		inner,
		f7Slot,
		el,
		classes,
		$$restProps,
		className,
		tabbar,
		labels,
		scrollable,
		hidden,
		noShadow,
		noHairline,
		noBorder,
		position,
		topMd,
		topIos,
		topAurora,
		top,
		bottomMd,
		bottomIos,
		bottomAurora,
		bottom,
		$$scope,
		$$slots,
		div_binding
	];
}

class Toolbar$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$i, create_fragment$l, safe_not_equal, {
			class: 5,
			tabbar: 6,
			labels: 7,
			scrollable: 8,
			hidden: 9,
			noShadow: 10,
			noHairline: 11,
			noBorder: 12,
			position: 13,
			topMd: 14,
			topIos: 15,
			topAurora: 16,
			top: 17,
			bottomMd: 18,
			bottomIos: 19,
			bottomAurora: 20,
			bottom: 21,
			inner: 0,
			f7Slot: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toolbar",
			options,
			id: create_fragment$l.name
		});
	}

	get class() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabbar() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabbar(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labels() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labels(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollable() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollable(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hidden() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hidden(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noShadow() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noShadow(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairline() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairline(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noBorder() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noBorder(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get topMd() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set topMd(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get topIos() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set topIos(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get topAurora() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set topAurora(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get top() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set top(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottomMd() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottomMd(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottomIos() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottomIos(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottomAurora() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottomAurora(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottom() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottom(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inner() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inner(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$m = "node_modules/framework7-svelte/components/view.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	return child_ctx;
}

// (141:2) {#each pages as page (page.id)}
function create_each_block$1(key_1, ctx) {
	let first;
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*page*/ ctx[27].props];
	var switch_value = /*page*/ ctx[27].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty$1();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty$1();
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*pages*/ 8)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*page*/ ctx[27].props)])
			: {};

			if (switch_value !== (switch_value = /*page*/ ctx[27].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(141:2) {#each pages as page (page.id)}",
		ctx
	});

	return block;
}

function create_fragment$m(ctx) {
	let div;
	let t;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	const default_slot_template = /*$$slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let each_value = /*pages*/ ctx[3];
	validate_each_argument(each_value);
	const get_key = ctx => /*page*/ ctx[27].id;
	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", /*classes*/ ctx[4]);
			attr_dev(div, "style", /*style*/ ctx[1]);
			attr_dev(div, "id", /*id*/ ctx[0]);
			add_location(div, file$m, 138, 0, 4153);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding*/ ctx[10](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			if (dirty & /*pages*/ 8) {
				const each_value = /*pages*/ ctx[3];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
				check_outros();
			}

			if (!current || dirty & /*classes*/ 16) {
				attr_dev(div, "class", /*classes*/ ctx[4]);
			}

			if (!current || dirty & /*style*/ 2) {
				attr_dev(div, "style", /*style*/ ctx[1]);
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(div, "id", /*id*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$3($$self, $$props, $$invalidate) {
	let { id = undefined } = $$props;
	let { style = undefined } = $$props;
	let { init = true } = $$props;
	let { class: className = undefined } = $$props;
	const dispatch = createEventDispatcher();
	const { main, tab, tabActive } = $$props;
	let el;
	let pages = [];
	let routerData;
	let f7View;

	function instance() {
		return f7View;
	}

	function onResize(view, width) {
		dispatch("viewResize", [width]);
		if (typeof $$props.onViewResize === "function") $$props.onViewResize(width);
	}

	function onSwipeBackMove(data) {
		dispatch("swipeBackMove", [data]);
		if (typeof $$props.onSwipeBackMove === "function") $$props.onSwipeBackMove(data);
	}

	function onSwipeBackBeforeChange(data) {
		dispatch("swipeBackBeforeChange", [data]);
		if (typeof $$props.onSwipeBackBeforeChange === "function") $$props.onSwipeBackBeforeChange(data);
	}

	function onSwipeBackAfterChange(data) {
		dispatch("swipeBackAfterChange", [data]);
		if (typeof $$props.onSwipeBackAfterChange === "function") $$props.onSwipeBackAfterChange(data);
	}

	function onSwipeBackBeforeReset(data) {
		dispatch("swipeBackBeforeReset", [data]);
		if (typeof $$props.onSwipeBackBeforeReset === "function") $$props.onSwipeBackBeforeReset(data);
	}

	function onSwipeBackAfterReset(data) {
		dispatch("swipeBackAfterReset", [data]);
		if (typeof $$props.onSwipeBackAfterReset === "function") $$props.onSwipeBackAfterReset(data);
	}

	function onTabShow(tabEl) {
		if (el !== tabEl) return;
		dispatch("tabShow");
		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
	}

	function onTabHide(tabEl) {
		if (el !== tabEl) return;
		dispatch("tabHide");
		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
	}

	function onViewInit(view) {
		f7View = view;
		routerData.instance = view;
		dispatch("viewInit", [view]);
		if (typeof $$props.onViewInit === "function") $$props.onViewInit(view);
	}

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			f7.instance.on("tabShow", onTabShow);
			f7.instance.on("tabHide", onTabHide);

			routerData = {
				el,
				instance: null,
				pages,
				setPages(p) {
					tick().then(() => {
						$$invalidate(3, pages = p);
					});
				}
			};

			f7.routers.views.push(routerData);

			routerData.instance = f7.instance.views.create(el, {
				...Utils$1.noUndefinedProps($$props),
				on: { init: onViewInit }
			});

			if (!f7View) f7View = routerData.instance;
			f7View.on("resize", onResize);
			f7View.on("swipebackMove", onSwipeBackMove);
			f7View.on("swipebackBeforeChange", onSwipeBackBeforeChange);
			f7View.on("swipebackAfterChange", onSwipeBackAfterChange);
			f7View.on("swipebackBeforeReset", onSwipeBackBeforeReset);
			f7View.on("swipebackAfterReset", onSwipeBackAfterReset);
		});
	});

	afterUpdate(() => {
		if (!routerData) return;
		f7.events.emit("viewRouterDidUpdate", routerData);
	});

	onDestroy(() => {
		if (!init) return;

		if (f7.instance) {
			f7.instance.off("tabShow", onTabShow);
			f7.instance.off("tabHide", onTabHide);
		}

		if (f7View) {
			f7View.off("resize", onResize);
			f7View.off("swipebackMove", onSwipeBackMove);
			f7View.off("swipebackBeforeChange", onSwipeBackBeforeChange);
			f7View.off("swipebackAfterChange", onSwipeBackAfterChange);
			f7View.off("swipebackBeforeReset", onSwipeBackBeforeReset);
			f7View.off("swipebackAfterReset", onSwipeBackAfterReset);

			if (f7View.destroy) {
				f7View.destroy();
			}
		}

		f7.routers.views.splice(f7.routers.views.indexOf(routerData), 1);
		f7View = null;
		routerData = null;
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("View", $$slots, ['default']);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
		if ("init" in $$new_props) $$invalidate(5, init = $$new_props.init);
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		afterUpdate,
		createEventDispatcher,
		tick,
		f7,
		Mixins,
		Utils: Utils$1,
		id,
		style,
		init,
		className,
		dispatch,
		main,
		tab,
		tabActive,
		el,
		pages,
		routerData,
		f7View,
		instance,
		onResize,
		onSwipeBackMove,
		onSwipeBackBeforeChange,
		onSwipeBackAfterChange,
		onSwipeBackBeforeReset,
		onSwipeBackAfterReset,
		onTabShow,
		onTabHide,
		onViewInit,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
		if ("init" in $$props) $$invalidate(5, init = $$new_props.init);
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
		if ("pages" in $$props) $$invalidate(3, pages = $$new_props.pages);
		if ("routerData" in $$props) routerData = $$new_props.routerData;
		if ("f7View" in $$props) f7View = $$new_props.f7View;
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(4, classes = Utils$1.classNames(
			className,
			"view",
			{
				"view-main": main,
				"tab-active": tabActive,
				tab
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		style,
		el,
		pages,
		classes,
		init,
		className,
		instance,
		$$scope,
		$$slots,
		div_binding
	];
}

class View$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1$3, create_fragment$m, safe_not_equal, {
			id: 0,
			style: 1,
			init: 5,
			class: 6,
			instance: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "View",
			options,
			id: create_fragment$m.name
		});
	}

	get id() {
		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[7];
	}

	set instance(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$n = "src/Toolbar.svelte";

// (11:0) <Toolbar style="background-color: hsl(181, 64%, 26%)" position="top">
function create_default_slot$4(ctx) {
	let img;
	let img_src_value;
	let t0;
	let div;
	let link0;
	let t1;
	let link1;
	let t2;
	let link2;
	let current;

	link0 = new Link({
			props: {
				text: "Improved UX",
				href: "/",
				class: /*getActiveClass*/ ctx[0]("/")
			},
			$$inline: true
		});

	link1 = new Link({
			props: {
				text: "New UI",
				href: "/New-UI",
				class: /*getActiveClass*/ ctx[0]("/New-UI")
			},
			$$inline: true
		});

	link2 = new Link({
			props: {
				text: "Itinerary Editor",
				href: "/Editor",
				class: /*getActiveClass*/ ctx[0]("/Editor")
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			img = element("img");
			t0 = space();
			div = element("div");
			create_component(link0.$$.fragment);
			t1 = space();
			create_component(link1.$$.fragment);
			t2 = space();
			create_component(link2.$$.fragment);
			set_style(img, "margin-left", "10px");
			set_style(img, "height", "20px");
			attr_dev(img, "alt", "Viator");
			if (img.src !== (img_src_value = "/viator.png")) attr_dev(img, "src", img_src_value);
			add_location(img, file$n, 11, 2, 256);
			set_style(div, "width", "100%");
			set_style(div, "display", "flex");
			set_style(div, "justify-content", "space-around");
			add_location(div, file$n, 12, 2, 337);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			mount_component(link0, div, null);
			append_dev(div, t1);
			mount_component(link1, div, null);
			append_dev(div, t2);
			mount_component(link2, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(link0.$$.fragment, local);
			transition_in(link1.$$.fragment, local);
			transition_in(link2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link0.$$.fragment, local);
			transition_out(link1.$$.fragment, local);
			transition_out(link2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			destroy_component(link0);
			destroy_component(link1);
			destroy_component(link2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(11:0) <Toolbar style=\\\"background-color: hsl(181, 64%, 26%)\\\" position=\\\"top\\\">",
		ctx
	});

	return block;
}

function create_fragment$n(ctx) {
	let toolbar;
	let current;

	toolbar = new Toolbar$2({
			props: {
				style: "background-color: hsl(181, 64%, 26%)",
				position: "top",
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(toolbar.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(toolbar, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const toolbar_changes = {};

			if (dirty & /*$$scope*/ 4) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(toolbar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	let { active } = $$props;

	function getActiveClass(path) {
		return path === active ? "active" : "";
	}

	const writable_props = ["active"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Toolbar> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Toolbar", $$slots, []);

	$$self.$set = $$props => {
		if ("active" in $$props) $$invalidate(1, active = $$props.active);
	};

	$$self.$capture_state = () => ({
		Page,
		Toolbar: Toolbar$2,
		Link,
		active,
		getActiveClass
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(1, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [getActiveClass, active];
}

class Toolbar_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$n, safe_not_equal, { active: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toolbar_1",
			options,
			id: create_fragment$n.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*active*/ ctx[1] === undefined && !("active" in props)) {
			console.warn("<Toolbar> was created without expected prop 'active'");
		}
	}

	get active() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const file$o = "src/UX.svelte";

// (122:6) <Button         style="margin-top: 20px; font-weight: bold"         fill         round         href="/New-UI/itinerary"         color="green">
function create_default_slot_1$3(ctx) {
	let t;
	let span;

	const block = {
		c: function create() {
			t = text$1("Show Solution\n        ");
			span = element("span");
			attr_dev(span, "class", "icon icon-solution svelte-19ibdq2");
			add_location(span, file$o, 128, 8, 4940);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(122:6) <Button         style=\\\"margin-top: 20px; font-weight: bold\\\"         fill         round         href=\\\"/New-UI/itinerary\\\"         color=\\\"green\\\">",
		ctx
	});

	return block;
}

// (40:0) <Page>
function create_default_slot$5(ctx) {
	let div25;
	let div22;
	let h1;
	let t1;
	let h2;
	let t3;
	let h3;
	let t5;
	let p0;
	let t7;
	let p1;
	let t9;
	let hr0;
	let t10;
	let div0;
	let t12;
	let div1;
	let t13;
	let span0;
	let t14;
	let hr1;
	let t15;
	let div2;
	let t17;
	let div3;
	let t18;
	let span1;
	let t19;
	let hr2;
	let t20;
	let div4;
	let t22;
	let div5;
	let t23;
	let span2;
	let t24;
	let hr3;
	let t25;
	let div6;
	let t27;
	let button;
	let t28;
	let div7;
	let t29;
	let span3;
	let t30;
	let div8;
	let t31;
	let span4;
	let t32;
	let hr4;
	let t33;
	let div9;
	let t35;
	let br0;
	let t36;
	let br1;
	let t37;
	let div10;
	let t38;
	let span5;
	let t39;
	let div11;
	let t40;
	let span6;
	let t41;
	let hr5;
	let t42;
	let div12;
	let t44;
	let br2;
	let t45;
	let br3;
	let t46;
	let div13;
	let t47;
	let span7;
	let t48;
	let hr6;
	let t49;
	let div14;
	let t51;
	let div15;
	let t52;
	let span8;
	let t53;
	let hr7;
	let t54;
	let div16;
	let t56;
	let div17;
	let t57;
	let span9;
	let t58;
	let hr8;
	let t59;
	let div18;
	let t61;
	let div19;
	let t62;
	let span10;
	let t63;
	let hr9;
	let t64;
	let div20;
	let t66;
	let div21;
	let t67;
	let span11;
	let t68;
	let div24;
	let div23;
	let t69;
	let br4;
	let t70;
	let a;
	let t72;
	let toolbar;
	let current;

	button = new Button({
			props: {
				style: "margin-top: 20px; font-weight: bold",
				fill: true,
				round: true,
				href: "/New-UI/itinerary",
				color: "green",
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	toolbar = new Toolbar_1({ props: { active: "/" }, $$inline: true });

	const block = {
		c: function create() {
			div25 = element("div");
			div22 = element("div");
			h1 = element("h1");
			h1.textContent = "A New Viator UX";
			t1 = space();
			h2 = element("h2");
			h2.textContent = "A Step forward for suppliers and users";
			t3 = space();
			h3 = element("h3");
			h3.textContent = "Why this UX Design Proposal";
			t5 = space();
			p0 = element("p");
			p0.textContent = "After almost 10 years of working with Viator and Tripadvisor, we wanted\n        to give you back some important feedbacks from the supplier's point of\n        view. Therefore we created this dedicated website to visualize our\n        ideas. I think we speak for many operators in the tourism field which\n        face the same bottlenecks and issues when creating and maintaining new\n        products on the Viator supplier website. Due to the more intense\n        competition from other OTAs such as GetYourGuide, Expedia, Klook etc,\n        there is a huge need to optimize the product UI appearance on Viator and\n        Tripadvisor website to have an outstanding experience.";
			t7 = space();
			p1 = element("p");
			p1.textContent = "The current Viator strategy to move from an open market place to a more\n        closed and controlled platform is the right decision. We totally agree\n        that someone of your team reviews the content of a product after it has\n        been submitted. We further think you should allow the supplier to be\n        more flexible in writing descriptions about the prodct as now everything\n        is double-checked to maintain high quality standards.";
			t9 = space();
			hr0 = element("hr");
			t10 = space();
			div0 = element("div");
			div0.textContent = "Product Type";
			t12 = text$1("\n      The fixed and strict categorization of products into different types (like\n      tours, activities, transfers) is not very flexible. For many of our\n      products we cannot clearly assign a product type, sometimes it is both a\n      tour and activity. A much more flexible approach would be to allow to\n      label the product with one or more themes like \"kaying, island tour,\n      caving, museum, etc.\" like Airbnb does for its experiences. This would be\n      much easier to understand for the supplier and feels more natural than\n      being forced to choose 1 product type.\n      ");
			div1 = element("div");
			t13 = text$1("Allow labeling of products\n        ");
			span0 = element("span");
			t14 = space();
			hr1 = element("hr");
			t15 = space();
			div2 = element("div");
			div2.textContent = "Long Description";
			t17 = text$1("\n      For an activity it is possible to add a long description of the product.\n      We think that should be possible for all products independent of their\n      type. As the Viator team will from now on review every change we make to\n      the product content, we would like to add more detailed information about\n      a product which does not fit into the summary 'What makes this tour\n      unique?', itinerary or anywhere else. Currently we feel that the content\n      of our products cannot be fully presented to the user and thus leaves a\n      bad aftertaste.\n      ");
			div3 = element("div");
			t18 = text$1("Allow long description for all products\n        ");
			span1 = element("span");
			t19 = space();
			hr2 = element("hr");
			t20 = space();
			div4 = element("div");
			div4.textContent = "Limited Text Length";
			t22 = text$1("\n      For many fields like activity description, option names, product option\n      details etc., the maximal text length is very limited. We often have to\n      shorten the text and cannot express the full colourfulness of our\n      experiences.\n      ");
			div5 = element("div");
			t23 = text$1("Increase the text length limit\n        ");
			span2 = element("span");
			t24 = space();
			hr3 = element("hr");
			t25 = space();
			div6 = element("div");
			div6.textContent = "Itinerary & Attractions";
			t27 = text$1("\n      The current UI presentation of the itinerary is very confusing for the\n      user (both in Viator and Tripadvsior) as well as for the supplier during\n      editing. We would like to add flexible itinerary items with a prefix\n      containing a schedule or duration and a title, like the way a standard\n      itinerary is built. It should be possible to link every itinerary item\n      optionally with an attraction/place in Tripadvisor.\n      ");
			create_component(button.$$.fragment);
			t28 = space();
			div7 = element("div");
			t29 = text$1("Allow to add free itinerary with schedule\n        ");
			span3 = element("span");
			t30 = space();
			div8 = element("div");
			t31 = text$1("Allow to optional link itinerary item with attraction\n        ");
			span4 = element("span");
			t32 = space();
			hr4 = element("hr");
			t33 = space();
			div9 = element("div");
			div9.textContent = "Hotel pickup";
			t35 = text$1("\n      The current solution for defining a hotel pickup service for a tour,\n      activity or transfer is not satisfactory. Using a fixed hotel list, or\n      defining an area in Google Maps does not cover all usecases and is a very\n      static and time-dependent approach. We often get bookings where the\n      customer has chosen the option \"Stay with friends/relatives\" because the\n      hotel they stayed was not in the prefilled list, and they just had chosen\n      the first item that came up in the list. You should gvive the user more\n      freedom by using a freely editable text field approach.\n      ");
			br0 = element("br");
			t36 = space();
			br1 = element("br");
			t37 = text$1("\n      I think Viator should actively pushing new technologies such as AI/machine\n      learning on their website where it makes sense. One area of application\n      could be the hotel pickup list where the previous data of bookings is used\n      to label hotels which are eligible for pickup. You could also show the\n      pickup times for each hotel to make it even more convenient for the user.\n      This requires that the operator has to give feedback for each booking with\n      exact pickup time so the system can learn over time. The most exact and\n      comprehensive hotel pickup data is always the one you already have in your\n      own hands based on existing bookings.\n      ");
			div10 = element("div");
			t38 = text$1("Use freely editable text field for hotels\n        ");
			span5 = element("span");
			t39 = space();
			div11 = element("div");
			t40 = text$1("Use machine learning to show eligible hotels & pickup times\n        ");
			span6 = element("span");
			t41 = space();
			hr5 = element("hr");
			t42 = space();
			div12 = element("div");
			div12.textContent = "Email address of user";
			t44 = text$1("\n      Currently it is not possible to reach the customer directly by email, for\n      getting more informations such as hotel room, dietary restrictions or in\n      an emergency. You give us the name of the customer, sometimes even all\n      traveller names, passport number, phone number, but why the email address\n      is not provided by Viator?! Of course it is possible to use the Viator\n      messaging system, but this is not enough for the following reasons.\n      ");
			br2 = element("br");
			t45 = space();
			br3 = element("br");
			t46 = text$1("\n      We use an in-house booking system which is highly optimized to handle a\n      large set of bookings each day. We send scheduled messages or messages\n      initiated from the booking tool to customers via email, WhatsApp, LINE\n      etc. Therefore it is required to know the email address or at least to\n      have a designated Viator email address which is bound to a certain\n      booking.\n      ");
			div13 = element("div");
			t47 = text$1("Allow to contact customers by email address\n        ");
			span7 = element("span");
			t48 = space();
			hr6 = element("hr");
			t49 = space();
			div14 = element("div");
			div14.textContent = "Dynamic Pricing";
			t51 = text$1("\n      The tourism industry is a very volatile business with price fluctuations\n      caused by different tourism seasons, customer demand, unexpected incidents\n      like the Corona crisis etc. We would like to have an easier way to push\n      our price changes faster into the Viator marketplace via API integration,\n      the same way we already do with the product availability.\n      ");
			div15 = element("div");
			t52 = text$1("Allow dynamic pricing via supplier API\n        ");
			span8 = element("span");
			t53 = space();
			hr7 = element("hr");
			t54 = space();
			div16 = element("div");
			div16.textContent = "Product Add-Ons";
			t56 = text$1("\n      For many products it is possible to buy add-ons for services like pickup\n      from remote hotels, transfer to hotel, National Park entrance fee, renting\n      kayaking equipment etc. The price of these add-ons are often not under\n      direct control of the supplier, but by the government, sub-contractors or\n      others. We would like to give the customers the possibility to buy these\n      add-ons in advance directly on the Viator website but at the same price as\n      if buying local. Therefore we recommend to allow add-ons with a\n      zero-commission approach like other OTAs such as GYG already offer do.\n      ");
			div17 = element("div");
			t57 = text$1("Allow add-ons at zero commission\n        ");
			span9 = element("span");
			t58 = space();
			hr8 = element("hr");
			t59 = space();
			div18 = element("div");
			div18.textContent = "Activity Duration";
			t61 = text$1("\n      For an activity it is required to set a duration on the product level. We\n      recommend to use the duration of the option if available, or to make the\n      duration field mandatory on the option level.\n      ");
			div19 = element("div");
			t62 = text$1("User duration from product options\n        ");
			span10 = element("span");
			t63 = space();
			hr9 = element("hr");
			t64 = space();
			div20 = element("div");
			div20.textContent = "Company Logo in Ticket";
			t66 = text$1("\n      When uploading a company logo in the ticket section, the logo disappears\n      after making changes to other fields in the ticket redemption section. The\n      company logo should be uploaded only once and be reused from that point\n      on. It would even make more sense to add a logo on the account level,\n      which will be used by all products.\n      ");
			div21 = element("div");
			t67 = text$1("Reuse uploaded company logo\n        ");
			span11 = element("span");
			t68 = space();
			div24 = element("div");
			div23 = element("div");
			t69 = text$1(" Trip Store Krabi Co., Ltd. 2020. All Rights Reserved.\n        ");
			br4 = element("br");
			t70 = space();
			a = element("a");
			a.textContent = "Contact Us";
			t72 = space();
			create_component(toolbar.$$.fragment);
			add_location(h1, file$o, 42, 6, 847);
			add_location(h2, file$o, 43, 6, 878);
			add_location(h3, file$o, 45, 6, 933);
			add_location(p0, file$o, 46, 6, 976);
			add_location(p1, file$o, 57, 6, 1683);
			attr_dev(hr0, "class", "new svelte-19ibdq2");
			add_location(hr0, file$o, 66, 6, 2164);
			attr_dev(div0, "class", "title svelte-19ibdq2");
			add_location(div0, file$o, 68, 6, 2190);
			set_style(span0, "font-weight", "bold");
			set_style(span0, "margin-left", "6px");
			attr_dev(span0, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span0, file$o, 79, 8, 2889);
			attr_dev(div1, "class", "suggestion svelte-19ibdq2");
			add_location(div1, file$o, 77, 6, 2821);
			attr_dev(hr1, "class", "new svelte-19ibdq2");
			add_location(hr1, file$o, 84, 6, 3010);
			attr_dev(div2, "class", "title svelte-19ibdq2");
			add_location(div2, file$o, 86, 6, 3036);
			attr_dev(span1, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span1, file$o, 97, 8, 3733);
			attr_dev(div3, "class", "suggestion svelte-19ibdq2");
			add_location(div3, file$o, 95, 6, 3652);
			attr_dev(hr2, "class", "new svelte-19ibdq2");
			add_location(hr2, file$o, 100, 6, 3790);
			attr_dev(div4, "class", "title svelte-19ibdq2");
			add_location(div4, file$o, 102, 6, 3816);
			attr_dev(span2, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span2, file$o, 109, 8, 4186);
			attr_dev(div5, "class", "suggestion svelte-19ibdq2");
			add_location(div5, file$o, 107, 6, 4114);
			attr_dev(hr3, "class", "new svelte-19ibdq2");
			add_location(hr3, file$o, 112, 6, 4243);
			attr_dev(div6, "class", "title svelte-19ibdq2");
			add_location(div6, file$o, 114, 6, 4269);
			attr_dev(span3, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span3, file$o, 132, 8, 5081);
			attr_dev(div7, "class", "suggestion svelte-19ibdq2");
			add_location(div7, file$o, 130, 6, 4998);
			attr_dev(span4, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span4, file$o, 136, 8, 5232);
			attr_dev(div8, "class", "suggestion svelte-19ibdq2");
			add_location(div8, file$o, 134, 6, 5137);
			attr_dev(hr4, "class", "new svelte-19ibdq2");
			add_location(hr4, file$o, 139, 6, 5289);
			attr_dev(div9, "class", "title svelte-19ibdq2");
			add_location(div9, file$o, 141, 6, 5315);
			add_location(br0, file$o, 150, 6, 5964);
			add_location(br1, file$o, 151, 6, 5977);
			attr_dev(span5, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span5, file$o, 163, 8, 6754);
			attr_dev(div10, "class", "suggestion svelte-19ibdq2");
			add_location(div10, file$o, 161, 6, 6671);
			attr_dev(span6, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span6, file$o, 167, 8, 6911);
			attr_dev(div11, "class", "suggestion svelte-19ibdq2");
			add_location(div11, file$o, 165, 6, 6810);
			attr_dev(hr5, "class", "new svelte-19ibdq2");
			add_location(hr5, file$o, 170, 6, 6968);
			attr_dev(div12, "class", "title svelte-19ibdq2");
			add_location(div12, file$o, 172, 6, 6994);
			add_location(br2, file$o, 179, 6, 7514);
			add_location(br3, file$o, 180, 6, 7527);
			attr_dev(span7, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span7, file$o, 189, 8, 8022);
			attr_dev(div13, "class", "suggestion svelte-19ibdq2");
			add_location(div13, file$o, 187, 6, 7937);
			attr_dev(hr6, "class", "new svelte-19ibdq2");
			add_location(hr6, file$o, 192, 6, 8079);
			attr_dev(div14, "class", "title svelte-19ibdq2");
			add_location(div14, file$o, 194, 6, 8105);
			attr_dev(span8, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span8, file$o, 202, 8, 8614);
			attr_dev(div15, "class", "suggestion svelte-19ibdq2");
			add_location(div15, file$o, 200, 6, 8534);
			attr_dev(hr7, "class", "new svelte-19ibdq2");
			add_location(hr7, file$o, 205, 6, 8671);
			attr_dev(div16, "class", "title svelte-19ibdq2");
			add_location(div16, file$o, 207, 6, 8697);
			attr_dev(span9, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span9, file$o, 218, 8, 9442);
			attr_dev(div17, "class", "suggestion svelte-19ibdq2");
			add_location(div17, file$o, 216, 6, 9368);
			attr_dev(hr8, "class", "new svelte-19ibdq2");
			add_location(hr8, file$o, 221, 6, 9499);
			attr_dev(div18, "class", "title svelte-19ibdq2");
			add_location(div18, file$o, 223, 6, 9525);
			attr_dev(span10, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span10, file$o, 229, 8, 9861);
			attr_dev(div19, "class", "suggestion svelte-19ibdq2");
			add_location(div19, file$o, 227, 6, 9785);
			attr_dev(hr9, "class", "new svelte-19ibdq2");
			add_location(hr9, file$o, 232, 6, 9918);
			attr_dev(div20, "class", "title svelte-19ibdq2");
			add_location(div20, file$o, 234, 6, 9944);
			attr_dev(span11, "class", "icon icon-lightbulb svelte-19ibdq2");
			add_location(span11, file$o, 242, 8, 10423);
			attr_dev(div21, "class", "suggestion svelte-19ibdq2");
			add_location(div21, file$o, 240, 6, 10354);
			set_style(div22, "margin", "auto");
			set_style(div22, "height", "100%");
			set_style(div22, "max-width", "1000px");
			set_style(div22, "padding", "20px");
			add_location(div22, file$o, 41, 4, 766);
			add_location(br4, file$o, 251, 8, 10693);
			attr_dev(a, "class", "link underline external");
			attr_dev(a, "href", "mailto:info@tripstorekrabi.com");
			add_location(a, file$o, 252, 8, 10708);
			attr_dev(div23, "class", "");
			add_location(div23, file$o, 249, 6, 10606);
			set_style(div24, "color", "hsl(181, 64%, 26%)");
			set_style(div24, "text-align", "center");
			set_style(div24, "margin-top", "80px");
			set_style(div24, "margin-bottom", "80px");
			add_location(div24, file$o, 246, 4, 10489);
			add_location(div25, file$o, 40, 2, 756);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div25, anchor);
			append_dev(div25, div22);
			append_dev(div22, h1);
			append_dev(div22, t1);
			append_dev(div22, h2);
			append_dev(div22, t3);
			append_dev(div22, h3);
			append_dev(div22, t5);
			append_dev(div22, p0);
			append_dev(div22, t7);
			append_dev(div22, p1);
			append_dev(div22, t9);
			append_dev(div22, hr0);
			append_dev(div22, t10);
			append_dev(div22, div0);
			append_dev(div22, t12);
			append_dev(div22, div1);
			append_dev(div1, t13);
			append_dev(div1, span0);
			append_dev(div22, t14);
			append_dev(div22, hr1);
			append_dev(div22, t15);
			append_dev(div22, div2);
			append_dev(div22, t17);
			append_dev(div22, div3);
			append_dev(div3, t18);
			append_dev(div3, span1);
			append_dev(div22, t19);
			append_dev(div22, hr2);
			append_dev(div22, t20);
			append_dev(div22, div4);
			append_dev(div22, t22);
			append_dev(div22, div5);
			append_dev(div5, t23);
			append_dev(div5, span2);
			append_dev(div22, t24);
			append_dev(div22, hr3);
			append_dev(div22, t25);
			append_dev(div22, div6);
			append_dev(div22, t27);
			mount_component(button, div22, null);
			append_dev(div22, t28);
			append_dev(div22, div7);
			append_dev(div7, t29);
			append_dev(div7, span3);
			append_dev(div22, t30);
			append_dev(div22, div8);
			append_dev(div8, t31);
			append_dev(div8, span4);
			append_dev(div22, t32);
			append_dev(div22, hr4);
			append_dev(div22, t33);
			append_dev(div22, div9);
			append_dev(div22, t35);
			append_dev(div22, br0);
			append_dev(div22, t36);
			append_dev(div22, br1);
			append_dev(div22, t37);
			append_dev(div22, div10);
			append_dev(div10, t38);
			append_dev(div10, span5);
			append_dev(div22, t39);
			append_dev(div22, div11);
			append_dev(div11, t40);
			append_dev(div11, span6);
			append_dev(div22, t41);
			append_dev(div22, hr5);
			append_dev(div22, t42);
			append_dev(div22, div12);
			append_dev(div22, t44);
			append_dev(div22, br2);
			append_dev(div22, t45);
			append_dev(div22, br3);
			append_dev(div22, t46);
			append_dev(div22, div13);
			append_dev(div13, t47);
			append_dev(div13, span7);
			append_dev(div22, t48);
			append_dev(div22, hr6);
			append_dev(div22, t49);
			append_dev(div22, div14);
			append_dev(div22, t51);
			append_dev(div22, div15);
			append_dev(div15, t52);
			append_dev(div15, span8);
			append_dev(div22, t53);
			append_dev(div22, hr7);
			append_dev(div22, t54);
			append_dev(div22, div16);
			append_dev(div22, t56);
			append_dev(div22, div17);
			append_dev(div17, t57);
			append_dev(div17, span9);
			append_dev(div22, t58);
			append_dev(div22, hr8);
			append_dev(div22, t59);
			append_dev(div22, div18);
			append_dev(div22, t61);
			append_dev(div22, div19);
			append_dev(div19, t62);
			append_dev(div19, span10);
			append_dev(div22, t63);
			append_dev(div22, hr9);
			append_dev(div22, t64);
			append_dev(div22, div20);
			append_dev(div22, t66);
			append_dev(div22, div21);
			append_dev(div21, t67);
			append_dev(div21, span11);
			append_dev(div25, t68);
			append_dev(div25, div24);
			append_dev(div24, div23);
			append_dev(div23, t69);
			append_dev(div23, br4);
			append_dev(div23, t70);
			append_dev(div23, a);
			insert_dev(target, t72, anchor);
			mount_component(toolbar, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div25);
			destroy_component(button);
			if (detaching) detach_dev(t72);
			destroy_component(toolbar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(40:0) <Page>",
		ctx
	});

	return block;
}

function create_fragment$o(ctx) {
	let page;
	let current;

	page = new Page({
			props: {
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(page.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(page, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const page_changes = {};

			if (dirty & /*$$scope*/ 1) {
				page_changes.$$scope = { dirty, ctx };
			}

			page.$set(page_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(page.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(page.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(page, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UX> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("UX", $$slots, []);
	$$self.$capture_state = () => ({ Page, BlockTitle: Block_title, Link, Button, Toolbar: Toolbar_1 });
	return [];
}

class UX extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$o, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UX",
			options,
			id: create_fragment$o.name
		});
	}
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var intro = createCommonjsModule(function (module, exports) {
/**
 * Intro.js v2.9.3
 * https://github.com/usablica/intro.js
 *
 * Copyright (C) 2017 Afshin Mehrabani (@afshinmeh)
 */

(function(f) {
    {
        module.exports = f();
        // deprecated function
        // @since 2.8.0
        module.exports.introJs = function () {
          console.warn('Deprecated: please use require("intro.js") directly, instead of the introJs method of the function');
          // introJs()
          return f().apply(this, arguments);
        };
    }
})(function () {
  //Default config/variables
  var VERSION = '2.9.3';

  /**
   * IntroJs main class
   *
   * @class IntroJs
   */
  function IntroJs(obj) {
    this._targetElement = obj;
    this._introItems = [];

    this._options = {
      /* Next button label in tooltip box */
      nextLabel: 'Next &rarr;',
      /* Previous button label in tooltip box */
      prevLabel: '&larr; Back',
      /* Skip button label in tooltip box */
      skipLabel: 'Skip',
      /* Done button label in tooltip box */
      doneLabel: 'Done',
      /* Hide previous button in the first step? Otherwise, it will be disabled button. */
      hidePrev: false,
      /* Hide next button in the last step? Otherwise, it will be disabled button. */
      hideNext: false,
      /* Default tooltip box position */
      tooltipPosition: 'bottom',
      /* Next CSS class for tooltip boxes */
      tooltipClass: '',
      /* CSS class that is added to the helperLayer */
      highlightClass: '',
      /* Close introduction when pressing Escape button? */
      exitOnEsc: true,
      /* Close introduction when clicking on overlay layer? */
      exitOnOverlayClick: true,
      /* Show step numbers in introduction? */
      showStepNumbers: true,
      /* Let user use keyboard to navigate the tour? */
      keyboardNavigation: true,
      /* Show tour control buttons? */
      showButtons: true,
      /* Show tour bullets? */
      showBullets: true,
      /* Show tour progress? */
      showProgress: false,
      /* Scroll to highlighted element? */
      scrollToElement: true,
      /*
       * Should we scroll the tooltip or target element?
       *
       * Options are: 'element' or 'tooltip'
       */
      scrollTo: 'element',
      /* Padding to add after scrolling when element is not in the viewport (in pixels) */
      scrollPadding: 30,
      /* Set the overlay opacity */
      overlayOpacity: 0.8,
      /* Precedence of positions, when auto is enabled */
      positionPrecedence: ["bottom", "top", "right", "left"],
      /* Disable an interaction with element? */
      disableInteraction: false,
      /* Set how much padding to be used around helper element */
      helperElementPadding: 10,
      /* Default hint position */
      hintPosition: 'top-middle',
      /* Hint button label */
      hintButtonLabel: 'Got it',
      /* Adding animation to hints? */
      hintAnimation: true,
      /* additional classes to put on the buttons */
      buttonClass: "introjs-button"
    };
  }

  /**
   * Initiate a new introduction/guide from an element in the page
   *
   * @api private
   * @method _introForElement
   * @param {Object} targetElm
   * @param {String} group
   * @returns {Boolean} Success or not?
   */
  function _introForElement(targetElm, group) {
    var allIntroSteps = targetElm.querySelectorAll("*[data-intro]"),
        introItems = [];

    if (this._options.steps) {
      //use steps passed programmatically
      _forEach(this._options.steps, function (step) {
        var currentItem = _cloneObject(step);

        //set the step
        currentItem.step = introItems.length + 1;

        //use querySelector function only when developer used CSS selector
        if (typeof (currentItem.element) === 'string') {
          //grab the element with given selector from the page
          currentItem.element = document.querySelector(currentItem.element);
        }

        //intro without element
        if (typeof (currentItem.element) === 'undefined' || currentItem.element === null) {
          var floatingElementQuery = document.querySelector(".introjsFloatingElement");

          if (floatingElementQuery === null) {
            floatingElementQuery = document.createElement('div');
            floatingElementQuery.className = 'introjsFloatingElement';

            document.body.appendChild(floatingElementQuery);
          }

          currentItem.element  = floatingElementQuery;
          currentItem.position = 'floating';
        }

        currentItem.scrollTo = currentItem.scrollTo || this._options.scrollTo;

        if (typeof (currentItem.disableInteraction) === 'undefined') {
          currentItem.disableInteraction = this._options.disableInteraction;
        }

        if (currentItem.element !== null) {
          introItems.push(currentItem);
        }        
      }.bind(this));

    } else {
      //use steps from data-* annotations
      var elmsLength = allIntroSteps.length;
      var disableInteraction;
      
      //if there's no element to intro
      if (elmsLength < 1) {
        return false;
      }

      _forEach(allIntroSteps, function (currentElement) {
        
        // PR #80
        // start intro for groups of elements
        if (group && (currentElement.getAttribute("data-intro-group") !== group)) {
          return;
        }

        // skip hidden elements
        if (currentElement.style.display === 'none') {
          return;
        }

        var step = parseInt(currentElement.getAttribute('data-step'), 10);

        if (typeof (currentElement.getAttribute('data-disable-interaction')) !== 'undefined') {
          disableInteraction = !!currentElement.getAttribute('data-disable-interaction');
        } else {
          disableInteraction = this._options.disableInteraction;
        }

        if (step > 0) {
          introItems[step - 1] = {
            element: currentElement,
            intro: currentElement.getAttribute('data-intro'),
            step: parseInt(currentElement.getAttribute('data-step'), 10),
            tooltipClass: currentElement.getAttribute('data-tooltipclass'),
            highlightClass: currentElement.getAttribute('data-highlightclass'),
            position: currentElement.getAttribute('data-position') || this._options.tooltipPosition,
            scrollTo: currentElement.getAttribute('data-scrollto') || this._options.scrollTo,
            disableInteraction: disableInteraction
          };
        }
      }.bind(this));

      //next add intro items without data-step
      //todo: we need a cleanup here, two loops are redundant
      var nextStep = 0;

      _forEach(allIntroSteps, function (currentElement) {
        
        // PR #80
        // start intro for groups of elements
        if (group && (currentElement.getAttribute("data-intro-group") !== group)) {
          return;
        }
        
        if (currentElement.getAttribute('data-step') === null) {

          while (true) {
            if (typeof introItems[nextStep] === 'undefined') {
              break;
            } else {
              nextStep++;
            }
          } 

          if (typeof (currentElement.getAttribute('data-disable-interaction')) !== 'undefined') {
            disableInteraction = !!currentElement.getAttribute('data-disable-interaction');
          } else {
            disableInteraction = this._options.disableInteraction;
          }

          introItems[nextStep] = {
            element: currentElement,
            intro: currentElement.getAttribute('data-intro'),
            step: nextStep + 1,
            tooltipClass: currentElement.getAttribute('data-tooltipclass'),
            highlightClass: currentElement.getAttribute('data-highlightclass'),
            position: currentElement.getAttribute('data-position') || this._options.tooltipPosition,
            scrollTo: currentElement.getAttribute('data-scrollto') || this._options.scrollTo,
            disableInteraction: disableInteraction
          };
        }
      }.bind(this));
    }

    //removing undefined/null elements
    var tempIntroItems = [];
    for (var z = 0; z < introItems.length; z++) {
      if (introItems[z]) {
        // copy non-falsy values to the end of the array
        tempIntroItems.push(introItems[z]);  
      } 
    }

    introItems = tempIntroItems;

    //Ok, sort all items with given steps
    introItems.sort(function (a, b) {
      return a.step - b.step;
    });

    //set it to the introJs object
    this._introItems = introItems;

    //add overlay layer to the page
    if(_addOverlayLayer.call(this, targetElm)) {
      //then, start the show
      _nextStep.call(this);

      if (this._options.keyboardNavigation) {
        DOMEvent.on(window, 'keydown', _onKeyDown, this, true);
      }
      //for window resize
      DOMEvent.on(window, 'resize', _onResize, this, true);
    }
    return false;
  }

  function _onResize () {
    this.refresh.call(this);
  }

  /**
  * on keyCode:
  * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
  * This feature has been removed from the Web standards.
  * Though some browsers may still support it, it is in
  * the process of being dropped.
  * Instead, you should use KeyboardEvent.code,
  * if it's implemented.
  *
  * jQuery's approach is to test for
  *   (1) e.which, then
  *   (2) e.charCode, then
  *   (3) e.keyCode
  * https://github.com/jquery/jquery/blob/a6b0705294d336ae2f63f7276de0da1195495363/src/event.js#L638
  *
  * @param type var
  * @return type
  */
  function _onKeyDown (e) {
    var code = (e.code === null) ? e.which : e.code;

    // if code/e.which is null
    if (code === null) {
      code = (e.charCode === null) ? e.keyCode : e.charCode;
    }
    
    if ((code === 'Escape' || code === 27) && this._options.exitOnEsc === true) {
      //escape key pressed, exit the intro
      //check if exit callback is defined
      _exitIntro.call(this, this._targetElement);
    } else if (code === 'ArrowLeft' || code === 37) {
      //left arrow
      _previousStep.call(this);
    } else if (code === 'ArrowRight' || code === 39) {
      //right arrow
      _nextStep.call(this);
    } else if (code === 'Enter' || code === 13) {
      //srcElement === ie
      var target = e.target || e.srcElement;
      if (target && target.className.match('introjs-prevbutton')) {
        //user hit enter while focusing on previous button
        _previousStep.call(this);
      } else if (target && target.className.match('introjs-skipbutton')) {
        //user hit enter while focusing on skip button
        if (this._introItems.length - 1 === this._currentStep && typeof (this._introCompleteCallback) === 'function') {
            this._introCompleteCallback.call(this);
        }

        _exitIntro.call(this, this._targetElement);
      } else if (target && target.getAttribute('data-stepnumber')) {
        // user hit enter while focusing on step bullet
        target.click();
      } else {
        //default behavior for responding to enter
        _nextStep.call(this);
      }

      //prevent default behaviour on hitting Enter, to prevent steps being skipped in some browsers
      if(e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
    }
  }

 /*
   * makes a copy of the object
   * @api private
   * @method _cloneObject
  */
  function _cloneObject(object) {
      if (object === null || typeof (object) !== 'object' || typeof (object.nodeType) !== 'undefined') {
        return object;
      }
      var temp = {};
      for (var key in object) {
        if (typeof(window.jQuery) !== 'undefined' && object[key] instanceof window.jQuery) {
          temp[key] = object[key];
        } else {
          temp[key] = _cloneObject(object[key]);
        }
      }
      return temp;
  }
  /**
   * Go to specific step of introduction
   *
   * @api private
   * @method _goToStep
   */
  function _goToStep(step) {
    //because steps starts with zero
    this._currentStep = step - 2;
    if (typeof (this._introItems) !== 'undefined') {
      _nextStep.call(this);
    }
  }

  /**
   * Go to the specific step of introduction with the explicit [data-step] number
   *
   * @api private
   * @method _goToStepNumber
   */
  function _goToStepNumber(step) {
    this._currentStepNumber = step;
    if (typeof (this._introItems) !== 'undefined') {
      _nextStep.call(this);
    }
  }

  /**
   * Go to next step on intro
   *
   * @api private
   * @method _nextStep
   */
  function _nextStep() {
    this._direction = 'forward';

    if (typeof (this._currentStepNumber) !== 'undefined') {
      _forEach(this._introItems, function (item, i) {
        if( item.step === this._currentStepNumber ) {
          this._currentStep = i - 1;
          this._currentStepNumber = undefined;
        }
      }.bind(this));
    }

    if (typeof (this._currentStep) === 'undefined') {
      this._currentStep = 0;
    } else {
      ++this._currentStep;
    }

    var nextStep = this._introItems[this._currentStep];
    var continueStep = true;

    if (typeof (this._introBeforeChangeCallback) !== 'undefined') {
      continueStep = this._introBeforeChangeCallback.call(this, nextStep.element);
    }

    // if `onbeforechange` returned `false`, stop displaying the element
    if (continueStep === false) {
      --this._currentStep;
      return false;
    }

    if ((this._introItems.length) <= this._currentStep) {
      //end of the intro
      //check if any callback is defined
      if (typeof (this._introCompleteCallback) === 'function') {
        this._introCompleteCallback.call(this);
      }
      _exitIntro.call(this, this._targetElement);
      return;
    }

    _showElement.call(this, nextStep);
  }

  /**
   * Go to previous step on intro
   *
   * @api private
   * @method _previousStep
   */
  function _previousStep() {
    this._direction = 'backward';

    if (this._currentStep === 0) {
      return false;
    }

    --this._currentStep;

    var nextStep = this._introItems[this._currentStep];
    var continueStep = true;

    if (typeof (this._introBeforeChangeCallback) !== 'undefined') {
      continueStep = this._introBeforeChangeCallback.call(this, nextStep.element);
    }

    // if `onbeforechange` returned `false`, stop displaying the element
    if (continueStep === false) {
      ++this._currentStep;
      return false;
    }

    _showElement.call(this, nextStep);
  }

  /**
   * Update placement of the intro objects on the screen
   * @api private
   */
  function _refresh() {
    // re-align intros
    _setHelperLayerPosition.call(this, document.querySelector('.introjs-helperLayer'));
    _setHelperLayerPosition.call(this, document.querySelector('.introjs-tooltipReferenceLayer'));
    _setHelperLayerPosition.call(this, document.querySelector('.introjs-disableInteraction'));

    // re-align tooltip
    if(this._currentStep !== undefined && this._currentStep !== null) {
      var oldHelperNumberLayer = document.querySelector('.introjs-helperNumberLayer'),
        oldArrowLayer        = document.querySelector('.introjs-arrow'),
        oldtooltipContainer  = document.querySelector('.introjs-tooltip');
      _placeTooltip.call(this, this._introItems[this._currentStep].element, oldtooltipContainer, oldArrowLayer, oldHelperNumberLayer);
    }

    //re-align hints
    _reAlignHints.call(this);
    return this;
  }

  /**
   * Exit from intro
   *
   * @api private
   * @method _exitIntro
   * @param {Object} targetElement
   * @param {Boolean} force - Setting to `true` will skip the result of beforeExit callback
   */
  function _exitIntro(targetElement, force) {
    var continueExit = true;

    // calling onbeforeexit callback
    //
    // If this callback return `false`, it would halt the process
    if (this._introBeforeExitCallback !== undefined) {
      continueExit = this._introBeforeExitCallback.call(this);
    }

    // skip this check if `force` parameter is `true`
    // otherwise, if `onbeforeexit` returned `false`, don't exit the intro
    if (!force && continueExit === false) return;

    //remove overlay layers from the page
    var overlayLayers = targetElement.querySelectorAll('.introjs-overlay');

    if (overlayLayers && overlayLayers.length) {
      _forEach(overlayLayers, function (overlayLayer) {
        overlayLayer.style.opacity = 0;
        window.setTimeout(function () {
          if (this.parentNode) {
            this.parentNode.removeChild(this);
          }
        }.bind(overlayLayer), 500);
      }.bind(this));
    }

    //remove all helper layers
    var helperLayer = targetElement.querySelector('.introjs-helperLayer');
    if (helperLayer) {
      helperLayer.parentNode.removeChild(helperLayer);
    }

    var referenceLayer = targetElement.querySelector('.introjs-tooltipReferenceLayer');
    if (referenceLayer) {
      referenceLayer.parentNode.removeChild(referenceLayer);
    }

    //remove disableInteractionLayer
    var disableInteractionLayer = targetElement.querySelector('.introjs-disableInteraction');
    if (disableInteractionLayer) {
      disableInteractionLayer.parentNode.removeChild(disableInteractionLayer);
    }

    //remove intro floating element
    var floatingElement = document.querySelector('.introjsFloatingElement');
    if (floatingElement) {
      floatingElement.parentNode.removeChild(floatingElement);
    }

    _removeShowElement();

    //remove `introjs-fixParent` class from the elements
    var fixParents = document.querySelectorAll('.introjs-fixParent');
    _forEach(fixParents, function (parent) {
      _removeClass(parent, /introjs-fixParent/g);
    });

    //clean listeners
    DOMEvent.off(window, 'keydown', _onKeyDown, this, true);
    DOMEvent.off(window, 'resize', _onResize, this, true);

    //check if any callback is defined
    if (this._introExitCallback !== undefined) {
      this._introExitCallback.call(this);
    }

    //set the step to zero
    this._currentStep = undefined;
  }

  /**
   * Render tooltip box in the page
   *
   * @api private
   * @method _placeTooltip
   * @param {HTMLElement} targetElement
   * @param {HTMLElement} tooltipLayer
   * @param {HTMLElement} arrowLayer
   * @param {HTMLElement} helperNumberLayer
   * @param {Boolean} hintMode
   */
  function _placeTooltip(targetElement, tooltipLayer, arrowLayer, helperNumberLayer, hintMode) {
    var tooltipCssClass = '',
        currentStepObj,
        tooltipOffset,
        targetOffset,
        windowSize,
        currentTooltipPosition;

    hintMode = hintMode || false;

    //reset the old style
    tooltipLayer.style.top        = null;
    tooltipLayer.style.right      = null;
    tooltipLayer.style.bottom     = null;
    tooltipLayer.style.left       = null;
    tooltipLayer.style.marginLeft = null;
    tooltipLayer.style.marginTop  = null;

    arrowLayer.style.display = 'inherit';

    if (typeof(helperNumberLayer) !== 'undefined' && helperNumberLayer !== null) {
      helperNumberLayer.style.top  = null;
      helperNumberLayer.style.left = null;
    }

    //prevent error when `this._currentStep` is undefined
    if (!this._introItems[this._currentStep]) return;

    //if we have a custom css class for each step
    currentStepObj = this._introItems[this._currentStep];
    if (typeof (currentStepObj.tooltipClass) === 'string') {
      tooltipCssClass = currentStepObj.tooltipClass;
    } else {
      tooltipCssClass = this._options.tooltipClass;
    }

    tooltipLayer.className = ('introjs-tooltip ' + tooltipCssClass).replace(/^\s+|\s+$/g, '');
    tooltipLayer.setAttribute('role', 'dialog');

    currentTooltipPosition = this._introItems[this._currentStep].position;

    // Floating is always valid, no point in calculating
    if (currentTooltipPosition !== "floating") { 
      currentTooltipPosition = _determineAutoPosition.call(this, targetElement, tooltipLayer, currentTooltipPosition);
    }

    var tooltipLayerStyleLeft;
    targetOffset  = _getOffset(targetElement);
    tooltipOffset = _getOffset(tooltipLayer);
    windowSize    = _getWinSize();

    _addClass(tooltipLayer, 'introjs-' + currentTooltipPosition);

    switch (currentTooltipPosition) {
      case 'top-right-aligned':
        arrowLayer.className      = 'introjs-arrow bottom-right';

        var tooltipLayerStyleRight = 0;
        _checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer);
        tooltipLayer.style.bottom    = (targetOffset.height +  20) + 'px';
        break;

      case 'top-middle-aligned':
        arrowLayer.className      = 'introjs-arrow bottom-middle';

        var tooltipLayerStyleLeftRight = targetOffset.width / 2 - tooltipOffset.width / 2;

        // a fix for middle aligned hints
        if (hintMode) {
          tooltipLayerStyleLeftRight += 5;
        }

        if (_checkLeft(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, tooltipLayer)) {
          tooltipLayer.style.right = null;
          _checkRight(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, windowSize, tooltipLayer);
        }
        tooltipLayer.style.bottom = (targetOffset.height + 20) + 'px';
        break;

      case 'top-left-aligned':
      // top-left-aligned is the same as the default top
      case 'top':
        arrowLayer.className = 'introjs-arrow bottom';

        tooltipLayerStyleLeft = (hintMode) ? 0 : 15;

        _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
        tooltipLayer.style.bottom = (targetOffset.height +  20) + 'px';
        break;
      case 'right':
        tooltipLayer.style.left = (targetOffset.width + 20) + 'px';
        if (targetOffset.top + tooltipOffset.height > windowSize.height) {
          // In this case, right would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          arrowLayer.className = "introjs-arrow left-bottom";
          tooltipLayer.style.top = "-" + (tooltipOffset.height - targetOffset.height - 20) + "px";
        } else {
          arrowLayer.className = 'introjs-arrow left';
        }
        break;
      case 'left':
        if (!hintMode && this._options.showStepNumbers === true) {
          tooltipLayer.style.top = '15px';
        }

        if (targetOffset.top + tooltipOffset.height > windowSize.height) {
          // In this case, left would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          tooltipLayer.style.top = "-" + (tooltipOffset.height - targetOffset.height - 20) + "px";
          arrowLayer.className = 'introjs-arrow right-bottom';
        } else {
          arrowLayer.className = 'introjs-arrow right';
        }
        tooltipLayer.style.right = (targetOffset.width + 20) + 'px';

        break;
      case 'floating':
        arrowLayer.style.display = 'none';

        //we have to adjust the top and left of layer manually for intro items without element
        tooltipLayer.style.left   = '50%';
        tooltipLayer.style.top    = '50%';
        tooltipLayer.style.marginLeft = '-' + (tooltipOffset.width / 2)  + 'px';
        tooltipLayer.style.marginTop  = '-' + (tooltipOffset.height / 2) + 'px';

        if (typeof(helperNumberLayer) !== 'undefined' && helperNumberLayer !== null) {
          helperNumberLayer.style.left = '-' + ((tooltipOffset.width / 2) + 18) + 'px';
          helperNumberLayer.style.top  = '-' + ((tooltipOffset.height / 2) + 18) + 'px';
        }

        break;
      case 'bottom-right-aligned':
        arrowLayer.className      = 'introjs-arrow top-right';

        tooltipLayerStyleRight = 0;
        _checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer);
        tooltipLayer.style.top    = (targetOffset.height +  20) + 'px';
        break;

      case 'bottom-middle-aligned':
        arrowLayer.className      = 'introjs-arrow top-middle';

        tooltipLayerStyleLeftRight = targetOffset.width / 2 - tooltipOffset.width / 2;

        // a fix for middle aligned hints
        if (hintMode) {
          tooltipLayerStyleLeftRight += 5;
        }

        if (_checkLeft(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, tooltipLayer)) {
          tooltipLayer.style.right = null;
          _checkRight(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, windowSize, tooltipLayer);
        }
        tooltipLayer.style.top = (targetOffset.height + 20) + 'px';
        break;

      // case 'bottom-left-aligned':
      // Bottom-left-aligned is the same as the default bottom
      // case 'bottom':
      // Bottom going to follow the default behavior
      default:
        arrowLayer.className = 'introjs-arrow top';

        tooltipLayerStyleLeft = 0;
        _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
        tooltipLayer.style.top    = (targetOffset.height +  20) + 'px';
    }
  }

  /**
   * Set tooltip left so it doesn't go off the right side of the window
   *
   * @return boolean true, if tooltipLayerStyleLeft is ok.  false, otherwise.
   */
  function _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer) {
    if (targetOffset.left + tooltipLayerStyleLeft + tooltipOffset.width > windowSize.width) {
      // off the right side of the window
      tooltipLayer.style.left = (windowSize.width - tooltipOffset.width - targetOffset.left) + 'px';
      return false;
    }
    tooltipLayer.style.left = tooltipLayerStyleLeft + 'px';
    return true;
  }

  /**
   * Set tooltip right so it doesn't go off the left side of the window
   *
   * @return boolean true, if tooltipLayerStyleRight is ok.  false, otherwise.
   */
  function _checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer) {
    if (targetOffset.left + targetOffset.width - tooltipLayerStyleRight - tooltipOffset.width < 0) {
      // off the left side of the window
      tooltipLayer.style.left = (-targetOffset.left) + 'px';
      return false;
    }
    tooltipLayer.style.right = tooltipLayerStyleRight + 'px';
    return true;
  }

  /**
   * Determines the position of the tooltip based on the position precedence and availability
   * of screen space.
   *
   * @param {Object}    targetElement
   * @param {Object}    tooltipLayer
   * @param {String}    desiredTooltipPosition
   * @return {String}   calculatedPosition
   */
  function _determineAutoPosition(targetElement, tooltipLayer, desiredTooltipPosition) {

    // Take a clone of position precedence. These will be the available
    var possiblePositions = this._options.positionPrecedence.slice();

    var windowSize = _getWinSize();
    var tooltipHeight = _getOffset(tooltipLayer).height + 10;
    var tooltipWidth = _getOffset(tooltipLayer).width + 20;
    var targetElementRect = targetElement.getBoundingClientRect();

    // If we check all the possible areas, and there are no valid places for the tooltip, the element
    // must take up most of the screen real estate. Show the tooltip floating in the middle of the screen.
    var calculatedPosition = "floating";

    /*
    * auto determine position 
    */

    // Check for space below
    if (targetElementRect.bottom + tooltipHeight + tooltipHeight > windowSize.height) {
      _removeEntry(possiblePositions, "bottom");
    }

    // Check for space above
    if (targetElementRect.top - tooltipHeight < 0) {
      _removeEntry(possiblePositions, "top");
    }

    // Check for space to the right
    if (targetElementRect.right + tooltipWidth > windowSize.width) {
      _removeEntry(possiblePositions, "right");
    }

    // Check for space to the left
    if (targetElementRect.left - tooltipWidth < 0) {
      _removeEntry(possiblePositions, "left");
    }

    // @var {String}  ex: 'right-aligned'
    var desiredAlignment = (function (pos) {
      var hyphenIndex = pos.indexOf('-');
      if (hyphenIndex !== -1) {
        // has alignment
        return pos.substr(hyphenIndex);
      }
      return '';
    })(desiredTooltipPosition || '');

    // strip alignment from position
    if (desiredTooltipPosition) {
      // ex: "bottom-right-aligned"
      // should return 'bottom'
      desiredTooltipPosition = desiredTooltipPosition.split('-')[0];
    }

    if (possiblePositions.length) {
      if (desiredTooltipPosition !== "auto" &&
          possiblePositions.indexOf(desiredTooltipPosition) > -1) {
        // If the requested position is in the list, choose that
        calculatedPosition = desiredTooltipPosition;
      } else {
        // Pick the first valid position, in order
        calculatedPosition = possiblePositions[0];
      }
    }

    // only top and bottom positions have optional alignments
    if (['top', 'bottom'].indexOf(calculatedPosition) !== -1) {
      calculatedPosition += _determineAutoAlignment(targetElementRect.left, tooltipWidth, windowSize, desiredAlignment);
    }

    return calculatedPosition;
  }

  /**
  * auto-determine alignment
  * @param {Integer}  offsetLeft
  * @param {Integer}  tooltipWidth
  * @param {Object}   windowSize
  * @param {String}   desiredAlignment
  * @return {String}  calculatedAlignment
  */
  function _determineAutoAlignment (offsetLeft, tooltipWidth, windowSize, desiredAlignment) {
    var halfTooltipWidth = tooltipWidth / 2,
      winWidth = Math.min(windowSize.width, window.screen.width),
      possibleAlignments = ['-left-aligned', '-middle-aligned', '-right-aligned'],
      calculatedAlignment = '';
    
    // valid left must be at least a tooltipWidth
    // away from right side
    if (winWidth - offsetLeft < tooltipWidth) {
      _removeEntry(possibleAlignments, '-left-aligned');
    }

    // valid middle must be at least half 
    // width away from both sides
    if (offsetLeft < halfTooltipWidth || 
      winWidth - offsetLeft < halfTooltipWidth) {
      _removeEntry(possibleAlignments, '-middle-aligned');
    }

    // valid right must be at least a tooltipWidth
    // width away from left side
    if (offsetLeft < tooltipWidth) {
      _removeEntry(possibleAlignments, '-right-aligned');
    }

    if (possibleAlignments.length) {
      if (possibleAlignments.indexOf(desiredAlignment) !== -1) {
        // the desired alignment is valid
        calculatedAlignment = desiredAlignment;
      } else {
        // pick the first valid position, in order
        calculatedAlignment = possibleAlignments[0];
      }
    } else {
      // if screen width is too small 
      // for ANY alignment, middle is 
      // probably the best for visibility
      calculatedAlignment = '-middle-aligned';
    }

    return calculatedAlignment;
  }

  /**
   * Remove an entry from a string array if it's there, does nothing if it isn't there.
   *
   * @param {Array} stringArray
   * @param {String} stringToRemove
   */
  function _removeEntry(stringArray, stringToRemove) {
    if (stringArray.indexOf(stringToRemove) > -1) {
      stringArray.splice(stringArray.indexOf(stringToRemove), 1);
    }
  }

  /**
   * Update the position of the helper layer on the screen
   *
   * @api private
   * @method _setHelperLayerPosition
   * @param {Object} helperLayer
   */
  function _setHelperLayerPosition(helperLayer) {
    if (helperLayer) {
      //prevent error when `this._currentStep` in undefined
      if (!this._introItems[this._currentStep]) return;

      var currentElement  = this._introItems[this._currentStep],
          elementPosition = _getOffset(currentElement.element),
          widthHeightPadding = this._options.helperElementPadding;

      // If the target element is fixed, the tooltip should be fixed as well.
      // Otherwise, remove a fixed class that may be left over from the previous
      // step.
      if (_isFixed(currentElement.element)) {
        _addClass(helperLayer, 'introjs-fixedTooltip');
      } else {
        _removeClass(helperLayer, 'introjs-fixedTooltip');
      }

      if (currentElement.position === 'floating') {
        widthHeightPadding = 0;
      }

      //set new position to helper layer
      helperLayer.style.cssText = 'width: ' + (elementPosition.width  + widthHeightPadding)  + 'px; ' +
                                        'height:' + (elementPosition.height + widthHeightPadding)  + 'px; ' +
                                        'top:'    + (elementPosition.top    - widthHeightPadding / 2)   + 'px;' +
                                        'left: '  + (elementPosition.left   - widthHeightPadding / 2)   + 'px;';

    }
  }

  /**
   * Add disableinteraction layer and adjust the size and position of the layer
   *
   * @api private
   * @method _disableInteraction
   */
  function _disableInteraction() {
    var disableInteractionLayer = document.querySelector('.introjs-disableInteraction');

    if (disableInteractionLayer === null) {
      disableInteractionLayer = document.createElement('div');
      disableInteractionLayer.className = 'introjs-disableInteraction';
      this._targetElement.appendChild(disableInteractionLayer);
    }

    _setHelperLayerPosition.call(this, disableInteractionLayer);
  }

  /**
   * Setting anchors to behave like buttons
   *
   * @api private
   * @method _setAnchorAsButton
   */
  function _setAnchorAsButton(anchor){
    anchor.setAttribute('role', 'button');
    anchor.tabIndex = 0;
  }

  /**
   * Show an element on the page
   *
   * @api private
   * @method _showElement
   * @param {Object} targetElement
   */
  function _showElement(targetElement) {
    if (typeof (this._introChangeCallback) !== 'undefined') {
      this._introChangeCallback.call(this, targetElement.element);
    }

    var self = this,
        oldHelperLayer = document.querySelector('.introjs-helperLayer'),
        oldReferenceLayer = document.querySelector('.introjs-tooltipReferenceLayer'),
        highlightClass = 'introjs-helperLayer',
        nextTooltipButton,
        prevTooltipButton,
        skipTooltipButton,
        scrollParent;

    //check for a current step highlight class
    if (typeof (targetElement.highlightClass) === 'string') {
      highlightClass += (' ' + targetElement.highlightClass);
    }
    //check for options highlight class
    if (typeof (this._options.highlightClass) === 'string') {
      highlightClass += (' ' + this._options.highlightClass);
    }

    if (oldHelperLayer !== null) {
      var oldHelperNumberLayer = oldReferenceLayer.querySelector('.introjs-helperNumberLayer'),
          oldtooltipLayer      = oldReferenceLayer.querySelector('.introjs-tooltiptext'),
          oldArrowLayer        = oldReferenceLayer.querySelector('.introjs-arrow'),
          oldtooltipContainer  = oldReferenceLayer.querySelector('.introjs-tooltip');
          
      skipTooltipButton    = oldReferenceLayer.querySelector('.introjs-skipbutton');
      prevTooltipButton    = oldReferenceLayer.querySelector('.introjs-prevbutton');
      nextTooltipButton    = oldReferenceLayer.querySelector('.introjs-nextbutton');

      //update or reset the helper highlight class
      oldHelperLayer.className = highlightClass;
      //hide the tooltip
      oldtooltipContainer.style.opacity = 0;
      oldtooltipContainer.style.display = "none";

      if (oldHelperNumberLayer !== null) {
        var lastIntroItem = this._introItems[(targetElement.step - 2 >= 0 ? targetElement.step - 2 : 0)];

        if (lastIntroItem !== null && (this._direction === 'forward' && lastIntroItem.position === 'floating') || (this._direction === 'backward' && targetElement.position === 'floating')) {
          oldHelperNumberLayer.style.opacity = 0;
        }
      }

      // scroll to element
      scrollParent = _getScrollParent( targetElement.element );

      if (scrollParent !== document.body) {
        // target is within a scrollable element
        _scrollParentToElement(scrollParent, targetElement.element);
      }

      // set new position to helper layer
      _setHelperLayerPosition.call(self, oldHelperLayer);
      _setHelperLayerPosition.call(self, oldReferenceLayer);

      //remove `introjs-fixParent` class from the elements
      var fixParents = document.querySelectorAll('.introjs-fixParent');
      _forEach(fixParents, function (parent) {
        _removeClass(parent, /introjs-fixParent/g);
      });
      
      //remove old classes if the element still exist
      _removeShowElement();

      //we should wait until the CSS3 transition is competed (it's 0.3 sec) to prevent incorrect `height` and `width` calculation
      if (self._lastShowElementTimer) {
        window.clearTimeout(self._lastShowElementTimer);
      }

      self._lastShowElementTimer = window.setTimeout(function() {
        //set current step to the label
        if (oldHelperNumberLayer !== null) {
          oldHelperNumberLayer.innerHTML = targetElement.step;
        }
        //set current tooltip text
        oldtooltipLayer.innerHTML = targetElement.intro;
        //set the tooltip position
        oldtooltipContainer.style.display = "block";
        _placeTooltip.call(self, targetElement.element, oldtooltipContainer, oldArrowLayer, oldHelperNumberLayer);

        //change active bullet
        if (self._options.showBullets) {
            oldReferenceLayer.querySelector('.introjs-bullets li > a.active').className = '';
            oldReferenceLayer.querySelector('.introjs-bullets li > a[data-stepnumber="' + targetElement.step + '"]').className = 'active';
        }
        oldReferenceLayer.querySelector('.introjs-progress .introjs-progressbar').style.cssText = 'width:' + _getProgress.call(self) + '%;';
        oldReferenceLayer.querySelector('.introjs-progress .introjs-progressbar').setAttribute('aria-valuenow', _getProgress.call(self));

        //show the tooltip
        oldtooltipContainer.style.opacity = 1;
        if (oldHelperNumberLayer) oldHelperNumberLayer.style.opacity = 1;

        //reset button focus
        if (typeof skipTooltipButton !== "undefined" && skipTooltipButton !== null && /introjs-donebutton/gi.test(skipTooltipButton.className)) {
          // skip button is now "done" button
          skipTooltipButton.focus();
        } else if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
          //still in the tour, focus on next
          nextTooltipButton.focus();
        }

        // change the scroll of the window, if needed
        _scrollTo.call(self, targetElement.scrollTo, targetElement, oldtooltipLayer);
      }, 350);

      // end of old element if-else condition
    } else {
      var helperLayer       = document.createElement('div'),
          referenceLayer    = document.createElement('div'),
          arrowLayer        = document.createElement('div'),
          tooltipLayer      = document.createElement('div'),
          tooltipTextLayer  = document.createElement('div'),
          bulletsLayer      = document.createElement('div'),
          progressLayer     = document.createElement('div'),
          buttonsLayer      = document.createElement('div');

      helperLayer.className = highlightClass;
      referenceLayer.className = 'introjs-tooltipReferenceLayer';

      // scroll to element
      scrollParent = _getScrollParent( targetElement.element );

      if (scrollParent !== document.body) {
        // target is within a scrollable element
        _scrollParentToElement(scrollParent, targetElement.element);
      }

      //set new position to helper layer
      _setHelperLayerPosition.call(self, helperLayer);
      _setHelperLayerPosition.call(self, referenceLayer);

      //add helper layer to target element
      this._targetElement.appendChild(helperLayer);
      this._targetElement.appendChild(referenceLayer);

      arrowLayer.className = 'introjs-arrow';

      tooltipTextLayer.className = 'introjs-tooltiptext';
      tooltipTextLayer.innerHTML = targetElement.intro;

      bulletsLayer.className = 'introjs-bullets';

      if (this._options.showBullets === false) {
        bulletsLayer.style.display = 'none';
      }

      var ulContainer = document.createElement('ul');
      ulContainer.setAttribute('role', 'tablist');

      var anchorClick = function () {
          self.goToStep(this.getAttribute('data-stepnumber'));
      };

      _forEach(this._introItems, function (item, i) {
        var innerLi    = document.createElement('li');
        var anchorLink = document.createElement('a');
        
        innerLi.setAttribute('role', 'presentation');
        anchorLink.setAttribute('role', 'tab');

        anchorLink.onclick = anchorClick;

        if (i === (targetElement.step-1)) {
          anchorLink.className = 'active';
        } 

        _setAnchorAsButton(anchorLink);
        anchorLink.innerHTML = "&nbsp;";
        anchorLink.setAttribute('data-stepnumber', item.step);

        innerLi.appendChild(anchorLink);
        ulContainer.appendChild(innerLi);
      });

      bulletsLayer.appendChild(ulContainer);

      progressLayer.className = 'introjs-progress';

      if (this._options.showProgress === false) {
        progressLayer.style.display = 'none';
      }
      var progressBar = document.createElement('div');
      progressBar.className = 'introjs-progressbar';
      progressBar.setAttribute('role', 'progress');
      progressBar.setAttribute('aria-valuemin', 0);
      progressBar.setAttribute('aria-valuemax', 100);
      progressBar.setAttribute('aria-valuenow', _getProgress.call(this));
      progressBar.style.cssText = 'width:' + _getProgress.call(this) + '%;';

      progressLayer.appendChild(progressBar);

      buttonsLayer.className = 'introjs-tooltipbuttons';
      if (this._options.showButtons === false) {
        buttonsLayer.style.display = 'none';
      }

      tooltipLayer.className = 'introjs-tooltip';
      tooltipLayer.appendChild(tooltipTextLayer);
      tooltipLayer.appendChild(bulletsLayer);
      tooltipLayer.appendChild(progressLayer);

      //add helper layer number
      var helperNumberLayer = document.createElement('span');
      if (this._options.showStepNumbers === true) {
        helperNumberLayer.className = 'introjs-helperNumberLayer';
        helperNumberLayer.innerHTML = targetElement.step;
        referenceLayer.appendChild(helperNumberLayer);
      }

      tooltipLayer.appendChild(arrowLayer);
      referenceLayer.appendChild(tooltipLayer);

      //next button
      nextTooltipButton = document.createElement('a');

      nextTooltipButton.onclick = function() {
        if (self._introItems.length - 1 !== self._currentStep) {
          _nextStep.call(self);
        }
      };

      _setAnchorAsButton(nextTooltipButton);
      nextTooltipButton.innerHTML = this._options.nextLabel;

      //previous button
      prevTooltipButton = document.createElement('a');

      prevTooltipButton.onclick = function() {
        if (self._currentStep !== 0) {
          _previousStep.call(self);
        }
      };

      _setAnchorAsButton(prevTooltipButton);
      prevTooltipButton.innerHTML = this._options.prevLabel;

      //skip button
      skipTooltipButton = document.createElement('a');
      skipTooltipButton.className = this._options.buttonClass + ' introjs-skipbutton ';
      _setAnchorAsButton(skipTooltipButton);
      skipTooltipButton.innerHTML = this._options.skipLabel;

      skipTooltipButton.onclick = function() {
        if (self._introItems.length - 1 === self._currentStep && typeof (self._introCompleteCallback) === 'function') {
          self._introCompleteCallback.call(self);
        }

        if (self._introItems.length - 1 !== self._currentStep && typeof (self._introExitCallback) === 'function') {
          self._introExitCallback.call(self);
        }

        if (typeof(self._introSkipCallback) === 'function') {
          self._introSkipCallback.call(self);
        }

        _exitIntro.call(self, self._targetElement);
      };

      buttonsLayer.appendChild(skipTooltipButton);

      //in order to prevent displaying next/previous button always
      if (this._introItems.length > 1) {
        buttonsLayer.appendChild(prevTooltipButton);
        buttonsLayer.appendChild(nextTooltipButton);
      }

      tooltipLayer.appendChild(buttonsLayer);

      //set proper position
      _placeTooltip.call(self, targetElement.element, tooltipLayer, arrowLayer, helperNumberLayer);

      // change the scroll of the window, if needed
      _scrollTo.call(this, targetElement.scrollTo, targetElement, tooltipLayer);

      //end of new element if-else condition
    }

    // removing previous disable interaction layer
    var disableInteractionLayer = self._targetElement.querySelector('.introjs-disableInteraction');
    if (disableInteractionLayer) {
      disableInteractionLayer.parentNode.removeChild(disableInteractionLayer);
    }

    //disable interaction
    if (targetElement.disableInteraction) {
      _disableInteraction.call(self);
    }

    // when it's the first step of tour
    if (this._currentStep === 0 && this._introItems.length > 1) {
      if (typeof skipTooltipButton !== "undefined" && skipTooltipButton !== null) {
        skipTooltipButton.className = this._options.buttonClass + ' introjs-skipbutton';
      }
      if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
        nextTooltipButton.className = this._options.buttonClass + ' introjs-nextbutton';
      }

      if (this._options.hidePrev === true) {
        if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
          prevTooltipButton.className = this._options.buttonClass + ' introjs-prevbutton introjs-hidden';
        }
        if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
          _addClass(nextTooltipButton, 'introjs-fullbutton');
        }
      } else {
        if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
          prevTooltipButton.className = this._options.buttonClass + ' introjs-prevbutton introjs-disabled';
        }
      }

      if (typeof skipTooltipButton !== "undefined" && skipTooltipButton !== null) {
        skipTooltipButton.innerHTML = this._options.skipLabel;
      }
    } else if (this._introItems.length - 1 === this._currentStep || this._introItems.length === 1) {
      // last step of tour
      if (typeof skipTooltipButton !== "undefined" && skipTooltipButton !== null) {
        skipTooltipButton.innerHTML = this._options.doneLabel;
        // adding donebutton class in addition to skipbutton
        _addClass(skipTooltipButton, 'introjs-donebutton');
      }
      if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
        prevTooltipButton.className = this._options.buttonClass + ' introjs-prevbutton';
      }

      if (this._options.hideNext === true) {
        if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
          nextTooltipButton.className = this._options.buttonClass + ' introjs-nextbutton introjs-hidden';
        }
        if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
          _addClass(prevTooltipButton, 'introjs-fullbutton');
        }
      } else {
        if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
          nextTooltipButton.className = this._options.buttonClass + ' introjs-nextbutton introjs-disabled';
        }
      }
    } else {
      // steps between start and end
      if (typeof skipTooltipButton !== "undefined" && skipTooltipButton !== null) {
        skipTooltipButton.className = this._options.buttonClass + ' introjs-skipbutton';
      }
      if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
        prevTooltipButton.className = this._options.buttonClass + ' introjs-prevbutton';
      }
      if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
        nextTooltipButton.className = this._options.buttonClass + ' introjs-nextbutton';
      }
      if (typeof skipTooltipButton !== "undefined" && skipTooltipButton !== null) {
        skipTooltipButton.innerHTML = this._options.skipLabel;
      }
    }

    prevTooltipButton.setAttribute('role', 'button');
    nextTooltipButton.setAttribute('role', 'button');
    skipTooltipButton.setAttribute('role', 'button');

    //Set focus on "next" button, so that hitting Enter always moves you onto the next step
    if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
      nextTooltipButton.focus();
    }

    _setShowElement(targetElement);

    if (typeof (this._introAfterChangeCallback) !== 'undefined') {
      this._introAfterChangeCallback.call(this, targetElement.element);
    }
  }

  /**
   * To change the scroll of `window` after highlighting an element
   *
   * @api private
   * @method _scrollTo
   * @param {String} scrollTo
   * @param {Object} targetElement
   * @param {Object} tooltipLayer
   */
  function _scrollTo(scrollTo, targetElement, tooltipLayer) {
    if (scrollTo === 'off') return;  
    var rect;

    if (!this._options.scrollToElement) return;

    if (scrollTo === 'tooltip') {
      rect = tooltipLayer.getBoundingClientRect();
    } else {
      rect = targetElement.element.getBoundingClientRect();
    }

    if (!_elementInViewport(targetElement.element)) {
      var winHeight = _getWinSize().height;
      var top = rect.bottom - (rect.bottom - rect.top);

      // TODO (afshinm): do we need scroll padding now?
      // I have changed the scroll option and now it scrolls the window to
      // the center of the target element or tooltip.

      if (top < 0 || targetElement.element.clientHeight > winHeight) {
        window.scrollBy(0, rect.top - ((winHeight / 2) -  (rect.height / 2)) - this._options.scrollPadding); // 30px padding from edge to look nice

      //Scroll down
      } else {
        window.scrollBy(0, rect.top - ((winHeight / 2) -  (rect.height / 2)) + this._options.scrollPadding); // 30px padding from edge to look nice
      }
    }
  }

  /**
   * To remove all show element(s)
   *
   * @api private
   * @method _removeShowElement
   */
  function _removeShowElement() {
    var elms = document.querySelectorAll('.introjs-showElement');

    _forEach(elms, function (elm) {
      _removeClass(elm, /introjs-[a-zA-Z]+/g);
    });
  }

  /**
   * To set the show element
   * This function set a relative (in most cases) position and changes the z-index
   *
   * @api private
   * @method _setShowElement
   * @param {Object} targetElement
   */
  function _setShowElement(targetElement) {
    var parentElm;
    // we need to add this show element class to the parent of SVG elements
    // because the SVG elements can't have independent z-index
    if (targetElement.element instanceof SVGElement) {
      parentElm = targetElement.element.parentNode;

      while (targetElement.element.parentNode !== null) {
        if (!parentElm.tagName || parentElm.tagName.toLowerCase() === 'body') break;

        if (parentElm.tagName.toLowerCase() === 'svg') {
          _addClass(parentElm, 'introjs-showElement introjs-relativePosition');
        }

        parentElm = parentElm.parentNode;
      }
    }

    _addClass(targetElement.element, 'introjs-showElement');

    var currentElementPosition = _getPropValue(targetElement.element, 'position');
    if (currentElementPosition !== 'absolute' &&
        currentElementPosition !== 'relative' &&
        currentElementPosition !== 'fixed') {
      //change to new intro item
      _addClass(targetElement.element, 'introjs-relativePosition');
    }

    parentElm = targetElement.element.parentNode;
    while (parentElm !== null) {
      if (!parentElm.tagName || parentElm.tagName.toLowerCase() === 'body') break;

      //fix The Stacking Context problem.
      //More detail: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
      var zIndex = _getPropValue(parentElm, 'z-index');
      var opacity = parseFloat(_getPropValue(parentElm, 'opacity'));
      var transform = _getPropValue(parentElm, 'transform') || _getPropValue(parentElm, '-webkit-transform') || _getPropValue(parentElm, '-moz-transform') || _getPropValue(parentElm, '-ms-transform') || _getPropValue(parentElm, '-o-transform');
      if (/[0-9]+/.test(zIndex) || opacity < 1 || (transform !== 'none' && transform !== undefined)) {
        _addClass(parentElm, 'introjs-fixParent');
      }

      parentElm = parentElm.parentNode;
    }
  }

  /**
  * Iterates arrays
  *
  * @param {Array} arr
  * @param {Function} forEachFnc
  * @param {Function} completeFnc
  * @return {Null}
  */
  function _forEach(arr, forEachFnc, completeFnc) {
    // in case arr is an empty query selector node list
    if (arr) {
      for (var i = 0, len = arr.length; i < len; i++) {
        forEachFnc(arr[i], i);
      }
    }

    if (typeof(completeFnc) === 'function') {
      completeFnc();
    }
  }

  /**
  * Mark any object with an incrementing number
  * used for keeping track of objects
  *
  * @param Object obj   Any object or DOM Element
  * @param String key
  * @return Object
  */
  var _stamp = (function () {
    var keys = {};
    return function stamp (obj, key) {
      
      // get group key
      key = key || 'introjs-stamp';

      // each group increments from 0
      keys[key] = keys[key] || 0;

      // stamp only once per object
      if (obj[key] === undefined) {
        // increment key for each new object
        obj[key] = keys[key]++;
      }

      return obj[key];
    };
  })();

  /**
  * DOMEvent Handles all DOM events
  *
  * methods:
  *
  * on - add event handler
  * off - remove event
  */
  var DOMEvent = (function () {
    function DOMEvent () {
      var events_key = 'introjs_event';
      
      /**
      * Gets a unique ID for an event listener
      *
      * @param Object obj
      * @param String type        event type
      * @param Function listener
      * @param Object context
      * @return String
      */
      this._id = function (obj, type, listener, context) {
        return type + _stamp(listener) + (context ? '_' + _stamp(context) : '');
      };

      /**
      * Adds event listener
      *
      * @param Object obj
      * @param String type        event type
      * @param Function listener
      * @param Object context
      * @param Boolean useCapture
      * @return null
      */
      this.on = function (obj, type, listener, context, useCapture) {
        var id = this._id.apply(this, arguments),
            handler = function (e) {
              return listener.call(context || obj, e || window.event);
            };

        if ('addEventListener' in obj) {
          obj.addEventListener(type, handler, useCapture);
        } else if ('attachEvent' in obj) {
          obj.attachEvent('on' + type, handler);
        }

        obj[events_key] = obj[events_key] || {};
        obj[events_key][id] = handler;
      };

      /**
      * Removes event listener
      *
      * @param Object obj
      * @param String type        event type
      * @param Function listener
      * @param Object context
      * @param Boolean useCapture
      * @return null
      */
      this.off = function (obj, type, listener, context, useCapture) {
        var id = this._id.apply(this, arguments),
            handler = obj[events_key] && obj[events_key][id];

        if (!handler) {
          return;
        }

        if ('removeEventListener' in obj) {
          obj.removeEventListener(type, handler, useCapture);
        } else if ('detachEvent' in obj) {
          obj.detachEvent('on' + type, handler);
        }

        obj[events_key][id] = null;
      };
    }

    return new DOMEvent();
  })();

  /**
   * Append a class to an element
   *
   * @api private
   * @method _addClass
   * @param {Object} element
   * @param {String} className
   * @returns null
   */
  function _addClass(element, className) {
    if (element instanceof SVGElement) {
      // svg
      var pre = element.getAttribute('class') || '';

      element.setAttribute('class', pre + ' ' + className);
    } else {
      if (element.classList !== undefined) {
        // check for modern classList property
        var classes = className.split(' ');
        _forEach(classes, function (cls) {
          element.classList.add( cls );
        });
      } else if (!element.className.match( className )) {
        // check if element doesn't already have className
        element.className += ' ' + className;
      }
    }
  }

  /**
   * Remove a class from an element
   *
   * @api private
   * @method _removeClass
   * @param {Object} element
   * @param {RegExp|String} classNameRegex can be regex or string
   * @returns null
   */
  function _removeClass(element, classNameRegex) {
    if (element instanceof SVGElement) {
      var pre = element.getAttribute('class') || '';

      element.setAttribute('class', pre.replace(classNameRegex, '').replace(/^\s+|\s+$/g, ''));
    } else {
      element.className = element.className.replace(classNameRegex, '').replace(/^\s+|\s+$/g, '');
    }
  }

  /**
   * Get an element CSS property on the page
   * Thanks to JavaScript Kit: http://www.javascriptkit.com/dhtmltutors/dhtmlcascade4.shtml
   *
   * @api private
   * @method _getPropValue
   * @param {Object} element
   * @param {String} propName
   * @returns Element's property value
   */
  function _getPropValue (element, propName) {
    var propValue = '';
    if (element.currentStyle) { //IE
      propValue = element.currentStyle[propName];
    } else if (document.defaultView && document.defaultView.getComputedStyle) { //Others
      propValue = document.defaultView.getComputedStyle(element, null).getPropertyValue(propName);
    }

    //Prevent exception in IE
    if (propValue && propValue.toLowerCase) {
      return propValue.toLowerCase();
    } else {
      return propValue;
    }
  }

  /**
   * Checks to see if target element (or parents) position is fixed or not
   *
   * @api private
   * @method _isFixed
   * @param {Object} element
   * @returns Boolean
   */
  function _isFixed (element) {
    var p = element.parentNode;

    if (!p || p.nodeName === 'HTML') {
      return false;
    }

    if (_getPropValue(element, 'position') === 'fixed') {
      return true;
    }

    return _isFixed(p);
  }

  /**
   * Provides a cross-browser way to get the screen dimensions
   * via: http://stackoverflow.com/questions/5864467/internet-explorer-innerheight
   *
   * @api private
   * @method _getWinSize
   * @returns {Object} width and height attributes
   */
  function _getWinSize() {
    if (window.innerWidth !== undefined) {
      return { width: window.innerWidth, height: window.innerHeight };
    } else {
      var D = document.documentElement;
      return { width: D.clientWidth, height: D.clientHeight };
    }
  }

  /**
   * Check to see if the element is in the viewport or not
   * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport
   *
   * @api private
   * @method _elementInViewport
   * @param {Object} el
   */
  function _elementInViewport(el) {
    var rect = el.getBoundingClientRect();

    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      (rect.bottom+80) <= window.innerHeight && // add 80 to get the text right
      rect.right <= window.innerWidth
    );
  }

  /**
   * Add overlay layer to the page
   *
   * @api private
   * @method _addOverlayLayer
   * @param {Object} targetElm
   */
  function _addOverlayLayer(targetElm) {
    var overlayLayer = document.createElement('div'),
        styleText = '',
        self = this;

    //set css class name
    overlayLayer.className = 'introjs-overlay';

    //check if the target element is body, we should calculate the size of overlay layer in a better way
    if (!targetElm.tagName || targetElm.tagName.toLowerCase() === 'body') {
      styleText += 'top: 0;bottom: 0; left: 0;right: 0;position: fixed;';
      overlayLayer.style.cssText = styleText;
    } else {
      //set overlay layer position
      var elementPosition = _getOffset(targetElm);
      if (elementPosition) {
        styleText += 'width: ' + elementPosition.width + 'px; height:' + elementPosition.height + 'px; top:' + elementPosition.top + 'px;left: ' + elementPosition.left + 'px;';
        overlayLayer.style.cssText = styleText;
      }
    }

    targetElm.appendChild(overlayLayer);

    overlayLayer.onclick = function() {
      if (self._options.exitOnOverlayClick === true) {
        _exitIntro.call(self, targetElm);
      }
    };

    window.setTimeout(function() {
      styleText += 'opacity: ' + self._options.overlayOpacity.toString() + ';';
      overlayLayer.style.cssText = styleText;
    }, 10);

    return true;
  }

  /**
   * Removes open hint (tooltip hint)
   *
   * @api private
   * @method _removeHintTooltip
   */
  function _removeHintTooltip() {
    var tooltip = document.querySelector('.introjs-hintReference');

    if (tooltip) {
      var step = tooltip.getAttribute('data-step');
      tooltip.parentNode.removeChild(tooltip);
      return step;
    }
  }

  /**
   * Start parsing hint items
   *
   * @api private
   * @param {Object} targetElm
   * @method _startHint
   */
  function _populateHints(targetElm) {

    this._introItems = [];

    if (this._options.hints) {
      _forEach(this._options.hints, function (hint) {
        var currentItem = _cloneObject(hint);

        if (typeof(currentItem.element) === 'string') {
          //grab the element with given selector from the page
          currentItem.element = document.querySelector(currentItem.element);
        }

        currentItem.hintPosition = currentItem.hintPosition || this._options.hintPosition;
        currentItem.hintAnimation = currentItem.hintAnimation || this._options.hintAnimation;

        if (currentItem.element !== null) {
          this._introItems.push(currentItem);
        }
      }.bind(this));
    } else {
      var hints = targetElm.querySelectorAll('*[data-hint]');

      if (!hints || !hints.length) {
        return false;
      }

      //first add intro items with data-step
      _forEach(hints, function (currentElement) {
        // hint animation
        var hintAnimation = currentElement.getAttribute('data-hintanimation');

        if (hintAnimation) {
          hintAnimation = (hintAnimation === 'true');
        } else {
          hintAnimation = this._options.hintAnimation;
        }

        this._introItems.push({
          element: currentElement,
          hint: currentElement.getAttribute('data-hint'),
          hintPosition: currentElement.getAttribute('data-hintposition') || this._options.hintPosition,
          hintAnimation: hintAnimation,
          tooltipClass: currentElement.getAttribute('data-tooltipclass'),
          position: currentElement.getAttribute('data-position') || this._options.tooltipPosition
        });
      }.bind(this));
    }

    _addHints.call(this);

    /* 
    todo:
    these events should be removed at some point 
    */
    DOMEvent.on(document, 'click', _removeHintTooltip, this, false);
    DOMEvent.on(window, 'resize', _reAlignHints, this, true);
  }

  /**
   * Re-aligns all hint elements
   *
   * @api private
   * @method _reAlignHints
   */
  function _reAlignHints() {
    _forEach(this._introItems, function (item) {
      if (typeof(item.targetElement) === 'undefined') {
        return;
      }

      _alignHintPosition.call(this, item.hintPosition, item.element, item.targetElement);
    }.bind(this));
  }

  /**
  * Get a queryselector within the hint wrapper
  *
  * @param {String} selector
  * @return {NodeList|Array}
  */
  function _hintQuerySelectorAll(selector) {
    var hintsWrapper = document.querySelector('.introjs-hints');
    return (hintsWrapper) ? hintsWrapper.querySelectorAll(selector) : [];
  }

  /**
   * Hide a hint
   *
   * @api private
   * @method _hideHint
   */
  function _hideHint(stepId) {
    var hint = _hintQuerySelectorAll('.introjs-hint[data-step="' + stepId + '"]')[0];
    
    _removeHintTooltip.call(this);

    if (hint) {
      _addClass(hint, 'introjs-hidehint');
    }

    // call the callback function (if any)
    if (typeof (this._hintCloseCallback) !== 'undefined') {
      this._hintCloseCallback.call(this, stepId);
    }
  }

  /**
   * Hide all hints
   *
   * @api private
   * @method _hideHints
   */
  function _hideHints() {
    var hints = _hintQuerySelectorAll('.introjs-hint');

    _forEach(hints, function (hint) {
      _hideHint.call(this, hint.getAttribute('data-step'));
    }.bind(this));
  }

  /**
   * Show all hints
   *
   * @api private
   * @method _showHints
   */
  function _showHints() {
    var hints = _hintQuerySelectorAll('.introjs-hint');

    if (hints && hints.length) {
      _forEach(hints, function (hint) {
        _showHint.call(this, hint.getAttribute('data-step'));
      }.bind(this));
    } else {
      _populateHints.call(this, this._targetElement);
    }
  }

  /**
   * Show a hint
   *
   * @api private
   * @method _showHint
   */
  function _showHint(stepId) {
    var hint = _hintQuerySelectorAll('.introjs-hint[data-step="' + stepId + '"]')[0];

    if (hint) {
      _removeClass(hint, /introjs-hidehint/g);
    }
  }

  /**
   * Removes all hint elements on the page
   * Useful when you want to destroy the elements and add them again (e.g. a modal or popup)
   *
   * @api private
   * @method _removeHints
   */
  function _removeHints() {
    var hints = _hintQuerySelectorAll('.introjs-hint');

    _forEach(hints, function (hint) {
      _removeHint.call(this, hint.getAttribute('data-step'));
    }.bind(this));
  }

  /**
   * Remove one single hint element from the page
   * Useful when you want to destroy the element and add them again (e.g. a modal or popup)
   * Use removeHints if you want to remove all elements.
   *
   * @api private
   * @method _removeHint
   */
  function _removeHint(stepId) {
    var hint = _hintQuerySelectorAll('.introjs-hint[data-step="' + stepId + '"]')[0];

    if (hint) {
      hint.parentNode.removeChild(hint);
    }
  }

  /**
   * Add all available hints to the page
   *
   * @api private
   * @method _addHints
   */
  function _addHints() {
    var self = this;

    var hintsWrapper = document.querySelector('.introjs-hints');

    if (hintsWrapper === null) {
      hintsWrapper = document.createElement('div');
      hintsWrapper.className = 'introjs-hints';
    }

    /**
    * Returns an event handler unique to the hint iteration
    * 
    * @param {Integer} i
    * @return {Function}
    */
    var getHintClick = function (i) {
      return function(e) {
        var evt = e ? e : window.event;
        
        if (evt.stopPropagation) {
          evt.stopPropagation();
        }

        if (evt.cancelBubble !== null) {
          evt.cancelBubble = true;
        }

        _showHintDialog.call(self, i);
      };
    };

    _forEach(this._introItems, function(item, i) {
      // avoid append a hint twice
      if (document.querySelector('.introjs-hint[data-step="' + i + '"]')) {
        return;
      }

      var hint = document.createElement('a');
      _setAnchorAsButton(hint);

      hint.onclick = getHintClick(i);

      hint.className = 'introjs-hint';

      if (!item.hintAnimation) {
        _addClass(hint, 'introjs-hint-no-anim');
      }

      // hint's position should be fixed if the target element's position is fixed
      if (_isFixed(item.element)) {
        _addClass(hint, 'introjs-fixedhint');
      }

      var hintDot = document.createElement('div');
      hintDot.className = 'introjs-hint-dot';
      var hintPulse = document.createElement('div');
      hintPulse.className = 'introjs-hint-pulse';

      hint.appendChild(hintDot);
      hint.appendChild(hintPulse);
      hint.setAttribute('data-step', i);

      // we swap the hint element with target element
      // because _setHelperLayerPosition uses `element` property
      item.targetElement = item.element;
      item.element = hint;

      // align the hint position
      _alignHintPosition.call(this, item.hintPosition, hint, item.targetElement);

      hintsWrapper.appendChild(hint);
    }.bind(this));

    // adding the hints wrapper
    document.body.appendChild(hintsWrapper);

    // call the callback function (if any)
    if (typeof (this._hintsAddedCallback) !== 'undefined') {
      this._hintsAddedCallback.call(this);
    }
  }

  /**
   * Aligns hint position
   *
   * @api private
   * @method _alignHintPosition
   * @param {String} position
   * @param {Object} hint
   * @param {Object} element
   */
  function _alignHintPosition(position, hint, element) {
    // get/calculate offset of target element
    var offset = _getOffset.call(this, element);
    var iconWidth = 20;
    var iconHeight = 20;

    // align the hint element
    switch (position) {
      default:
      case 'top-left':
        hint.style.left = offset.left + 'px';
        hint.style.top = offset.top + 'px';
        break;
      case 'top-right':
        hint.style.left = (offset.left + offset.width - iconWidth) + 'px';
        hint.style.top = offset.top + 'px';
        break;
      case 'bottom-left':
        hint.style.left = offset.left + 'px';
        hint.style.top = (offset.top + offset.height - iconHeight) + 'px';
        break;
      case 'bottom-right':
        hint.style.left = (offset.left + offset.width - iconWidth) + 'px';
        hint.style.top = (offset.top + offset.height - iconHeight) + 'px';
        break;
      case 'middle-left':
        hint.style.left = offset.left + 'px';
        hint.style.top = (offset.top + (offset.height - iconHeight) / 2) + 'px';
        break;
      case 'middle-right':
        hint.style.left = (offset.left + offset.width - iconWidth) + 'px';
        hint.style.top = (offset.top + (offset.height - iconHeight) / 2) + 'px';
        break;
      case 'middle-middle':
        hint.style.left = (offset.left + (offset.width - iconWidth) / 2) + 'px';
        hint.style.top = (offset.top + (offset.height - iconHeight) / 2) + 'px';
        break;
      case 'bottom-middle':
        hint.style.left = (offset.left + (offset.width - iconWidth) / 2) + 'px';
        hint.style.top = (offset.top + offset.height - iconHeight) + 'px';
        break;
      case 'top-middle':
        hint.style.left = (offset.left + (offset.width - iconWidth) / 2) + 'px';
        hint.style.top = offset.top + 'px';
        break;
    }
  }

  /**
   * Triggers when user clicks on the hint element
   *
   * @api private
   * @method _showHintDialog
   * @param {Number} stepId
   */
  function _showHintDialog(stepId) {
    var hintElement = document.querySelector('.introjs-hint[data-step="' + stepId + '"]');
    var item = this._introItems[stepId];

    // call the callback function (if any)
    if (typeof (this._hintClickCallback) !== 'undefined') {
      this._hintClickCallback.call(this, hintElement, item, stepId);
    }

    // remove all open tooltips
    var removedStep = _removeHintTooltip.call(this);

    // to toggle the tooltip
    if (parseInt(removedStep, 10) === stepId) {
      return;
    }

    var tooltipLayer = document.createElement('div');
    var tooltipTextLayer = document.createElement('div');
    var arrowLayer = document.createElement('div');
    var referenceLayer = document.createElement('div');

    tooltipLayer.className = 'introjs-tooltip';

    tooltipLayer.onclick = function (e) {
      //IE9 & Other Browsers
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      //IE8 and Lower
      else {
        e.cancelBubble = true;
      }
    };

    tooltipTextLayer.className = 'introjs-tooltiptext';

    var tooltipWrapper = document.createElement('p');
    tooltipWrapper.innerHTML = item.hint;

    var closeButton = document.createElement('a');
    closeButton.className = this._options.buttonClass;
    closeButton.setAttribute('role', 'button');
    closeButton.innerHTML = this._options.hintButtonLabel;
    closeButton.onclick = _hideHint.bind(this, stepId);

    tooltipTextLayer.appendChild(tooltipWrapper);
    tooltipTextLayer.appendChild(closeButton);

    arrowLayer.className = 'introjs-arrow';
    tooltipLayer.appendChild(arrowLayer);

    tooltipLayer.appendChild(tooltipTextLayer);

    // set current step for _placeTooltip function
    this._currentStep = hintElement.getAttribute('data-step');

    // align reference layer position
    referenceLayer.className = 'introjs-tooltipReferenceLayer introjs-hintReference';
    referenceLayer.setAttribute('data-step', hintElement.getAttribute('data-step'));
    _setHelperLayerPosition.call(this, referenceLayer);

    referenceLayer.appendChild(tooltipLayer);
    document.body.appendChild(referenceLayer);

    //set proper position
    _placeTooltip.call(this, hintElement, tooltipLayer, arrowLayer, null, true);
  }

  /**
   * Get an element position on the page
   * Thanks to `meouw`: http://stackoverflow.com/a/442474/375966
   *
   * @api private
   * @method _getOffset
   * @param {Object} element
   * @returns Element's position info
   */
  function _getOffset(element) {
    var body = document.body;
    var docEl = document.documentElement;
    var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
    var x = element.getBoundingClientRect();
    return {
      top: x.top + scrollTop,
      width: x.width,
      height: x.height,
      left: x.left + scrollLeft
    };
  }

  /**
  * Find the nearest scrollable parent
  * copied from https://stackoverflow.com/questions/35939886/find-first-scrollable-parent
  *
  * @param Element element
  * @return Element
  */
  function _getScrollParent(element) {
    var style = window.getComputedStyle(element);
    var excludeStaticParent = (style.position === "absolute");
    var overflowRegex = /(auto|scroll)/;

    if (style.position === "fixed") return document.body;
    
    for (var parent = element; (parent = parent.parentElement);) {
      style = window.getComputedStyle(parent);
      if (excludeStaticParent && style.position === "static") {
        continue;
      }
      if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) return parent;
    }

    return document.body;
  }

  /**
  * scroll a scrollable element to a child element
  *
  * @param Element parent
  * @param Element element
  * @return Null
  */
  function _scrollParentToElement (parent, element) {
    parent.scrollTop = element.offsetTop - parent.offsetTop;
  }

  /**
   * Gets the current progress percentage
   *
   * @api private
   * @method _getProgress
   * @returns current progress percentage
   */
  function _getProgress() {
    // Steps are 0 indexed
    var currentStep = parseInt((this._currentStep + 1), 10);
    return ((currentStep / this._introItems.length) * 100);
  }

  /**
   * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
   * via: http://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically
   *
   * @param obj1
   * @param obj2
   * @returns obj3 a new object based on obj1 and obj2
   */
  function _mergeOptions(obj1,obj2) {
    var obj3 = {},
      attrname;
    for (attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
  }

  var introJs = function (targetElm) {
    var instance;

    if (typeof (targetElm) === 'object') {
      //Ok, create a new instance
      instance = new IntroJs(targetElm);

    } else if (typeof (targetElm) === 'string') {
      //select the target element with query selector
      var targetElement = document.querySelector(targetElm);

      if (targetElement) {
        instance = new IntroJs(targetElement);
      } else {
        throw new Error('There is no element with given selector.');
      }
    } else {
      instance = new IntroJs(document.body);
    }
    // add instance to list of _instances
    // passing group to _stamp to increment
    // from 0 onward somewhat reliably
    introJs.instances[ _stamp(instance, 'introjs-instance') ] = instance;

    return instance;
  };

  /**
   * Current IntroJs version
   *
   * @property version
   * @type String
   */
  introJs.version = VERSION;

  /**
  * key-val object helper for introJs instances
  *
  * @property instances
  * @type Object
  */
  introJs.instances = {};

  //Prototype
  introJs.fn = IntroJs.prototype = {
    clone: function () {
      return new IntroJs(this);
    },
    setOption: function(option, value) {
      this._options[option] = value;
      return this;
    },
    setOptions: function(options) {
      this._options = _mergeOptions(this._options, options);
      return this;
    },
    start: function (group) {
      _introForElement.call(this, this._targetElement, group);
      return this;
    },
    goToStep: function(step) {
      _goToStep.call(this, step);
      return this;
    },
    addStep: function(options) {
      if (!this._options.steps) {
        this._options.steps = [];
      }

      this._options.steps.push(options);

      return this;
    },
    addSteps: function(steps) {
      if (!steps.length) return;

      for(var index = 0; index < steps.length; index++) {
        this.addStep(steps[index]);
      }

      return this;
    },
    goToStepNumber: function(step) {
      _goToStepNumber.call(this, step);

      return this;
    },
    nextStep: function() {
      _nextStep.call(this);
      return this;
    },
    previousStep: function() {
      _previousStep.call(this);
      return this;
    },
    exit: function(force) {
      _exitIntro.call(this, this._targetElement, force);
      return this;
    },
    refresh: function() {
      _refresh.call(this);
      return this;
    },
    onbeforechange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introBeforeChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onbeforechange was not a function');
      }
      return this;
    },
    onchange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onchange was not a function.');
      }
      return this;
    },
    onafterchange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introAfterChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onafterchange was not a function');
      }
      return this;
    },
    oncomplete: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introCompleteCallback = providedCallback;
      } else {
        throw new Error('Provided callback for oncomplete was not a function.');
      }
      return this;
    },
    onhintsadded: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._hintsAddedCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onhintsadded was not a function.');
      }
      return this;
    },
    onhintclick: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._hintClickCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onhintclick was not a function.');
      }
      return this;
    },
    onhintclose: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._hintCloseCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onhintclose was not a function.');
      }
      return this;
    },
    onexit: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introExitCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onexit was not a function.');
      }
      return this;
    },
    onskip: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introSkipCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onskip was not a function.');
      }
      return this;
    },
    onbeforeexit: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introBeforeExitCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onbeforeexit was not a function.');
      }
      return this;
    },
    addHints: function() {
      _populateHints.call(this, this._targetElement);
      return this;
    },
    hideHint: function (stepId) {
      _hideHint.call(this, stepId);
      return this;
    },
    hideHints: function () {
      _hideHints.call(this);
      return this;
    },
    showHint: function (stepId) {
      _showHint.call(this, stepId);
      return this;
    },
    showHints: function () {
      _showHints.call(this);
      return this;
    },
    removeHints: function () {
      _removeHints.call(this);
      return this;
    },
    removeHint: function (stepId) {
      _removeHint.call(this, stepId);
      return this;
    },
    showHintDialog: function (stepId) {
      _showHintDialog.call(this, stepId);
      return this;
    }
  };

  return introJs;
});
});

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

let STANDARD_TOUR = {
  title:
    "John Grays Hong by Starlight from Phuket with Sea Kayaking & Loi Krathong Floating",
  subtitle:
    "Sea cave exploring literally inside Phang Nga Bays marine geology",
  summary:
    "Enjoy an afternoon of sea cave exploring in Phang Nga Bay, including the limestone caves and hidden cliff-lined lagoons at Koh Panak discovered by John Gray in 1989. Expect a great nature and wildlife adventure with an experienced guide and enjoy the best Thai seafood buffet during your holiday aboard the convenient escort boat of John Gray's Sea Canoe. Finish your trip after dark by floating your own self-made flower Kratong in a spiritual and spectacular natural light show.",
  description:
    "<p>This full-day kayak trip from Phuket starts at midday to avoid the crowds, with a convenient pickup service by luxury air-conditioned minivan from the entire Phuket Island. Dont eat lunch, as you will be served a healthy and nutritious meal onboard the comfortable and modern twin-engine escort boat after leaving from Ao Po Pier. During the boat ride you will watch a raptor show and get a detailed briefing about the nature and geological site of Phang Nga Bay. Learn the basic dos and donts of how to securely enter the caves and hongs.</p><p>Start the first kayaking session with your well-educated and experienced guide through limestone caves and lagoons in the dramatic setting at Koh Panak. The hand-made kayaks are specially designed for your trip, and you can feel absolutely safe because there was never a capsize, a puncture or any accident. Your professional guide paddles you and your partner through 'Tidal Nape' sea caves inside Phang Nga Bays marine limestone karstic islands into 'hongs' (Thai for room). The hidden cliff-lined lagoons are populated with macaques, water monitors, kingfishers, mud-skippers, egrets, sea eagles and brahminy kites. Explore the Ice Cream Cave famous for its formations with different shapes, colors and size - absolutely phenomenal. Return to the escort boat and move on to the second island with two more caves and hongs to explore.</p><p>You will finish after dark by floating your own self-made flower Krathong in a spiritual and spectacular natural light show. Guests say that the evening Loi Kratong ceremony complete with fireflies and dinoflagellates (bio-luminescent plankton) is a 'spiritual experience'.</p><p>Eat a delicious seafood/vegan buffet on the trip back, you return to the pier two hours after sunset. Only the highest-quality ingredients are used to prepare the lunch and dinner, fresh from the local market. Seafood is net caught and chickens are free range. Brown, red, and black rice is served with homemade Massaman curry.</p>",
  highlights: [
    "Kayak into hidden caves and lagoons of Koh Panak",
    "Cruise from Phuket into the Phang Nga Bay",
    "Be guided by highly trained and experienced tour guides of John Gray's Sea Canoe",
    "Eat healthy Thai food including lunch and dinner",
    "Float your own self-made flower Kratong"
  ],
  important: [
    "To start the tour you must show the ticket voucher on your mobile phone to the staff of John Gray's Sea Canoe",
    "Bring towel, bathing clothes, dry and warm clothes for the way back, sunglasses, sun cream and a camera or smart phone (at your own risk, dry-bags are provided)",
    "This tour is not recommended for pregnant women or people with back or neck problems"
  ],
  itineraries: [
    {
      title: "Hotel pickup service in Phuket",
      schedule: "10:30 - 12:00",
      attraction: {
        title: "Phuket",
        url:
          "https://www.tripadvisor.com/Tourism-g293920-Phuket-Vacations.html"
      }
    },
    {
      title: "Meet the crew at Ao Po Pier & get instructions",
      schedule: "12:00 - 13:00",
      attraction: {
        title: "Ao Po Pier",
        url:
          "https://www.tripadvisor.com/Attraction_Review-g2315811-d8559001-Reviews-Ao_Po_Pier-Pa_Khlok_Thalang_District_Phuket.html",
        location: {
          lat: 8.061265,
          lng: 98.432329
        }
      }
    },
    {
      title: "Departure by escort boat to Phang Nga Bay",
      schedule: "13:00 - 13:10",
      attraction: {
        title: "Phang Nga Bay",
        url:
          "https://www.tripadvisor.com/Attraction_Review-g1152716-d317707-Reviews-Phang_Nga_Bay-Ao_Phang_Nga_National_Park_Phang_Nga_Province.html",
        location: {
          lat: 8.221881,
          lng: 98.50035
        }
      }
    },
    {
      title: "Enjoy lunch on board the tour boat",
      schedule: "13:10 - 14:10"
    },
    {
      title: "Kayak into the cave at Koh Phanak",
      schedule: "14:10 - 16:15",
      attraction: {
        title: "Koh Panak",
        url:
          "https://www.tripadvisor.com/Attraction_Review-g1152716-d7702675-Reviews-Koh_Panak_Cave-Ao_Phang_Nga_National_Park_Phang_Nga_Province.html",
        location: {
          lat: 8.190414,
          lng: 98.490306
        }
      }
    },
    {
      title: "Continue to Hong Island",
      schedule: "16:15 - 16:30"
    },
    {
      title: "Sightseeing & kayaking at Koh Hong",
      schedule: "16:30 - 17:00",
      attraction: {
        title: "Koh Hong",
        url:
          "https://www.tripadvisor.com/Attraction_Review-g1152716-d10594729-Reviews-Hongs_of_Phang_Nga-Ao_Phang_Nga_National_Park_Phang_Nga_Province.html",
        location: {
          lat: 8.222773,
          lng: 98.500712
        }
      }
    },
    {
      title: "Explore Bat Cave",
      schedule: "17:00 - 17:15",
      attraction: {
        title: "Bat Cave",
        url:
          "https://www.tripadvisor.com/Attraction_Review-g1152716-d7702675-Reviews-Koh_Panak_Cave-Ao_Phang_Nga_National_Park_Phang_Nga_Province.html",
        location: {
          lat: 8.191899,
          lng: 98.488180
        }
      }
    },
    {
      title: "Explore Ice-cream Cave",
      schedule: "17:15 - 17:30",
      attraction: {
        title: "Ice Cream Cave",
        url:
          "https://www.tripadvisor.com/Attraction_Review-g1152716-d13454969-Reviews-Ice_Cream_Cave-Ao_Phang_Nga_National_Park_Phang_Nga_Province.html",
        location: {
          lat: 8.197626,
          lng: 98.492186
        }
      }
    },
    {
      title: "Free time for relaxing at the beach or kayaking",
      schedule: "17:30 - 18:15"
    },
    {
      title: "Make your own Krathong & have dinner on the boat",
      schedule: "18:15 - 18:45"
    },
    {
      title: "Float the self-made Krathong in the cave of Phanak Island",
      schedule: "18:45 - 19:15",
      attraction: {
        title: "Koh Panak",
        url:
          "https://www.tripadvisor.com/Attraction_Review-g1152716-d7702675-Reviews-Koh_Panak_Cave-Ao_Phang_Nga_National_Park_Phang_Nga_Province.html",
        location: {
          lat: 8.190414,
          lng: 98.490306
        }
      }
    },
    {
      title: "See phosphorescent plankton",
      schedule: "19:15 - 19:30",
      attraction: {
        title: "Koh Panak",
        url:
          "https://www.tripadvisor.com/Attraction_Review-g1152716-d7702675-Reviews-Koh_Panak_Cave-Ao_Phang_Nga_National_Park_Phang_Nga_Province.html",
        location: {
          lat: 8.190414,
          lng: 98.490306
        }
      }
    },
    {
      title: "Head back to Phuket",
      schedule: "19:30 - 20:30"
    },
    {
      title: "Transfer to your hotel",
      schedule: "20:30 - 21:00"
    }
  ],

  attractions: [
    {
      title: "John Gray's Sea Canoe",
      url:
        "https://www.tripadvisor.com/Attraction_Review-g1215781-d639970-Reviews-John_Gray_s_Sea_Canoe-Phuket_Town_Phuket.html"
    }
  ],

  includes: [
    "Hotel round-trip transfer on the entire Phuket island including airport pick-up and drop-off service",
    "Full board meal plan with lunch, dinner, bottled water and herbal tea",
    "Comfortable and modern twin-engine escort boat",
    "Caveman's SOTAR sea kayaks",
    "Kayak equipment including a dry bag",
    "Basic accident insurance",
    "Professional and experienced English and Chinese speaking guide",
    "National Park entrance fee"
  ]
};

function createTour() {
  var tourDefinition = localStorage.getItem("tour");
  if (!tourDefinition) {
    tourDefinition = JSON.parse(JSON.stringify(STANDARD_TOUR));
  } else {
    tourDefinition = JSON.parse(tourDefinition);
  }
  let tour = writable(tourDefinition);
  tour.subscribe(function (tour) {
    localStorage.setItem("tour", JSON.stringify(tour));
  });
  return tour;
}

const mapsLoaded = writable(false);
const mapsLoading = writable(false);
const map$1 = writable(null);

const URL =
  "https://maps.googleapis.com/maps/api/js?key=" +
  process.env.GOOGLE_API_KEY +
  "&libraries=places,geometry&callback=initMap";

let mapsLoadedValue;
let mapsLoadingValue;

mapsLoaded.subscribe(value => {
  mapsLoadedValue = value;
});

mapsLoading.subscribe(value => {
  mapsLoadingValue = value;
});

function initMapService(callback) {
  if (mapsLoadedValue) {
    callback();
  } else if (!mapsLoadingValue) {
    window.initMap = function () {
      mapsLoaded.set(true);
      delete window.initMap;
      callback();
    };

    mapsLoading.set(true);
    const script = document.createElement("script");
    script.src = URL;
    script.async = true;
    script.defer = true;
    document.body.appendChild(script);
  }
}

class GeoControl {
  constructor(parent) {
    this.controlUI = document.createElement("div");
    this.controlUI.style.backgroundColor = "#fff";
    this.controlUI.style.boxShadow = "0 2px 6px rgba(0,0,0,.3)";
    this.controlUI.style.cursor = "pointer";
    this.controlUI.style.margin = "10px";
    this.controlUI.style.padding = "0px";
    this.controlUI.style.textAlign = "center";
    this.controlUI.title = "Use your location";
    parent.appendChild(this.controlUI);

    this.controlText = document.createElement("div");
    this.controlText.style.color = "rgb(25,25,25)";
    this.controlText.style.fontSize = "26px";
    this.controlText.style.width = "40px";
    this.controlText.style.height = "40px";
    this.controlText.style.lineHeight = "35px";
    this.controlText.innerHTML = "<i class='icon icon-myLocation'></i>";
    this.controlUI.appendChild(this.controlText);
  }

  addClickListener(callback) {
    this.controlUI.addEventListener("click", () => {
      this.findYourLocation(callback);
    });
  }

  findYourLocation(callback) {
    if (navigator.geolocation) {
      this.controlText.style.color == "rgb(25,25,25)";
      this.controlText.className = "blinking";

      navigator.geolocation.getCurrentPosition((position) => {
        this.controlText.className = "";
        this.controlText.style.color = "#4285F4";
        let pos = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };

        if (callback) {
          callback(pos);
        }
      }, (error) => {
        console.log(error);
        this.controlText.className = "";
        this.controlUI.title = "Cannot access your location";
        this.controlText.style.color = "gray";
        if (callback) {
          callback(null);
        }
      });
    } else {
      this.controlUI.title = "Cannot access your location";
      this.controlText.style.color = "gray";
      if (callback) {
        callback(null);
      }
    }
  }
}

const file$p = "src/Map.svelte";

function create_fragment$p(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "full-screen svelte-te6v6m");
			add_location(div, file$p, 69, 0, 1553);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[1](div);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*div_binding*/ ctx[1](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let $map;
	validate_store(map$1, "map");
	component_subscribe($$self, map$1, $$value => $$invalidate(3, $map = $$value));
	let container;
	let zoom = 16;
	let myLocationMarker;
	let mapUnsubscribe;

	onMount(async () => {
		initMapService(() => showMap());
	});

	function showMap() {
		map$1.set(new google.maps.Map(container, { zoom, gestureHandling: "cooperative" }));

		var icon = {
			url: "/myLocation.png",
			scaledSize: new google.maps.Size(50, 50),
			origin: new google.maps.Point(0, 0),
			anchor: new google.maps.Point(25, 25)
		};

		myLocationMarker = new google.maps.Marker({
				map: $map,
				draggable: false,
				icon,
				zIndex: 0
			});

		let geoControlDiv = document.createElement("div");
		geoControlDiv.index = 1;

		let findYourLocationCallback = function (pos) {
			if (pos) {
				let latLng = new google.maps.LatLng({ lat: pos.lat, lng: pos.lng });
				myLocationMarker.setPosition(latLng);
				$map.panTo({ lat: pos.lat, lng: pos.lng });
				markerMoved(latLng);
			}
		};

		var geoControl = new GeoControl(geoControlDiv, $map);
		geoControl.addClickListener(findYourLocationCallback);
		$map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(geoControlDiv);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Map> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Map", $$slots, []);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$capture_state = () => ({
		onMount,
		f7: f7Instance,
		map: map$1,
		initMapService,
		GeoControl,
		container,
		zoom,
		myLocationMarker,
		mapUnsubscribe,
		showMap,
		$map
	});

	$$self.$inject_state = $$props => {
		if ("container" in $$props) $$invalidate(0, container = $$props.container);
		if ("zoom" in $$props) zoom = $$props.zoom;
		if ("myLocationMarker" in $$props) myLocationMarker = $$props.myLocationMarker;
		if ("mapUnsubscribe" in $$props) mapUnsubscribe = $$props.mapUnsubscribe;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [container, div_binding];
}

class Map$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$l, create_fragment$p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Map",
			options,
			id: create_fragment$p.name
		});
	}
}

const file$q = "src/UI.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	child_ctx[20] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	return child_ctx;
}

// (257:10) {#each $tour.highlights as highlight}
function create_each_block_3(ctx) {
	let li;
	let span;
	let t0;
	let html_tag;
	let raw_value = /*injectSmartLinks*/ ctx[4](/*highlight*/ ctx[21], /*attractions*/ ctx[3]) + "";
	let t1;

	const block = {
		c: function create() {
			li = element("li");
			span = element("span");
			t0 = space();
			t1 = space();
			set_style(span, "margin-right", "5px");
			attr_dev(span, "class", "icon icon-checkmark svelte-dqbsy4");
			add_location(span, file$q, 258, 14, 6971);
			html_tag = new HtmlTag(t1);
			attr_dev(li, "class", "svelte-dqbsy4");
			add_location(li, file$q, 257, 12, 6952);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, span);
			append_dev(li, t0);
			html_tag.m(raw_value, li);
			append_dev(li, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$tour*/ 2 && raw_value !== (raw_value = /*injectSmartLinks*/ ctx[4](/*highlight*/ ctx[21], /*attractions*/ ctx[3]) + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(257:10) {#each $tour.highlights as highlight}",
		ctx
	});

	return block;
}

// (277:10) <Button             fill             round             href="/Editor"             style="background-color: rgb(24, 107, 109)">
function create_default_slot_2$3(ctx) {
	let t;
	let span;

	const block = {
		c: function create() {
			t = text$1("Change Itinerary\n            ");
			span = element("span");
			set_style(span, "font-weight", "bold");
			set_style(span, "margin-left", "2px");
			attr_dev(span, "class", "icon icon-change");
			add_location(span, file$q, 282, 12, 7767);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(277:10) <Button             fill             round             href=\\\"/Editor\\\"             style=\\\"background-color: rgb(24, 107, 109)\\\">",
		ctx
	});

	return block;
}

// (312:18) {#if itinerary.attraction}
function create_if_block$d(ctx) {
	let div2;
	let div0;

	let t0_value = (/*i*/ ctx[20] == 0
	? "Start at:"
	: /*i*/ ctx[20] == /*$tour*/ ctx[1].itineraries.length - 1
		? "End at:"
		: "Stopover at:") + "";

	let t0;
	let t1;
	let a0;
	let t2_value = /*itinerary*/ ctx[18].attraction.title + "";
	let t2;
	let a0_href_value;
	let t3;
	let a1;
	let div1;
	let a1_href_value;

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			a0 = element("a");
			t2 = text$1(t2_value);
			t3 = space();
			a1 = element("a");
			div1 = element("div");
			attr_dev(a0, "class", "underline external");
			attr_dev(a0, "href", a0_href_value = /*itinerary*/ ctx[18].attraction.url);
			attr_dev(a0, "target", "_blank");
			add_location(a0, file$q, 315, 24, 9098);
			add_location(div0, file$q, 313, 22, 8956);
			set_style(div1, "font-size", "1.2em");
			attr_dev(div1, "class", "icon icon-location");
			add_location(div1, file$q, 327, 24, 9607);
			attr_dev(a1, "title", "Show in Tripadvisor");
			attr_dev(a1, "class", "external");
			attr_dev(a1, "href", a1_href_value = /*itinerary*/ ctx[18].attraction.url);
			attr_dev(a1, "target", "_blank");
			add_location(a1, file$q, 322, 22, 9390);
			attr_dev(div2, "class", "attraction svelte-dqbsy4");
			add_location(div2, file$q, 312, 20, 8909);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div0, t1);
			append_dev(div0, a0);
			append_dev(a0, t2);
			append_dev(div2, t3);
			append_dev(div2, a1);
			append_dev(a1, div1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$tour*/ 2 && t0_value !== (t0_value = (/*i*/ ctx[20] == 0
			? "Start at:"
			: /*i*/ ctx[20] == /*$tour*/ ctx[1].itineraries.length - 1
				? "End at:"
				: "Stopover at:") + "")) set_data_dev(t0, t0_value);

			if (dirty & /*$tour*/ 2 && t2_value !== (t2_value = /*itinerary*/ ctx[18].attraction.title + "")) set_data_dev(t2, t2_value);

			if (dirty & /*$tour*/ 2 && a0_href_value !== (a0_href_value = /*itinerary*/ ctx[18].attraction.url)) {
				attr_dev(a0, "href", a0_href_value);
			}

			if (dirty & /*$tour*/ 2 && a1_href_value !== (a1_href_value = /*itinerary*/ ctx[18].attraction.url)) {
				attr_dev(a1, "href", a1_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$d.name,
		type: "if",
		source: "(312:18) {#if itinerary.attraction}",
		ctx
	});

	return block;
}

// (295:12) {#each $tour.itineraries as itinerary, i}
function create_each_block_2(ctx) {
	let li;
	let div0;
	let span0;
	let t0_value = /*itinerary*/ ctx[18].schedule + "";
	let t0;
	let t1;
	let div1;
	let span1;
	let t2;
	let div2;
	let h3;
	let t3_value = /*itinerary*/ ctx[18].title + "";
	let t3;
	let h3_class_value;
	let t4;
	let t5;
	let if_block = /*itinerary*/ ctx[18].attraction && create_if_block$d(ctx);

	const block = {
		c: function create() {
			li = element("li");
			div0 = element("div");
			span0 = element("span");
			t0 = text$1(t0_value);
			t1 = space();
			div1 = element("div");
			span1 = element("span");
			t2 = space();
			div2 = element("div");
			h3 = element("h3");
			t3 = text$1(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			t5 = space();
			attr_dev(span0, "class", "svelte-dqbsy4");
			add_location(span0, file$q, 297, 18, 8257);
			attr_dev(div0, "class", "date svelte-dqbsy4");
			add_location(div0, file$q, 296, 16, 8220);
			set_style(span1, "position", "absolute");
			set_style(span1, "top", "50%");
			set_style(span1, "left", "50%");
			set_style(span1, "transform", "translate(-50%, -50%)");

			set_style(span1, "color", /*i*/ ctx[20] == /*$tour*/ ctx[1].itineraries.length - 1
			? "hsl(181, 64%, 26%)"
			: "white");

			attr_dev(span1, "class", "icon icon-circle svelte-dqbsy4");
			add_location(span1, file$q, 300, 18, 8368);
			attr_dev(div1, "class", "point svelte-dqbsy4");
			add_location(div1, file$q, 299, 16, 8330);
			attr_dev(h3, "class", h3_class_value = "title " + (/*itinerary*/ ctx[18].attraction ? "" : "noAttraction") + " svelte-dqbsy4");
			add_location(h3, file$q, 307, 18, 8698);
			attr_dev(div2, "class", "content svelte-dqbsy4");
			add_location(div2, file$q, 306, 16, 8658);
			attr_dev(li, "class", "svelte-dqbsy4");
			add_location(li, file$q, 295, 14, 8199);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, div0);
			append_dev(div0, span0);
			append_dev(span0, t0);
			append_dev(li, t1);
			append_dev(li, div1);
			append_dev(div1, span1);
			append_dev(li, t2);
			append_dev(li, div2);
			append_dev(div2, h3);
			append_dev(h3, t3);
			append_dev(div2, t4);
			if (if_block) if_block.m(div2, null);
			append_dev(li, t5);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$tour*/ 2 && t0_value !== (t0_value = /*itinerary*/ ctx[18].schedule + "")) set_data_dev(t0, t0_value);

			if (dirty & /*$tour*/ 2) {
				set_style(span1, "color", /*i*/ ctx[20] == /*$tour*/ ctx[1].itineraries.length - 1
				? "hsl(181, 64%, 26%)"
				: "white");
			}

			if (dirty & /*$tour*/ 2 && t3_value !== (t3_value = /*itinerary*/ ctx[18].title + "")) set_data_dev(t3, t3_value);

			if (dirty & /*$tour*/ 2 && h3_class_value !== (h3_class_value = "title " + (/*itinerary*/ ctx[18].attraction ? "" : "noAttraction") + " svelte-dqbsy4")) {
				attr_dev(h3, "class", h3_class_value);
			}

			if (/*itinerary*/ ctx[18].attraction) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$d(ctx);
					if_block.c();
					if_block.m(div2, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(295:12) {#each $tour.itineraries as itinerary, i}",
		ctx
	});

	return block;
}

// (351:10) {#each $tour.includes as include}
function create_each_block_1(ctx) {
	let li;
	let span;
	let t0;
	let html_tag;
	let raw_value = /*injectSmartLinks*/ ctx[4](/*include*/ ctx[15], /*attractions*/ ctx[3]) + "";
	let t1;

	const block = {
		c: function create() {
			li = element("li");
			span = element("span");
			t0 = space();
			t1 = space();
			set_style(span, "margin-right", "5px");
			attr_dev(span, "class", "icon icon-plus svelte-dqbsy4");
			add_location(span, file$q, 352, 14, 10254);
			html_tag = new HtmlTag(t1);
			set_style(li, "padding", "3px");
			set_style(li, "font-weight", "bold");
			attr_dev(li, "class", "svelte-dqbsy4");
			add_location(li, file$q, 351, 12, 10195);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, span);
			append_dev(li, t0);
			html_tag.m(raw_value, li);
			append_dev(li, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$tour*/ 2 && raw_value !== (raw_value = /*injectSmartLinks*/ ctx[4](/*include*/ ctx[15], /*attractions*/ ctx[3]) + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(351:10) {#each $tour.includes as include}",
		ctx
	});

	return block;
}

// (375:10) {#each $tour.important as important}
function create_each_block$2(ctx) {
	let li;
	let span;
	let t0;
	let html_tag;
	let raw_value = /*injectSmartLinks*/ ctx[4](/*important*/ ctx[12], /*attractions*/ ctx[3]) + "";
	let t1;

	const block = {
		c: function create() {
			li = element("li");
			span = element("span");
			t0 = space();
			t1 = space();
			set_style(span, "margin-right", "5px");
			attr_dev(span, "class", "icon icon-circle svelte-dqbsy4");
			add_location(span, file$q, 376, 14, 10972);
			html_tag = new HtmlTag(t1);
			attr_dev(li, "class", "svelte-dqbsy4");
			add_location(li, file$q, 375, 12, 10953);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, span);
			append_dev(li, t0);
			html_tag.m(raw_value, li);
			append_dev(li, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$tour*/ 2 && raw_value !== (raw_value = /*injectSmartLinks*/ ctx[4](/*important*/ ctx[12], /*attractions*/ ctx[3]) + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(375:10) {#each $tour.important as important}",
		ctx
	});

	return block;
}

// (402:2) <Toolbar style="font-size: 0.7rem" tabbar labels position="bottom">
function create_default_slot_1$4(ctx) {
	let link;
	let current;

	link = new Link({
			props: {
				text: "Show Hints",
				style: "color: red",
				icon: "icon icon-lightbulb"
			},
			$$inline: true
		});

	link.$on("click", /*click_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(link.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(link, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(link, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(402:2) <Toolbar style=\\\"font-size: 0.7rem\\\" tabbar labels position=\\\"bottom\\\">",
		ctx
	});

	return block;
}

// (230:0) <Page>
function create_default_slot$6(ctx) {
	let div7;
	let div6;
	let h1;
	let t0_value = /*$tour*/ ctx[1].title + "";
	let t0;
	let t1;
	let h20;
	let t2_value = /*$tour*/ ctx[1].subtitle + "";
	let t2;
	let t3;
	let section0;
	let raw0_value = /*injectSmartLinks*/ ctx[4](/*$tour*/ ctx[1].summary, /*attractions*/ ctx[3]) + "";
	let t4;
	let img;
	let img_alt_value;
	let img_src_value;
	let t5;
	let section1;
	let h21;
	let t7;
	let ul0;
	let t8;
	let section2;
	let div0;
	let h22;
	let t10;
	let button;
	let t11;
	let div1;
	let ul1;
	let t12;
	let section3;
	let h23;
	let t14;
	let div2;
	let map_1;
	let t15;
	let section4;
	let h24;
	let t17;
	let ul2;
	let t18;
	let section5;
	let h25;
	let t20;
	let div3;
	let raw1_value = /*injectSmartLinks*/ ctx[4](/*$tour*/ ctx[1].description, /*attractions*/ ctx[3]) + "";
	let t21;
	let section6;
	let h26;
	let t23;
	let ul3;
	let t24;
	let div5;
	let div4;
	let t25;
	let br;
	let t26;
	let a;
	let t28;
	let navtoolbar;
	let t29;
	let toolbar;
	let current;
	let each_value_3 = /*$tour*/ ctx[1].highlights;
	validate_each_argument(each_value_3);
	let each_blocks_3 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	button = new Button({
			props: {
				fill: true,
				round: true,
				href: "/Editor",
				style: "background-color: rgb(24, 107, 109)",
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let each_value_2 = /*$tour*/ ctx[1].itineraries;
	validate_each_argument(each_value_2);
	let each_blocks_2 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	map_1 = new Map$1({ $$inline: true });
	let each_value_1 = /*$tour*/ ctx[1].includes;
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = /*$tour*/ ctx[1].important;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	navtoolbar = new Toolbar_1({
			props: { active: "/New-UI" },
			$$inline: true
		});

	toolbar = new Toolbar$2({
			props: {
				style: "font-size: 0.7rem",
				tabbar: true,
				labels: true,
				position: "bottom",
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div7 = element("div");
			div6 = element("div");
			h1 = element("h1");
			t0 = text$1(t0_value);
			t1 = space();
			h20 = element("h2");
			t2 = text$1(t2_value);
			t3 = space();
			section0 = element("section");
			t4 = space();
			img = element("img");
			t5 = space();
			section1 = element("section");
			h21 = element("h2");
			h21.textContent = "Highlights";
			t7 = space();
			ul0 = element("ul");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			t8 = space();
			section2 = element("section");
			div0 = element("div");
			h22 = element("h2");
			h22.textContent = "Scheduled Itinerary";
			t10 = space();
			create_component(button.$$.fragment);
			t11 = space();
			div1 = element("div");
			ul1 = element("ul");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t12 = space();
			section3 = element("section");
			h23 = element("h2");
			h23.textContent = "Attractions Map";
			t14 = space();
			div2 = element("div");
			create_component(map_1.$$.fragment);
			t15 = space();
			section4 = element("section");
			h24 = element("h2");
			h24.textContent = "What's Included";
			t17 = space();
			ul2 = element("ul");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t18 = space();
			section5 = element("section");
			h25 = element("h2");
			h25.textContent = "What To Expect";
			t20 = space();
			div3 = element("div");
			t21 = space();
			section6 = element("section");
			h26 = element("h2");
			h26.textContent = "Additional Info";
			t23 = space();
			ul3 = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t24 = space();
			div5 = element("div");
			div4 = element("div");
			t25 = text$1(" Trip Store Krabi Co., Ltd. 2020. All Rights Reserved.\n          ");
			br = element("br");
			t26 = space();
			a = element("a");
			a.textContent = "Contact Us";
			t28 = space();
			create_component(navtoolbar.$$.fragment);
			t29 = space();
			create_component(toolbar.$$.fragment);
			add_location(h1, file$q, 232, 6, 5402);
			attr_dev(h20, "data-intro", "Allow to define a subtitle which reflects a creative name of\n        the product in contrast to the technical name in the title.");
			add_location(h20, file$q, 233, 6, 5431);
			add_location(section0, file$q, 238, 6, 5629);
			attr_dev(img, "class", "hero svelte-dqbsy4");
			attr_dev(img, "alt", img_alt_value = /*tour*/ ctx[2].title);
			if (img.src !== (img_src_value = "https://lh3.googleusercontent.com/f7yM63HIwTGLHBtYOMiNyw_moiRbKnzBC7GtL8O5V1BZUCy4RH54tfiwt8tEP145jxHjuyP5JpKIYNa9NpLBfZBXs1RxWFJVD6kDcNE1h8YeRm9Yz5Qybhel0zbjNwF_Pi-oFNt6xCTumeRTq__NbNSvLGjKqlK354UsOjBPWuD60N656JRqeQUsiZP_CKUdTp5aMjDKUpYIisJAm8a6XraKeH7EdawsGfdciW58u9-DM5ENTBfm2kIqGB3vkOUetwbu1I7YF6bUnoMgnX9r2rC0qZOdhGSIyPCdOKayh725Z1vkyz2CvM6I_IOG1bBWaPZjbITlsdIMCAF8xZu2soVX_s7biu9tAWJPIeMB8EzW0U_DHOH_VbLz2NRV0yYToc9ViFWA3oZXAsVBjboWXumqMXPW9rOoDo25fwGNBNxQFUbHoothk1xnbpij9OiWDN5pM4NYK4POfeaPNc0nwmzd8vAo_fl3lsootLeVILj2XAjGQxgj_njXhOmQMTtchtLUvxvnRwMT0Q8Y4r5eSsOcIfYeMwklDfzTmQv3YOC_EQK1kRIlsJHv79uLzifwJS3zJqO_3og6PTto-G4HeHgyoN8u16vugoEruVEqIUFwnx-dF56gg0y7U7YeLl47Ajb3AUzLKcKdyj60mWHn5lkOA7ZLa1-9P6x64JwcFkJpqGG_1oGnwBv9Fnub1eAUl-tJbU-SKELloTNlv2NZIfmlYU5_fGWV72nOyVN8Uo05sYq7XQ=s1600")) attr_dev(img, "src", img_src_value);
			add_location(img, file$q, 242, 6, 5724);
			attr_dev(h21, "data-intro", "Allow a maximum of 5 highlights to be added by the\n          supplier himself because she/he knows best which product features\n          should stand out.");
			add_location(h21, file$q, 249, 8, 6642);
			attr_dev(ul0, "class", "highlights svelte-dqbsy4");
			add_location(ul0, file$q, 255, 8, 6868);
			add_location(section1, file$q, 248, 6, 6624);
			attr_dev(h22, "id", "itinerary");
			set_style(h22, "margin-top", "0px");
			set_style(h22, "margin-bottom", "0px");
			attr_dev(h22, "data-intro", "Allow to define a scheduled itinerary with starting &\n            end times, or an itinerary with durations.");
			add_location(h22, file$q, 269, 10, 7319);
			set_style(div0, "margin-top", "40px");
			set_style(div0, "display", "flex");
			set_style(div0, "align-items", "center");
			set_style(div0, "justify-content", "space-between");
			add_location(div0, file$q, 266, 8, 7189);
			attr_dev(ul1, "class", "svelte-dqbsy4");
			add_location(ul1, file$q, 293, 10, 8126);
			attr_dev(div1, "class", "timeline svelte-dqbsy4");
			attr_dev(div1, "data-intro", "Display itinerary items with schedule/duration,\n          description and an optional link to the related attraction on\n          Tripadvisor.");
			add_location(div1, file$q, 288, 8, 7917);
			add_location(section2, file$q, 265, 6, 7171);
			add_location(h23, file$q, 341, 8, 9933);
			set_style(div2, "width", "100%");
			set_style(div2, "height", "600px");
			add_location(div2, file$q, 342, 8, 9966);
			add_location(section3, file$q, 340, 6, 9915);
			add_location(h24, file$q, 348, 8, 10082);
			attr_dev(ul2, "class", "inclusions svelte-dqbsy4");
			add_location(ul2, file$q, 349, 8, 10115);
			add_location(section4, file$q, 347, 6, 10064);
			attr_dev(h25, "data-intro", "Allow to add a long product description of up to 2000\n          characters independent of the chosen product type (tour, activity,\n          etc.).");
			add_location(h25, file$q, 360, 8, 10465);
			attr_dev(div3, "class", "description svelte-dqbsy4");
			add_location(div3, file$q, 366, 8, 10688);
			add_location(section5, file$q, 359, 6, 10447);
			add_location(h26, file$q, 372, 8, 10838);
			attr_dev(ul3, "class", "important svelte-dqbsy4");
			add_location(ul3, file$q, 373, 8, 10871);
			add_location(section6, file$q, 371, 6, 10820);
			add_location(br, file$q, 388, 10, 11383);
			attr_dev(a, "class", "link underline external");
			attr_dev(a, "href", "mailto:info@tripstorekrabi.com");
			add_location(a, file$q, 389, 10, 11400);
			attr_dev(div4, "class", "");
			add_location(div4, file$q, 386, 8, 11292);
			set_style(div5, "color", "hsl(181, 64%, 26%)");
			set_style(div5, "text-align", "center");
			set_style(div5, "margin-top", "80px");
			set_style(div5, "margin-bottom", "80px");
			add_location(div5, file$q, 383, 6, 11169);
			set_style(div6, "margin", "auto");
			set_style(div6, "height", "100%");
			set_style(div6, "max-width", "1000px");
			set_style(div6, "padding", "20px");
			add_location(div6, file$q, 231, 4, 5321);
			attr_dev(div7, "class", "page-content");
			add_location(div7, file$q, 230, 2, 5290);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div7, anchor);
			append_dev(div7, div6);
			append_dev(div6, h1);
			append_dev(h1, t0);
			append_dev(div6, t1);
			append_dev(div6, h20);
			append_dev(h20, t2);
			append_dev(div6, t3);
			append_dev(div6, section0);
			section0.innerHTML = raw0_value;
			append_dev(div6, t4);
			append_dev(div6, img);
			/*img_binding*/ ctx[6](img);
			append_dev(div6, t5);
			append_dev(div6, section1);
			append_dev(section1, h21);
			append_dev(section1, t7);
			append_dev(section1, ul0);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].m(ul0, null);
			}

			append_dev(div6, t8);
			append_dev(div6, section2);
			append_dev(section2, div0);
			append_dev(div0, h22);
			append_dev(div0, t10);
			mount_component(button, div0, null);
			append_dev(section2, t11);
			append_dev(section2, div1);
			append_dev(div1, ul1);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(ul1, null);
			}

			append_dev(div6, t12);
			append_dev(div6, section3);
			append_dev(section3, h23);
			append_dev(section3, t14);
			append_dev(section3, div2);
			mount_component(map_1, div2, null);
			append_dev(div6, t15);
			append_dev(div6, section4);
			append_dev(section4, h24);
			append_dev(section4, t17);
			append_dev(section4, ul2);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(ul2, null);
			}

			append_dev(div6, t18);
			append_dev(div6, section5);
			append_dev(section5, h25);
			append_dev(section5, t20);
			append_dev(section5, div3);
			div3.innerHTML = raw1_value;
			append_dev(div6, t21);
			append_dev(div6, section6);
			append_dev(section6, h26);
			append_dev(section6, t23);
			append_dev(section6, ul3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul3, null);
			}

			append_dev(div6, t24);
			append_dev(div6, div5);
			append_dev(div5, div4);
			append_dev(div4, t25);
			append_dev(div4, br);
			append_dev(div4, t26);
			append_dev(div4, a);
			insert_dev(target, t28, anchor);
			mount_component(navtoolbar, target, anchor);
			insert_dev(target, t29, anchor);
			mount_component(toolbar, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*$tour*/ 2) && t0_value !== (t0_value = /*$tour*/ ctx[1].title + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*$tour*/ 2) && t2_value !== (t2_value = /*$tour*/ ctx[1].subtitle + "")) set_data_dev(t2, t2_value);
			if ((!current || dirty & /*$tour*/ 2) && raw0_value !== (raw0_value = /*injectSmartLinks*/ ctx[4](/*$tour*/ ctx[1].summary, /*attractions*/ ctx[3]) + "")) section0.innerHTML = raw0_value;
			if (dirty & /*injectSmartLinks, $tour, attractions*/ 26) {
				each_value_3 = /*$tour*/ ctx[1].highlights;
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks_3[i]) {
						each_blocks_3[i].p(child_ctx, dirty);
					} else {
						each_blocks_3[i] = create_each_block_3(child_ctx);
						each_blocks_3[i].c();
						each_blocks_3[i].m(ul0, null);
					}
				}

				for (; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].d(1);
				}

				each_blocks_3.length = each_value_3.length;
			}

			const button_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (dirty & /*$tour*/ 2) {
				each_value_2 = /*$tour*/ ctx[1].itineraries;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_2[i]) {
						each_blocks_2[i].p(child_ctx, dirty);
					} else {
						each_blocks_2[i] = create_each_block_2(child_ctx);
						each_blocks_2[i].c();
						each_blocks_2[i].m(ul1, null);
					}
				}

				for (; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].d(1);
				}

				each_blocks_2.length = each_value_2.length;
			}

			if (dirty & /*injectSmartLinks, $tour, attractions*/ 26) {
				each_value_1 = /*$tour*/ ctx[1].includes;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(ul2, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if ((!current || dirty & /*$tour*/ 2) && raw1_value !== (raw1_value = /*injectSmartLinks*/ ctx[4](/*$tour*/ ctx[1].description, /*attractions*/ ctx[3]) + "")) div3.innerHTML = raw1_value;
			if (dirty & /*injectSmartLinks, $tour, attractions*/ 26) {
				each_value = /*$tour*/ ctx[1].important;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const toolbar_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(map_1.$$.fragment, local);
			transition_in(navtoolbar.$$.fragment, local);
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(map_1.$$.fragment, local);
			transition_out(navtoolbar.$$.fragment, local);
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div7);
			/*img_binding*/ ctx[6](null);
			destroy_each(each_blocks_3, detaching);
			destroy_component(button);
			destroy_each(each_blocks_2, detaching);
			destroy_component(map_1);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t28);
			destroy_component(navtoolbar, detaching);
			if (detaching) detach_dev(t29);
			destroy_component(toolbar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(230:0) <Page>",
		ctx
	});

	return block;
}

function create_fragment$q(ctx) {
	let page;
	let current;

	page = new Page({
			props: {
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(page.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(page, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const page_changes = {};

			if (dirty & /*$$scope, $tour, heroImage*/ 16777219) {
				page_changes.$$scope = { dirty, ctx };
			}

			page.$set(page_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(page.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(page.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(page, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let $tour;
	let { f7route } = $$props;
	let scrollTo = f7route.params.scrollTo;
	let tour = createTour();
	validate_store(tour, "tour");
	component_subscribe($$self, tour, value => $$invalidate(1, $tour = value));
	let heroImage;

	let attractions = [
		...$tour.itineraries.filter(function (itinerary) {
			return itinerary.attraction;
		}).map(function (itinerary) {
			return itinerary.attraction;
		}),
		...$tour.attractions
	];

	let center = attractions[0].location;
	let smartLinkIntroAdded = false;
	let mapUnsubscribe;

	onMount(async () => {
		$$invalidate(
			0,
			heroImage.onload = () => {
				if (scrollTo) {
					let node = document.getElementById(scrollTo);

					if (node) {
						node.scrollIntoView({ behavior: "smooth" });
					}
				}
			},
			heroImage
		);

		mapUnsubscribe = map$1.subscribe(function (map) {
			if (map) {
				let bounds = new google.maps.LatLngBounds();
				let infoWindow = new google.maps.InfoWindow();

				attractions.forEach(function (attraction) {
					if (attraction.location) {
						bounds.extend(new google.maps.LatLng({
								lat: attraction.location.lat,
								lng: attraction.location.lng
							}));

						let marker = new google.maps.Marker({
								position: attraction.location,
								map,
								title: attraction.title
							});

						marker.addListener("click", function (event) {
							infoWindow.setContent("<a target='_new' class='external' href='" + attraction.url + "'>" + attraction.title + "</a>");
							infoWindow.open(map, marker);
						});
					}
				});

				map.fitBounds(bounds);
			}
		});
	});

	onDestroy(async () => {
		mapUnsubscribe();
	});

	function injectSmartLinks(text, attractions) {
		attractions.forEach(function (attraction) {
			let regexp = new RegExp("(w*" + attraction.title + "w*)(?=S*['])?([a-zA-Z']+)?", "gmi");

			function replacer(match, p1, p2, p3, offset, string) {
				let dataIntro = !smartLinkIntroAdded
				? "data-intro='Insert smart links for occurrences of Tripadvisor attractions & places into the tour summary and description.'"
				: "";

				smartLinkIntroAdded = true;
				return "<a class='external' " + dataIntro + " href='" + attraction.url + "' target='_blank'>" + match + "</a>";
			}

			text = text.replace(regexp, replacer);
		});

		return text;
	}

	const writable_props = ["f7route"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UI> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("UI", $$slots, []);

	function img_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			heroImage = $$value;
			$$invalidate(0, heroImage);
		});
	}

	const click_handler = function () {
		intro().start();
	};

	$$self.$set = $$props => {
		if ("f7route" in $$props) $$invalidate(5, f7route = $$props.f7route);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		Page,
		Link,
		Toolbar: Toolbar$2,
		Button,
		Preloader: Preloader$2,
		introJs: intro,
		createTour,
		map: map$1,
		NavToolbar: Toolbar_1,
		Map: Map$1,
		f7route,
		scrollTo,
		tour,
		heroImage,
		attractions,
		center,
		smartLinkIntroAdded,
		mapUnsubscribe,
		injectSmartLinks,
		$tour
	});

	$$self.$inject_state = $$props => {
		if ("f7route" in $$props) $$invalidate(5, f7route = $$props.f7route);
		if ("scrollTo" in $$props) scrollTo = $$props.scrollTo;
		if ("tour" in $$props) $$invalidate(2, tour = $$props.tour);
		if ("heroImage" in $$props) $$invalidate(0, heroImage = $$props.heroImage);
		if ("attractions" in $$props) $$invalidate(3, attractions = $$props.attractions);
		if ("center" in $$props) center = $$props.center;
		if ("smartLinkIntroAdded" in $$props) smartLinkIntroAdded = $$props.smartLinkIntroAdded;
		if ("mapUnsubscribe" in $$props) mapUnsubscribe = $$props.mapUnsubscribe;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		heroImage,
		$tour,
		tour,
		attractions,
		injectSmartLinks,
		f7route,
		img_binding,
		click_handler
	];
}

class UI extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$m, create_fragment$q, safe_not_equal, { f7route: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UI",
			options,
			id: create_fragment$q.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*f7route*/ ctx[5] === undefined && !("f7route" in props)) {
			console.warn("<UI> was created without expected prop 'f7route'");
		}
	}

	get f7route() {
		throw new Error("<UI>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7route(value) {
		throw new Error("<UI>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const DAY_IN_MILLIS = 86400000;
const MONTH_IN_MILLIS = 30 * DAY_IN_MILLIS;

function getJSONWithExpiry(key) {
  if (typeof (Storage) !== "undefined") {
    let item = localStorage.getItem(key);
    if (!item) {
      return null;
    } else {
      let jsonItem = JSON.parse(item);
      let now = new Date();

      if (now.getTime() > jsonItem.expiry) {
        localStorage.removeItem(key);
        return null;
      }
      return jsonItem.value;
    }
  } else {
    return null;
  }
}

function setJSONWithExpiry(key, value, ttl) {
  if (typeof (Storage) !== "undefined") {
    let now = new Date();

    let item = {
      value: value,
      expiry: now.getTime() + ttl
    };
    localStorage.setItem(key, JSON.stringify(item));
  }
}

async function suggestAttractions(query) {
  let result = getJSONWithExpiry(query);
  if (result) {
    return result;
  } else {
    let data = {
      searchString: query,
      countryCode: null,
      language: "en",
      categories: ["point_of_interest", "neighborhood", "city"],
      serviceProviders: ["TRIPADVISOR", "GOOGLE"],
      filterBlacklistedLocations: false,
      useStrictCategorySearch: false,
      nearLocation: null
    };

    return fetch(
      "https://server-dot-viator-done-right.et.r.appspot.com/viator/suggest",
      {
        method: "POST",
        body: JSON.stringify(data),
        headers: {
          "Content-Type": "application/json"
        }
      }
    )
      .then(res => res.json())
      .then(data => {
        let result = data.suggestions;
        setJSONWithExpiry(query, result, MONTH_IN_MILLIS);
        return result;
      })
      .catch(error => {
        console.log(error);
        f7Instance.dialog.alert(
          "An error occurred while loading attractions!",
          "Loading Attractions"
        );
        return [];
      });
  }
}

async function getAttractionDetails(providerReference) {
  let result = getJSONWithExpiry(providerReference);

  if (result) {
    return result;
  }
  else {
    var dialog = f7Instance.dialog.preloader('Loading...');
    let data = { providerReference: providerReference };
    return fetch(
      'https://server-dot-viator-done-right.et.r.appspot.com/viator/details',
      {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
          'Content-Type': 'application/json'
        }
      }
    )
      .then(res => res.json())
      .then(data => {
        setJSONWithExpiry(providerReference, data, MONTH_IN_MILLIS);
        dialog.close();
        return data;
      })
      .catch(error => {
        console.log(error);
        dialog.close();
        f7Instance.dialog.alert(
          "An error occurred while loading attracion details!",
          "Loading Attraction Details"
        );
      });
  }
}

const file$r = "src/Editor.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i];
	return child_ctx;
}

// (131:6) {:else}
function create_else_block_3$1(ctx) {
	let list;
	let current;

	list = new List({
			props: {
				sortable: true,
				class: "sortable-enabled",
				"data-sortable-move-elements": "false",
				$$slots: { default: [create_default_slot_20] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(list.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const list_changes = {};

			if (dirty[0] & /*itineraries, $tour, selectedItinerary, searchbarComponent*/ 204 | dirty[1] & /*$$scope*/ 8) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(list, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3$1.name,
		type: "else",
		source: "(131:6) {:else}",
		ctx
	});

	return block;
}

// (129:6) {#if itineraries.length == 0}
function create_if_block_5$2(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			div.textContent = "No itinerary items added yet.";
			add_location(div, file$r, 129, 8, 2928);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$2.name,
		type: "if",
		source: "(129:6) {#if itineraries.length == 0}",
		ctx
	});

	return block;
}

// (139:16) <Link                   style="font-weight: bold"                   on:click={function() {                     selectedItinerary = itinerary;                     openItinerarySheet();                   }}>
function create_default_slot_25(ctx) {
	let t_value = /*itinerary*/ ctx[31].schedule + ": " + /*itinerary*/ ctx[31].title + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*itineraries*/ 64 && t_value !== (t_value = /*itinerary*/ ctx[31].schedule + ": " + /*itinerary*/ ctx[31].title + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_25.name,
		type: "slot",
		source: "(139:16) <Link                   style=\\\"font-weight: bold\\\"                   on:click={function() {                     selectedItinerary = itinerary;                     openItinerarySheet();                   }}>",
		ctx
	});

	return block;
}

// (138:14) <div slot="title">
function create_title_slot_2(ctx) {
	let div;
	let link;
	let current;

	function click_handler(...args) {
		return /*click_handler*/ ctx[14](/*itinerary*/ ctx[31], ...args);
	}

	link = new Link({
			props: {
				style: "font-weight: bold",
				$$slots: { default: [create_default_slot_25] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	link.$on("click", click_handler);

	const block = {
		c: function create() {
			div = element("div");
			create_component(link.$$.fragment);
			attr_dev(div, "slot", "title");
			add_location(div, file$r, 137, 14, 3185);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(link, div, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const link_changes = {};

			if (dirty[0] & /*itineraries*/ 64 | dirty[1] & /*$$scope*/ 8) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(link);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot_2.name,
		type: "slot",
		source: "(138:14) <div slot=\\\"title\\\">",
		ctx
	});

	return block;
}

// (150:16) {#if itinerary.attraction}
function create_if_block_6$2(ctx) {
	let button;
	let current;

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[15](/*itinerary*/ ctx[31], ...args);
	}

	button = new Button({
			props: {
				round: true,
				outline: true,
				small: true,
				style: "color: rgb(24, 107, 109); border-color: rgb(24, 107,\n                    109); font-weight: bold; margin-right: 10px",
				$$slots: { default: [create_default_slot_24] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", click_handler_1);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};

			if (dirty[0] & /*itineraries*/ 64 | dirty[1] & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$2.name,
		type: "if",
		source: "(150:16) {#if itinerary.attraction}",
		ctx
	});

	return block;
}

// (151:18) <Button                     round                     outline                     small                     style="color: rgb(24, 107, 109); border-color: rgb(24, 107,                     109); font-weight: bold; margin-right: 10px"                     on:click={function() {                       selectedItinerary = itinerary;                       openAttractionSheet();                       searchbarComponent                         .instance()                         .search(selectedItinerary.attraction.title);                     }}>
function create_default_slot_24(ctx) {
	let t_value = /*itinerary*/ ctx[31].attraction.title + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*itineraries*/ 64 && t_value !== (t_value = /*itinerary*/ ctx[31].attraction.title + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_24.name,
		type: "slot",
		source: "(151:18) <Button                     round                     outline                     small                     style=\\\"color: rgb(24, 107, 109); border-color: rgb(24, 107,                     109); font-weight: bold; margin-right: 10px\\\"                     on:click={function() {                       selectedItinerary = itinerary;                       openAttractionSheet();                       searchbarComponent                         .instance()                         .search(selectedItinerary.attraction.title);                     }}>",
		ctx
	});

	return block;
}

// (170:18) <Button                     fill                     small                     style="background-color: rgb(24, 107, 109);"                     on:click={function() {                       selectedItinerary = itinerary;                       openItinerarySheet();                     }}>
function create_default_slot_23(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "title", "Change attraction");
			attr_dev(span, "class", "icon icon-pencil");
			add_location(span, file$r, 177, 20, 4697);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_23.name,
		type: "slot",
		source: "(170:18) <Button                     fill                     small                     style=\\\"background-color: rgb(24, 107, 109);\\\"                     on:click={function() {                       selectedItinerary = itinerary;                       openItinerarySheet();                     }}>",
		ctx
	});

	return block;
}

// (181:18) <Button                     style="margin-left: 8px"                     fill                     small                     color="red"                     on:click={function() {                       f7.dialog.confirm(                         'Are you sure you want to remove this item?',                         'Remove Itinerary Item',                         () => {                           let newItineraries = itineraries.filter(                             item => item !== itinerary                           );                           $tour.itineraries = newItineraries;                           tour.set($tour);                         }                       );                     }}>
function create_default_slot_22(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "title", "Remove attraction");
			attr_dev(span, "class", "icon icon-cross");
			add_location(span, file$r, 198, 20, 5526);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_22.name,
		type: "slot",
		source: "(181:18) <Button                     style=\\\"margin-left: 8px\\\"                     fill                     small                     color=\\\"red\\\"                     on:click={function() {                       f7.dialog.confirm(                         'Are you sure you want to remove this item?',                         'Remove Itinerary Item',                         () => {                           let newItineraries = itineraries.filter(                             item => item !== itinerary                           );                           $tour.itineraries = newItineraries;                           tour.set($tour);                         }                       );                     }}>",
		ctx
	});

	return block;
}

// (168:14) <div slot="after">
function create_after_slot_2(ctx) {
	let div0;
	let div1;
	let div2;
	let button0;
	let t;
	let button1;
	let current;
	let if_block = /*itinerary*/ ctx[31].attraction && create_if_block_6$2(ctx);

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[16](/*itinerary*/ ctx[31], ...args);
	}

	button0 = new Button({
			props: {
				fill: true,
				small: true,
				style: "background-color: rgb(24, 107, 109);",
				$$slots: { default: [create_default_slot_23] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", click_handler_2);

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[17](/*itinerary*/ ctx[31], ...args);
	}

	button1 = new Button({
			props: {
				style: "margin-left: 8px",
				fill: true,
				small: true,
				color: "red",
				$$slots: { default: [create_default_slot_22] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", click_handler_3);

	const block = {
		c: function create() {
			div0 = element("div");
			if (if_block) if_block.c();
			div1 = element("div");
			div2 = element("div");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr_dev(div0, "slot", "after");
			add_location(div0, file$r, 148, 14, 3550);
			set_style(div2, "display", "flex");
			add_location(div2, file$r, 168, 16, 4343);
			attr_dev(div1, "slot", "after");
			add_location(div1, file$r, 167, 14, 4308);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			if (if_block) if_block.m(div0, null);
			insert_dev(target, div1, anchor);
			append_dev(div1, div2);
			mount_component(button0, div2, null);
			append_dev(div2, t);
			mount_component(button1, div2, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*itinerary*/ ctx[31].attraction) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*itineraries*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_6$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 8) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 8) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (if_block) if_block.d();
			if (detaching) detach_dev(div1);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_after_slot_2.name,
		type: "slot",
		source: "(168:14) <div slot=\\\"after\\\">",
		ctx
	});

	return block;
}

// (203:14) <span                 class="icon icon-circle"                 slot="media"                 style="color: rgb(24, 107, 109);" />
function create_media_slot_4(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "icon icon-circle");
			attr_dev(span, "slot", "media");
			set_style(span, "color", "rgb(24, 107, 109)");
			add_location(span, file$r, 202, 14, 5671);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_media_slot_4.name,
		type: "slot",
		source: "(203:14) <span                 class=\\\"icon icon-circle\\\"                 slot=\\\"media\\\"                 style=\\\"color: rgb(24, 107, 109);\\\" />",
		ctx
	});

	return block;
}

// (137:12) <ListItem>
function create_default_slot_21(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
			t2 = space();
			t3 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, t3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(t3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_21.name,
		type: "slot",
		source: "(137:12) <ListItem>",
		ctx
	});

	return block;
}

// (136:10) {#each itineraries as itinerary}
function create_each_block_1$1(ctx) {
	let listitem;
	let current;

	listitem = new List_item({
			props: {
				$$slots: {
					default: [create_default_slot_21],
					media: [create_media_slot_4],
					after: [create_after_slot_2],
					title: [create_title_slot_2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(listitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(listitem, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const listitem_changes = {};

			if (dirty[0] & /*itineraries, $tour, selectedItinerary, searchbarComponent*/ 204 | dirty[1] & /*$$scope*/ 8) {
				listitem_changes.$$scope = { dirty, ctx };
			}

			listitem.$set(listitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(listitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(listitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(listitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(136:10) {#each itineraries as itinerary}",
		ctx
	});

	return block;
}

// (132:8) <List           sortable={true}           class="sortable-enabled"           data-sortable-move-elements="false">
function create_default_slot_20(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = /*itineraries*/ ctx[6];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*itineraries, $tour, tour, selectedItinerary, openItinerarySheet, openAttractionSheet, searchbarComponent*/ 1996) {
				each_value_1 = /*itineraries*/ ctx[6];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_20.name,
		type: "slot",
		source: "(132:8) <List           sortable={true}           class=\\\"sortable-enabled\\\"           data-sortable-move-elements=\\\"false\\\">",
		ctx
	});

	return block;
}

// (231:8) <Link           on:click={function() {             itinerarySheet.close();           }}>
function create_default_slot_19(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text$1("Close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_19.name,
		type: "slot",
		source: "(231:8) <Link           on:click={function() {             itinerarySheet.close();           }}>",
		ctx
	});

	return block;
}

// (228:4) <Toolbar>
function create_default_slot_18(ctx) {
	let div0;
	let t;
	let div1;
	let link;
	let current;

	link = new Link({
			props: {
				$$slots: { default: [create_default_slot_19] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	link.$on("click", /*click_handler_4*/ ctx[18]);

	const block = {
		c: function create() {
			div0 = element("div");
			t = space();
			div1 = element("div");
			create_component(link.$$.fragment);
			attr_dev(div0, "class", "left");
			add_location(div0, file$r, 228, 6, 6382);
			attr_dev(div1, "class", "right");
			add_location(div1, file$r, 229, 6, 6409);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, div1, anchor);
			mount_component(link, div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const link_changes = {};

			if (dirty[1] & /*$$scope*/ 8) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			destroy_component(link);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18.name,
		type: "slot",
		source: "(228:4) <Toolbar>",
		ctx
	});

	return block;
}

// (243:6) {#if selectedItinerary}
function create_if_block_3$7(ctx) {
	let list;
	let current;

	list = new List({
			props: {
				mediaList: true,
				style: "margin-top: 0px",
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(list.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const list_changes = {};

			if (dirty[0] & /*selectedItinerary, searchbarComponent*/ 12 | dirty[1] & /*$$scope*/ 8) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(list, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$7.name,
		type: "if",
		source: "(243:6) {#if selectedItinerary}",
		ctx
	});

	return block;
}

// (261:12) <div slot="media">
function create_media_slot_3(ctx) {
	let div;
	let span;

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			attr_dev(span, "class", "icon icon-clock");
			add_location(span, file$r, 261, 14, 7285);
			attr_dev(div, "slot", "media");
			add_location(div, file$r, 260, 12, 7252);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_media_slot_3.name,
		type: "slot",
		source: "(261:12) <div slot=\\\"media\\\">",
		ctx
	});

	return block;
}

// (282:12) <div slot="media">
function create_media_slot_2(ctx) {
	let div;
	let span;

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			attr_dev(span, "class", "icon icon-file-text");
			add_location(span, file$r, 282, 14, 7955);
			attr_dev(div, "slot", "media");
			add_location(div, file$r, 281, 12, 7922);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_media_slot_2.name,
		type: "slot",
		source: "(282:12) <div slot=\\\"media\\\">",
		ctx
	});

	return block;
}

// (288:12) <div slot="media">
function create_media_slot_1(ctx) {
	let div;
	let span;

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			attr_dev(span, "class", "icon icon-location");
			add_location(span, file$r, 288, 14, 8121);
			attr_dev(div, "slot", "media");
			add_location(div, file$r, 287, 12, 8088);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_media_slot_1.name,
		type: "slot",
		source: "(288:12) <div slot=\\\"media\\\">",
		ctx
	});

	return block;
}

// (299:14) {:else}
function create_else_block_2$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text$1("No attraction linked");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$3.name,
		type: "else",
		source: "(299:14) {:else}",
		ctx
	});

	return block;
}

// (292:14) {#if selectedItinerary.attraction}
function create_if_block_4$4(ctx) {
	let link;
	let current;

	link = new Link({
			props: {
				external: true,
				target: "_new",
				href: /*selectedItinerary*/ ctx[2].attraction.url,
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(link.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(link, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const link_changes = {};
			if (dirty[0] & /*selectedItinerary*/ 4) link_changes.href = /*selectedItinerary*/ ctx[2].attraction.url;

			if (dirty[0] & /*selectedItinerary*/ 4 | dirty[1] & /*$$scope*/ 8) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(link, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$4.name,
		type: "if",
		source: "(292:14) {#if selectedItinerary.attraction}",
		ctx
	});

	return block;
}

// (293:16) <Link                   external                   target="_new"                   href={selectedItinerary.attraction.url}>
function create_default_slot_15(ctx) {
	let t_value = /*selectedItinerary*/ ctx[2].attraction.title + "";
	let t;

	const block = {
		c: function create() {
			t = text$1(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*selectedItinerary*/ 4 && t_value !== (t_value = /*selectedItinerary*/ ctx[2].attraction.title + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(293:16) <Link                   external                   target=\\\"_new\\\"                   href={selectedItinerary.attraction.url}>",
		ctx
	});

	return block;
}

// (291:12) <div slot="title">
function create_title_slot_1(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_4$4, create_else_block_2$3];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*selectedItinerary*/ ctx[2].attraction) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			attr_dev(div, "slot", "title");
			add_location(div, file$r, 290, 12, 8188);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot_1.name,
		type: "slot",
		source: "(291:12) <div slot=\\\"title\\\">",
		ctx
	});

	return block;
}

// (302:14) <Button                 style="background-color: rgb(24, 107, 109)"                 fill                 small                 round                 on:click={function() {                   openAttractionSheet();                   if (selectedItinerary.attraction) {                     searchbarComponent                       .instance()                       .search(selectedItinerary.attraction.title);                   }                 }}>
function create_default_slot_14(ctx) {
	let html_tag;

	let raw_value = (/*selectedItinerary*/ ctx[2].attraction
	? "Change"
	: "Link") + "<span style='font-size: 1rem; font-weight: bold; margin-left: 4px; vertical-align: sub' class='icon icon-link'></span>" + "";

	let html_anchor;

	const block = {
		c: function create() {
			html_anchor = empty$1();
			html_tag = new HtmlTag(html_anchor);
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*selectedItinerary*/ 4 && raw_value !== (raw_value = (/*selectedItinerary*/ ctx[2].attraction
			? "Change"
			: "Link") + "<span style='font-size: 1rem; font-weight: bold; margin-left: 4px; vertical-align: sub' class='icon icon-link'></span>" + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(302:14) <Button                 style=\\\"background-color: rgb(24, 107, 109)\\\"                 fill                 small                 round                 on:click={function() {                   openAttractionSheet();                   if (selectedItinerary.attraction) {                     searchbarComponent                       .instance()                       .search(selectedItinerary.attraction.title);                   }                 }}>",
		ctx
	});

	return block;
}

// (301:12) <div style="display: flex" slot="after">
function create_after_slot_1(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				style: "background-color: rgb(24, 107, 109)",
				fill: true,
				small: true,
				round: true,
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler_5*/ ctx[21]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			set_style(div, "display", "flex");
			attr_dev(div, "slot", "after");
			add_location(div, file$r, 300, 12, 8553);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[0] & /*selectedItinerary*/ 4 | dirty[1] & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_after_slot_1.name,
		type: "slot",
		source: "(301:12) <div style=\\\"display: flex\\\" slot=\\\"after\\\">",
		ctx
	});

	return block;
}

// (287:10) <ListItem header="Attraction">
function create_default_slot_13(ctx) {
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(287:10) <ListItem header=\\\"Attraction\\\">",
		ctx
	});

	return block;
}

// (244:8) <List mediaList style="margin-top: 0px">
function create_default_slot_12(ctx) {
	let listinput0;
	let t0;
	let listinput1;
	let t1;
	let listitem;
	let current;

	listinput0 = new List_input({
			props: {
				label: "Schedule",
				type: "text",
				placeholder: "Enter the schedule",
				clearButton: true,
				required: true,
				validate: true,
				errorMessage: "Enter a schedule",
				value: /*selectedItinerary*/ ctx[2].schedule,
				onChange: /*func*/ ctx[19],
				$$slots: { media: [create_media_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	listinput1 = new List_input({
			props: {
				label: "Title",
				type: "text",
				placeholder: "Enter a short description of the itinerary item",
				clearButton: true,
				required: true,
				validate: true,
				errorMessage: "Enter a description",
				value: /*selectedItinerary*/ ctx[2].title,
				onChange: /*func_1*/ ctx[20],
				$$slots: { media: [create_media_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	listitem = new List_item({
			props: {
				header: "Attraction",
				$$slots: {
					default: [create_default_slot_13],
					after: [create_after_slot_1],
					title: [create_title_slot_1],
					media: [create_media_slot_1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(listinput0.$$.fragment);
			t0 = space();
			create_component(listinput1.$$.fragment);
			t1 = space();
			create_component(listitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(listinput0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(listinput1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(listitem, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const listinput0_changes = {};
			if (dirty[0] & /*selectedItinerary*/ 4) listinput0_changes.value = /*selectedItinerary*/ ctx[2].schedule;
			if (dirty[0] & /*selectedItinerary*/ 4) listinput0_changes.onChange = /*func*/ ctx[19];

			if (dirty[1] & /*$$scope*/ 8) {
				listinput0_changes.$$scope = { dirty, ctx };
			}

			listinput0.$set(listinput0_changes);
			const listinput1_changes = {};
			if (dirty[0] & /*selectedItinerary*/ 4) listinput1_changes.value = /*selectedItinerary*/ ctx[2].title;
			if (dirty[0] & /*selectedItinerary*/ 4) listinput1_changes.onChange = /*func_1*/ ctx[20];

			if (dirty[1] & /*$$scope*/ 8) {
				listinput1_changes.$$scope = { dirty, ctx };
			}

			listinput1.$set(listinput1_changes);
			const listitem_changes = {};

			if (dirty[0] & /*selectedItinerary, searchbarComponent*/ 12 | dirty[1] & /*$$scope*/ 8) {
				listitem_changes.$$scope = { dirty, ctx };
			}

			listitem.$set(listitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(listinput0.$$.fragment, local);
			transition_in(listinput1.$$.fragment, local);
			transition_in(listitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(listinput0.$$.fragment, local);
			transition_out(listinput1.$$.fragment, local);
			transition_out(listitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(listinput0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(listinput1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(listitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(244:8) <List mediaList style=\\\"margin-top: 0px\\\">",
		ctx
	});

	return block;
}

// (240:4) <Block>
function create_default_slot_11$1(ctx) {
	let h1;
	let t1;
	let if_block_anchor;
	let current;
	let if_block = /*selectedItinerary*/ ctx[2] && create_if_block_3$7(ctx);

	const block = {
		c: function create() {
			h1 = element("h1");
			h1.textContent = "Edit Itinerary Item";
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
			add_location(h1, file$r, 240, 6, 6605);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*selectedItinerary*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*selectedItinerary*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11$1.name,
		type: "slot",
		source: "(240:4) <Block>",
		ctx
	});

	return block;
}

// (227:2) <Sheet class="itinerarySheet" style="height: 100%; z-index: 12000">
function create_default_slot_10$1(ctx) {
	let toolbar;
	let t;
	let block;
	let current;

	toolbar = new Toolbar$2({
			props: {
				$$slots: { default: [create_default_slot_18] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	block = new Block({
			props: {
				$$slots: { default: [create_default_slot_11$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block_1 = {
		c: function create() {
			create_component(toolbar.$$.fragment);
			t = space();
			create_component(block.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(toolbar, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(block, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const toolbar_changes = {};

			if (dirty[0] & /*itinerarySheet*/ 16 | dirty[1] & /*$$scope*/ 8) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
			const block_changes = {};

			if (dirty[0] & /*selectedItinerary, searchbarComponent*/ 12 | dirty[1] & /*$$scope*/ 8) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(toolbar.$$.fragment, local);
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(toolbar, detaching);
			if (detaching) detach_dev(t);
			destroy_component(block, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_default_slot_10$1.name,
		type: "slot",
		source: "(227:2) <Sheet class=\\\"itinerarySheet\\\" style=\\\"height: 100%; z-index: 12000\\\">",
		ctx
	});

	return block_1;
}

// (328:8) <Link           on:click={function() {             attractionSheet.close();           }}>
function create_default_slot_9$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text$1("Close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$1.name,
		type: "slot",
		source: "(328:8) <Link           on:click={function() {             attractionSheet.close();           }}>",
		ctx
	});

	return block;
}

// (325:4) <Toolbar>
function create_default_slot_8$1(ctx) {
	let div0;
	let t;
	let div1;
	let link;
	let current;

	link = new Link({
			props: {
				$$slots: { default: [create_default_slot_9$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	link.$on("click", /*click_handler_6*/ ctx[22]);

	const block = {
		c: function create() {
			div0 = element("div");
			t = space();
			div1 = element("div");
			create_component(link.$$.fragment);
			attr_dev(div0, "class", "left");
			add_location(div0, file$r, 325, 6, 9462);
			attr_dev(div1, "class", "right");
			add_location(div1, file$r, 326, 6, 9489);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, div1, anchor);
			mount_component(link, div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const link_changes = {};

			if (dirty[1] & /*$$scope*/ 8) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			destroy_component(link);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$1.name,
		type: "slot",
		source: "(325:4) <Toolbar>",
		ctx
	});

	return block;
}

// (341:6) <Toolbar>
function create_default_slot_7$1(ctx) {
	let searchbar;
	let current;

	let searchbar_props = {
		placeholder: "Search for attraction and places in Tripadvisor",
		id: "searchbar",
		searchContainer: ".search-list",
		disableButton: false,
		clearButton: false,
		customSearch: true,
		value: /*selectedItinerary*/ ctx[2] && /*selectedItinerary*/ ctx[2].attraction
		? /*selectedItinerary*/ ctx[2].attraction.title
		: ""
	};

	searchbar = new Searchbar$2({ props: searchbar_props, $$inline: true });
	/*searchbar_binding*/ ctx[23](searchbar);

	const block = {
		c: function create() {
			create_component(searchbar.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(searchbar, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const searchbar_changes = {};

			if (dirty[0] & /*selectedItinerary*/ 4) searchbar_changes.value = /*selectedItinerary*/ ctx[2] && /*selectedItinerary*/ ctx[2].attraction
			? /*selectedItinerary*/ ctx[2].attraction.title
			: "";

			searchbar.$set(searchbar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(searchbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(searchbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*searchbar_binding*/ ctx[23](null);
			destroy_component(searchbar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$1.name,
		type: "slot",
		source: "(341:6) <Toolbar>",
		ctx
	});

	return block;
}

// (359:6) {:else}
function create_else_block$8(ctx) {
	let list;
	let current;

	list = new List({
			props: {
				class: "search-list",
				style: "margin-top: 0px",
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(list.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const list_changes = {};

			if (dirty[0] & /*attractions, selectedItinerary, $tour, attractionSheet*/ 166 | dirty[1] & /*$$scope*/ 8) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(list, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$8.name,
		type: "else",
		source: "(359:6) {:else}",
		ctx
	});

	return block;
}

// (353:6) {#if loading}
function create_if_block$e(ctx) {
	let div;
	let preloader;
	let current;
	preloader = new Preloader$2({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(preloader.$$.fragment);
			set_style(div, "align-items", "center");
			set_style(div, "display", "flex");
			set_style(div, "justify-content", "center");
			set_style(div, "flex-direction", "column");
			set_style(div, "height", "100%");
			add_location(div, file$r, 353, 8, 10266);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(preloader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(preloader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$e.name,
		type: "if",
		source: "(353:6) {#if loading}",
		ctx
	});

	return block;
}

// (361:10) {#if attractions}
function create_if_block_1$a(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2$9, create_else_block_1$3];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*attractions*/ ctx[1].length == 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$a.name,
		type: "if",
		source: "(361:10) {#if attractions}",
		ctx
	});

	return block;
}

// (364:12) {:else}
function create_else_block_1$3(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*attractions*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*attractions, selectedItinerary, tour, $tour, attractionSheet*/ 422) {
				each_value = /*attractions*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$3.name,
		type: "else",
		source: "(364:12) {:else}",
		ctx
	});

	return block;
}

// (362:12) {#if attractions.length == 0}
function create_if_block_2$9(ctx) {
	let listitem;
	let current;

	listitem = new List_item({
			props: { title: "No attractions found" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(listitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(listitem, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(listitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(listitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(listitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$9.name,
		type: "if",
		source: "(362:12) {#if attractions.length == 0}",
		ctx
	});

	return block;
}

// (367:18) <div slot="title">
function create_title_slot(ctx) {
	let div;
	let t0_value = /*item*/ ctx[28].description + "";
	let t0;
	let t1;
	let link;
	let current;

	function click_handler_7(...args) {
		return /*click_handler_7*/ ctx[24](/*item*/ ctx[28], ...args);
	}

	link = new Link({
			props: {
				title: "Open attraction",
				icon: "icon icon-external-link",
				external: true,
				style: "margin-left: 6px"
			},
			$$inline: true
		});

	link.$on("click", click_handler_7);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text$1(t0_value);
			t1 = space();
			create_component(link.$$.fragment);
			attr_dev(div, "slot", "title");
			add_location(div, file$r, 366, 18, 10744);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			mount_component(link, div, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*attractions*/ 2) && t0_value !== (t0_value = /*item*/ ctx[28].description + "")) set_data_dev(t0, t0_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(link);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot.name,
		type: "slot",
		source: "(367:18) <div slot=\\\"title\\\">",
		ctx
	});

	return block;
}

// (382:18) <span class="icon icon-location" slot="media" />
function create_media_slot(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "icon icon-location");
			attr_dev(span, "slot", "media");
			add_location(span, file$r, 381, 18, 11351);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_media_slot.name,
		type: "slot",
		source: "(382:18) <span class=\\\"icon icon-location\\\" slot=\\\"media\\\" />",
		ctx
	});

	return block;
}

// (384:20) <Button                       fill                       small                       round                       style="background-color: rgb(24, 107, 109)"                       on:click={function() {                         getAttractionDetails(item.providerReference).then(                           function(details) {                             let attraction = selectedItinerary.attraction;                             if (!attraction) {                               attraction = {};                               selectedItinerary.attraction = attraction;                             }                             attraction.title = item.description.split(',')[0];                             attraction.url = details.url;                             if (details.location) {                               attraction.location = details.location;                             }                             selectedItinerary = selectedItinerary;                             tour.set($tour);                             attractionSheet.close();                           }                         );                       }}>
function create_default_slot_6$1(ctx) {
	let t;
	let span;

	const block = {
		c: function create() {
			t = text$1("Choose\n                      ");
			span = element("span");
			set_style(span, "font-size", "1.0rem");
			set_style(span, "margin-left", "1px");
			set_style(span, "font-weight", "bold");
			set_style(span, "vertical-align", "sub");
			attr_dev(span, "class", "icon icon-choose");
			add_location(span, file$r, 408, 22, 12638);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$1.name,
		type: "slot",
		source: "(384:20) <Button                       fill                       small                       round                       style=\\\"background-color: rgb(24, 107, 109)\\\"                       on:click={function() {                         getAttractionDetails(item.providerReference).then(                           function(details) {                             let attraction = selectedItinerary.attraction;                             if (!attraction) {                               attraction = {};                               selectedItinerary.attraction = attraction;                             }                             attraction.title = item.description.split(',')[0];                             attraction.url = details.url;                             if (details.location) {                               attraction.location = details.location;                             }                             selectedItinerary = selectedItinerary;                             tour.set($tour);                             attractionSheet.close();                           }                         );                       }}>",
		ctx
	});

	return block;
}

// (383:18) <div slot="after">
function create_after_slot(ctx) {
	let div;
	let button;
	let current;

	function click_handler_8(...args) {
		return /*click_handler_8*/ ctx[25](/*item*/ ctx[28], ...args);
	}

	button = new Button({
			props: {
				fill: true,
				small: true,
				round: true,
				style: "background-color: rgb(24, 107, 109)",
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", click_handler_8);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			attr_dev(div, "slot", "after");
			add_location(div, file$r, 382, 18, 11418);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};

			if (dirty[1] & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_after_slot.name,
		type: "slot",
		source: "(383:18) <div slot=\\\"after\\\">",
		ctx
	});

	return block;
}

// (366:16) <ListItem>
function create_default_slot_5$1(ctx) {
	let t0;
	let t1;
	let t2;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
			t2 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, t2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$1.name,
		type: "slot",
		source: "(366:16) <ListItem>",
		ctx
	});

	return block;
}

// (365:14) {#each attractions as item}
function create_each_block$3(ctx) {
	let listitem;
	let current;

	listitem = new List_item({
			props: {
				$$slots: {
					default: [create_default_slot_5$1],
					after: [create_after_slot],
					media: [create_media_slot],
					title: [create_title_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(listitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(listitem, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const listitem_changes = {};

			if (dirty[0] & /*attractions, selectedItinerary, $tour, attractionSheet*/ 166 | dirty[1] & /*$$scope*/ 8) {
				listitem_changes.$$scope = { dirty, ctx };
			}

			listitem.$set(listitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(listitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(listitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(listitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(365:14) {#each attractions as item}",
		ctx
	});

	return block;
}

// (360:8) <List class="search-list" style="margin-top: 0px">
function create_default_slot_4$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*attractions*/ ctx[1] && create_if_block_1$a(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*attractions*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*attractions*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(360:8) <List class=\\\"search-list\\\" style=\\\"margin-top: 0px\\\">",
		ctx
	});

	return block;
}

// (336:4) <Block>
function create_default_slot_3$1(ctx) {
	let h1;

	let t0_value = (/*selectedItinerary*/ ctx[2] && /*selectedItinerary*/ ctx[2].attraction
	? "Change"
	: "Link") + "";

	let t0;
	let t1;
	let t2;
	let toolbar;
	let t3;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	toolbar = new Toolbar$2({
			props: {
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block$e, create_else_block$8];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*loading*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text$1(t0_value);
			t1 = text$1("\n        Attraction");
			t2 = space();
			create_component(toolbar.$$.fragment);
			t3 = space();
			if_block.c();
			if_block_anchor = empty$1();
			add_location(h1, file$r, 336, 6, 9685);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			append_dev(h1, t1);
			insert_dev(target, t2, anchor);
			mount_component(toolbar, target, anchor);
			insert_dev(target, t3, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*selectedItinerary*/ 4) && t0_value !== (t0_value = (/*selectedItinerary*/ ctx[2] && /*selectedItinerary*/ ctx[2].attraction
			? "Change"
			: "Link") + "")) set_data_dev(t0, t0_value);

			const toolbar_changes = {};

			if (dirty[0] & /*selectedItinerary, searchbarComponent*/ 12 | dirty[1] & /*$$scope*/ 8) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(toolbar.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t2);
			destroy_component(toolbar, detaching);
			if (detaching) detach_dev(t3);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(336:4) <Block>",
		ctx
	});

	return block;
}

// (324:2) <Sheet class="attractionSheet" style="height: 100%; z-index: 12001">
function create_default_slot_2$4(ctx) {
	let toolbar;
	let t;
	let block;
	let current;

	toolbar = new Toolbar$2({
			props: {
				$$slots: { default: [create_default_slot_8$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	block = new Block({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block_1 = {
		c: function create() {
			create_component(toolbar.$$.fragment);
			t = space();
			create_component(block.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(toolbar, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(block, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const toolbar_changes = {};

			if (dirty[0] & /*attractionSheet*/ 32 | dirty[1] & /*$$scope*/ 8) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
			const block_changes = {};

			if (dirty[0] & /*loading, attractions, selectedItinerary, $tour, attractionSheet, searchbarComponent*/ 175 | dirty[1] & /*$$scope*/ 8) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(toolbar.$$.fragment, local);
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(toolbar, detaching);
			if (detaching) detach_dev(t);
			destroy_component(block, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(324:2) <Sheet class=\\\"attractionSheet\\\" style=\\\"height: 100%; z-index: 12001\\\">",
		ctx
	});

	return block_1;
}

// (425:2) <Toolbar style="font-size: 0.7rem" tabbar labels position="bottom">
function create_default_slot_1$5(ctx) {
	let link0;
	let t0;
	let link1;
	let t1;
	let link2;
	let current;

	link0 = new Link({
			props: {
				text: "Add Item",
				style: "color: rgb(24, 107, 109);",
				icon: "icon icon-plus"
			},
			$$inline: true
		});

	link0.$on("click", /*click_handler_9*/ ctx[26]);

	link1 = new Link({
			props: {
				text: "Show UI",
				style: "color: rgb(24, 107, 109);",
				icon: "icon icon-lightbulb",
				href: "/New-UI/itinerary"
			},
			$$inline: true
		});

	link2 = new Link({
			props: {
				text: "Reset Itinerary",
				style: "color: red",
				icon: "icon icon-reload"
			},
			$$inline: true
		});

	link2.$on("click", /*click_handler_10*/ ctx[27]);

	const block = {
		c: function create() {
			create_component(link0.$$.fragment);
			t0 = space();
			create_component(link1.$$.fragment);
			t1 = space();
			create_component(link2.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(link0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(link1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(link2, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(link0.$$.fragment, local);
			transition_in(link1.$$.fragment, local);
			transition_in(link2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link0.$$.fragment, local);
			transition_out(link1.$$.fragment, local);
			transition_out(link2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(link0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(link1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(link2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$5.name,
		type: "slot",
		source: "(425:2) <Toolbar style=\\\"font-size: 0.7rem\\\" tabbar labels position=\\\"bottom\\\">",
		ctx
	});

	return block;
}

// (124:0) <Page {onPageBeforeOut} {onPageBeforeRemove}>
function create_default_slot$7(ctx) {
	let div3;
	let div2;
	let h1;
	let t1;
	let current_block_type_index;
	let if_block;
	let t2;
	let div1;
	let div0;
	let t3;
	let br;
	let t4;
	let a;
	let t6;
	let sheet0;
	let t7;
	let sheet1;
	let t8;
	let navtoolbar;
	let t9;
	let toolbar;
	let current;
	const if_block_creators = [create_if_block_5$2, create_else_block_3$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*itineraries*/ ctx[6].length == 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	sheet0 = new Sheet$2({
			props: {
				class: "itinerarySheet",
				style: "height: 100%; z-index: 12000",
				$$slots: { default: [create_default_slot_10$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	sheet1 = new Sheet$2({
			props: {
				class: "attractionSheet",
				style: "height: 100%; z-index: 12001",
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	navtoolbar = new Toolbar_1({
			props: { active: "/Editor" },
			$$inline: true
		});

	toolbar = new Toolbar$2({
			props: {
				style: "font-size: 0.7rem",
				tabbar: true,
				labels: true,
				position: "bottom",
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			h1 = element("h1");
			h1.textContent = "Itinerary Editor";
			t1 = space();
			if_block.c();
			t2 = space();
			div1 = element("div");
			div0 = element("div");
			t3 = text$1(" Trip Store Krabi Co., Ltd. 2020. All Rights Reserved.\n          ");
			br = element("br");
			t4 = space();
			a = element("a");
			a.textContent = "Contact Us";
			t6 = space();
			create_component(sheet0.$$.fragment);
			t7 = space();
			create_component(sheet1.$$.fragment);
			t8 = space();
			create_component(navtoolbar.$$.fragment);
			t9 = space();
			create_component(toolbar.$$.fragment);
			add_location(h1, file$r, 126, 6, 2857);
			add_location(br, file$r, 215, 10, 6090);
			attr_dev(a, "class", "link underline external");
			attr_dev(a, "href", "mailto:info@tripstorekrabi.com");
			add_location(a, file$r, 216, 10, 6107);
			attr_dev(div0, "class", "");
			add_location(div0, file$r, 213, 8, 5999);
			set_style(div1, "color", "hsl(181, 64%, 26%)");
			set_style(div1, "text-align", "center");
			set_style(div1, "margin-top", "80px");
			set_style(div1, "margin-bottom", "80px");
			add_location(div1, file$r, 210, 6, 5876);
			set_style(div2, "margin", "auto");
			set_style(div2, "height", "100%");
			set_style(div2, "max-width", "1000px");
			set_style(div2, "padding", "20px");
			add_location(div2, file$r, 125, 4, 2776);
			attr_dev(div3, "class", "page-content");
			add_location(div3, file$r, 124, 2, 2745);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, h1);
			append_dev(div2, t1);
			if_blocks[current_block_type_index].m(div2, null);
			append_dev(div2, t2);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div0, t3);
			append_dev(div0, br);
			append_dev(div0, t4);
			append_dev(div0, a);
			insert_dev(target, t6, anchor);
			mount_component(sheet0, target, anchor);
			insert_dev(target, t7, anchor);
			mount_component(sheet1, target, anchor);
			insert_dev(target, t8, anchor);
			mount_component(navtoolbar, target, anchor);
			insert_dev(target, t9, anchor);
			mount_component(toolbar, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div2, t2);
			}

			const sheet0_changes = {};

			if (dirty[0] & /*selectedItinerary, searchbarComponent, itinerarySheet*/ 28 | dirty[1] & /*$$scope*/ 8) {
				sheet0_changes.$$scope = { dirty, ctx };
			}

			sheet0.$set(sheet0_changes);
			const sheet1_changes = {};

			if (dirty[0] & /*loading, attractions, selectedItinerary, $tour, attractionSheet, searchbarComponent*/ 175 | dirty[1] & /*$$scope*/ 8) {
				sheet1_changes.$$scope = { dirty, ctx };
			}

			sheet1.$set(sheet1_changes);
			const toolbar_changes = {};

			if (dirty[0] & /*itineraries, $tour, selectedItinerary*/ 196 | dirty[1] & /*$$scope*/ 8) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(sheet0.$$.fragment, local);
			transition_in(sheet1.$$.fragment, local);
			transition_in(navtoolbar.$$.fragment, local);
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(sheet0.$$.fragment, local);
			transition_out(sheet1.$$.fragment, local);
			transition_out(navtoolbar.$$.fragment, local);
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if_blocks[current_block_type_index].d();
			if (detaching) detach_dev(t6);
			destroy_component(sheet0, detaching);
			if (detaching) detach_dev(t7);
			destroy_component(sheet1, detaching);
			if (detaching) detach_dev(t8);
			destroy_component(navtoolbar, detaching);
			if (detaching) detach_dev(t9);
			destroy_component(toolbar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(124:0) <Page {onPageBeforeOut} {onPageBeforeRemove}>",
		ctx
	});

	return block;
}

function create_fragment$r(ctx) {
	let page;
	let current;

	page = new Page({
			props: {
				onPageBeforeOut: /*onPageBeforeOut*/ ctx[11],
				onPageBeforeRemove: /*onPageBeforeRemove*/ ctx[12],
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(page.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(page, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const page_changes = {};

			if (dirty[0] & /*itineraries, $tour, selectedItinerary, loading, attractions, attractionSheet, searchbarComponent, itinerarySheet*/ 255 | dirty[1] & /*$$scope*/ 8) {
				page_changes.$$scope = { dirty, ctx };
			}

			page.$set(page_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(page.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(page.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(page, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function arrayMove(arr, old_index, new_index) {
	if (new_index >= arr.length) {
		var k = new_index - arr.length + 1;

		while (k--) {
			arr.push(undefined);
		}
	}

	arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
	return arr;
}

function instance$n($$self, $$props, $$invalidate) {
	let $tour;
	let tour = createTour();
	validate_store(tour, "tour");
	component_subscribe($$self, tour, value => $$invalidate(7, $tour = value));
	let loading = false;
	let attractions = null;
	let selectedItinerary = null;
	let searchbarComponent;

	f7Instance.on("sortableSort", function (item, data) {
		let newItineraries = arrayMove(itineraries, data.from, data.to);
		set_store_value(tour, $tour.itineraries = newItineraries, $tour);
	});

	onMount(async () => {
		let timeout;

		searchbarComponent.instance().on("search", function (searchbar) {
			let query = searchbar.query.trim();

			if (query.length === 0) {
				$$invalidate(1, attractions = []);
				return;
			}

			if (timeout) {
				clearInterval(timeout);
			}

			$$invalidate(0, loading = true);

			timeout = setTimeout(
				function () {
					suggestAttractions(query.trim()).then(function (result) {
						$$invalidate(0, loading = false);
						$$invalidate(1, attractions = result);
					});
				},
				400
			);
		});
	});

	let itinerarySheet;

	function openItinerarySheet() {
		if (!itinerarySheet) {
			$$invalidate(4, itinerarySheet = f7Instance.sheet.create({ el: ".itinerarySheet" }));
		}

		itinerarySheet.open();
	}

	let attractionSheet;

	function openAttractionSheet() {
		if (!attractionSheet) {
			$$invalidate(5, attractionSheet = f7Instance.sheet.create({ el: ".attractionSheet" }));
		}

		attractionSheet.open();
	}

	function onPageBeforeOut() {
		if (itinerarySheet) {
			itinerarySheet.close();
		}

		if (attractionSheet) {
			attractionSheet.close();
		}
	}

	function onPageBeforeRemove() {
		if (itinerarySheet) {
			itinerarySheet.destroy();
		}

		if (attractionSheet) {
			attractionSheet.destroy();
		}
	}

	function saveItinerary(itinerary) {
		if (itineraries.indexOf(itinerary) === -1) {
			itineraries.push(itinerary);
			set_store_value(tour, $tour.itineraries = itineraries, $tour);
		}

		tour.set($tour);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Editor> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Editor", $$slots, []);

	const click_handler = function (itinerary) {
		$$invalidate(2, selectedItinerary = itinerary);
		openItinerarySheet();
	};

	const click_handler_1 = function (itinerary) {
		$$invalidate(2, selectedItinerary = itinerary);
		openAttractionSheet();
		searchbarComponent.instance().search(selectedItinerary.attraction.title);
	};

	const click_handler_2 = function (itinerary) {
		$$invalidate(2, selectedItinerary = itinerary);
		openItinerarySheet();
	};

	const click_handler_3 = function (itinerary) {
		f7Instance.dialog.confirm("Are you sure you want to remove this item?", "Remove Itinerary Item", () => {
			let newItineraries = itineraries.filter(item => item !== itinerary);
			set_store_value(tour, $tour.itineraries = newItineraries, $tour);
			tour.set($tour);
		});
	};

	const click_handler_4 = function () {
		itinerarySheet.close();
	};

	const func = function (e) {
		let value = e.target.value;

		if (value.length > 0) {
			$$invalidate(2, selectedItinerary.schedule = value, selectedItinerary);
			saveItinerary(selectedItinerary);
		}
	};

	const func_1 = function (e) {
		let value = e.target.value;

		if (value.length > 0) {
			$$invalidate(2, selectedItinerary.title = value, selectedItinerary);
			saveItinerary(selectedItinerary);
		}
	};

	const click_handler_5 = function () {
		openAttractionSheet();

		if (selectedItinerary.attraction) {
			searchbarComponent.instance().search(selectedItinerary.attraction.title);
		}
	};

	const click_handler_6 = function () {
		attractionSheet.close();
	};

	function searchbar_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			searchbarComponent = $$value;
			$$invalidate(3, searchbarComponent);
		});
	}

	const click_handler_7 = function (item) {
		getAttractionDetails(item.providerReference).then(function (details) {
			window.open(details.url);
		});
	};

	const click_handler_8 = function (item) {
		getAttractionDetails(item.providerReference).then(function (details) {
			let attraction = selectedItinerary.attraction;

			if (!attraction) {
				attraction = {};
				$$invalidate(2, selectedItinerary.attraction = attraction, selectedItinerary);
			}

			attraction.title = item.description.split(",")[0];
			attraction.url = details.url;

			if (details.location) {
				attraction.location = details.location;
			}

			$$invalidate(2, selectedItinerary);
			tour.set($tour);
			attractionSheet.close();
		});
	};

	const click_handler_9 = function () {
		$$invalidate(2, selectedItinerary = { title: "", schedule: "" });
		openItinerarySheet();
	};

	const click_handler_10 = function () {
		f7Instance.dialog.confirm("Are you sure you want to reset the itinerary to the default value?", "Reset Itinerary", () => {
			$$invalidate(6, itineraries = JSON.parse(JSON.stringify(STANDARD_TOUR)).itineraries);
			set_store_value(tour, $tour.itineraries = itineraries, $tour);
			tour.set($tour);
		});
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		f7: f7Instance,
		Page,
		Link,
		List,
		ListInput: List_input,
		ListItem: List_item,
		Block,
		Button,
		Toolbar: Toolbar$2,
		Sheet: Sheet$2,
		Searchbar: Searchbar$2,
		Preloader: Preloader$2,
		NavToolbar: Toolbar_1,
		createTour,
		STANDARD_TOUR,
		getJSONWithExpiry,
		setJSONWithExpiry,
		MONTH_IN_MILLIS,
		suggestAttractions,
		getAttractionDetails,
		tour,
		loading,
		attractions,
		selectedItinerary,
		searchbarComponent,
		arrayMove,
		itinerarySheet,
		openItinerarySheet,
		attractionSheet,
		openAttractionSheet,
		onPageBeforeOut,
		onPageBeforeRemove,
		saveItinerary,
		itineraries,
		$tour
	});

	$$self.$inject_state = $$props => {
		if ("tour" in $$props) $$invalidate(8, tour = $$props.tour);
		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
		if ("attractions" in $$props) $$invalidate(1, attractions = $$props.attractions);
		if ("selectedItinerary" in $$props) $$invalidate(2, selectedItinerary = $$props.selectedItinerary);
		if ("searchbarComponent" in $$props) $$invalidate(3, searchbarComponent = $$props.searchbarComponent);
		if ("itinerarySheet" in $$props) $$invalidate(4, itinerarySheet = $$props.itinerarySheet);
		if ("attractionSheet" in $$props) $$invalidate(5, attractionSheet = $$props.attractionSheet);
		if ("itineraries" in $$props) $$invalidate(6, itineraries = $$props.itineraries);
	};

	let itineraries;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$tour*/ 128) {
			 $$invalidate(6, itineraries = $tour.itineraries);
		}
	};

	return [
		loading,
		attractions,
		selectedItinerary,
		searchbarComponent,
		itinerarySheet,
		attractionSheet,
		itineraries,
		$tour,
		tour,
		openItinerarySheet,
		openAttractionSheet,
		onPageBeforeOut,
		onPageBeforeRemove,
		saveItinerary,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		func,
		func_1,
		click_handler_5,
		click_handler_6,
		searchbar_binding,
		click_handler_7,
		click_handler_8,
		click_handler_9,
		click_handler_10
	];
}

class Editor extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$n, create_fragment$r, safe_not_equal, {}, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Editor",
			options,
			id: create_fragment$r.name
		});
	}
}

const file$s = "src/404.svelte";

// (9:4) <Link href="/Home">
function create_default_slot_2$5(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "alt", "404 Not Found");
			set_style(img, "width", "100%");
			set_style(img, "max-width", "500px");
			if (img.src !== (img_src_value = "https://lh3.googleusercontent.com/pw/ACtC-3c0Pib7AWnog0z-1uM89GbMMJPavNveCKw_0VJqFC8VgftZoLFB7Ed44VQ45vznolvDN331Ui3EiTou31JgQi1KszxMQygWKax5tcqxZ16_sqVlrQR6YNDOET2i96dRH6WCUl63F1NTfbZA667g_QJ6MQ=s800")) attr_dev(img, "src", img_src_value);
			add_location(img, file$s, 9, 6, 253);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$5.name,
		type: "slot",
		source: "(9:4) <Link href=\\\"/Home\\\">",
		ctx
	});

	return block;
}

// (17:6) <Button style="margin: 40px" outline round href="/Home">
function create_default_slot_1$6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text$1("sss");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$6.name,
		type: "slot",
		source: "(17:6) <Button style=\\\"margin: 40px\\\" outline round href=\\\"/Home\\\">",
		ctx
	});

	return block;
}

// (5:0) <Page>
function create_default_slot$8(ctx) {
	let navbar;
	let t0;
	let div1;
	let link;
	let t1;
	let div0;
	let t2;
	let button;
	let current;

	navbar = new Navbar$2({
			props: {
				title: "Page Not Found",
				backLink: "Back"
			},
			$$inline: true
		});

	link = new Link({
			props: {
				href: "/Home",
				$$slots: { default: [create_default_slot_2$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button = new Button({
			props: {
				style: "margin: 40px",
				outline: true,
				round: true,
				href: "/Home",
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(navbar.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(link.$$.fragment);
			t1 = space();
			div0 = element("div");
			t2 = text$1("ssss\n      ");
			create_component(button.$$.fragment);
			set_style(div0, "margin-bottom", "40px");
			set_style(div0, "font-size", "1.2rem");
			set_style(div0, "font-weight", "bold");
			add_location(div0, file$s, 14, 4, 566);
			attr_dev(div1, "class", "page-content");
			set_style(div1, "width", "100%");
			set_style(div1, "text-align", "center");
			add_location(div1, file$s, 7, 2, 155);
		},
		m: function mount(target, anchor) {
			mount_component(navbar, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			mount_component(link, div1, null);
			append_dev(div1, t1);
			append_dev(div1, div0);
			append_dev(div0, t2);
			mount_component(button, div0, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const link_changes = {};

			if (dirty & /*$$scope*/ 1) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);
			transition_in(link.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navbar.$$.fragment, local);
			transition_out(link.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navbar, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			destroy_component(link);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(5:0) <Page>",
		ctx
	});

	return block;
}

function create_fragment$s(ctx) {
	let page;
	let current;

	page = new Page({
			props: {
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(page.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(page, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const page_changes = {};

			if (dirty & /*$$scope*/ 1) {
				page_changes.$$scope = { dirty, ctx };
			}

			page.$set(page_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(page.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(page.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(page, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<_404> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("_404", $$slots, []);
	$$self.$capture_state = () => ({ Page, Navbar: Navbar$2, Block, Link, Button });
	return [];
}

class _404 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$o, create_fragment$s, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "_404",
			options,
			id: create_fragment$s.name
		});
	}
}

var routes = [
  {
    path: '/',
    component: UX
  },
  {
    path: '/New-UI',
    component: UI,
  },
  {
    path: '/New-UI/:scrollTo',
    component: UI
  },
  {
    path: '/Editor',
    component: Editor
  },
  {
    path: '(.*)',
    component: _404
  }
];

// (22:0) <App params={f7params}>
function create_default_slot$9(ctx) {
	let view;
	let current;

	view = new View$2({
			props: {
				url: "/",
				pushState: true,
				history: true,
				pushStateSeparator: "",
				main: true,
				animate: false
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(view.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(view, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(view.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(view.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(view, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(22:0) <App params={f7params}>",
		ctx
	});

	return block;
}

function create_fragment$t(ctx) {
	let app;
	let current;

	app = new App({
			props: {
				params: /*f7params*/ ctx[0],
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(app.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(app, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const app_changes = {};

			if (dirty & /*$$scope*/ 2) {
				app_changes.$$scope = { dirty, ctx };
			}

			app.$set(app_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(app.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(app.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(app, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	const f7params = {
		theme: "auto",
		routes,
		name: "A New Viator UX",
		id: "com.tripstorekrabi.viator.svelte",
		root: "#app",
		on: {
			pageAfterOut(page) {
				page.el.style.display = "none";
			},
			pageAfterIn(page) {
				page.el.style.display = "inherit";
			}
		}
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("App", $$slots, []);
	$$self.$capture_state = () => ({ f7: f7Instance, App, View: View$2, routes, f7params });
	return [f7params];
}

class App_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$p, create_fragment$t, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App_1",
			options,
			id: create_fragment$t.name
		});
	}
}

Framework7.use(Plugin);

const app = new App_1({
	target: document.getElementById('app')
});

export default app;
//# sourceMappingURL=bundle.js.map
